<div id="Deduction2">
<div class="head"><h1>Theory Deduction2</h1>
<span class="command">theory</span> <span class="name">Deduction2</span><br/>
<span class="keyword">imports</span> <a href="../Syntax_Independent_Logic/Deduction.html"><span class="name">Deduction</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Deduction with Two Provability Relations›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Deduction2</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Syntax_Independent_Logic.Deduction"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We work with two provability relations:
provability @{term prv} and basic provability @{term bprv}.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹From Deduction with One Provability Relation to Two›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Deduct2</span><span> </span><span class="delimiter">=</span><span>
</span><span>Deduct</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>prv</span><span>
</span><span class="delimiter">+</span><span>
</span><span>B</span><span class="delimiter">:</span><span> </span><span>Deduct</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>bprv_prv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀φ. φ ∈ fmla ⟹ Fvars φ = {} ⟹ bprv φ ⟹ prv φ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Removing the sentence (empty Fvars) hypothesis from bprv_prv *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bprv_prv'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>φ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv φ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv φ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>V</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>V</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>VV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V ⊆ var"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Fvars</span><span> </span><span>V</span><span> </span><span>φ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite V"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>V</span><span> </span><span>finite_Fvars</span><span class="delimiter">[</span><span>OF</span><span> </span><span>φ</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>φ</span><span> </span><span>b</span><span> </span><span>V</span><span> </span><span>VV</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>V</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>φ</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>finite.induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>emptyI</span><span> </span><span>φ</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bprv_prv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>insertI</span><span> </span><span>W</span><span> </span><span>v</span><span> </span><span>φ</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"v ∈ W"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>insertI.IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`φ ∈ fmla`</span></span></span><span class="delimiter">]</span><span> </span><span>insertI.prems</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>insert_absorb</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars (all v φ) = W"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>insertI.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (all v φ)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.prv_all_gen</span><span> </span><span>insertI.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (all v φ)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>insertI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>allE_id</span><span> </span><span>insertI.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale Deduct2}›</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Deduct2_with_False</span><span> </span><span class="delimiter">=</span><span>
</span><span>Deduct_with_False</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>prv</span><span>
</span><span class="delimiter">+</span><span>
</span><span>B</span><span class="delimiter">:</span><span> </span><span>Deduct_with_False</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>bprv_prv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀φ. φ ∈ fmla ⟹ Fvars φ = {} ⟹ bprv φ ⟹ prv φ"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>Deduct2_with_False</span><span> </span><span class="delimiter">&lt;</span><span> </span><span>d_dwf</span><span class="delimiter">:</span><span> </span><span>Deduct2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>bprv_prv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Deduct2_with_False</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>consistent_B_consistent</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"consistent ⟹ B.consistent"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.consistent_def</span><span> </span><span>bprv_prv</span><span> </span><span>consistent_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale Deduct2_with_False}›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Deduct2_with_False_Disj</span><span> </span><span class="delimiter">=</span><span>
</span><span>Deduct_with_False_Disj</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>prv</span><span>
</span><span class="delimiter">+</span><span>
</span><span>B</span><span class="delimiter">:</span><span> </span><span>Deduct_with_False_Disj</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dsj</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>bprv_prv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀φ. φ ∈ fmla ⟹ Fvars φ = {} ⟹ bprv φ ⟹ prv φ"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>Deduct2_with_False_Disj</span><span> </span><span class="delimiter">&lt;</span><span> </span><span>dwf_dwfd</span><span class="delimiter">:</span><span> </span><span>Deduct2_with_False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>bprv_prv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Factoring in a strict-order-like relation (not actually required to be an order): *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Deduct2_with_PseudoOrder</span><span> </span><span class="delimiter">=</span><span>
</span><span>Deduct2_with_False_Disj</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="delimiter">+</span><span>
</span><span>Syntax_PseudoOrder</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>Lq</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dsj</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Lq</span><span>
</span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* We do not assume any ordering properties, but only these two axioms, Lq_num and Lq_num2,
which (interestingly) would be satisfied by both ≤ and &lt; within a sufficiently strong
arithmetic such as Robinson's Q *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* For each formula φ(z) and numeral q, if φ(p) is provable for all p
then ∀ z ≤ q. φ(z) is provable.
(Note that a more natural property would assume φ(p) is provable for all p≤q,
but we can get away with the stronger assumption (on the left of the implication). )
*)</span></span></span></span></span><span>
</span><span>Lq_num</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"let LLq = (λ t1 t2. psubst Lq [(t1,zz), (t2,yy)]) in
 ∀ φ ∈ fmla. ∀ q ∈ num. Fvars φ = {zz} ∧ (∀ p ∈ num. bprv (subst φ p zz))
    ⟶ prv (all zz (imp (LLq (Var zz) q) φ))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* For each numeral p, there exists a finite set P such that it is provable that
∀ y. (⋁p∈P. x = p) ∨ y ≤ p
(where we write ≤ instead of Lq, but could also think of &lt;):
*)</span></span></span></span></span><span>
</span><span>Lq_num2</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"let LLq = (λ t1 t2. psubst Lq [(t1,zz), (t2,yy)]) in
 ∀ p ∈ num. ∃ P ⊆ num. finite P ∧ prv (dsj (sdsj {eql (Var yy) r | r. r ∈ P}) (LLq p (Var yy)))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LLq_num</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q ∈ num"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {zz}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ p ∈ num. bprv (subst φ p zz)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (all zz (imp (LLq (Var zz) q) φ))"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>Lq_num</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LLq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LLq_num2</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ∈ num"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ P ⊆ num. finite P ∧ prv (dsj (sdsj {eql (Var yy) r | r. r ∈ P}) (LLq p (Var yy)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>Lq_num2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LLq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale Deduct2_with_PseudoOrder}›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Factoring In Explicit Proofs›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Deduct_with_Proofs</span><span> </span><span class="delimiter">=</span><span>
</span><span>Deduct_with_False_Disj</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>prv</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dsj</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span>
</span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'proof set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>prfOf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'proof ⇒ 'fmla ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span class="comment">― ‹Provability means there exists a proof (only needed for sentences):›</span><span>
</span><span>prv_prfOf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ φ. φ ∈ fmla ⟹ Fvars φ = {} ⟹ prv φ ⟷ (∃ prf ∈ proof. prfOf prf φ)"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* We consider proof structure only for prv, not for bprv *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Deduct2_with_Proofs</span><span> </span><span class="delimiter">=</span><span>
</span><span>Deduct2_with_False_Disj</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="delimiter">+</span><span>
</span><span>Deduct_with_Proofs</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>prv</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span> </span><span>prfOf</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dsj</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'proof set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prfOf</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Deduct2_with_Proofs_PseudoOrder</span><span> </span><span class="delimiter">=</span><span>
</span><span>Deduct2_with_Proofs</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span> </span><span>prfOf</span><span>
</span><span class="delimiter">+</span><span>
</span><span>Deduct2_with_PseudoOrder</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>Lq</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dsj</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'proof set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prfOf</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Lq</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span></pre>
</div>
</div><div id="Abstract_Encoding">
<div class="head"><h1>Theory Abstract_Encoding</h1>
<span class="command">theory</span> <span class="name">Abstract_Encoding</span><br/>
<span class="keyword">imports</span> <a href="Deduction2.html"><span class="name">Deduction2</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Abstract Encoding›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Abstract_Encoding</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Deduction2</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Here we simply fix some unspecified encoding functions: encoding formulas
and proofs as numerals.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Encode</span><span> </span><span class="delimiter">=</span><span>
</span><span>Syntax_with_Numerals</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla ⇒ 'trm"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>enc</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ φ. φ ∈ fmla ⟹ enc φ ∈ num"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale Encode}›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Explicit proofs (encoded as numbers), needed only for the harder half of
Goedel's first, and for both half's of Rosser's version; not needed in Goedel's
second.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Encode_Proofs</span><span> </span><span class="delimiter">=</span><span>
</span><span>Encode</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>enc</span><span>
</span><span class="delimiter">+</span><span>
</span><span>Deduct2_with_Proofs</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span> </span><span>prfOf</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span> </span><span>dsj</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'proof set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prfOf</span><span>
</span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>encPf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'proof ⇒ 'trm"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>encPf</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ pf. pf ∈ proof ⟹ encPf pf ∈ num"</span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span></pre>
</div>
</div><div id="Abstract_Representability">
<div class="head"><h1>Theory Abstract_Representability</h1>
<span class="command">theory</span> <span class="name">Abstract_Representability</span><br/>
<span class="keyword">imports</span> <a href="Abstract_Encoding.html"><span class="name">Abstract_Encoding</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Representability Assumptions›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Abstract_Representability</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Abstract_Encoding</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Here we make assumptions about various functions or relations being
representable.›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Representability of Negation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The negation function neg is assumed to be representable by a
two-variable formula N.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Repr_Neg</span><span> </span><span class="delimiter">=</span><span>
</span><span>Deduct2_with_False</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="delimiter">+</span><span>
</span><span>Encode</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>enc</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>N</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'fmla</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>N</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"N ∈ fmla"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>Fvars_N</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars N = {xx,yy}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>neg_implies_prv_N</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀ φ.
  let NN = (λ t1 t2. psubst N [(t1,xx), (t2,yy)]) in
   φ ∈ fmla ⟶ Fvars φ = {} ⟶ bprv (NN ⟨φ⟩ ⟨neg φ⟩)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>N_unique</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀ φ.
  let NN = (λ t1 t2. psubst N [(t1,xx), (t2,yy)]) in
  φ ∈ fmla ⟶ Fvars φ = {} ⟶
  bprv (all yy (all yy'
    (imp (cnj (NN ⟨φ⟩ (Var yy)) (NN ⟨φ⟩ (Var yy')))
         (eql (Var yy) (Var yy')))))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹NN is a notation for the predicate that takes terms and returns corresponding instances
of N, obtained by substituting its free variables with these terms. This is very convenient
for reasoning, and will be done for all the representing formulas we will consider.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>NN</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NN ≡ λ t1 t2. psubst N [(t1,xx), (t2,yy)]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NN_def2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t1 ∈ trm ⟹ t2 ∈ trm ⟹ yy ∉ FvarsT t1 ⟹
 NN t1 t2 = subst (subst N t1 xx) t2 yy"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>NN_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>psubst_eq_rawpsubst2</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NN_neg</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla ⟹ Fvars φ = {} ⟹ bprv (NN ⟨φ⟩ ⟨neg φ⟩)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>neg_implies_prv_N</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Let_def</span><span> </span><span>NN_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NN_unique</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (all yy (all yy'
    (imp (cnj (NN ⟨φ⟩ (Var yy)) (NN ⟨φ⟩ (Var yy')))
         (eql (Var yy) (Var yy')))))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>N_unique</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Let_def</span><span> </span><span>NN_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NN</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"t1 ∈ trm ⟹ t2 ∈ trm ⟹ NN t1 t2 ∈ fmla"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>NN_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Fvars_NN</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t1 ∈ trm ⟹ t2 ∈ trm ⟹ yy ∉ FvarsT t1 ⟹
Fvars (NN t1 t2) = FvarsT t1 ∪ FvarsT t2"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>NN_def2</span><span> </span><span>subst2_fresh_switch</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Here and elsewhere: hard to make into one or two uniform statements,
given that we don't assume sufficiently powerful properties for trm substitution.
So such lists would need to be maintained on an ad hoc basis, keeping adding instances
when needed. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"m ∈ num ⟹ n ∈ num ⟹ subst (NN m (Var yy)) n yy = NN m n"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"m ∈ num ⟹ n ∈ num ⟹ subst (NN m (Var yy')) n yy = NN m (Var yy')"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"m ∈ num ⟹ subst (NN m (Var yy')) (Var yy) yy' = NN m (Var yy)"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"n ∈ num ⟹ subst (NN (Var xx) (Var yy)) n xx = NN n (Var yy)"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"n ∈ num ⟹ subst (NN (Var xx) (Var xx')) n xx = NN n (Var xx')"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"m ∈ num ⟹ n ∈ num ⟹ subst (NN m (Var xx')) n zz = NN m (Var xx')"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"n ∈ num ⟹ subst (NN n (Var yy)) (Var xx') yy = NN n (Var xx')"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"m ∈ num ⟹ n ∈ num ⟹ subst (NN m (Var xx')) n xx' = NN m n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>NN_def2</span><span> </span><span>subst2_fresh_switch</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NN_unique2</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"bprv (all yy
     (imp (NN ⟨φ⟩ (Var yy))
          (eql ⟨neg φ⟩ (Var yy))))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (NN ⟨φ⟩ ⟨neg φ⟩)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NN_neg</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (all yy' (
             imp (cnj (NN ⟨φ⟩ ⟨neg φ⟩)
                      (NN ⟨φ⟩ (Var yy')))
                 (eql ⟨neg φ⟩ (Var yy'))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.prv_allE</span><span class="delimiter">[</span><span>of</span><span> </span><span>yy</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>NN_unique</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨neg φ⟩"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>31</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (all yy' (
             imp (NN ⟨φ⟩ ⟨neg φ⟩)
                 (imp (NN ⟨φ⟩ (Var yy'))
                      (eql ⟨neg φ⟩ (Var yy')))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.prv_all_imp_cnj_rev</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>32</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (NN ⟨φ⟩ ⟨neg φ⟩)
                      (all yy' (imp (NN ⟨φ⟩ (Var yy'))
                                    (eql ⟨neg φ⟩ (Var yy')))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>B.prv_all_imp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>31</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>NN_def2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>33</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (all yy' (imp (NN ⟨φ⟩ (Var yy'))
                              (eql ⟨neg φ⟩ (Var yy'))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>B.prv_imp_mp</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>32</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.all_subst_rename_prv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>33</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>yy</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NN_neg_unique</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"bprv (imp (NN ⟨φ⟩ (Var yy))
           (eql ⟨neg φ⟩ (Var yy)))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv ?A"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (all yy ?A)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NN_unique2</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>B.allE_id</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>0</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NN_exi_cnj</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>φ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>χ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"χ ∈ fmla"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars χ = {yy}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (eqv (subst χ ⟨neg φ⟩ yy)
                 (exi yy (cnj χ (NN ⟨φ⟩ (Var yy)))))"</span></span></span><span>
</span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (eqv ?A ?B)"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>B.prv_eqvI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>yy</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"yy ∈ var"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?N</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"NN ⟨φ⟩ (Var yy)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (subst χ ⟨neg φ⟩ yy) ((subst (cnj χ ?N) ⟨neg φ⟩ yy)))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NN_neg</span><span class="delimiter">[</span><span>OF</span><span> </span><span>φ</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>B.prv_imp_cnj</span><span> </span><span>B.prv_imp_refl</span><span> </span><span>B.prv_imp_triv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp ?A ?B)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>B.prv_prv_imp_trans</span><span class="delimiter">[</span><span>rotated</span><span> </span><span>3</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>B.prv_exi_inst</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>00</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (eql ⟨neg φ⟩ (Var yy)) (imp χ (subst χ ⟨neg φ⟩ yy)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>B.prv_eql_subst_trm_id_rev</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>11</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (NN ⟨φ⟩ (Var yy)) (imp χ (subst χ ⟨neg φ⟩ yy)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>00</span><span> </span><span>NN_neg_unique</span><span class="delimiter">[</span><span>OF</span><span> </span><span>φ</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NN</span><span> </span><span>num</span><span> </span><span>Var</span><span> </span><span>Variable</span><span> </span><span>φ</span><span> </span><span>χ</span><span> </span><span>eql</span><span> </span><span>imp</span><span> </span><span>subst</span><span> </span><span>B.prv_prv_imp_trans</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>enc</span><span> </span><span>in_num</span><span> </span><span>neg</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (cnj χ (NN ⟨φ⟩ (Var yy))) (subst χ ⟨neg φ⟩ yy))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>11</span><span> </span><span>B.prv_cnj_imp_monoR2</span><span> </span><span>B.prv_imp_com</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (all yy (imp (cnj χ (NN ⟨φ⟩ (Var yy))) (subst χ ⟨neg φ⟩ yy)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>B.prv_all_gen</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars (subst χ ⟨neg φ⟩ yy) = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp ?B ?A)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>B.prv_exi_imp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale Repr_Neg}›</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Representability of Self-Substitution›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Self-substitution is the function that takes a formula @{term φ}
and returns $\phi[\langle\phi\rangle/\mathit{xx}]$ (for the fixed variable @{term xx}). This is all that
will be needed for the diagonalization lemma.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Repr_SelfSubst</span><span> </span><span class="delimiter">=</span><span>
</span><span>Encode</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>enc</span><span>
</span><span class="delimiter">+</span><span>
</span><span>Deduct2</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'fmla</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>S</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S ∈ fmla"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>Fvars_S</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars S = {xx,yy}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>subst_implies_prv_S</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀ φ.
  let SS = (λ t1 t2. psubst S [(t1,xx), (t2,yy)]) in
  φ ∈ fmla ⟶ Fvars φ = {xx} ⟶
  bprv (SS ⟨φ⟩ ⟨subst φ ⟨φ⟩ xx⟩)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>S_unique</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀ φ.
  let SS = (λ t1 t2. psubst S [(t1,xx), (t2,yy)]) in
  φ ∈ fmla ⟶ Fvars φ = {xx} ⟶
  bprv (all yy (all yy'
     (imp (cnj (SS ⟨φ⟩ (Var yy)) (SS ⟨φ⟩ (Var yy')))
          (eql (Var yy) (Var yy')))))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹SS is the instantiation combinator of S:›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>SS</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SS ≡ λ t1 t2. psubst S [(t1,xx), (t2,yy)]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SS_def2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t1 ∈ trm ⟹ t2 ∈ trm ⟹
 yy ∉ FvarsT t1 ⟹
 SS t1 t2 = subst (subst S t1 xx) t2 yy"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SS_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>psubst_eq_rawpsubst2</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subst_implies_prv_SS</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla ⟹ Fvars φ = {xx} ⟹ bprv (SS ⟨φ⟩ ⟨subst φ ⟨φ⟩ xx⟩)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subst_implies_prv_S</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Let_def</span><span> </span><span>SS_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SS_unique</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla ⟹ Fvars φ = {xx} ⟹
 bprv (all yy (all yy'
      (imp (cnj (SS ⟨φ⟩ (Var yy)) (SS ⟨φ⟩ (Var yy')))
           (eql (Var yy) (Var yy')))))"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_unique</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Let_def</span><span> </span><span>SS_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SS</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"t1 ∈ trm ⟹ t2 ∈ trm ⟹ SS t1 t2 ∈ fmla"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SS_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Fvars_SS</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t1 ∈ trm ⟹ t2 ∈ trm ⟹ yy ∉ FvarsT t1 ⟹
Fvars (SS t1 t2) = FvarsT t1 ∪ FvarsT t2"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>SS_def2</span><span> </span><span>subst2_fresh_switch</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"m ∈ num ⟹ p ∈ num ⟹ subst (SS m (Var yy)) p yy = SS m p"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"m ∈ num ⟹ subst (SS m (Var yy')) (Var yy) yy' = SS m (Var yy)"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"m ∈ num ⟹ p ∈ num ⟹ subst (SS m (Var yy')) p yy' = SS m p"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"m ∈ num ⟹ p ∈ num ⟹ subst (SS m (Var yy')) p yy = SS m (Var yy')"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"m ∈ num ⟹ subst (SS (Var xx) (Var yy)) m xx = SS m (Var yy)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>SS_def2</span><span> </span><span>subst_comp_num</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale Repr_SelfSubst}›</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Representability of Self-Soft-Substitution›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The soft substitution function performs substitution logically instead of
syntactically. In particular, its "self" version sends @{term φ} to
@{term "exi xx (cnj (eql (Var xx) (enc φ)) φ)"}. Representability of self-soft-substitution will be
an alternative assumption in the diagonalization lemma.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Repr_SelfSoftSubst</span><span> </span><span class="delimiter">=</span><span>
</span><span>Encode</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>enc</span><span>
</span><span class="delimiter">+</span><span>
</span><span>Deduct2</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'fmla</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>S</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S ∈ fmla"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>Fvars_S</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars S = {xx,yy}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>softSubst_implies_prv_S</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀ φ.
  let SS = (λ t1 t2. psubst S [(t1,xx), (t2,yy)]) in
  φ ∈ fmla ⟶ Fvars φ = {xx} ⟶
  bprv (SS ⟨φ⟩ ⟨softSubst φ ⟨φ⟩ xx⟩)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>S_unique</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀ φ.
  let SS = (λ t1 t2. psubst S [(t1,xx), (t2,yy)]) in
  φ ∈ fmla ⟶ Fvars φ = {xx} ⟶
  bprv (all yy (all yy'
     (imp (cnj (SS ⟨φ⟩ (Var yy)) (SS ⟨φ⟩ (Var yy')))
          (eql (Var yy) (Var yy')))))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹SS is the instantiation combinator of S:›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>SS</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SS ≡ λ t1 t2. psubst S [(t1,xx), (t2,yy)]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SS_def2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t1 ∈ trm ⟹ t2 ∈ trm ⟹
 yy ∉ FvarsT t1 ⟹
 SS t1 t2 = subst (subst S t1 xx) t2 yy"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SS_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>psubst_eq_rawpsubst2</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>softSubst_implies_prv_SS</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla ⟹ Fvars φ = {xx} ⟹ bprv (SS ⟨φ⟩ ⟨softSubst φ ⟨φ⟩ xx⟩)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>softSubst_implies_prv_S</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Let_def</span><span> </span><span>SS_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SS_unique</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla ⟹ Fvars φ = {xx} ⟹
 bprv (all yy (all yy'
     (imp (cnj (SS ⟨φ⟩ (Var yy)) (SS ⟨φ⟩ (Var yy')))
          (eql (Var yy) (Var yy')))))"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_unique</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Let_def</span><span> </span><span>SS_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SS</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"t1 ∈ trm ⟹ t2 ∈ trm ⟹ SS t1 t2 ∈ fmla"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SS_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Fvars_SS</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t1 ∈ trm ⟹ t2 ∈ trm ⟹ yy ∉ FvarsT t1 ⟹
Fvars (SS t1 t2) = FvarsT t1 ∪ FvarsT t2"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>SS_def2</span><span> </span><span>subst2_fresh_switch</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"m ∈ num ⟹ p ∈ num ⟹ subst (SS m (Var yy)) p yy = SS m p"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"m ∈ num ⟹ subst (SS m (Var yy')) (Var yy) yy' = SS m (Var yy)"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"m ∈ num ⟹ p ∈ num ⟹ subst (SS m (Var yy')) p yy' = SS m p"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"m ∈ num ⟹ p ∈ num ⟹ subst (SS m (Var yy')) p yy = SS m (Var yy')"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"m ∈ num ⟹ subst (SS (Var xx) (Var yy)) m xx = SS m (Var yy)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>SS_def2</span><span> </span><span>subst_comp_num</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale Repr_SelfSoftSubst}›</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Clean Representability of the "Proof-of" Relation›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹For the proof-of relation, we must assume a stronger version of
representability, namely clean representability on the first argument, which
is dedicated to encoding the proof component. The property asks that the
representation predicate is provably false on numerals that do not encode
proofs; it would hold trivially for surjective proof encodings.

Cleanness is not a standard concept in the literature -- we have
introduced it in our CADE 2019 paper~\cite{DBLP:conf/cade/0001T19}.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>CleanRepr_Proofs</span><span> </span><span class="delimiter">=</span><span>
</span><span>Encode_Proofs</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span> </span><span>prfOf</span><span>
</span><span>  </span><span>encPf</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span> </span><span>dsj</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'proof set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prfOf</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>encPf</span><span>
</span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>Pf</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'fmla</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>Pf</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Pf ∈ fmla"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>Fvars_Pf</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars Pf = {yy,xx}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>prfOf_Pf</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀ prf φ.
  let PPf = (λ t1 t2. psubst Pf [(t1,yy), (t2,xx)]) in
  (prf ∈ proof ∧ φ ∈ fmla ∧ Fvars φ = {} ⟶
   prfOf prf φ
   ⟶
   bprv (PPf (encPf prf) ⟨φ⟩))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>not_prfOf_Pf</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀ prf φ.
  let PPf = (λ t1 t2. psubst Pf [(t1,yy), (t2,xx)]) in
  (prf ∈ proof ∧ φ ∈ fmla ∧ Fvars φ = {} ⟶
   ¬ prfOf prf φ
   ⟶
   bprv (neg (PPf (encPf prf) ⟨φ⟩)))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>Clean_Pf_encPf</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀ p φ. let PPf = (λ t1 t2. psubst Pf [(t1,yy), (t2,xx)]) in
  p ∈ num ∧ φ ∈ fmla ∧ Fvars φ = {} ⟶ p ∉ encPf ` proof ⟶ bprv (neg (PPf p ⟨φ⟩))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹PPf is the instantiation combinator of Pf:›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>PPf</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"PPf ≡ λ t1 t2. psubst Pf [(t1,yy), (t2,xx)]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prfOf_PPf</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prf ∈ proof"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prfOf prf φ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (PPf (encPf prf) ⟨φ⟩)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>prfOf_Pf</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PPf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_prfOf_PPf</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prf ∈ proof"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ prfOf prf φ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (neg (PPf (encPf prf) ⟨φ⟩))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>not_prfOf_Pf</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PPf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Clean_PPf_encPf</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ∈ num"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ∉ encPf ` proof"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (neg (PPf p ⟨φ⟩))"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>Clean_Pf_encPf</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PPf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>PPf</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t1 ∈ trm ⟹ t2 ∈ trm ⟹ xx ∉ FvarsT t1 ⟹ PPf t1 t2 ∈ fmla"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PPf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>PPf_def2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t1 ∈ trm ⟹ t2 ∈ trm ⟹ xx ∉ FvarsT t1 ⟹
  PPf t1 t2 = subst (subst Pf t1 yy) t2 xx"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PPf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>psubst_eq_rawpsubst2</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Fvars_PPf</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"t1 ∈ trm ⟹ t2 ∈ trm ⟹ xx ∉ FvarsT t1 ⟹
 Fvars (PPf t1 t2) = FvarsT t1 ∪ FvarsT t2"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>PPf_def2</span><span> </span><span>subst2_fresh_switch</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"n ∈ num ⟹ subst (PPf (Var yy) (Var xx)) n xx = PPf (Var yy) n"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"m ∈ num ⟹ n ∈ num ⟹ subst (PPf (Var yy) m) n yy = PPf n m"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"n ∈ num ⟹ subst (PPf (Var yy) (Var xx)) n yy = PPf n (Var xx)"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"m ∈ num ⟹ n ∈ num ⟹ subst (PPf m (Var xx)) n xx = PPf m n"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"m ∈ num ⟹ subst (PPf (Var zz) (Var xx')) m zz = PPf m (Var xx')"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"m ∈ num ⟹ n ∈ num ⟹ subst (PPf m (Var xx')) n xx' = PPf m n"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"n ∈ num ⟹ subst (PPf (Var zz) (Var xx')) n xx' = PPf (Var zz) n"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"m ∈ num ⟹ n ∈ num ⟹ subst (PPf (Var zz) n) m zz = PPf m n"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>PPf_def2</span><span> </span><span>subst2_fresh_switch</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>B_consistent_prfOf_iff_PPf</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"B.consistent ⟹ prf ∈ proof ⟹ φ ∈ fmla ⟹ Fvars φ = {} ⟶ prfOf prf φ ⟷ bprv (PPf (encPf prf) ⟨φ⟩)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>B.consistent_def3</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_prfOf_PPf</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"prf"</span></span></span><span> </span><span>φ</span><span class="delimiter">]</span><span> </span><span>prfOf_PPf</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"prf"</span></span></span><span> </span><span>φ</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>consistent_prfOf_iff_PPf</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"consistent ⟹ prf ∈ proof ⟹ φ ∈ fmla ⟹ Fvars φ = {} ⟶ prfOf prf φ ⟷ bprv (PPf (encPf prf) ⟨φ⟩)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B_consistent_prfOf_iff_PPf</span><span class="delimiter">[</span><span>OF</span><span> </span><span>dwf_dwfd.consistent_B_consistent</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale CleanRepr_Proofs}›</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="Diagonalization">
<div class="head"><h1>Theory Diagonalization</h1>
<span class="command">theory</span> <span class="name">Diagonalization</span><br/>
<span class="keyword">imports</span> <a href="Abstract_Representability.html"><span class="name">Abstract_Representability</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Diagonalization›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This theory proves abstract versions of the diagonalization lemma,
with both hard and soft substitution.›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Alternative Diagonalization via Self-Substitution›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Diagonalization</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Abstract_Representability</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Assuming representability of the diagonal instance of the substitution function,
we prove the standard diagonalization lemma. More precisely, we show that it applies
to any logic that
-- embeds intuitionistic first-order logic over numerals
-- has a countable number of formulas
-- has formula self-substitution representable
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Repr_SelfSubst</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>diagonalization</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>φ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {xx}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ ψ. ψ ∈ fmla ∧ Fvars ψ = {} ∧ bprv (eqv ψ (subst φ ⟨ψ⟩ xx))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?phi</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ t. subst φ t xx"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>χ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"χ ≡ exi yy (cnj (?phi (Var yy)) (SS (Var xx) (Var yy)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>χ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"χ ∈ fmla"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>χ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?chi</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ t. subst χ t xx"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ψ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ ≡ ?chi ⟨χ⟩"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ψ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ ∈ fmla"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ψ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fχ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars χ = {xx}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>χ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>Fvars_ψ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars ψ = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ψ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (SS ⟨χ⟩ ⟨ψ⟩)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subst_implies_prv_SS</span><span class="delimiter">[</span><span>OF</span><span> </span><span>χ</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ψ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (all yy' (
             imp (cnj (SS ⟨χ⟩ ⟨ψ⟩)
                      (SS ⟨χ⟩ (Var yy')))
                 (eql ⟨ψ⟩ (Var yy'))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Fvars_ψ</span><span> </span><span>B.prv_allE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>SS_unique</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>χ</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨ψ⟩"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>31</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (all yy'
                     (imp (SS ⟨χ⟩ ⟨ψ⟩)
                          (imp (SS ⟨χ⟩ (Var yy'))
                               (eql ⟨ψ⟩ (Var yy')))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.prv_all_imp_cnj_rev</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>32</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (SS ⟨χ⟩ ⟨ψ⟩)
                      (all yy' (imp (SS ⟨χ⟩ (Var yy'))
                                    (eql ⟨ψ⟩ (Var yy')))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>B.prv_all_imp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>31</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>SS_def2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>33</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (all yy' (imp (SS ⟨χ⟩ (Var yy'))
                               (eql ⟨ψ⟩ (Var yy'))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>B.prv_imp_mp</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>32</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (all yy (imp (SS ⟨χ⟩ (Var yy))
                             (eql ⟨ψ⟩ (Var yy))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.all_subst_rename_prv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>33</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>yy</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>41</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (?phi ⟨ψ⟩)
                      (cnj (?phi ⟨ψ⟩)
                           (SS ⟨χ⟩ ⟨ψ⟩)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>in_num</span><span> </span><span>B.prv_imp_cnj</span><span> </span><span>B.prv_imp_refl</span><span> </span><span>B.prv_imp_triv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst (subst φ ⟨ψ⟩ xx) ⟨ψ⟩ yy = subst φ ⟨ψ⟩ xx"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>subst_notIn</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst (subst φ (Var yy) xx) ⟨ψ⟩ yy = subst φ ⟨ψ⟩ xx"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>subst_subst</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>42</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (exi yy (imp (?phi ⟨ψ⟩)
                              (cnj (?phi (Var yy))
                                   (SS ⟨χ⟩ (Var yy)))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>41</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>B.prv_exiI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨ψ⟩"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (?phi ⟨ψ⟩) (?chi ⟨χ⟩))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.prv_imp_exi</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>42</span><span class="delimiter">,</span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>χ_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>subst_comp_num</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>50</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (all yy (
          (imp (eql ⟨ψ⟩ (Var yy))
               (imp (?phi (Var yy))
                    (?phi ⟨ψ⟩)))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.prv_all_eql</span><span class="delimiter">[</span><span>of</span><span> </span><span>yy</span><span> </span><span>xx</span><span> </span><span>φ</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨ψ⟩"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Var yy"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>51</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (all yy (
          (imp (SS ⟨χ⟩ (Var yy))
               (imp (?phi (Var yy))
               (?phi ⟨ψ⟩)))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.prv_all_imp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>3</span><span> </span><span>50</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>52</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (all yy (
          (imp (cnj (?phi (Var yy))
                    (SS ⟨χ⟩ (Var yy)))
               (?phi ⟨ψ⟩))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.prv_all_imp_cnj</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>51</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (?chi ⟨χ⟩) (?phi ⟨ψ⟩))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.prv_exi_imp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>52</span><span class="delimiter">,</span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>χ_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>subst_comp_num</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>6</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (eqv (?chi ⟨χ⟩) (?phi ⟨ψ⟩))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.prv_cnjI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>5</span><span> </span><span>4</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eqv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>7</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (eqv ψ (?phi ⟨ψ⟩))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>6</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ψ_def</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ψ</span><span> </span><span>7</span><span> </span><span>Fvars_ψ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Making this existential into a function.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>diag</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla ⇒ 'fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"diag φ ≡ SOME ψ. ψ ∈ fmla ∧ Fvars ψ = {} ∧ bprv (eqv ψ (subst φ ⟨ψ⟩ xx))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>diag_everything</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {xx}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"diag φ ∈ fmla ∧ Fvars (diag φ) = {} ∧ bprv (eqv (diag φ) (subst φ ⟨diag φ⟩ xx))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diag_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>someI_ex</span><span class="delimiter">[</span><span>OF</span><span> </span><span>diagonalization</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>diag</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>diag_everything</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conjunct1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>Fvars_diag</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>diag_everything</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>conjunct1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>bprv_diag_eqv</span><span> </span><span class="delimiter">=</span><span> </span><span>diag_everything</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale Repr_SelfSubst}›</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Alternative Diagonalization via Soft Self-Substitution›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Repr_SelfSoftSubst</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>diagonalization</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>φ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {xx}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ ψ. ψ ∈ fmla ∧ Fvars ψ = {} ∧ bprv (eqv ψ (subst φ ⟨ψ⟩ xx))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?phi</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ t. subst φ t xx"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>χ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"χ ≡ exi yy (cnj (?phi (Var yy)) (SS (Var xx) (Var yy)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>χ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"χ ∈ fmla"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>χ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?chi</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ t. softSubst χ t xx"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ψ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ ≡ ?chi ⟨χ⟩"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ψ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ ∈ fmla"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ψ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fχ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars χ = {xx}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>χ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>Fvars_ψ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars ψ = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ψ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (SS ⟨χ⟩ ⟨ψ⟩)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>softSubst_implies_prv_SS</span><span class="delimiter">[</span><span>OF</span><span> </span><span>χ</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ψ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (all yy' (
             imp (cnj (SS ⟨χ⟩ ⟨ψ⟩)
                      (SS ⟨χ⟩ (Var yy')))
                 (eql ⟨ψ⟩ (Var yy'))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Fvars_ψ</span><span> </span><span>B.prv_allE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>SS_unique</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>χ</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨ψ⟩"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>31</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (all yy'
                     (imp (SS ⟨χ⟩ ⟨ψ⟩)
                          (imp (SS ⟨χ⟩ (Var yy'))
                               (eql ⟨ψ⟩ (Var yy')))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.prv_all_imp_cnj_rev</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>32</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (SS ⟨χ⟩ ⟨ψ⟩)
                     (all yy' (imp (SS ⟨χ⟩ (Var yy'))
                                   (eql ⟨ψ⟩ (Var yy')))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>B.prv_all_imp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>31</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>SS_def2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>33</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (all yy' (imp (SS ⟨χ⟩ (Var yy'))
                              (eql ⟨ψ⟩ (Var yy'))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>B.prv_imp_mp</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>32</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (all yy (imp (SS ⟨χ⟩ (Var yy))
                            (eql ⟨ψ⟩ (Var yy))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.all_subst_rename_prv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>33</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>yy</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>41</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (?phi ⟨ψ⟩)
                     (cnj (?phi ⟨ψ⟩)
                          (SS ⟨χ⟩ ⟨ψ⟩)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>in_num</span><span> </span><span>B.prv_imp_cnj</span><span> </span><span>B.prv_imp_refl</span><span> </span><span>B.prv_imp_triv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst (subst φ ⟨ψ⟩ xx) ⟨ψ⟩ yy = subst φ ⟨ψ⟩ xx"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>subst_notIn</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst (subst φ (Var yy) xx) ⟨ψ⟩ yy = subst φ ⟨ψ⟩ xx"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>subst_subst</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>42</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (exi yy (imp (?phi ⟨ψ⟩)
                             (cnj (?phi (Var yy))
                                  (SS ⟨χ⟩ (Var yy)))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>41</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>B.prv_exiI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨ψ⟩"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (?phi ⟨ψ⟩) (subst χ ⟨χ⟩ xx))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.prv_imp_exi</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>42</span><span class="delimiter">,</span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>χ_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>subst_comp_num</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (subst χ ⟨χ⟩ xx) (?chi ⟨χ⟩))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>B.prv_subst_imp_softSubst</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (?phi ⟨ψ⟩) (?chi ⟨χ⟩))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>B.prv_prv_imp_trans</span><span class="delimiter">[</span><span>rotated</span><span> </span><span>-</span><span>2</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>50</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (all yy (
          (imp (eql ⟨ψ⟩ (Var yy))
               (imp (?phi (Var yy))
                    (?phi ⟨ψ⟩)))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.prv_all_eql</span><span class="delimiter">[</span><span>of</span><span> </span><span>yy</span><span> </span><span>xx</span><span> </span><span>φ</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨ψ⟩"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Var yy"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>51</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (all yy (
          (imp (SS ⟨χ⟩ (Var yy))
               (imp (?phi (Var yy))
               (?phi ⟨ψ⟩)))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.prv_all_imp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>3</span><span> </span><span>50</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>52</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (all yy (
          (imp (cnj (?phi (Var yy))
                    (SS ⟨χ⟩ (Var yy)))
               (?phi ⟨ψ⟩))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.prv_all_imp_cnj</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>51</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (?chi ⟨χ⟩) (subst χ ⟨χ⟩ xx))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>B.prv_softSubst_imp_subst</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (subst χ ⟨χ⟩ xx) (?phi ⟨ψ⟩))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.prv_exi_imp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>52</span><span class="delimiter">,</span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>χ_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>subst_comp_num</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (?chi ⟨χ⟩) (?phi ⟨ψ⟩))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>B.prv_prv_imp_trans</span><span class="delimiter">[</span><span>rotated</span><span> </span><span>-</span><span>2</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>6</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (eqv (?chi ⟨χ⟩) (?phi ⟨ψ⟩))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.prv_cnjI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>5</span><span> </span><span>4</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eqv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>7</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (eqv ψ (?phi ⟨ψ⟩))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>6</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ψ_def</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ψ</span><span> </span><span>7</span><span> </span><span>Fvars_ψ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Making this existential into a function.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>diag</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla ⇒ 'fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"diag φ ≡ SOME ψ. ψ ∈ fmla ∧ Fvars ψ = {} ∧ bprv (eqv ψ (subst φ ⟨ψ⟩ xx))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>diag_everything</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {xx}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"diag φ ∈ fmla ∧ Fvars (diag φ) = {} ∧ bprv (eqv (diag φ) (subst φ ⟨diag φ⟩ xx))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>diag_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>someI_ex</span><span class="delimiter">[</span><span>OF</span><span> </span><span>diagonalization</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>diag</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>diag_everything</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conjunct1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>Fvars_diag</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>diag_everything</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>conjunct1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>prv_diag_eqv</span><span> </span><span class="delimiter">=</span><span> </span><span>diag_everything</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale Repr_SelfSoftSubst}›</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="Derivability_Conditions">
<div class="head"><h1>Theory Derivability_Conditions</h1>
<span class="command">theory</span> <span class="name">Derivability_Conditions</span><br/>
<span class="keyword">imports</span> <a href="Abstract_Representability.html"><span class="name">Abstract_Representability</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The Hilbert-Bernays-Löb (HBL) Derivability Conditions›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Derivability_Conditions</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Abstract_Representability</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹First Derivability Condition›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Assume the provability predicate is "very-weakly" representable,
in that one implication of the weak representability condition holds.   *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>HBL1</span><span> </span><span class="delimiter">=</span><span>
</span><span>Encode</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>enc</span><span>
</span><span class="delimiter">+</span><span>
</span><span>Deduct2</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="delimiter">+</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Very-weak represenatbility of provability, as a one-variable formula P, usually called the provability predicate: *)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>P</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'fmla</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>P</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∈ fmla"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>Fvars_P</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars P = {xx}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>HBL1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀φ. φ ∈ fmla ⟹ Fvars φ = {} ⟹ prv φ ⟹ bprv (subst P ⟨φ⟩ xx)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* For all our (very-weak) representability assumptions, in addition to
 the representing formulas,
here, P, we define a corresponding instantiation combinator, here the
predicate PP.
If we think of P as P(xx), then PP t is the instance PP(t)  *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>PP</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"PP ≡ λt. subst P t xx"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>PP</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀t. t ∈ trm ⟹ PP t ∈ fmla"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Fvars_PP</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀t. t ∈ trm ⟹ Fvars (PP t) = FvarsT t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"n ∈ num ⟹ subst (PP (Var yy)) n yy = PP n"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"n ∈ num ⟹ subst (PP (Var xx)) n xx = PP n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HBL1_PP</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla ⟹ Fvars φ = {} ⟹ prv φ ⟹ bprv (PP ⟨φ⟩)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HBL1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale HBL1}›</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Connections between Proof Representability,
First Derivability Condition, and Its Converse›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>CleanRepr_Proofs</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Defining @{term P}, the internal notion of provability,
from @{term Pf} (in its predicate form @{term PPf}), the internal notion of "proof-of".
NB: In the technical sense of the term "represents", we have that
@{term Pf} represents @{term pprv}, whereas @{term P} will not represent @{term prv}, but satisfy a weaker
condition (weaker than weak representability), namely HBL1.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹HBL1 from "proof-of" representability›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>P</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≡ exi yy (PPf (Var yy) (Var xx))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>P</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∈ fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Fvars_P</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars P = {xx}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>P_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>PPf_def2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We infer HBL1 from Pf representing prv:›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HBL1</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>φ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pφ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv φ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (subst P ⟨φ⟩ xx)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prf"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>pf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prf ∈ proof"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prfOf prf φ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_prfOf</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (PPf (encPf prf) (enc φ))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prfOf_PPf</span><span> </span><span>φ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst (subst Pf (encPf prf) yy) ⟨φ⟩ xx = subst (subst Pf ⟨φ⟩ xx) (substT (encPf prf) ⟨φ⟩ xx) yy"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>pf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>subst_compose_diff</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>0</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>P_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>PPf_def2</span><span> </span><span>1</span><span> </span><span>pf</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>B.prv_exiI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"encPf prf"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This is used in several places, including for the hard half of
Gödel's First and the truth of Gödel formulas (and also for the Rosser variants
of these).›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_prv_prv_neg_PPf</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ prv φ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n ∈ num"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (neg (PPf n ⟨φ⟩))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀prf∈proof. ¬ prfOf prf φ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_prfOf</span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀prf∈proof. bprv (neg (PPf (encPf prf) ⟨φ⟩))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_prfOf_PPf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_prfOf_PPf</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Clean_PPf_encPf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"n ∈ encPf ` proof"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>consistent_not_prv_not_prv_PPf</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span>consistent</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>0</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ prv φ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ∈ num"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ bprv (PPf n ⟨φ⟩)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_prv_prv_neg_PPf</span><span class="delimiter">[</span><span>OF</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span>c</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>dwf_dwfd.consistent_B_consistent</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>B.consistent_def3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale CleanRepr_Proofs}›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The inference of HBL1 from "proof-of" representability, in locale form:›</span></span></span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>CleanRepr_Proofs</span><span> </span><span class="delimiter">&lt;</span><span> </span><span>wrepr</span><span class="delimiter">:</span><span> </span><span>HBL1</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span> </span><span class="delimiter">=</span><span> </span><span>P</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HBL1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sufficient condition for the converse of HBL1›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>CleanRepr_Proofs</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>PP_PPf</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wrepr.PP ⟨φ⟩ = exi yy (PPf (Var yy) ⟨φ⟩)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrepr.PP_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>PPf_def2</span><span> </span><span>P_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The converse of HLB1 condition follows from (the standard notion of)
$\omega$-consistency for @{term bprv} and strong representability of proofs:›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ωconsistentStd1_HBL1_rev</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>oc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"B.ωconsistentStd1"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>φ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>iPP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (wrepr.PP ⟨φ⟩)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv φ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (exi yy (PPf (Var yy) ⟨φ⟩))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iPP</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>PP_PPf</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ prv φ"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n ∈ num. bprv (neg (PPf n ⟨φ⟩))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_prv_prv_neg_PPf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ bprv (exi yy (PPf (Var yy) ⟨φ⟩))"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>oc</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>B.ωconsistentStd1_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>φ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale CleanRepr_Proofs}›</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Second and Third Derivability Conditions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹These are only needed for Gödel's Second.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>HBL1_2_3</span><span> </span><span class="delimiter">=</span><span>
</span><span>HBL1</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>P</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span>
</span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>HBL2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀φ χ. φ ∈ fmla ⟹ χ ∈ fmla ⟹ Fvars φ = {} ⟹ Fvars χ = {} ⟹
  bprv (imp (cnj (PP ⟨φ⟩) (PP ⟨imp φ χ⟩))
           (PP ⟨χ⟩))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>HBL3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀φ. φ ∈ fmla ⟹ Fvars φ = {} ⟹ bprv (imp (PP ⟨φ⟩) (PP ⟨PP ⟨φ⟩⟩))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The implicational form of HBL2:›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HBL2_imp</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀φ χ. φ ∈ fmla ⟹ χ ∈ fmla ⟹ Fvars φ = {} ⟹ Fvars χ = {} ⟹
  bprv (imp (PP ⟨imp φ χ⟩) (imp (PP ⟨φ⟩) (PP ⟨χ⟩)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HBL2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>B.prv_cnj_imp</span><span> </span><span>B.prv_imp_com</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹... and its weaker, "detached" version:›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HBL2_imp2</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"χ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars χ = {}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (PP ⟨imp φ χ⟩)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (PP ⟨φ⟩) (PP ⟨χ⟩))"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>HBL2_imp</span><span> </span><span>PP</span><span> </span><span>enc</span><span> </span><span>imp</span><span> </span><span>num</span><span> </span><span>B.prv_imp_mp</span><span> </span><span>subsetCE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale HBL1_2_3}›</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span></pre>
</div>
</div><div id="Goedel_Formula">
<div class="head"><h1>Theory Goedel_Formula</h1>
<span class="command">theory</span> <span class="name">Goedel_Formula</span><br/>
<span class="keyword">imports</span> <a href="Diagonalization.html"><span class="name">Diagonalization</span></a> <a href="Derivability_Conditions.html"><span class="name">Derivability_Conditions</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Gödel Formulas›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Goedel_Formula</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Diagonalization</span><span> </span><span>Derivability_Conditions</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Gödel formulas are defined by diagonalizing the negation of the provability predicate.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Goedel_Form</span><span> </span><span class="delimiter">=</span><span>
</span><span class="comment">― ‹Assuming the @{term fls} (False) connective gives us negation:›</span><span>
</span><span>Deduct2_with_False</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="delimiter">+</span><span>
</span><span>Repr_SelfSubst</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>S</span><span>
</span><span class="delimiter">+</span><span>
</span><span>HBL1</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>P</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>num</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The Gödel formula.
NB, we speak of "the" Gödel formula because the diagonalization function makes a choice.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>φG</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'fmla</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φG ≡ diag (neg P)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>φG</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φG ∈ fmla"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>Fvars_φG</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φG = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>φG_def</span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bprv_φG_eqv</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"bprv (eqv φG (neg (PP ⟨φG⟩)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>φG_def</span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bprv_diag_eqv</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"neg P"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prv_φG_eqv</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"prv (eqv φG (neg (PP ⟨φG⟩)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bprv_prv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>bprv_φG_eqv</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale Goedel_Form}›</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Adding cleanly representable proofs to the assumptions
behind Gödel formulas:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Goedel_Form_Proofs</span><span> </span><span class="delimiter">=</span><span>
</span><span>Repr_SelfSubst</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>S</span><span>
</span><span class="delimiter">+</span><span>
</span><span>CleanRepr_Proofs</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span> </span><span>prfOf</span><span>
</span><span>  </span><span>encPf</span><span>
</span><span>  </span><span>Pf</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dsj</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'proof set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prfOf</span><span> </span><span>encPf</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Pf</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹... and extending the sublocale relationship @{locale CleanRepr_Proofs} &lt; @{locale HBL1}:›</span></span></span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>Goedel_Form_Proofs</span><span> </span><span class="delimiter">&lt;</span><span> </span><span>Goedel_Form</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span> </span><span class="delimiter">=</span><span> </span><span>P</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Goedel_Form_Proofs</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bprv_φG_eqv_not_exi_PPf</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"bprv (eqv φG (neg (exi yy (PPf (Var yy) ⟨φG⟩))))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P = exi yy Pf"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>PPf_def2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subst P ⟨φG⟩ xx = subst (exi yy Pf) ⟨φG⟩ xx"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subst P ⟨φG⟩ xx = exi yy (subst Pf ⟨φG⟩ xx)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bprv_φG_eqv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wrepr.PP_def</span><span> </span><span>PPf_def2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prv_φG_eqv_not_exi_PPf</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"prv (eqv φG (neg (exi yy (PPf (Var yy) ⟨φG⟩))))"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bprv_prv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>bprv_φG_eqv_not_exi_PPf</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bprv_φG_eqv_all_not_PPf</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"bprv (eqv φG (all yy (neg (PPf (Var yy) ⟨φG⟩))))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>B.prv_eqv_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>bprv_φG_eqv_not_exi_PPf</span><span> </span><span>B.prv_neg_exi_eqv_all_neg</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prv_φG_eqv_all_not_PPf</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"prv (eqv φG (all yy (neg (PPf (Var yy) ⟨φG⟩))))"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bprv_prv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>bprv_φG_eqv_all_not_PPf</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bprv_eqv_all_not_PPf_imp_φG</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"bprv (imp (all yy (neg (PPf (Var yy) ⟨φG⟩))) φG)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bprv_φG_eqv_all_not_PPf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>B.prv_imp_eqvER</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prv_eqv_all_not_PPf_imp_φG</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"prv (imp (all yy (neg (PPf (Var yy) ⟨φG⟩))) φG)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bprv_prv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>bprv_eqv_all_not_PPf_imp_φG</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale Goedel_Form_Proofs}›</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="Standard_Model_More">
<div class="head"><h1>Theory Standard_Model_More</h1>
<span class="command">theory</span> <span class="name">Standard_Model_More</span><br/>
<span class="keyword">imports</span> <a href="Derivability_Conditions.html"><span class="name">Derivability_Conditions</span></a> <a href="../Syntax_Independent_Logic/Standard_Model.html"><span class="name">Standard_Model</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Standard Models with Two Provability Relations›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Abstract notion of standard model and truth  *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Standard_Model_More</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Derivability_Conditions</span><span> </span><span class="string"><span class="delete"><span class="delete">"Syntax_Independent_Logic.Standard_Model"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Minimal_Truth_Soundness_Proof_Repr</span><span> </span><span class="delimiter">=</span><span>
</span><span>CleanRepr_Proofs</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span> </span><span>prfOf</span><span>
</span><span>  </span><span>encPf</span><span>
</span><span>  </span><span>Pf</span><span>
</span><span class="delimiter">+</span><span> </span><span class="comment">― ‹The label "B" stands for "basic", as a reminder that soundness
refers to the basic provability relation:›</span><span>
</span><span>B</span><span class="delimiter">:</span><span> </span><span>Minimal_Truth_Soundness</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>bprv</span><span>
</span><span>  </span><span>isTrue</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dsj</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>isTrue</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'proof set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prfOf</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>encPf</span><span> </span><span>Pf</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>prfOf_iff_PPf</span><span> </span><span class="delimiter">=</span><span> </span><span>B_consistent_prfOf_iff_PPf</span><span class="delimiter">[</span><span>OF</span><span> </span><span>B.consistent</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The provability predicate is decided by basic provability on encodings:›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isTrue_prv_PPf_prf_or_neg</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"prf ∈ proof ⟹ φ ∈ fmla ⟹ Fvars φ = {} ⟹
    bprv (PPf (encPf prf) ⟨φ⟩) ∨ bprv (neg (PPf (encPf prf) ⟨φ⟩))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_prfOf_PPf</span><span> </span><span>prfOf_PPf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹... hence that predicate is complete w.r.t. truth:›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isTrue_PPf_Implies_bprv_PPf</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"prf ∈ proof ⟹ φ ∈ fmla ⟹ Fvars φ = {} ⟹
   isTrue (PPf (encPf prf) ⟨φ⟩) ⟹ bprv (PPf (encPf prf) ⟨φ⟩)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>FvarsT_num</span><span> </span><span>Fvars_PPf</span><span> </span><span>Fvars_fls</span><span> </span><span>PPf</span><span>
</span><span>Un_empty</span><span> </span><span>empty_iff</span><span> </span><span>enc</span><span> </span><span>encPf</span><span> </span><span>fls</span><span> </span><span>in_num</span><span> </span><span>isTrue_prv_PPf_prf_or_neg</span><span>
</span><span>neg_def</span><span> </span><span>B.not_isTrue_fls</span><span> </span><span>B.prv_imp_implies_isTrue</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹... and thanks cleanness we can replace encoded proofs
with arbitrary numerals in the completeness property:›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isTrue_implies_bprv_PPf</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n ∈ num"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>iT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isTrue (PPf n ⟨φ⟩)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (PPf n ⟨φ⟩)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"n ∈ encPf ` proof"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iT</span><span> </span><span>isTrue_PPf_Implies_bprv_PPf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (neg (PPf n ⟨φ⟩))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Clean_PPf_encPf</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isTrue (neg (PPf n ⟨φ⟩))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>B.sound_isTrue</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iT</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>B.isTrue_neg_excl</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹... in fact, by @{locale Minimal_Truth_Soundness} we even have an iff:›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isTrue_iff_bprv_PPf</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀ n φ. n ∈ num ⟹ φ ∈ fmla ⟹ Fvars φ = {} ⟹ isTrue (PPf n ⟨φ⟩) ⟷ bprv (PPf n ⟨φ⟩)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>isTrue_implies_bprv_PPf</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>exists_no_Fvars</span><span> </span><span>B.not_isTrue_fls</span><span> </span><span>B.sound_isTrue</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Truth of the provability representation implies provability (TIP):›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TIP</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>φ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>iPP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isTrue (wrepr.PP ⟨φ⟩)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv φ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isTrue (exi yy (PPf (Var yy) ⟨φ⟩))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iPP</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP_PPf</span><span class="delimiter">[</span><span>OF</span><span> </span><span>φ</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>B.isTrue_exi</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>n</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n ∈ num"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isTrue (PPf n ⟨φ⟩)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>pP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (PPf n ⟨φ⟩)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>isTrue_implies_bprv_PPf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ bprv (neg (PPf n ⟨φ⟩))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.prv_neg_excl</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"PPf n ⟨φ⟩"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prf"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prf"</span></span></span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prf ∈ proof"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n = encPf prf"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>n</span><span> </span><span>Clean_PPf_encPf</span><span> </span><span>φ</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prfOf prf φ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pP</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>nn</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prfOf_iff_PPf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_prfOf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The reverse HBL1 -- now without the $\omega$-consistency assumption which holds here
thanks to our truth-in-standard-model assumption:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>HBL1_rev</span><span> </span><span class="delimiter">=</span><span> </span><span>ωconsistentStd1_HBL1_rev</span><span class="delimiter">[</span><span>OF</span><span> </span><span>B.ωconsistentStd1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Note that the above would also follow by @{locale Minimal_Truth_Soundness} from TIP:›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TIP_implies_HBL1_rev</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>TIP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀φ. φ ∈ fmla ∧ Fvars φ = {} ∧ isTrue (wrepr.PP ⟨φ⟩) ⟶ prv φ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀φ. φ ∈ fmla ∧ Fvars φ = {} ∧ bprv (wrepr.PP ⟨φ⟩) ⟶ prv φ"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.sound_isTrue</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"wrepr.PP ⟨_⟩"</span></span></span><span class="delimiter">]</span><span> </span><span>TIP</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale Minimal_Truth_Soundness_Proof_Repr}›</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Proof recovery from $\mathit{HBL1\_iff}$›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Minimal_Truth_Soundness_HBL1iff_Compl_Pf</span><span> </span><span class="delimiter">=</span><span>
</span><span>HBL1</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>P</span><span>
</span><span class="delimiter">+</span><span>
</span><span>B</span><span> </span><span class="delimiter">:</span><span> </span><span>Minimal_Truth_Soundness</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>bprv</span><span>
</span><span>  </span><span>isTrue</span><span>
</span><span class="delimiter">+</span><span>
</span><span>Deduct_with_False_Disj</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>prv</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dsj</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>isTrue</span><span>
</span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>Pf</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'fmla</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span class="comment">― ‹@{term Pf} is a formula with free variables @{term xx} @{term yy}:›</span><span>
</span><span>Pf</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Pf ∈ fmla"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>Fvars_Pf</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars Pf = {yy,xx}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span class="comment">― ‹@{term P} relates to @{term Pf} internally (inside basic provability)
just like a @{term prv} and a @{term prfOf} would relate---via an existential:›</span><span>
</span><span>P_Pf</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla ⟹ Fvars φ = {} ⟹
 let PPf = (λ t1 t2. psubst Pf [(t1,yy), (t2,xx)]) in
 bprv (eqv (subst P ⟨φ⟩ xx) (exi yy (PPf (Var yy) ⟨φ⟩)))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span class="comment">― ‹We assume both $\mathit{HBL1}$ and $\mathit{HBL1\_rev}$, i.e., an iff version:›</span><span>
</span><span>HBL1_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ φ. φ ∈ fmla ⟹ Fvars φ = {} ⟹ bprv (PP ⟨φ⟩) ⟷ prv φ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>Compl_Pf</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀ n φ. n ∈ num ⟹ φ ∈ fmla ⟹ Fvars φ = {} ⟹
 let PPf = (λ t1 t2. psubst Pf [(t1,yy), (t2,xx)]) in
 isTrue (PPf n ⟨φ⟩) ⟶ bprv (PPf n ⟨φ⟩)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>PPf</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"PPf ≡ λ t1 t2. psubst Pf [(t1,yy), (t2,xx)]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>PP_deff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"PP t = subst P t xx"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>PP_PPf_eqv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla ⟹ Fvars φ = {} ⟹ bprv (eqv (PP ⟨φ⟩) (exi yy (PPf (Var yy) ⟨φ⟩)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PP_deff</span><span> </span><span>PPf_def</span><span> </span><span>P_Pf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>PPf</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t1 ∈ trm ⟹ t2 ∈ trm ⟹ xx ∉ FvarsT t1 ⟹ PPf t1 t2 ∈ fmla"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PPf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>PPf_def2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t1 ∈ trm ⟹ t2 ∈ trm ⟹ xx ∉ FvarsT t1 ⟹
  PPf t1 t2 = subst (subst Pf t1 yy) t2 xx"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PPf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>psubst_eq_rawpsubst2</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Fvars_PPf</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"t1 ∈ trm ⟹ t2 ∈ trm ⟹ xx ∉ FvarsT t1 ⟹ Fvars (PPf t1 t2) = FvarsT t1 ∪ FvarsT t2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>PPf_def2</span><span> </span><span>subst2_fresh_switch</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"n ∈ num ⟹ subst (PPf (Var yy) (Var xx)) n xx = PPf (Var yy) n"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"m ∈ num ⟹ n ∈ num ⟹ subst (PPf (Var yy) m) n yy = PPf n m"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"n ∈ num ⟹ subst (PPf (Var yy) (Var xx)) n yy = PPf n (Var xx)"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"m ∈ num ⟹ n ∈ num ⟹ subst (PPf m (Var xx)) n xx = PPf m n"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"m ∈ num ⟹ subst (PPf (Var zz) (Var xx')) m zz = PPf m (Var xx')"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"m ∈ num ⟹ n ∈ num ⟹ subst (PPf m (Var xx')) n xx' = PPf m n"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"n ∈ num ⟹ subst (PPf (Var zz) (Var xx')) n xx' = PPf (Var zz) n"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"m ∈ num ⟹ n ∈ num ⟹ subst (PPf (Var zz) n) m zz = PPf m n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>PPf_def2</span><span> </span><span>subst2_fresh_switch</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>PP_PPf</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (PP ⟨φ⟩) ⟷ bprv (exi yy (PPf (Var yy) ⟨φ⟩))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>PP_PPf_eqv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>B.prv_eqv_sym</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>PP_PPf_eqv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>B.prv_eqv_prv</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"PP ⟨φ⟩"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exi yy (PPf (Var yy) ⟨φ⟩)"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span>B.prv_eqv_prv</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"exi yy (PPf (Var yy) ⟨φ⟩)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"PP ⟨φ⟩"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isTrue_implies_bprv_PPf</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀ n φ. n ∈ num ⟹ φ ∈ fmla ⟹ Fvars φ = {} ⟹
 isTrue (PPf n ⟨φ⟩) ⟹ bprv (PPf n ⟨φ⟩)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Compl_Pf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>PPf_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isTrue_iff_bprv_PPf</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀ n φ. n ∈ num ⟹ φ ∈ fmla ⟹ Fvars φ = {} ⟹ isTrue (PPf n ⟨φ⟩) ⟷ bprv (PPf n ⟨φ⟩)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>isTrue_implies_bprv_PPf</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>exists_no_Fvars</span><span> </span><span>B.not_isTrue_fls</span><span> </span><span>B.sound_isTrue</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Preparing to instantiate this "proof recovery" alternative into our
mainstream locale hierarchy, which assumes proofs.
We define the "missing" proofs to be numerals, we encode them as the identity,
and we "copy" @{term prfOf} from the corresponding predicate one-level-up, @{term PPf}:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"proof = num"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>prfOf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm ⇒ 'fmla ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prfOf n φ ≡ bprv (PPf n ⟨φ⟩)"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>encPf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm ⇒ 'trm"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"encPf ≡ id"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prv_exi_PPf_iff_isTrue</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (exi yy (PPf (Var yy) ⟨φ⟩)) ⟷ isTrue (exi yy (PPf (Var yy) ⟨φ⟩))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L ⟷ ?R"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?L</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?R</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>B.sound_isTrue</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?R</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>n</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n ∈ num"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isTrue (PPf n ⟨φ⟩)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.isTrue_exi</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`?R`</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (PPf n ⟨φ⟩)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isTrue_iff_bprv_PPf</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?L</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>B.prv_exiI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>n</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isTrue_exi_iff</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isTrue (exi yy (PPf (Var yy) ⟨φ⟩)) ⟷ (∃n∈num. isTrue (PPf n ⟨φ⟩))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L ⟷ ?R"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?L</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?R</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.isTrue_exi</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`?L`</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?R</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>n</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n ∈ num"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isTrue (PPf n ⟨φ⟩)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (PPf n ⟨φ⟩)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isTrue_iff_bprv_PPf</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (exi yy (PPf (Var yy) ⟨φ⟩))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>B.prv_exiI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>n</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?L</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>B.sound_isTrue</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prv_prfOf</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv φ ⟷ (∃n∈num. prfOf n φ)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv φ ⟷ bprv (PP ⟨φ⟩)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HBL1_iff</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ⟷ bprv (exi yy (PPf (Var yy) ⟨φ⟩))"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP_PPf</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ⟷ isTrue (exi yy (PPf (Var yy) ⟨φ⟩))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_exi_PPf_iff_isTrue</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ⟷ (∃n∈num. isTrue (PPf n ⟨φ⟩))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>isTrue_exi_iff</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ⟷ (∃n∈num. bprv (PPf n ⟨φ⟩))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>isTrue_iff_bprv_PPf</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ⟷ (∃n∈num. prfOf n φ)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>prfOf_def</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prfOf_prv_Pf</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ∈ num"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prfOf n φ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (psubst Pf [(n, yy), (⟨φ⟩, xx)])"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>prfOf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>PPf_def2</span><span> </span><span>psubst_eq_rawpsubst2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isTrue_exi_iff_PP</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isTrue (PP ⟨φ⟩) ⟷ (∃n∈num. isTrue (PPf n ⟨φ⟩))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (eqv (PP ⟨φ⟩) (exi yy (PPf (Var yy) ⟨φ⟩)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PP_PPf_eqv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (PP ⟨φ⟩) (exi yy (PPf (Var yy) ⟨φ⟩)))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (exi yy (PPf (Var yy) ⟨φ⟩)) (PP ⟨φ⟩))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>B.prv_imp_eqvEL</span><span> </span><span>B.prv_imp_eqvER</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isTrue_exi_iff</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>iffI</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>B.prv_imp_implies_isTrue</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bprv_compl_isTrue_PP_enc</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isTrue (PP ⟨φ⟩)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (PP ⟨φ⟩)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>nn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n ∈ num"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isTrue (PPf n ⟨φ⟩)"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isTrue_exi_iff_PP</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (PPf n ⟨φ⟩)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nn</span><span> </span><span>assms</span><span> </span><span>isTrue_iff_bprv_PPf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (exi yy (PPf (Var yy) ⟨φ⟩))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span> </span><span>assms</span><span> </span><span>isTrue_exi_iff</span><span> </span><span>isTrue_exi_iff_PP</span><span> </span><span>prv_exi_PPf_iff_isTrue</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PP_PPf</span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TIP</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isTrue (PP ⟨φ⟩)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv φ"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bprv_compl_isTrue_PP_enc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>HBL1_iff</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale Minimal_Truth_Soundness_HBL1iff_Compl_Pf}›</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Minimal_Truth_Soundness_HBL1iff_Compl_Pf_Compl_NegPf</span><span> </span><span class="delimiter">=</span><span>
</span><span>Minimal_Truth_Soundness_HBL1iff_Compl_Pf</span><span>
</span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>Compl_NegPf</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀ n φ. n ∈ num ⟹ φ ∈ fmla ⟹ Fvars φ = {} ⟹
 let PPf = (λ t1 t2. psubst Pf [(t1,yy), (t2,xx)]) in
 isTrue (B.neg (PPf n ⟨φ⟩)) ⟶ bprv (B.neg (PPf n ⟨φ⟩))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isTrue_implies_prv_neg_PPf</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀ n φ. n ∈ num ⟹ φ ∈ fmla ⟹ Fvars φ = {} ⟹
 isTrue (B.neg (PPf n ⟨φ⟩)) ⟹ bprv (B.neg (PPf n ⟨φ⟩))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Compl_NegPf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>PPf_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isTrue_iff_prv_neg_PPf</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀ n φ. n ∈ num ⟹ φ ∈ fmla ⟹ Fvars φ = {} ⟹ isTrue (B.neg (PPf n ⟨φ⟩)) ⟷ bprv (B.neg (PPf n ⟨φ⟩))"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>isTrue_implies_prv_neg_PPf</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>exists_no_Fvars</span><span> </span><span>B.not_isTrue_fls</span><span> </span><span>B.sound_isTrue</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prv_PPf_decide</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n ∈ num"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>np</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ bprv (PPf n ⟨φ⟩)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (B.neg (PPf n ⟨φ⟩))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ isTrue (PPf n ⟨φ⟩)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isTrue_iff_bprv_PPf</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isTrue (B.neg (PPf n ⟨φ⟩))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.isTrue_neg</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"PPf n ⟨φ⟩"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isTrue_iff_prv_neg_PPf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_prfOf_prv_neg_Pf</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>nφ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n ∈ num"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ prfOf n φ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (B.neg (psubst Pf [(n, yy), (⟨φ⟩, xx)]))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>prv_PPf_decide</span><span class="delimiter">[</span><span>OF</span><span> </span><span>nφ</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>prfOf_def</span><span> </span><span>PPf_def2</span><span> </span><span>psubst_eq_rawpsubst2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale Minimal_Truth_Soundness_HBL1iff_Compl_Pf_Compl_NegPf}›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>Minimal_Truth_Soundness_HBL1iff_Compl_Pf_Compl_NegPf</span><span> </span><span class="delimiter">&lt;</span><span>
</span><span>   </span><span>repr</span><span class="delimiter">:</span><span> </span><span>CleanRepr_Proofs</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* added label to avoid duplicated constant P, which is assumed
in Minimal_Truth_Soundness_HBL1iff_Compl_Pf but defined in CleanRepr_Proofs
(they are of course extensionally equal).
*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prfOf</span><span> </span><span class="delimiter">=</span><span> </span><span>prfOf</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>encPf</span><span> </span><span class="delimiter">=</span><span> </span><span>encPf</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bprv_prv</span><span> </span><span>prv_prfOf</span><span> </span><span>prfOf_prv_Pf</span><span> </span><span>not_prfOf_prv_neg_Pf</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Lemma 6 ("proof recovery") from the JAR paper: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>Minimal_Truth_Soundness_HBL1iff_Compl_Pf_Compl_NegPf</span><span> </span><span class="delimiter">&lt;</span><span>
</span><span>  </span><span>min_truth</span><span class="delimiter">:</span><span> </span><span>Minimal_Truth_Soundness_Proof_Repr</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prfOf</span><span> </span><span class="delimiter">=</span><span> </span><span>prfOf</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>encPf</span><span> </span><span class="delimiter">=</span><span> </span><span>encPf</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FOR THE CLASSICAL REASONING VERSION *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Minimal_Truth_Soundness_HBL1iff_prv_Compl_Pf</span><span> </span><span class="delimiter">=</span><span>
</span><span>HBL1</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>P</span><span>
</span><span class="delimiter">+</span><span>
</span><span>B</span><span class="delimiter">:</span><span> </span><span>Minimal_Truth_Soundness</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>bprv</span><span>
</span><span>  </span><span>isTrue</span><span>
</span><span class="delimiter">+</span><span>
</span><span>Deduct_with_False_Disj</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>prv</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dsj</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>isTrue</span><span>
</span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>Pf</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'fmla</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Pf is a formula with free variables xx yy  *)</span></span></span></span></span><span>
</span><span>Pf</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Pf ∈ fmla"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>Fvars_Pf</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars Pf = {yy,xx}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* P relates to Pf internally just like a prv and a proofOf would
relate: via an existential *)</span></span></span></span></span><span>
</span><span>P_Pf</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla ⟹
 let PPf = (λ t1 t2. psubst Pf [(t1,yy), (t2,xx)]) in
 bprv (eqv (subst P ⟨φ⟩ xx) (exi yy (PPf (Var yy) ⟨φ⟩)))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* We assume, in addition to HBL1, the strong form of HBL1_rev: *)</span></span></span></span></span><span>
</span><span>HBL1_rev_prv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ φ. φ ∈ fmla ⟹ Fvars φ = {} ⟹ prv (PP ⟨φ⟩) ⟹ prv φ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>Compl_Pf</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀ n φ. n ∈ num ⟹ φ ∈ fmla ⟹ Fvars φ = {} ⟹
 let PPf = (λ t1 t2. psubst Pf [(t1,yy), (t2,xx)]) in
 isTrue (PPf n ⟨φ⟩) ⟶ bprv (PPf n ⟨φ⟩)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HBL1_rev</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (PP ⟨φ⟩)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv φ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>HBL1_rev_prv</span><span> </span><span>bprv_prv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>bp</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HBL1_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla ⟹ Fvars φ = {} ⟹ bprv (PP ⟨φ⟩) ⟷ prv φ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HBL1</span><span> </span><span>HBL1_rev</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HBL1_iff_prv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla ⟹ Fvars φ = {} ⟹ prv (PP ⟨φ⟩) ⟷ prv φ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>iffI</span><span> </span><span>bprv_prv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>HBL1_PP</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>elim</span><span> </span><span>HBL1_rev_prv</span><span class="delimiter">[</span><span>rotated</span><span> </span><span>-</span><span>1</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale Minimal_Truth_Soundness_HBL1iff_prv_Compl_Pf}›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>Minimal_Truth_Soundness_HBL1iff_prv_Compl_Pf</span><span> </span><span class="delimiter">&lt;</span><span>
</span><span>  </span><span>mts_prv_mts</span><span class="delimiter">:</span><span> </span><span>Minimal_Truth_Soundness_HBL1iff_Compl_Pf</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Pf</span><span> </span><span class="delimiter">=</span><span> </span><span>Pf</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P_Pf</span><span> </span><span>HBL1_rev</span><span> </span><span>HBL1_PP</span><span> </span><span>Compl_Pf</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Minimal_Truth_Soundness_HBL1iff_prv_Compl_Pf_Classical</span><span> </span><span class="delimiter">=</span><span>
</span><span>Minimal_Truth_Soundness_HBL1iff_prv_Compl_Pf</span><span>
</span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span class="comment">― ‹NB: we don't really need to assume classical reasoning (double negation) all throughout,
but only for the provability predicate:›</span><span>
</span><span>classical_P</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ φ. φ ∈ fmla ⟹ Fvars φ = {} ⟹ let PP = (λt. subst P t xx) in
  prv (B.neg (B.neg (PP ⟨φ⟩))) ⟹ prv (PP ⟨φ⟩)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>classical_PP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla ⟹ Fvars φ = {} ⟹ prv (B.neg (B.neg (PP ⟨φ⟩))) ⟹ prv (PP ⟨φ⟩)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>classical_P</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale Minimal_Truth_Soundness_HBL1iff_prv_Compl_Pf_Classical}›</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="Abstract_First_Goedel">
<div class="head"><h1>Theory Abstract_First_Goedel</h1>
<span class="command">theory</span> <span class="name">Abstract_First_Goedel</span><br/>
<span class="keyword">imports</span> <a href="Goedel_Formula.html"><span class="name">Goedel_Formula</span></a> <a href="Standard_Model_More.html"><span class="name">Standard_Model_More</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Abstract Formulations of Gödel's First Incompleteness Theorem›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Abstract_First_Goedel</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Goedel_Formula</span><span> </span><span>Standard_Model_More</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Proof-Theoretic Versions of Gödel's First›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Goedel_Form</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The easy half›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹First the "direct", positive formulation:›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>goedel_first_theEasyHalf_pos</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv φG"</span></span></span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv fls"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (neg (PP ⟨φG⟩))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_eqv_prv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>assms</span><span> </span><span>prv_φG_eqv</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (PP ⟨φG⟩)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HBL1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>φG</span><span> </span><span>Fvars_φG</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>bprv_prv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>this</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (PP ⟨φG⟩)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PP</span><span> </span><span>prv_neg_fls</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>φG</span><span> </span><span>enc</span><span> </span><span>in_num</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹... then the more standard contrapositive formulation:›</span></span></span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>goedel_first_theEasyHalf</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"consistent ⟹ ¬ prv φG"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>goedel_first_theEasyHalf_pos</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>consistent_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale Goedel_Form}›</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The hard half›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The hard half needs explicit proofs:›</span></span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Goedel_Form_Proofs</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>goedel_first_theHardHalf</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>oc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ωconsistent"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ prv (neg φG)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>pn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (neg φG)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>pnn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (neg (neg (wrepr.PP ⟨φG⟩)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_eqv_imp_transi</span><span> </span><span>num</span><span> </span><span>wrepr.PP</span><span> </span><span>φG</span><span> </span><span>fls</span><span> </span><span>neg</span><span> </span><span>neg_def</span><span> </span><span>prv_φG_eqv</span><span> </span><span>prv_eqv_sym</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>enc</span><span> </span><span>in_num</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>c</span><span> </span><span class="delimiter">=</span><span> </span><span>ωconsistent_implies_consistent</span><span class="delimiter">[</span><span>OF</span><span> </span><span>oc</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>np</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ prv φG"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pn</span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>consistent_def3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀p ∈ num. bprv (neg (PPf p ⟨φG⟩))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_prv_prv_neg_PPf</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>np</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀p ∈ num. prv (neg (PPf p ⟨φG⟩))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_prv_prv_neg_PPf</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>np</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>bprv_prv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ prv (neg (neg (exi yy (PPf (Var yy) ⟨φG⟩))))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>0</span><span> </span><span>oc</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ωconsistent_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ prv (neg (neg (wrepr.PP ⟨φG⟩)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrepr.PP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>P_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>  </span><span>PPf_def2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pnn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>goedel_first</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ωconsistent"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ prv φG ∧ ¬ prv (neg φG)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>goedel_first_theEasyHalf</span><span> </span><span>goedel_first_theHardHalf</span><span> </span><span>ωconsistent_implies_consistent</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>goedel_first_ex</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ωconsistent"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ φ. φ ∈ fmla ∧ ¬ prv φ ∧ ¬ prv (neg φ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>goedel_first</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>φG</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale Goedel_Form_Proofs}›</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Model-Theoretic Versions of Gödel's First›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The model-theoretic twist is that of additionally proving
the truth of Gödel sentences.›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹First model-theoretic version›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Goedel_Form_Proofs_Minimal_Truth</span><span> </span><span class="delimiter">=</span><span>
</span><span>Goedel_Form_Proofs</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>S</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span> </span><span>prfOf</span><span> </span><span>encPf</span><span>
</span><span>  </span><span>Pf</span><span>
</span><span class="delimiter">+</span><span>
</span><span>Minimal_Truth_Soundness</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>bprv</span><span>
</span><span>  </span><span>isTrue</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dsj</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'proof set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prfOf</span><span> </span><span>encPf</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Pf</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>isTrue</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Recall that "consistent" and "$\omega$-consistent" refer to @{term prv}, not to @{term bprv}.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>isTrue_φG</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"consistent"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isTrue φG"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ n ∈ num. bprv (neg (PPf n ⟨φG⟩))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_prv_prv_neg_PPf</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>goedel_first_theEasyHalf</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ n ∈ num. isTrue (neg (PPf n ⟨φG⟩))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>sound_isTrue</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isTrue (all yy (neg (PPf (Var yy) ⟨φG⟩)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>isTrue_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isTrue (imp (all yy (neg (PPf (Var yy) ⟨φG⟩))) φG)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bprv_eqv_all_not_PPf_imp_φG</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sound_isTrue</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>isTrue_imp</span><span class="delimiter">[</span><span>rotated</span><span> </span><span>-</span><span>2</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The "strong" form of Gödel's First (also asserting the truth of
the Gödel sentences):›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>goedel_first_strong</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"ωconsistent ⟹ ¬ prv φG ∧ ¬ prv (neg φG) ∧ isTrue φG"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>goedel_first</span><span> </span><span>isTrue_φG</span><span> </span><span>ωconsistent_implies_consistent</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>goedel_first_strong_ex</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"ωconsistent ⟹ ∃ φ. φ ∈ fmla ∧ ¬ prv φ ∧ ¬ prv (neg φ) ∧ isTrue φ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>goedel_first_strong</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>φG</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale Goedel_Form_Proofs_Minimal_Truth}›</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Second model-theoretic version›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Goedel_Form_Minimal_Truth_Soundness_HBL1iff_Compl_Pf</span><span> </span><span class="delimiter">=</span><span>
</span><span>Goedel_Form</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>num</span><span>
</span><span>  </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>S</span><span>
</span><span>  </span><span>P</span><span>
</span><span class="delimiter">+</span><span>
</span><span>Minimal_Truth_Soundness_HBL1iff_Compl_Pf</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>P</span><span>
</span><span>  </span><span>isTrue</span><span>
</span><span>  </span><span>Pf</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dsj</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>isTrue</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Pf</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Goedel_Form_Minimal_Truth_Soundness_HBL1iff_Compl_Pf_Compl_NegPf</span><span> </span><span class="delimiter">=</span><span>
</span><span>Goedel_Form_Minimal_Truth_Soundness_HBL1iff_Compl_Pf</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>S</span><span>
</span><span>  </span><span>isTrue</span><span>
</span><span>  </span><span>P</span><span>
</span><span>  </span><span>Pf</span><span>
</span><span class="delimiter">+</span><span>
</span><span>Minimal_Truth_Soundness_HBL1iff_Compl_Pf_Compl_NegPf</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>P</span><span>
</span><span>  </span><span>isTrue</span><span>
</span><span>  </span><span>Pf</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dsj</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>isTrue</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Pf</span><span>
</span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>prv_ωconsistent</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ωconsistent"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Semantic Goedel's first, Goedel-style, second variant
... established as a sublocale statement *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span>
</span><span>  </span><span>Goedel_Form_Minimal_Truth_Soundness_HBL1iff_Compl_Pf_Compl_NegPf</span><span> </span><span class="delimiter">&lt;</span><span>
</span><span>  </span><span>recover_proofs</span><span class="delimiter">:</span><span> </span><span>Goedel_Form_Proofs_Minimal_Truth</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>prfOf</span><span> </span><span class="delimiter">=</span><span> </span><span>prfOf</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>encPf</span><span> </span><span class="delimiter">=</span><span> </span><span>encPf</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span class="delimiter">=</span><span> </span><span>prv</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bprv</span><span> </span><span class="delimiter">=</span><span> </span><span>bprv</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* ... and here is the explicit statement, inside the locale that
provides all the assumptions *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Goedel_Form_Minimal_Truth_Soundness_HBL1iff_Compl_Pf_Compl_NegPf</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>recover_proofs.goedel_first_strong</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Classical-Logic Versions of Gödel's First›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹First classical-logic version›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Goedel_Form_Classical_HBL1_rev_prv</span><span> </span><span class="delimiter">=</span><span>
</span><span>Goedel_Form</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>num</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>S</span><span>
</span><span>  </span><span>P</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>num</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span>
</span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span class="comment">― ‹NB: we don't really need to assume classical reasoning (double negation)
for all formulas, but only for the provability predicate:›</span><span>
</span><span>classical_P_prv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ φ. φ ∈ fmla ⟹ Fvars φ = {} ⟹ let PP = (λt. subst P t xx) in
  prv (neg (neg (PP ⟨φ⟩))) ⟹ prv (PP ⟨φ⟩)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>HBL1_rev_prv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ φ. φ ∈ fmla ⟹ Fvars φ = {} ⟹ prv (PP ⟨φ⟩) ⟹ prv φ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HBL1_rev</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (PP ⟨φ⟩)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv φ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>HBL1_rev_prv</span><span> </span><span>bprv_prv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>bp</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>classical_PP_prv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla ⟹ Fvars φ = {} ⟹ prv (neg (neg (PP ⟨φ⟩))) ⟹ prv (PP ⟨φ⟩)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>classical_P_prv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HBL1_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla ⟹ Fvars φ = {} ⟹ bprv (PP ⟨φ⟩) ⟷ prv φ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HBL1</span><span> </span><span>HBL1_rev</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HBL1_iff_prv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla ⟹ Fvars φ = {} ⟹ prv (PP ⟨φ⟩) ⟷ prv φ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>HBL1_PP</span><span> </span><span>HBL1_rev_prv</span><span> </span><span>PP</span><span> </span><span>d_dwf.bprv_prv'</span><span> </span><span>enc</span><span> </span><span>in_num</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>goedel_first_theHardHalf_pos</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (neg φG)"</span></span></span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv fls"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (neg (neg (PP ⟨φG⟩)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>neg_def</span><span> </span><span>prv_φG_eqv</span><span> </span><span>prv_eqv_imp_transi_rev</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (PP ⟨φG⟩)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>classical_PP_prv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv φG"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Fvars_φG</span><span> </span><span>HBL1_rev_prv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>prv_neg_fls</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>goedel_first_theHardHalf</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"consistent ⟹ ¬ prv (neg φG)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>goedel_first_theHardHalf_pos</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>consistent_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>goedel_first_classic</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"consistent"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ prv φG ∧ ¬ prv (neg φG)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>goedel_first_theEasyHalf</span><span> </span><span>goedel_first_theHardHalf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>goedel_first_classic_ex</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"consistent"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ φ. φ ∈ fmla ∧ ¬ prv φ ∧ ¬ prv (neg φ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>goedel_first_classic</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>φG</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale Goedel_Form_Classical_HBL1_rev_prv}›</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Second classical-logic version›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Goedel_Form_Classical_HBL1_rev_prv_Minimal_Truth_Soundness_TIP</span><span> </span><span class="delimiter">=</span><span>
</span><span>Goedel_Form_Classical_HBL1_rev_prv</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>num</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>S</span><span>
</span><span>  </span><span>P</span><span>
</span><span class="delimiter">+</span><span>
</span><span>Minimal_Truth_Soundness</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>bprv</span><span>
</span><span>  </span><span>isTrue</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>num</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>dsj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>isTrue</span><span>
</span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span class="comment">―‹Truth of @{term φ} implies provability (TIP) of (the internal representation of) @{term φ}›</span><span>
</span><span>TIP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ φ. φ ∈ fmla ⟹ Fvars φ = {} ⟹
  let PP = (λt. subst P t xx) in
  isTrue (PP ⟨φ⟩) ⟹ prv φ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TIP_PP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla ⟹ Fvars φ = {} ⟹ isTrue (PP ⟨φ⟩) ⟹ prv φ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>TIP</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>isTrue_φG</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>consistent</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isTrue φG"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ isTrue φG"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isTrue (neg φG)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>isTrue_neg</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (neg φG) (neg (neg (PP ⟨φG⟩))))"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bprv_φG_eqv</span><span> </span><span>B.prv_imp_eqvER</span><span> </span><span>B.prv_imp_neg_rev</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>prv_imp_implies_isTrue</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>this</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isTrue (neg (neg (PP ⟨φG⟩)))"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>isTrue_neg_neg</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>this</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isTrue (PP ⟨φG⟩)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv φG"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>TIP_PP</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>goedel_first_classic</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>goedel_first_classic_strong</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"consistent ⟹ ¬ prv φG ∧ ¬ prv (neg φG) ∧ isTrue φG"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>goedel_first_classic</span><span> </span><span>isTrue_φG</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>goedel_first_classic_strong_ex</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"consistent ⟹ ∃ φ. φ ∈ fmla ∧ ¬ prv φ ∧ ¬ prv (neg φ) ∧ isTrue φ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>goedel_first_classic_strong</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>φG</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale Goedel_Form_Classical_HBL1_rev_prv_Minimal_Truth_Soundness_TIP}›</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Third classical-logic version›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Goedel_Form_Minimal_Truth_Soundness_HBL1iff_prv_Compl_Pf_Classical</span><span> </span><span class="delimiter">=</span><span>
</span><span>Goedel_Form</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>num</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>S</span><span>
</span><span>  </span><span>P</span><span>
</span><span class="delimiter">+</span><span>
</span><span>Minimal_Truth_Soundness_HBL1iff_prv_Compl_Pf_Classical</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>P</span><span>
</span><span>  </span><span>isTrue</span><span>
</span><span>  </span><span>Pf</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dsj</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>isTrue</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Pf</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>Goedel_Form_Minimal_Truth_Soundness_HBL1iff_prv_Compl_Pf_Classical</span><span> </span><span class="delimiter">&lt;</span><span>
</span><span>  </span><span>recover_proofs</span><span class="delimiter">:</span><span> </span><span>Goedel_Form_Classical_HBL1_rev_prv_Minimal_Truth_Soundness_TIP</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>prv</span><span> </span><span class="delimiter">=</span><span> </span><span>prv</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bprv</span><span> </span><span class="delimiter">=</span><span> </span><span>bprv</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span> </span><span>classical</span><span> </span><span>rev_rpv</span><span> </span><span>TIPf</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>classical</span><span> </span><span>φ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HBL1_iff</span><span> </span><span>classical_P</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mts_prv_mts.PP_deff</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>rev_rpv</span><span> </span><span>φ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HBL1_iff_prv</span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>TIPf</span><span> </span><span>φ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>classical_P</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>SS_def</span><span> </span><span>PP_def</span><span> </span><span>mts_prv_mts.TIP</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Goedel_Form_Minimal_Truth_Soundness_HBL1iff_prv_Compl_Pf_Classical</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>recover_proofs.goedel_first_classic_strong</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">―‹context @{locale Goedel_Form_Minimal_Truth_Soundness_HBL1iff_prv_Compl_Pf_Classical}›</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="Rosser_Formula">
<div class="head"><h1>Theory Rosser_Formula</h1>
<span class="command">theory</span> <span class="name">Rosser_Formula</span><br/>
<span class="keyword">imports</span> <a href="Goedel_Formula.html"><span class="name">Goedel_Formula</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Rosser Formulas›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The Rosser formula is a modification of the Gödel formula that
is undecidable assuming consistency only (not $\omega$-consistency).›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Rosser_Formula</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Diagonalization</span><span> </span><span>Goedel_Formula</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Rosser_Form</span><span> </span><span class="delimiter">=</span><span>
</span><span>Deduct2_with_PseudoOrder</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>Lq</span><span>
</span><span>  </span><span class="delimiter">+</span><span>
</span><span>Repr_Neg</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>N</span><span>
</span><span>  </span><span class="delimiter">+</span><span>
</span><span>Repr_SelfSubst</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>S</span><span>
</span><span>  </span><span class="delimiter">+</span><span>
</span><span>HBL1</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>P</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>    </span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Lq</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dsj</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>N</span><span> </span><span>S</span><span> </span><span>P</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Rosser_Form_Proofs</span><span> </span><span class="delimiter">=</span><span>
</span><span>Deduct2_with_PseudoOrder</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>Lq</span><span>
</span><span>  </span><span class="delimiter">+</span><span>
</span><span>Repr_Neg</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>N</span><span>
</span><span>  </span><span class="delimiter">+</span><span>
</span><span>Repr_SelfSubst</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>S</span><span>
</span><span>  </span><span class="delimiter">+</span><span>
</span><span>CleanRepr_Proofs</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span> </span><span>prfOf</span><span>
</span><span>  </span><span>encPf</span><span>
</span><span>  </span><span>Pf</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>    </span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Lq</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dsj</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'proof set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prfOf</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>N</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>encPf</span><span> </span><span>Pf</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Rosser_Form_Proofs</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>R</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"R = all zz (imp (LLq (Var zz) (Var yy))
                                     (all xx' (imp (NN (Var xx) (Var xx'))
                                                   (neg (PPf (Var zz) (Var xx'))))))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>RR</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"RR t1 t2 = psubst R [(t1,yy), (t2,xx)]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>R</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"R ∈ fmla"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>R_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>RR_def2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"t1 ∈ trm ⟹ t2 ∈ trm ⟹ xx ∉ FvarsT t1 ⟹ RR t1 t2 = subst (subst R t1 yy) t2 xx"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RR_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>psubst_eq_rawpsubst2</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>P'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P' = exi yy (cnj (PPf (Var yy) (Var xx)) (RR (Var yy) (Var xx)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>PP'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"PP' t = subst P' t xx"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Fvars_R</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars R = {xx,yy}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>R_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars (RR (Var yy) (Var xx)) = {yy,xx}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>RR_def2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>P'</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P' ∈ fmla"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>P'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>PPf_def2</span><span> </span><span>RR_def2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Fvars_P'</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars P' = {xx}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>P'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>PPf_def2</span><span> </span><span>RR_def2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>PP'</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ trm ⟹ PP' t ∈ fmla"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>RR</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t1 ∈ trm ⟹ t2 ∈ trm ⟹ RR t1 t2 ∈ fmla"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>RR_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>RR_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"n ∈ num ⟹ subst (RR (Var yy) (Var xx)) n xx = RR (Var yy) n"</span></span></span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"m ∈ num ⟹ n ∈ num ⟹ subst (RR (Var yy) m) n yy = RR n m"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>RR_def2</span><span> </span><span>subst2_fresh_switch</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The Rosser modification of the Gödel formula›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>φR</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'fmla</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φR ≡ diag (neg P')"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>φR</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φR ∈ fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Fvars_φR</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φR = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>φR_def</span><span> </span><span>wrepr.PP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bprv_φR_eqv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bprv (eqv φR (neg (PP' ⟨φR⟩)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>φR_def</span><span> </span><span>PP'_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bprv_diag_eqv</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"neg P'"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bprv_imp_φR</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (neg (PP' ⟨φR⟩)) φR)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>B.prv_imp_eqvER</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>bprv_φR_eqv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prv_φR_eqv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prv (eqv φR (neg (PP' ⟨φR⟩)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dwf_dwfd.d_dwf.bprv_prv'</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>bprv_φR_eqv</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prv_imp_φR</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prv (imp (neg (PP' ⟨φR⟩)) φR)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>prv_imp_eqvER</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>prv_φR_eqv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale Rosser_Form}›</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>Rosser_Form_Proofs</span><span> </span><span class="delimiter">&lt;</span><span> </span><span>Rosser_Form</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span> </span><span class="delimiter">=</span><span> </span><span>P</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>Rosser_Form_Proofs</span><span> </span><span class="delimiter">&lt;</span><span> </span><span>Goedel_Form</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span> </span><span class="delimiter">=</span><span> </span><span>P</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="Abstract_First_Goedel_Rosser">
<div class="head"><h1>Theory Abstract_First_Goedel_Rosser</h1>
<span class="command">theory</span> <span class="name">Abstract_First_Goedel_Rosser</span><br/>
<span class="keyword">imports</span> <a href="Rosser_Formula.html"><span class="name">Rosser_Formula</span></a> <a href="Standard_Model_More.html"><span class="name">Standard_Model_More</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Abstract Formulations of Gödel-Rosser's First Incompleteness Theorem›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Abstract_First_Goedel_Rosser</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Rosser_Formula</span><span> </span><span>Standard_Model_More</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The development here is very similar to that of Gödel First Incompleteness Theorem.
It lacks classical logical variants, since for them Rosser's trick does bring
any extra value.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Proof-Theoretic Versions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Rosser_Form_Proofs</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NN_neg_unique_xx'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (NN ⟨φ⟩ (Var xx'))
          (eql ⟨neg φ⟩ (Var xx')))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.prv_subst</span><span class="delimiter">[</span><span>of</span><span> </span><span>yy</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"Var xx'"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>NN_neg_unique</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NN_imp_xx'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"χ ∈ fmla"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (subst χ ⟨neg φ⟩ xx')
                   (all xx' (imp (NN ⟨φ⟩ (Var xx')) χ)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (eql ⟨neg φ⟩ (Var xx')) (imp (subst χ ⟨neg φ⟩ xx') χ))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.prv_eql_subst_trm</span><span class="delimiter">[</span><span>of</span><span> </span><span>xx'</span><span> </span><span>χ</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨neg φ⟩"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Var xx'"</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (subst χ ⟨neg φ⟩ xx') (imp (eql ⟨neg φ⟩ (Var xx')) χ))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"2"</span></span></span><span> </span><span>B.prv_imp_com</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (subst χ ⟨neg φ⟩ xx') (imp (NN ⟨φ⟩ (Var xx')) χ))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>B.prv_prv_imp_trans</span><span class="delimiter">[</span><span>rotated</span><span> </span><span>3</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>B.prv_imp_com</span><span> </span><span>B.prv_imp_monoR</span><span> </span><span>NN_neg_unique_xx'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>B.prv_all_imp_gen</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>0</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>goedel_rosser_first_theEasyHalf</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"consistent"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ prv φR"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv φR"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prf"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prf ∈ proof"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prfOf prf φR"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_prfOf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>00</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (PPf (encPf prf) ⟨φR⟩)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prfOf_PPf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>dwf_dwfd.d_dwf.bprv_prv'</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>00</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b00</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (PPf (encPf prf) ⟨φR⟩)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ prv (neg φR)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>0</span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>consistent_def3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ prf ∈ proof.  ¬ prfOf prf (neg φR)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>00</span><span> </span><span>prv_prfOf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (neg (PPf p ⟨neg φR⟩))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ∈ num"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_prfOf_PPf</span><span> </span><span>Clean_PPf_encPf</span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ∈ encPf ` proof"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (all zz (imp (LLq (Var zz) (encPf prf)) (neg (PPf (Var zz) ⟨neg φR⟩))))"</span></span></span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* here use locale assumption about the order-like relation: *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>LLq_num</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>11</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (RR (encPf prf) ⟨φR⟩)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NN_imp_xx'</span><span class="delimiter">[</span><span>of</span><span> </span><span>φR</span><span> </span><span class="string"><span class="delete"><span class="delete">"neg (PPf (Var zz) (Var xx'))"</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>RR_def2</span><span> </span><span>R_def</span><span>
</span><span>      </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>prv_all_congW</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>1</span><span class="delimiter">]</span><span> </span><span>prv_imp_monoL</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>dwf_dwfd.d_dwf.bprv_prv'</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (cnj (PPf (encPf prf) ⟨φR⟩) (RR (encPf prf) ⟨φR⟩))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>prv_cnjI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>b00</span><span> </span><span>11</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv ((PP' ⟨φR⟩))"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP'_def</span><span> </span><span>P'_def</span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>prv_exiI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"encPf prf"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (neg (PP' ⟨φR⟩))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_eqv_prv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>0</span><span> </span><span>prv_φR_eqv</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>consistent_def3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>goedel_rosser_first_theHardHalf</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"consistent"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ prv (neg φR)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (neg φR)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prf"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prf ∈ proof"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prfOf prf (neg φR)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_prfOf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p = encPf prf"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ∈ num"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>11</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (PPf p ⟨neg φR⟩)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pr</span><span> </span><span>prfOf_PPf</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (NN ⟨φR⟩ ⟨neg φR⟩)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NN_neg</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ prv φR"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>0</span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>consistent_def3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>not_prv_prv_neg_PPf</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ r ∈ num. bprv (neg (PPf r ⟨φR⟩))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ r ∈ num. prv (neg (PPf r ⟨φR⟩))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>dwf_dwfd.d_dwf.bprv_prv'</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>P</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ⊆num"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite P"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (dsj (sdsj {eql (Var yy) r |r. r ∈ P}) (LLq p (Var yy)))"</span></span></span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* here use the other locale assumption about the order-like relation: *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LLq_num2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp (cnj (PPf (Var yy) ⟨φR⟩) (RR (Var yy) ⟨φR⟩)) fls)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>prv_dsj_cases</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>3</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>r</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r ∈ P"</span></span></span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>rn</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r ∈ num"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp (cnj (PPf r ⟨φR⟩) (RR r ⟨φR⟩)) fls)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>neg_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>FvarsT_num</span><span> </span><span>PPf</span><span> </span><span>RR</span><span> </span><span>rn</span><span> </span><span>φR</span><span> </span><span>all_not_in_conv</span><span> </span><span>cnj</span><span> </span><span>enc</span><span> </span><span>fls</span><span> </span><span>imp</span><span> </span><span>in_num</span><span> </span><span>prv_imp_cnj3L</span><span> </span><span>prv_imp_mp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp (eql (Var yy) r)
                (imp (cnj (PPf (Var yy) ⟨φR⟩) (RR (Var yy) ⟨φR⟩)) fls))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_eql_subst_trm_id</span><span class="delimiter">[</span><span>of</span><span> </span><span>yy</span><span> </span><span class="string"><span class="delete"><span class="delete">"cnj (PPf (Var yy) ⟨φR⟩) (RR (Var yy) ⟨φR⟩)"</span></span></span><span> </span><span>r</span><span class="delimiter">,</span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>neg_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>prv_neg_imp_imp_trans</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp (sdsj {eql (Var yy) r |r. r ∈ P})
              (imp (cnj (PPf (Var yy) ⟨φR⟩) (RR (Var yy) ⟨φR⟩)) fls))"</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Var</span><span> </span><span>P</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>eql</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>prv_sdsj_imp</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>0</span><span> </span><span>0</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>set_rev_mp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?φ</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"all xx' (imp (NN ⟨φR⟩ (Var xx')) (neg (PPf p (Var xx'))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (neg ?φ)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>11</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>B.prv_imp_neg_allWI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨neg φR⟩"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>B.prv_prv_neg_imp_neg</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (neg ?φ)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>dwf_dwfd.d_dwf.bprv_prv'</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>00</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp (LLq p (Var yy))
                       (imp (imp (LLq p (Var yy)) ?φ) fls))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>neg_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>prv_imp_neg_imp_neg_imp</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp (LLq p (Var yy))
              (imp (RR (Var yy) ⟨φR⟩) fls))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>neg_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>00</span><span class="delimiter">[</span><span>folded</span><span> </span><span>neg_def</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>RR_def2</span><span> </span><span>R_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>prv_imp_neg_allI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t</span><span> </span><span class="delimiter">=</span><span> </span><span>p</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp (LLq p (Var yy))
              (imp (cnj (PPf (Var yy) ⟨φR⟩) (RR (Var yy) ⟨φR⟩)) fls))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>neg_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>prv_imp_neg_imp_cnjR</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span> </span><span>insert</span><span> </span><span>Var</span><span> </span><span>P</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>eql</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>set_rev_mp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (neg (exi yy (cnj (PPf (Var yy) ⟨φR⟩) (RR (Var yy) ⟨φR⟩))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>neg_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>prv_neg_neg_exi</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (neg (PP' ⟨φR⟩))"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP'_def</span><span> </span><span>P'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv φR"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_φR_eqv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>PP'</span><span> </span><span>φR</span><span> </span><span>enc</span><span> </span><span>in_num</span><span> </span><span>neg</span><span> </span><span>prv_eqv_prv_rev</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`¬ prv φR`</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>consistent_def3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>goedel_rosser_first</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"consistent"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ prv φR ∧ ¬ prv (neg φR)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>goedel_rosser_first_theEasyHalf</span><span> </span><span>goedel_rosser_first_theHardHalf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>goedel_rosser_first_ex</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"consistent"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ φ. φ ∈ fmla ∧ ¬ prv φ ∧ ¬ prv (neg φ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>goedel_rosser_first</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>φR</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale Rosser_Form}›</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Model-Theoretic Versions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹First model-theoretic version›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Rosser_Form_Proofs_Minimal_Truth</span><span> </span><span class="delimiter">=</span><span>
</span><span>Rosser_Form_Proofs</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>Lq</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span> </span><span>prfOf</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>N</span><span> </span><span>S</span><span>
</span><span>  </span><span>encPf</span><span>
</span><span>  </span><span>Pf</span><span>
</span><span class="delimiter">+</span><span>
</span><span>Minimal_Truth_Soundness</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>bprv</span><span>
</span><span>  </span><span>isTrue</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dsj</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Lq</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>N</span><span> </span><span>S</span><span> </span><span>P</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'proof set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prfOf</span><span> </span><span>encPf</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Pf</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>isTrue</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Fvars_PP'</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars (PP' ⟨φR⟩) = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP'_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>Fvars_subst</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Fvars_RR'</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars (RR (Var yy) ⟨φR⟩) = {yy}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RR_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>Fvars_psubst</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"{yy}"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isTrue_PPf_implies_φR</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isTrue (all yy (neg (PPf (Var yy) ⟨φR⟩)))"</span></span></span><span>
</span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isTrue ?H"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isTrue φR"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>F</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F ≡ RR (Var yy) ⟨φR⟩"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"F ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars F = {yy}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>F_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"exi yy (PPf (Var yy) ⟨φR⟩) ∈ fmla"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PPf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv
     (imp (all yy (neg (PPf (Var yy) ⟨φR⟩)))
       (neg (exi yy (PPf (Var yy) ⟨φR⟩))))"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (all yy (neg ?G)) (neg (exi yy ?G)))"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.prv_all_neg_imp_neg_exi</span><span class="delimiter">[</span><span>of</span><span> </span><span>yy</span><span> </span><span class="var">?G</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (neg (exi yy ?G)) (neg (exi yy (cnj ?G F))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>B.prv_imp_neg_rev</span><span> </span><span>B.prv_exi_cong</span><span> </span><span>B.prv_imp_cnjL</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (all yy (neg ?G)) (neg (exi yy (cnj ?G F))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.prv_prv_imp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span>  </span><span>1</span><span> </span><span>2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp ?H (neg (PP' ⟨φR⟩)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP'_def</span><span> </span><span>P'_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>F_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>B.prv_prv_imp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span>  </span><span>this</span><span> </span><span>bprv_imp_φR</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp ?H φR)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>prv_imp_implies_isTrue</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>this</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>isTrue_φR</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"consistent"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isTrue φR"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ n ∈ num. bprv (neg (PPf n ⟨φR⟩))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_prv_prv_neg_PPf</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>goedel_rosser_first_theEasyHalf</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ n ∈ num. isTrue (neg (PPf n ⟨φR⟩))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>sound_isTrue</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isTrue (all yy (neg (PPf (Var yy) ⟨φR⟩)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>isTrue_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>isTrue_PPf_implies_φR</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>goedel_rosser_first_strong</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"consistent ⟹ ¬ prv φR ∧ ¬ prv (neg φR) ∧ isTrue φR"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>isTrue_φR</span><span> </span><span>goedel_rosser_first</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>goedel_rosser_first_strong_ex</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"consistent ⟹ ∃ φ. φ ∈ fmla ∧ ¬ prv φ ∧ ¬ prv (neg φ) ∧ isTrue φ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>goedel_rosser_first_strong</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>φR</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale Rosser_Form_Proofs_Minimal_Truth}›</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Second model-theoretic version›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Rosser_Form</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">print_context</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Rosser_Form_Minimal_Truth_Soundness_HBL1iff_Compl_Pf</span><span> </span><span class="delimiter">=</span><span>
</span><span>Rosser_Form</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span>
</span><span>  </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>Lq</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>N</span><span>
</span><span>  </span><span>S</span><span>
</span><span>  </span><span>P</span><span>
</span><span class="delimiter">+</span><span>
</span><span>Minimal_Truth_Soundness_HBL1iff_Compl_Pf</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>P</span><span>
</span><span>  </span><span>isTrue</span><span>
</span><span>  </span><span>Pf</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dsj</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Lq</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>N</span><span> </span><span>S</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>isTrue</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span> </span><span>Pf</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Rosser_Form_Minimal_Truth_Soundness_HBL1iff_Compl_Pf_Compl_NegPf</span><span> </span><span class="delimiter">=</span><span>
</span><span>Rosser_Form_Minimal_Truth_Soundness_HBL1iff_Compl_Pf</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>Lq</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>N</span><span> </span><span>S</span><span>
</span><span>  </span><span>isTrue</span><span>
</span><span>  </span><span>P</span><span>
</span><span>  </span><span>Pf</span><span>
</span><span class="delimiter">+</span><span>
</span><span>M</span><span> </span><span class="delimiter">:</span><span> </span><span>Minimal_Truth_Soundness_HBL1iff_Compl_Pf_Compl_NegPf</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>N</span><span>
</span><span>  </span><span>isTrue</span><span>
</span><span>  </span><span>Pf</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dsj</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Lq</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>N</span><span> </span><span>S</span><span> </span><span>P</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>isTrue</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Pf</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span>
</span><span>  </span><span>Rosser_Form_Minimal_Truth_Soundness_HBL1iff_Compl_Pf_Compl_NegPf</span><span> </span><span class="delimiter">&lt;</span><span>
</span><span>  </span><span>recover_proofs</span><span class="delimiter">:</span><span> </span><span>Rosser_Form_Proofs_Minimal_Truth</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>prfOf</span><span> </span><span class="delimiter">=</span><span> </span><span>prfOf</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>encPf</span><span> </span><span class="delimiter">=</span><span> </span><span>encPf</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span class="delimiter">=</span><span> </span><span>prv</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bprv</span><span> </span><span class="delimiter">=</span><span> </span><span>bprv</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Rosser_Form_Minimal_Truth_Soundness_HBL1iff_Compl_Pf_Compl_NegPf</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>recover_proofs.goedel_rosser_first_strong</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span></pre>
</div>
</div><div id="Abstract_Second_Goedel">
<div class="head"><h1>Theory Abstract_Second_Goedel</h1>
<span class="command">theory</span> <span class="name">Abstract_Second_Goedel</span><br/>
<span class="keyword">imports</span> <a href="Abstract_First_Goedel.html"><span class="name">Abstract_First_Goedel</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Abstract Formulation of Gödel's Second Incompleteness Theorem›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Abstract_Second_Goedel</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Abstract_First_Goedel</span><span> </span><span>Derivability_Conditions</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We assume all three derivability conditions, and assumptions
behind Gödel formulas:›</span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Goedel_Second_Assumptions</span><span> </span><span class="delimiter">=</span><span>
</span><span>HBL1_2_3</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>P</span><span>
</span><span class="delimiter">+</span><span>
</span><span>Goedel_Form</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>num</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>S</span><span>
</span><span>  </span><span>P</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>P_G</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"bprv (imp (PP ⟨φG⟩) (PP ⟨fls⟩))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp φG (neg (PP ⟨φG⟩)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_φG_eqv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>prv_imp_eqvEL</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (PP ⟨imp φG (neg (PP ⟨φG⟩))⟩)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HBL1_PP</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (PP ⟨φG⟩) (PP ⟨neg (PP ⟨φG⟩)⟩))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HBL2_imp2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span>  </span><span>_</span><span> </span><span>_</span><span> </span><span>1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (PP ⟨φG⟩) (PP ⟨PP ⟨φG⟩⟩))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HBL3</span><span class="delimiter">[</span><span>OF</span><span> </span><span>φG</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>23</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (PP ⟨φG⟩)
                      (cnj (PP ⟨PP ⟨φG⟩⟩)
                           (PP ⟨neg (PP ⟨φG⟩)⟩)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.prv_imp_cnj</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>3</span><span> </span><span>2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (cnj (PP ⟨PP ⟨φG⟩⟩)
                          (PP ⟨neg (PP ⟨φG⟩)⟩))
                     (PP ⟨fls⟩))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HBL2</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"PP ⟨φG⟩"</span></span></span><span> </span><span>fls</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>neg_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.prv_prv_imp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>23</span><span> </span><span>4</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹First the "direct", positive formulation:›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>goedel_second_pos</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (neg (PP ⟨fls⟩))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv fls"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>PG</span><span> </span><span class="delimiter">=</span><span> </span><span>bprv_prv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>P_G</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (neg (PP ⟨φG⟩))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PG</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>neg_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>prv_prv_imp_trans</span><span class="delimiter">[</span><span>rotated</span><span> </span><span>3</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv φG"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_φG_eqv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>prv_eqv_prv_rev</span><span class="delimiter">[</span><span>rotated</span><span> </span><span>2</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="comment">―‹The only part of Goedel's first theorem that is needed:›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>goedel_first_theEasyHalf_pos</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Then the more standard, counterpositive formulation:›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>goedel_second</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"consistent ⟹ ¬ prv (neg (PP ⟨fls⟩))"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>goedel_second_pos</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>consistent_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹It is an immediate consequence of Gödel's Second HLB1, HLB2 that
(assuming consistency)  @{term "prv (neg (PP ⟨φ⟩))"} holds for no sentence, be it
provable or not. The theory is omniscient about what it can prove
(thanks to HLB1), but completely ignorant about what it cannot prove.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>not_prv_neg_PP</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"consistent"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ prv (neg (PP ⟨φ⟩))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (neg (PP ⟨φ⟩))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp fls φ)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (PP ⟨imp fls φ⟩)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>HBL1_PP</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (PP ⟨fls⟩) (PP ⟨φ⟩))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>HBL2_imp2</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (neg (PP ⟨φ⟩)) (neg (PP ⟨fls⟩)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>B.prv_imp_neg_rev</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>prv_imp_mp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>bprv_prv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>this</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (neg (PP ⟨fls⟩))"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>goedel_second</span><span class="delimiter">[</span><span>OF</span><span> </span><span>c</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale Goedel_Second_Assumptions}›</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span></pre>
</div>
</div><div id="Abstract_Jeroslow_Encoding">
<div class="head"><h1>Theory Abstract_Jeroslow_Encoding</h1>
<span class="command">theory</span> <span class="name">Abstract_Jeroslow_Encoding</span><br/>
<span class="keyword">imports</span> <a href="../Syntax_Independent_Logic/Deduction.html"><span class="name">Deduction</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Jeroslow's Variant of G\"odel's Second Incompleteness Theorem›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Abstract_Jeroslow_Encoding</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"Syntax_Independent_Logic.Deduction"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Encodings and Derivability›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Here we formalize some of the assumptions of Jeroslow's theorem:
encoding, term-encoding and the First Derivability Condition.›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Encoding of formulas›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Encode</span><span> </span><span class="delimiter">=</span><span>
</span><span>Syntax_with_Numerals</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*************************************)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Numeric formulas are assumed to be encoded as numerals: *)</span></span></span></span></span><span>
</span><span>enc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla ⇒ 'trm"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>enc</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ φ. φ ∈ fmla ⟹ enc φ ∈ num"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale Encode}›</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Encoding of computable functions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Jeroslow assumes the encodability of an abstract (unspecified) class of
computable functions and the assumption that a particular function, @{term "sub φ"} for each formula
@{term φ}, is in this collection. This is used to prove a different flavor of the diagonalization
lemma (Jeroslow 1973). It turns out that only an encoding of unary computable functions
is needed, so we only assume that.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Encode_UComput</span><span> </span><span class="delimiter">=</span><span>
</span><span>Encode</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>enc</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="delimiter">+</span><span>
</span><span class="comment">― ‹Abstract (unspeficied) notion of unary "computable" function
between numerals, which are encoded as numerals. They
contain a special substitution-like function @{term "sub φ"} for each formula @{term "φ"}.›</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>ucfunc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('trm ⇒ 'trm) set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>encF</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('trm ⇒ 'trm) ⇒ 'trm"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sub</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla ⇒ 'trm ⇒ 'trm"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span class="comment">― ‹NB: Due to the limitations of the type system, we define @{term "ufunc"} as a set of functions
between terms, but we only care about their actions on numerals ...
so we assume they send numerals to numerals:›</span><span>
</span><span>ucfunc</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ f n. f ∈ ucfunc ⟹ n ∈ num ⟹ f n ∈ num"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>encF</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ f. f ∈ ucfunc ⟹ encF f ∈ num"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>sub</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀φ. φ ∈ fmla ⟹ sub φ ∈ ucfunc"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span class="comment">― ‹The function @{term "sub φ"} takes any encoding of a function @{term "f"} and returns the encoding of
the formula obtained by substituting for @{term "xx"} the value of @{term "f"} applied to its own encoding:›</span><span>
</span><span>sub_enc</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀ φ f. φ ∈ fmla ⟹ Fvars φ = {xx} ⟹ f ∈ ucfunc ⟹
    sub φ (encF f) = enc (inst φ (f (encF f)))"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Term-encoding of computable functons›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹For handling the notion of term-representation (which we introduce later),
we assume we are given a set @{term "Ops"} of term operators and their encodings as numerals.
We additionally assume that the term operators behave well w.r.t. free variables and
substitution.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>TermEncode</span><span> </span><span class="delimiter">=</span><span>
</span><span>Syntax_with_Numerals</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>Ops</span><span> </span><span class="delimiter">::</span><span>  </span><span class="string"><span class="delete"><span class="delete">"('trm ⇒ 'trm) set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>enc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('trm ⇒ 'trm) ⇒ 'trm"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>Ops</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀f t. f ∈ Ops ⟹ t ∈ trm ⟹ f t ∈ trm"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>enc</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ f. f ∈ Ops ⟹ enc f ∈ num"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>Ops_FvarsT</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ f t. f ∈ Ops ⟹ t ∈ trm ⟹ FvarsT (f t) = FvarsT t"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>Ops_substT</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ f t. f ∈ Ops ⟹ t ∈ trm ⟹ t1 ∈ trm ⟹ x ∈ var ⟹
  substT (f t) t1 x = f (substT t t1 x)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale TermEncode}›</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The first Hilbert-Bernays-Löb derivability condition›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>HBL1</span><span> </span><span class="delimiter">=</span><span>
</span><span>Encode</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>enc</span><span>
</span><span class="delimiter">+</span><span>
</span><span>Deduct</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>prv</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>P</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'fmla</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>P</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∈ fmla"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>Fvars_P</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars P = {xx}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>HBL1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀φ. φ ∈ fmla ⟹ Fvars φ = {} ⟹ prv φ ⟹ prv (subst P ⟨φ⟩ xx)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Predicate version of the provability formula›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>PP</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"PP ≡ λt. subst P t xx"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>PP</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀t. t ∈ trm ⟹ PP t ∈ fmla"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Fvars_PP</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀t. t ∈ trm ⟹ Fvars (PP t) = FvarsT t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"n ∈ num ⟹ subst (PP (Var yy)) n yy = PP n"</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"n ∈ num ⟹ subst (PP (Var xx)) n xx = PP n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HBL1_PP</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla ⟹ Fvars φ = {} ⟹ prv φ ⟹ prv (PP ⟨φ⟩)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HBL1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale HBL1}›</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span></pre>
</div>
</div><div id="Jeroslow_Original">
<div class="head"><h1>Theory Jeroslow_Original</h1>
<span class="command">theory</span> <span class="name">Jeroslow_Original</span><br/>
<span class="keyword">imports</span> <a href="../Syntax_Independent_Logic/Pseudo_Term.html"><span class="name">Pseudo_Term</span></a> <a href="Abstract_Jeroslow_Encoding.html"><span class="name">Abstract_Jeroslow_Encoding</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A Formalization of Jeroslow's Original Argument›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Jeroslow_Original</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"Syntax_Independent_Logic.Pseudo_Term"</span></span></span><span>
</span><span>Abstract_Jeroslow_Encoding</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Preliminaries›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The First Derivability Condition was stated using a formula
with free variable @{term xx}, whereas the pseudo-term theory employs a different variable,
inp. The distinction is of course immaterial, because we can perform
a change of variable in the instantiation:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>HBL1</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Changing the variable (from @{term xx} to @{term inp}) in the provability predicate:›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Pinp ≡ subst P (Var inp) xx"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>PP_Pinp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ trm ⟹ PP t = instInp Pinp t"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP_def</span><span> </span><span>Pinp_def</span><span> </span><span>instInp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A version of HBL1 that uses the @{term inp} variable:›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HBL1_inp</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla ⟹ Fvars φ = {} ⟹ prv φ ⟹ prv (instInp Pinp ⟨φ⟩)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Pinp_def</span><span> </span><span>instInp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>HBL1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale HBL1 }›</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Jeroslow-style diagonalization›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Jeroslow_Diagonalization</span><span> </span><span class="delimiter">=</span><span>
</span><span>Deduct_with_False_Disj_Rename</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>prv</span><span>
</span><span class="delimiter">+</span><span>
</span><span>Encode</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>enc</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dsj</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>F</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('trm ⇒ 'trm) set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>encF</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('trm ⇒ 'trm) ⇒ 'fmla"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>N</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm ⇒ 'trm"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ssap</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla ⇒ 'trm ⇒ 'trm"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span class="comment">― ‹For the members @{term f} of @{term F}, we will only care about their action on numerals,
and we assume that they send numerals to numerals.›</span><span>
</span><span>F</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ f n. f ∈ F ⟹ n ∈ num ⟹ f n ∈ num"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>encF</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ f. f ∈ F ⟹ encF f ∈ ptrm (Suc 0)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>N</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"N ∈ F"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>ssap</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀φ. φ ∈ fmla ⟹ Fvars φ = {inp} ⟹ ssap φ ∈ F"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>ReprF</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀f n. f ∈ F ⟹ n ∈ num ⟹ prveqlPT (instInp (encF f) n) (f n)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>CapN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀φ. φ ∈ fmla ⟹ Fvars φ = {} ⟹ N ⟨φ⟩ = ⟨neg φ⟩"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>CapSS</span><span class="delimiter">:</span><span> </span><span class="comment">― ‹We consider formulas @{term ψ} of one variable, called @{term inp}:›</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀ ψ f. ψ ∈ fmla ⟹ Fvars ψ = {inp} ⟹ f ∈ F ⟹
    ssap ψ ⟨encF f⟩ = ⟨instInpP ψ 0 (instInp (encF f) ⟨encF f⟩)⟩"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>encF_fmla</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ f. f ∈ F ⟹ encF f ∈ fmla"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>enc_trm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla ⟹ ⟨φ⟩ ∈ trm"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>τJ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla ⇒ 'fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"τJ ψ ≡ instInp (encF (ssap ψ)) (⟨encF (ssap ψ)⟩)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>φJ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla ⇒ 'fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"φJ ψ ≡ instInpP ψ 0 (τJ ψ)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>τJ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ ∈ fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars ψ = {inp}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"τJ ψ ∈ ptrm 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>τJ_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>instInp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>τJ_fmla</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ ∈ fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars ψ = {inp}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"τJ ψ ∈ fmla"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>τJ</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ptrm_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FvarsT_τJ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ ∈ fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars ψ = {inp}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars (τJ ψ) = {out}"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>τJ</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ptrm_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>φJ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ ∈ fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars ψ = {inp}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φJ ψ ∈ fmla"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>φJ_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>instInpP_fmla</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Fvars_φJ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ ∈ fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars ψ = {inp}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars (φJ ψ) = {}"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>φJ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diagonalization</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ψ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ ∈ fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars ψ = {inp}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prveqlPT (τJ ψ) ⟨instInpP ψ 0 (τJ ψ)⟩ ∧
       prv (eqv (φJ ψ) (instInp ψ ⟨φJ ψ⟩))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ≡ ssap ψ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ F"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>f_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ⟨encF f⟩ = ⟨instInpP ψ 0 (τJ ψ)⟩"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>f_def</span><span> </span><span>τJ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>CapSS</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prveqlPT (τJ ψ) ⟨instInpP ψ 0 (τJ ψ)⟩"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ReprF</span><span class="delimiter">[</span><span>OF</span><span> </span><span>f</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨encF f⟩"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>τJ_def</span><span class="delimiter">[</span><span>of</span><span> </span><span>ψ</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>f_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>ff</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>prveqlPT_prv_instInp_eqv_instInpP</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ψ</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"τJ ψ"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>this</span><span class="delimiter">,</span><span>
</span><span>           </span><span>unfolded</span><span> </span><span>φJ_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (eqv (φJ ψ) (instInp ψ ⟨φJ ψ⟩))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale Jeroslow_Diagonalization}›</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Jeroslow's Second Incompleteness Theorem›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We follow Jeroslow's pseudo-term-based development of the
Second Incompleteness Theorem and point out the location in the proof that
implicitly uses an unstated assumption: the fact that, for certain two provably
equivalent formulas @{term φ} and @{term φ'}, it is provable that
the provability of the encoding of @{term φ'} implies
the provability of the encoding of @{term φ}. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Jeroslow_Godel_Second</span><span> </span><span class="delimiter">=</span><span>
</span><span>Jeroslow_Diagonalization</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>dsj</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>prv</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>F</span><span> </span><span>encF</span><span> </span><span>N</span><span> </span><span>ssap</span><span>
</span><span class="delimiter">+</span><span>
</span><span>HBL1</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>prv</span><span> </span><span>prv</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>P</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dsj</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>F</span><span> </span><span>encF</span><span> </span><span>N</span><span> </span><span>ssap</span><span>
</span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>SHBL3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀τ. τ ∈ ptrm 0 ⟹ prv (imp (instInpP Pinp 0 τ) (instInp Pinp ⟨instInpP Pinp 0 τ⟩))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Consistency formula a la Jeroslow:›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>jcons</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"jcons ≡ all xx (neg (cnj (instInp Pinp (Var xx))
                           (instInpP Pinp 0 (instInp (encF N) (Var (xx))))))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prv_eql_subst_trm3</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"x ∈ var ⟹ φ ∈ fmla ⟹ t1 ∈ trm ⟹ t2 ∈ trm ⟹
prv (eql t1 t2) ⟹ prv (subst φ t1 x) ⟹ prv (subst φ t2 x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_eql_subst_trm2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>subst</span><span> </span><span>prv_imp_mp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Pinp</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Pinp ∈ fmla"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Fvars_Pinp</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars Pinp = {inp}"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Pinp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ReprF_combineWith_CapN</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prveqlPT (instInp (encF N) ⟨φ⟩) ⟨neg φ⟩"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>CapN</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ReprF</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>jeroslow_godel_second</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>consistent</span><span>
</span><span class="comment">― ‹Assumption that is not stated by Jeroslow, but seems to be needed:›</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>unstated</span><span class="delimiter">:</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"let ψ = instInpP Pinp (Suc 0) (encF N);
             τ = τJ ψ;
             φ = instInpP (instInpP Pinp (Suc 0) (encF N)) 0 τ;
             φ' = instInpP Pinp 0 (instInpP (encF N) 0 τ)
         in prv (imp (instInp Pinp ⟨φ'⟩) (instInp Pinp ⟨φ⟩))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ prv jcons"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv jcons"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ψ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ ≡ instInpP Pinp (Suc 0) (encF N)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>τ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"τ ≡ τJ ψ"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>φ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ≡ φJ ψ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ψ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars ψ = {inp}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ψ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>τ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"τ ∈ ptrm 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"τ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars τ = {out}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>τ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>φ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>eNτ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eNτ ≡ instInpP (encF N) 0 τ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eNτ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"eNτ ∈ ptrm 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eNτ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars eNτ = {out}"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eNτ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>φ'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ' ≡ instInpP Pinp 0 eNτ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ' ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ' = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>φ'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>φφ'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp φ φ')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>φ'φ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp φ' φ)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>φeφ'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (eqv φ φ')"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>φ_def</span><span> </span><span>φJ_def</span><span> </span><span>φ'_def</span><span> </span><span>eNτ_def</span><span> </span><span>τ_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ψ_def</span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_instInpP_compose</span><span class="delimiter">[</span><span>of</span><span> </span><span>Pinp</span><span> </span><span class="string"><span class="delete"><span class="delete">"encF N"</span></span></span><span> </span><span>τ</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>diagonalization</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ψ</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prveqlPT τ ⟨instInpP ψ 0 τ⟩"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>**</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (eqv φ (instInp ψ ⟨φ⟩))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>τ_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>φ_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"**1"</span></span></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp φ (instInp ψ ⟨φ⟩))"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp (instInp ψ ⟨φ⟩) φ)"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_imp_eqvEL</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>**</span><span class="delimiter">]</span><span> </span><span>prv_imp_eqvER</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>**</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>SHBL3</span><span class="delimiter">[</span><span>OF</span><span> </span><span>eNτ</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp (instInpP Pinp 0 eNτ) (instInp Pinp ⟨instInpP Pinp 0 eNτ⟩))"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp φ' (instInp Pinp ⟨φ'⟩))"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>φ'_def</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>prv_prv_imp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>φφ'</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp φ (instInp Pinp ⟨φ'⟩))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>unr</span><span> </span><span class="delimiter">=</span><span> </span><span>unstated</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>Let_def</span><span>
</span><span>    </span><span>φ_def</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>φJ_def</span><span> </span><span>τ_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>ψ_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>      </span><span>τ_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>eNτ_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>φ'_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>φJ_def</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp φ (instInp Pinp ⟨φ⟩))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>nrule</span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span>nprv_prvI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>nrule</span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span>nprv_impI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>nrule</span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span>nprv_addLemmaE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>unr</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>nrule</span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span>nprv_addImpLemmaE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>0</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>nrule</span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span>nprv_clear3_3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nprv_clear2_2</span><span> </span><span>prv_nprv1I</span><span> </span><span>unr</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp φ (cnj (instInp Pinp ⟨φ⟩)
                           (instInp ψ ⟨φ⟩)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>nrule</span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span>nprv_prvI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>nrule</span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span>nprv_impI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>nrule</span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span>nprv_cnjI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>nrule</span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span>nprv_addImpLemmaE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>nrule</span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span>nprv_addImpLemmaE</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="string"><span class="delete"><span class="delete">"**1"</span></span></span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>z</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ≡ Variable (Suc (Suc 0))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>z_facts</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∈ var"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ≠ xx"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∉ Fvars Pinp"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"out ≠ z ∧ z ≠ out"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inp ≠ z ∧ z ≠ inp"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>z_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>30</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst (instInpP Pinp 0 (instInp (encF N) (Var xx))) ⟨φ⟩ xx =
            instInpP Pinp 0 (instInp (encF N) ⟨φ⟩)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>z_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>instInp_def</span><span> </span><span>instInpP_def</span><span> </span><span>Let_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>variousSubsts4</span><span> </span><span>auto</span><span>
</span><span>        </span><span>s1</span><span class="delimiter">:</span><span> </span><span>subst_compose_diff</span><span> </span><span>s2</span><span class="delimiter">:</span><span> </span><span>subst_subst</span><span>
</span><span>        </span><span>s3</span><span class="delimiter">:</span><span> </span><span>subst_notIn</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>xx</span><span class="delimiter">]</span><span> </span><span>s4</span><span class="delimiter">:</span><span> </span><span>subst_compose_diff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>31</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst (instInp Pinp (Var xx)) ⟨φ⟩ xx =
            instInp Pinp ⟨φ⟩"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>instInp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"instInp (instInpP Pinp (Suc 0) (encF N)) ⟨φ⟩ =
           instInpP Pinp 0 (instInp (encF N) ⟨φ⟩)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>instInp_instInpP</span><span> </span><span>ψ_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (neg (cnj (instInp Pinp ⟨φ⟩)
                         (instInp ψ ⟨φ⟩)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>nrule</span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span>nprv_prvI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>nrule</span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span>nprv_addLemmaE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>*</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>jcons_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>nprv_allE0</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨φ⟩"</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>30</span><span> </span><span>31</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>nrule</span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span>nprv_clear2_2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>nrule</span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span>nprv_negI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>nrule</span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span>nprv_negE0</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>nrule</span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span>nprv_clear2_2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>nrule</span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span>nprv_cnjE0</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>nrule</span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span>nprv_clear3_3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>nrule</span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span>nprv_cnjI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>nrule</span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span>nprv_clear2_1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ψ_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>nrule</span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span>nprv_hyp</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>***</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (neg φ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>nrule</span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span>nprv_prvI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>nrule</span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span>nprv_negI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>nrule</span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span>nprv_addImpLemmaE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>2</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>nrule</span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span>nprv_addLemmaE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>3</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>nrule</span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span>nprv_negE0</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (instInp Pinp ⟨neg φ⟩)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HBL1_inp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>***</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prveqlPT (instInp (encF N) ⟨φ⟩) ⟨neg φ⟩"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ReprF_combineWith_CapN</span><span class="delimiter">[</span><span>of</span><span> </span><span>φ</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"instInp (encF N) ⟨φ⟩ ∈ ptrm 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>instInp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>6</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (instInpP Pinp 0 (instInp (encF N) ⟨φ⟩))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>nrule</span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span>nprv_prvI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>nrule</span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span>nprv_addLemmaE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>4</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>nrule</span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span>prveqlPT_nprv_instInpP_instInp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>5</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>lem</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"**1"</span></span></span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>ψ_def</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv φ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>nrule</span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span>nprv_prvI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>nrule</span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span>nprv_addLemmaE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>6</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>nrule</span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span>nprv_addImpLemmaE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>lem</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span>***</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`consistent`</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>consistent_def3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale Jeroslow_Godel_Second}›</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="Jeroslow_Simplified">
<div class="head"><h1>Theory Jeroslow_Simplified</h1>
<span class="command">theory</span> <span class="name">Jeroslow_Simplified</span><br/>
<span class="keyword">imports</span> <a href="Abstract_Jeroslow_Encoding.html"><span class="name">Abstract_Jeroslow_Encoding</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A Simplification of Jeroslow's Original Argument›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Jeroslow_Simplified</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Abstract_Jeroslow_Encoding</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This is the simplified version of Jeroslow's Second Incompleteness Theorem
reported in our CADE 2019 paper~\cite{DBLP:conf/cade/0001T19}.
The simplification consists of replacing pseudo-terms with plain terms
and representability with (what we call in the paper) term-representability.
This simplified version does not incur the complications of the original.›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Jeroslow-style term-based diagonalization›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Jeroslow_Diagonalization</span><span> </span><span class="delimiter">=</span><span>
</span><span>Deduct_with_False</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>prv</span><span>
</span><span class="delimiter">+</span><span>
</span><span>Encode</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>enc</span><span>
</span><span class="delimiter">+</span><span>
</span><span>TermEncode</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>Ops</span><span> </span><span>tenc</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Ops</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tenc</span><span>
</span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>F</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('trm ⇒ 'trm) set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>encF</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('trm ⇒ 'trm) ⇒ ('trm ⇒ 'trm)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>N</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm ⇒ 'trm"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ssap</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla ⇒ 'trm ⇒ 'trm"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>F</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ f n. f ∈ F ⟹ n ∈ num ⟹ f n ∈ num"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>encF</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ f. f ∈ F ⟹ encF f ∈ Ops"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>N</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"N ∈ F"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>ssap</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀φ. φ ∈ fmla ⟹ Fvars φ = {xx} ⟹ ssap φ ∈ F"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>ReprF</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀f n. f ∈ F ⟹ n ∈ num ⟹ prv (eql (encF f n) (f n))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>CapN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀φ. φ ∈ fmla ⟹ Fvars φ = {} ⟹ N ⟨φ⟩ = ⟨neg φ⟩"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>CapSS</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀ ψ f. ψ ∈ fmla ⟹ Fvars ψ = {xx} ⟹ f ∈ F ⟹
    ssap ψ (tenc (encF f)) = ⟨inst ψ (encF f (tenc (encF f)))⟩"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>tJ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla ⇒ 'trm"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"tJ ψ ≡ encF (ssap ψ) (tenc (encF (ssap ψ)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>φJ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla ⇒ 'fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"φJ ψ ≡ subst ψ (tJ ψ) xx"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tJ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ ∈ fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars ψ = {xx}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tJ ψ ∈ trm"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>tJ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FvarsT_tJ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ ∈ fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars ψ = {xx}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"FvarsT (tJ ψ) = {}"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>tJ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>φJ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ ∈ fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars ψ = {xx}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φJ ψ ∈ fmla"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>φJ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Fvars_φJ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ ∈ fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars ψ = {xx}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars (φJ ψ) = {}"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>φJ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diagonalization</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ ∈ fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars ψ = {xx}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (eql (tJ ψ) ⟨inst ψ (tJ ψ)⟩) ∧
       prv (eqv (φJ ψ) (inst ψ ⟨φJ ψ⟩))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>fJ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fJ ≡ ssap ψ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fJ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fJ ∈ F"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fJ_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fJ (tenc (encF fJ)) = ⟨inst ψ (tJ ψ)⟩"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CapSS</span><span> </span><span>assms</span><span> </span><span>fJ_def</span><span> </span><span>tJ_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>**</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (eql (tJ ψ) ⟨inst ψ (tJ ψ)⟩)"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ReprF</span><span> </span><span>fJ</span><span> </span><span>fJ_def</span><span> </span><span>tJ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (eqv (φJ ψ) (inst ψ ⟨φJ ψ⟩))"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>prv_eql_subst_trm_eqv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>xx</span><span> </span><span>_</span><span>  </span><span>_</span><span> </span><span>_</span><span> </span><span>**</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ"</span></span></span><span class="delimiter">]</span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>φJ_def</span><span> </span><span>inst_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale Jeroslow_Diagonalization}›</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Term-based version of Jeroslow's Second Incompleteness Theorem›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Jeroslow_Godel_Second</span><span> </span><span class="delimiter">=</span><span>
</span><span>Jeroslow_Diagonalization</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>prv</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>Ops</span><span> </span><span>tenc</span><span>
</span><span>  </span><span>F</span><span> </span><span>encF</span><span> </span><span>N</span><span> </span><span>ssap</span><span>
</span><span class="delimiter">+</span><span>
</span><span>HBL1</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>prv</span><span> </span><span>prv</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>P</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>num</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Ops</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tenc</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>F</span><span> </span><span>encF</span><span> </span><span>N</span><span> </span><span>ssap</span><span>
</span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>SHBL3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀t. t ∈ trm ⟹ FvarsT t = {} ⟹ prv (imp (PP t) (PP ⟨PP t⟩))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Consistency formula a la Jeroslow:›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>jcons</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"jcons ≡ all xx (neg (cnj (PP (Var xx)) (PP (encF N (Var (xx))))))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prv_eql_subst_trm3</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"x ∈ var ⟹ φ ∈ fmla ⟹ t1 ∈ trm ⟹ t2 ∈ trm ⟹
prv (eql t1 t2) ⟹ prv (subst φ t1 x) ⟹ prv (subst φ t2 x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_eql_subst_trm2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>subst</span><span> </span><span>prv_imp_mp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prv_eql_neg_encF_N</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (eql ⟨neg φ⟩ (encF N ⟨φ⟩))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>CapN</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>prv_prv_eql_sym</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>ReprF</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prv_imp_neg_encF_N_aux</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp (PP ⟨neg φ⟩) (PP (encF N ⟨φ⟩)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>prv_eql_subst_trm2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>prv_eql_neg_encF_N</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>  </span><span>of</span><span> </span><span>xx</span><span> </span><span class="string"><span class="delete"><span class="delete">"PP (Var xx)"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prv_cnj_neg_encF_N_aux</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"χ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars χ = {}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (neg (cnj χ (PP ⟨neg φ⟩)))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span class="string"><span class="delete"><span class="delete">"prv (neg (cnj χ (PP (encF N ⟨φ⟩))))"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>prv_eql_subst_trm3</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>prv_eql_neg_encF_N</span><span class="delimiter">,</span><span>
</span><span>  </span><span>of</span><span> </span><span>xx</span><span> </span><span class="string"><span class="delete"><span class="delete">"neg (cnj χ (PP (Var xx)))"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>jeroslow_godel_second</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>consistent</span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ prv jcons"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv jcons"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ψ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ ≡ PP (encF N (Var xx))"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ≡ tJ ψ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ψ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars ψ = {xx}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ trm"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"FvarsT t = {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ψ_def</span><span> </span><span>t_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sPP</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst (PP (encF N (Var xx))) ⟨PP (encF N t)⟩ xx =
             PP (encF N ⟨PP (encF N t)⟩)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>subst_compose_eq_or</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sPP2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst (PP (encF N (Var xx))) t xx = PP (encF N t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>subst_compose_eq_or</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>00</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"PP (encF N t) = inst ψ t"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ψ_def</span><span> </span><span>inst_def</span><span> </span><span>PP_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>subst_compose_eq_or</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>φ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ≡ φJ ψ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>φ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>**</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (eql t ⟨φ⟩)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>00</span><span> </span><span>φ_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>φJ_def</span><span> </span><span>diagonalization</span><span> </span><span>inst_def</span><span> </span><span>t_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>φ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ = PP (encF N t)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>φ_def</span><span> </span><span>φJ_def</span><span> </span><span>t_def</span><span> </span><span>ψ_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sPP2</span><span> </span><span>ψ_def</span><span> </span><span>t_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp φ (PP ⟨φ⟩))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SHBL3</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"encF N t"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>00</span><span> </span><span>φJ_def</span><span> </span><span>φ_def</span><span> </span><span>ψ_def</span><span> </span><span>inst_def</span><span> </span><span>t_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eqv_φ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (eqv φ (PP (encF N ⟨φ⟩)))"</span></span></span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>diagonalization</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="string"><span class="delete"><span class="delete">"00"</span></span></span><span> </span><span>sPP</span><span> </span><span>φJ_def</span><span> </span><span>φ_def</span><span> </span><span>ψ</span><span> </span><span>ψ_def</span><span> </span><span>diagonalization</span><span> </span><span>inst_def</span><span> </span><span>t_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp φ (PP (encF N ⟨φ⟩)))"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_cnjEL</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>eqv_φ</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>eqv_def</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp (PP (encF N ⟨φ⟩)) φ)"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_cnjER</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>eqv_φ</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>eqv_def</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span>  </span><span>prv_prv_imp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>prv_imp_neg_encF_N_aux</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>22</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp (PP ⟨neg φ⟩) φ)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp φ (cnj (PP ⟨φ⟩) (PP (encF N ⟨φ⟩))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>prv_imp_cnj</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>1</span><span> </span><span>2</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>φ_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (neg (cnj (PP ⟨φ⟩) (PP (encF N ⟨φ⟩))))"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_allE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>*</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>jcons_def</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨φ⟩"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>φ</span><span> </span><span>ψ_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (neg φ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>neg_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>prv_prv_imp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>3</span><span> </span><span>4</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>neg_def</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (PP ⟨neg φ⟩)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span>
</span><span>      </span><span>HBL1_PP</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>5</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv φ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_imp_mp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>22</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>5</span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>consistent_def3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A variant of the Second Incompleteness Theorem›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This variant (also discussed in our CADE 2019 paper~\cite{DBLP:conf/cade/0001T19}) strengthens
the conclusion of the theorem to the standard formulation
of "does not prove its own consistency" at the expense of two
additional derivability-like conditions, HBL4 and WHBL2.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>jeroslow_godel_second_standardCon</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>consistent</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>HBL4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀φ1 φ2. {φ1,φ2} ⊆ fmla ⟹ Fvars φ1 = {} ⟹ Fvars φ2 = {} ⟹
   prv (imp (cnj (PP ⟨φ1⟩) (PP ⟨φ2⟩)) (PP ⟨cnj φ1 φ2⟩))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>WHBL2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀φ1 φ2. {φ1,φ2} ⊆ fmla ⟹ Fvars φ1 = {} ⟹ Fvars φ2 = {} ⟹
   prv (imp φ1 φ2) ⟹ prv (imp (PP ⟨φ1⟩) (PP ⟨φ2⟩))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ prv (neg (PP ⟨fls⟩))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>*</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prv (neg (PP ⟨fls⟩))"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ψ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ ≡ PP (encF N (Var xx))"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ≡ tJ ψ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ψ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ψ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars ψ = {xx}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ∈ trm"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"FvarsT t = {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ψ_def</span><span> </span><span>t_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst (PP (encF N (Var xx))) ⟨PP (encF N t)⟩ xx =
             PP (encF N ⟨PP (encF N t)⟩)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>subst_compose_eq_or</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst (PP (encF N (Var xx))) t xx = PP (encF N t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>subst_compose_eq_or</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>00</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"PP (encF N t) = inst ψ t"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ψ_def</span><span> </span><span>inst_def</span><span> </span><span>PP_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>subst_compose_eq_or</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>φ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φ = PP (encF N t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>φ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>**</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (eql t ⟨PP (encF N t)⟩)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>00</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>diagonalization</span><span> </span><span>t_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp φ (PP ⟨φ⟩))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SHBL3</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"encF N t"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>φ_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp φ (PP (encF N ⟨φ⟩)))"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_eql_subst_trm2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>xx</span><span> </span><span>_</span><span>  </span><span>_</span><span> </span><span>_</span><span> </span><span>**</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"PP (encF N (Var xx))"</span></span></span><span class="delimiter">]</span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>φ_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp (PP (encF N ⟨φ⟩)) φ)"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_eql_subst_trm_rev2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>xx</span><span> </span><span>_</span><span>  </span><span>_</span><span> </span><span>_</span><span> </span><span>**</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"PP (encF N (Var xx))"</span></span></span><span class="delimiter">]</span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>φ_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>prv_prv_imp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>prv_imp_neg_encF_N_aux</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>22</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp (PP ⟨neg φ⟩) φ)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp φ (cnj (PP ⟨φ⟩) (PP (encF N ⟨φ⟩))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>prv_imp_cnj</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>1</span><span> </span><span>2</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>φ_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹This is the modification from the proof of @{thm jeroslow_godel_second}:›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>41</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp (cnj (PP ⟨φ⟩) (PP ⟨neg φ⟩)) (PP ⟨cnj φ (neg φ)⟩))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HBL4</span><span class="delimiter">[</span><span>of</span><span> </span><span>φ</span><span> </span><span class="string"><span class="delete"><span class="delete">"neg φ"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp (cnj φ (neg φ)) (fls))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>prv_cnj_imp_monoR2</span><span> </span><span>prv_imp_neg_fls</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>WHBL2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>42</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp (PP ⟨cnj φ (neg φ)⟩) (PP ⟨fls⟩))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>prv_prv_imp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>41</span><span> </span><span>42</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp (cnj (PP ⟨φ⟩) (PP ⟨neg φ⟩)) (PP ⟨fls⟩))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>prv_prv_imp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>this</span><span> </span><span>*</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>neg_def</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (neg (cnj (PP ⟨φ⟩) (PP ⟨neg φ⟩)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>neg_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>prv_cnj_neg_encF_N_aux</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (neg (cnj (PP ⟨φ⟩) (PP (encF N ⟨φ⟩))))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="comment">― ‹End modification›</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (neg φ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>neg_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>prv_prv_imp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>3</span><span> </span><span>4</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>neg_def</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (PP ⟨neg φ⟩)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HBL1_PP</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>5</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv φ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_imp_mp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>22</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>5</span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>consistent_def3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Next we perform a formal analysis of some connection between the
above theorems' hypotheses.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>noContr</span><span> </span><span class="delimiter">::</span><span> </span><span>bool</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"noContr ≡ ∀ φ ∈ fmla. Fvars φ = {} ⟶ prv (neg (cnj (PP ⟨φ⟩) (PP ⟨neg φ⟩)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>jcons_noContr</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv jcons"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"noContr"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>noContr_def</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>safe</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>φ</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>φ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst (PP (encF N (Var xx))) ⟨φ⟩ xx =
               PP (encF N ⟨φ⟩)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>subst_compose_same</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>j</span><span> </span><span class="delimiter">=</span><span> </span><span>allE_id</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>j</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>jcons_def</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (neg (cnj (PP ⟨φ⟩)
                         (PP (encF N ⟨φ⟩))))"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (neg (cnj (PP ⟨φ⟩) ?j))"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_subst</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>j</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>xx</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨φ⟩"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp (PP ⟨neg φ⟩) ?j)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_eql_neg_encF_N</span><span class="delimiter">[</span><span>of</span><span> </span><span>φ</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_imp_neg_encF_N_aux</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp (cnj (PP ⟨φ⟩) (PP ⟨neg φ⟩))
                    (cnj (PP ⟨φ⟩) ?j))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>0</span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>  </span><span>prv_cnj_mono</span><span> </span><span>prv_imp_refl</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp (cnj (PP ⟨φ⟩) (PP ⟨neg φ⟩))
                 (cnj (PP ⟨φ⟩) ?j))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>2</span><span> </span><span>prv_cnj_mono</span><span> </span><span>prv_imp_refl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (neg (cnj (PP ⟨φ⟩) (PP ⟨neg φ⟩)))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>neg_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>prv_prv_imp_trans</span><span class="delimiter">[</span><span>rotated</span><span> </span><span>3</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹@{term noContr} is still stronger than the standard notion of proving own consistency:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>noContr_implies_neg_PP_fls</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"noContr"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (neg (PP ⟨fls⟩))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (neg (cnj (PP ⟨fls⟩) (PP ⟨neg fls⟩)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>noContr_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Fvars_tru</span><span> </span><span>enc</span><span> </span><span>in_num</span><span> </span><span>tru_def</span><span> </span><span>PP</span><span> </span><span>PP_def</span><span> </span><span>fls</span><span> </span><span>imp</span><span> </span><span>HBL1</span><span> </span><span>neg_def</span><span>
</span><span>       </span><span>prv_cnj_imp</span><span> </span><span>prv_fls</span><span> </span><span>prv_imp_com</span><span> </span><span>prv_imp_mp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Encode.enc</span><span> </span><span>HBL1_axioms</span><span> </span><span>HBL1_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>jcons_implies_neg_PP_fls</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv jcons"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (neg (PP ⟨fls⟩))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>noContr_implies_neg_PP_fls</span><span> </span><span>jcons_noContr</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹However, unlike @{term jcons}, which seems to be quite a bit stronger,
@{term noContr} is equivalent to the standard notion under a slightly
stronger assumption than our WWHBL2, namely, a binary version of that:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>neg_PP_fls_implies_noContr</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>WWHBL22</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀φ χ ψ. φ ∈ fmla ⟹ χ ∈ fmla ⟹ ψ ∈ fmla ⟹
   Fvars φ = {} ⟹ Fvars χ = {} ⟹ Fvars ψ = {} ⟹
   prv (imp φ (imp χ ψ)) ⟹ prv (imp (PP ⟨φ⟩) (imp (PP ⟨χ⟩) (PP ⟨ψ⟩)))"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (neg (PP ⟨fls⟩))"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"noContr"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>noContr_def</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>safe</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>φ</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>φ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp φ (imp (neg φ) fls))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>prv_imp_neg_fls</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp (PP ⟨φ⟩) (imp (PP ⟨neg φ⟩) (PP ⟨fls⟩)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>WWHBL22</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (neg (cnj (PP ⟨φ⟩) (PP ⟨neg φ⟩)))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>p</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>neg_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>prv_cnj_imp_monoR2</span><span class="delimiter">[</span><span>rotated</span><span> </span><span>3</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>prv_prv_imp_trans</span><span class="delimiter">[</span><span>rotated</span><span> </span><span>3</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>prv_imp_monoL</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale Jeroslow_Godel_Second}›</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="Loeb_Formula">
<div class="head"><h1>Theory Loeb_Formula</h1>
<span class="command">theory</span> <span class="name">Loeb_Formula</span><br/>
<span class="keyword">imports</span> <a href="Diagonalization.html"><span class="name">Diagonalization</span></a> <a href="Derivability_Conditions.html"><span class="name">Derivability_Conditions</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Löb  Formulas›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Loeb_Formula</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Diagonalization</span><span> </span><span>Derivability_Conditions</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The Löb formula, parameterized by a sentence @{term φ}, is defined by diagonalizing @{term "imp P φ"}.›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Loeb_Form</span><span> </span><span class="delimiter">=</span><span>
</span><span>Deduct2</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="delimiter">+</span><span>
</span><span>Repr_SelfSubst</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>S</span><span>
</span><span class="delimiter">+</span><span>
</span><span>HBL1</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>P</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>num</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The Löb formula associated to a formula @{term φ}:›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>φL</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla ⇒ 'fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φL φ ≡ diag (imp P φ)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>φL</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀φ. φ ∈ fmla ⟹ Fvars φ = {} ⟹ φL φ ∈ fmla"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>Fvars_φL</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla ⟹ Fvars φ = {} ⟹ Fvars (φL φ) = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>φL_def</span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bprv_φL_eqv</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla ⟹ Fvars φ  = {} ⟹ bprv (eqv (φL φ) (imp (PP ⟨φL φ⟩) φ))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>φL_def</span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bprv_diag_eqv</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"imp P φ"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prv_φL_eqv</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla ⟹ Fvars φ  = {} ⟹ prv (eqv (φL φ) (imp (PP ⟨φL φ⟩) φ))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bprv_prv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>bprv_φL_eqv</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale Loeb_Form}›</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="Loeb">
<div class="head"><h1>Theory Loeb</h1>
<span class="command">theory</span> <span class="name">Loeb</span><br/>
<span class="keyword">imports</span> <a href="Loeb_Formula.html"><span class="name">Loeb_Formula</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Löb's Theorem›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Loeb</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Loeb_Formula</span><span> </span><span>Derivability_Conditions</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We have set up the formalization of Gödel's first (easy half) and Gödel's second
so that the following generalizations, leading to Löb's theorem, are trivial
modifications of these, replacing negation with "implies @{term φ}" in all proofs.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Loeb_Assumptions</span><span> </span><span class="delimiter">=</span><span>
</span><span>HBL1_2_3</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>num</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>P</span><span>
</span><span class="delimiter">+</span><span>
</span><span>Loeb_Form</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>num</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>S</span><span>
</span><span>  </span><span>P</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>num</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Generalization of $\mathit{goedel\_first\_theEasyHalf\_pos}$, replacing @{term fls} with a sentence @{term φ}:›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>loeb_aux_prv</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>φ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (φL φ)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv φ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp (PP ⟨φL φ⟩) φ)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>prv_eqv_prv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>p</span><span> </span><span>prv_φL_eqv</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (PP ⟨φL φ⟩)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HBL1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>φL</span><span class="delimiter">[</span><span>OF</span><span> </span><span>φ</span><span class="delimiter">]</span><span> </span><span>_</span><span> </span><span>p</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>bprv_prv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>this</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (PP ⟨φL φ⟩)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PP</span><span> </span><span>φL</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>assms</span><span> </span><span>enc</span><span> </span><span>in_num</span><span> </span><span>prv_imp_mp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>loeb_aux_bprv</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>φ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (φL φ)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv φ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>pp</span><span> </span><span class="delimiter">=</span><span> </span><span>bprv_prv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>p</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (PP ⟨φL φ⟩) φ)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>B.prv_eqv_prv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>p</span><span> </span><span>bprv_φL_eqv</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (PP ⟨φL φ⟩)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HBL1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>φL</span><span class="delimiter">[</span><span>OF</span><span> </span><span>φ</span><span class="delimiter">]</span><span> </span><span>_</span><span> </span><span>pp</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PP</span><span> </span><span>φL</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>assms</span><span> </span><span>enc</span><span> </span><span>in_num</span><span> </span><span>B.prv_imp_mp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Generalization of $\mathit{P\_G}$, the main lemma used for Gödel's second:›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>P_L</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>φ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (PP ⟨φL φ⟩) (PP ⟨φ⟩))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp (φL φ) (imp (PP ⟨φL φ⟩) φ))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_φL_eqv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>prv_imp_eqvEL</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (PP ⟨imp (φL φ) (imp (PP ⟨φL φ⟩) φ)⟩)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HBL1_PP</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (PP ⟨φL φ⟩) (PP ⟨imp (PP ⟨φL φ⟩) φ⟩))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HBL2_imp2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (PP ⟨φL φ⟩) (PP ⟨PP ⟨φL φ⟩⟩))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HBL3</span><span class="delimiter">[</span><span>OF</span><span> </span><span>φL</span><span class="delimiter">[</span><span>OF</span><span> </span><span>φ</span><span class="delimiter">]</span><span> </span><span>_</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>23</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (PP ⟨φL φ⟩)
                      (cnj (PP ⟨PP ⟨φL φ⟩⟩)
                           (PP ⟨imp (PP ⟨φL φ⟩) φ⟩)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.prv_imp_cnj</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>3</span><span> </span><span>2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (cnj (PP ⟨PP ⟨φL φ⟩⟩)
                          (PP ⟨imp (PP ⟨φL φ⟩) φ⟩))
                    (PP ⟨φ⟩))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HBL2</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"PP ⟨φL φ⟩"</span></span></span><span> </span><span>φ</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B.prv_prv_imp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>23</span><span> </span><span>4</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Löb's theorem generalizes the positive formulation Gödel's Second
($\mathit{goedel\_second}$). In our two-provability-relation framework, we get two variants of Löb's theorem.
A stronger variant, assuming @{term prv} and proving @{term bprv}, seems impossible.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>loeb_bprv</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>φ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (PP ⟨φ⟩) φ)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv φ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (imp (PP ⟨φL φ⟩) φ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>B.prv_prv_imp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>P_L</span><span> </span><span>p</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bprv (φL φ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>B.prv_eqv_prv_rev</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>bprv_φL_eqv</span><span class="delimiter">,</span><span> </span><span>rotated</span><span> </span><span>2</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>loeb_aux_bprv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>φ</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>loeb_prv</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>φ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φ ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φ = {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp (PP ⟨φ⟩) φ)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv φ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>PL</span><span> </span><span class="delimiter">=</span><span> </span><span>bprv_prv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>P_L</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (imp (PP ⟨φL φ⟩) φ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>prv_prv_imp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>PL</span><span> </span><span>p</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prv (φL φ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>prv_eqv_prv_rev</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>prv_φL_eqv</span><span class="delimiter">,</span><span> </span><span>rotated</span><span> </span><span>2</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>loeb_aux_prv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>φ</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We could have of course inferred $\mathit{goedel\_first\_theEasyHalf\_pos}$
and $\mathit{goedel\_second}$ from these more general versions, but we leave the original
arguments as they are more instructive.›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale Loeb_Assumptions}›</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span>
</span></pre>
</div>
</div><div id="Tarski">
<div class="head"><h1>Theory Tarski</h1>
<span class="command">theory</span> <span class="name">Tarski</span><br/>
<span class="keyword">imports</span> <a href="Goedel_Formula.html"><span class="name">Goedel_Formula</span></a> <a href="Standard_Model_More.html"><span class="name">Standard_Model_More</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Abstract Formulation of Tarski's Theorems›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We prove Tarski's proof-theoretic and semantic theorems about the
non-definability and respectively non-expressiveness (in the standard model) of truth›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Tarski</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Goedel_Formula</span><span> </span><span>Standard_Model_More</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Non-Definability of Truth›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Goedel_Form</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>T</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'fmla</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>T</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"T ∈ fmla"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Fvars_T</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars T = {xx}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv_T</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀φ. φ ∈ fmla ⟹ Fvars φ = {} ⟹ prv (eqv (subst T ⟨φ⟩ xx) φ)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>φT</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'fmla</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"φT ≡ diag (neg T)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>φT</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"φT ∈ fmla"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>Fvars_φT</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars φT = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>φT_def</span><span> </span><span>PP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bprv_φT_eqv</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"bprv (eqv φT (neg (subst T ⟨φT⟩ xx)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>φT_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bprv_diag_eqv</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"neg T"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prv_φT_eqv</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"prv (eqv φT (neg (subst T ⟨φT⟩ xx)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>d_dwf.bprv_prv'</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>bprv_φT_eqv</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>φT_prv_fls</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prv fls"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prv_eqv_eqv_neg_prv_fls2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>prv_T</span><span class="delimiter">[</span><span>OF</span><span> </span><span>φT</span><span> </span><span>Fvars_φT</span><span class="delimiter">]</span><span> </span><span>prv_φT_eqv</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Tarski_proof_theoretic</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars T = {xx}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀φ. φ ∈ fmla ⟹ Fvars φ = {} ⟹ prv (eqv (subst T ⟨φ⟩ xx) φ)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ consistent"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>φT_prv_fls</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>consistent_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale Goedel_Form}›</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Non-Expressiveness of Truth›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This follows as a corollary of the syntactic version, after taking prv
to be isTrue on sentences.Indeed, this is a virtue of our abstract treatment
of provability: We don't work with a particular predicate, but with any predicate
that is closed under some rules --- which could as well be a semantic notion of truth (for sentences).›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Goedel_Form_prv_eq_isTrue</span><span> </span><span class="delimiter">=</span><span>
</span><span>Goedel_Form</span><span>
</span><span>  </span><span>var</span><span> </span><span>trm</span><span> </span><span>fmla</span><span> </span><span>Var</span><span> </span><span>num</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span>  </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span>  </span><span>fls</span><span>
</span><span>  </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span>  </span><span>enc</span><span>
</span><span>  </span><span>P</span><span>
</span><span>  </span><span>S</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>var</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'trm set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fmla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Var</span><span> </span><span>num</span><span> </span><span>FvarsT</span><span> </span><span>substT</span><span> </span><span>Fvars</span><span> </span><span>subst</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eql</span><span> </span><span>cnj</span><span> </span><span>imp</span><span> </span><span>all</span><span> </span><span>exi</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fls</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prv</span><span> </span><span>bprv</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>enc</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span>
</span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>isTrue</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'fmla ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>prv_eq_isTrue</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ φ. φ ∈ fmla ⟹ Fvars φ = {} ⟹ prv φ = isTrue φ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Tarski_semantic</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"T ∈ fmla"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fvars T = {xx}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀φ. φ ∈ fmla ⟹ Fvars φ = {} ⟹ isTrue (eqv (subst T ⟨φ⟩ xx) φ)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ consistent"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>prv_eq_isTrue</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"eqv (subst T ⟨_⟩ xx) _"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>Tarski_proof_theoretic</span><span class="delimiter">[</span><span>OF</span><span> </span><span>0</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹NB: To instantiate the semantic version of Tarski's theorem for a truth predicate
isTruth on sentences, one needs to extend it to a predicate "prv" on formulas and verify
that "prv" satisfies the rules of intuitionistic logic.›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹context @{locale Goedel_Form_prv_eq_isTrue}›</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="All_Abstract">
<div class="head"><h1>Theory All_Abstract</h1>
<span class="command">theory</span> <span class="name">All_Abstract</span><br/>
<span class="keyword">imports</span> <a href="Abstract_First_Goedel_Rosser.html"><span class="name">Abstract_First_Goedel_Rosser</span></a> <a href="Abstract_Second_Goedel.html"><span class="name">Abstract_Second_Goedel</span></a> <a href="Jeroslow_Original.html"><span class="name">Jeroslow_Original</span></a> <a href="Jeroslow_Simplified.html"><span class="name">Jeroslow_Simplified</span></a> <a href="Loeb.html"><span class="name">Loeb</span></a> <a href="Tarski.html"><span class="name">Tarski</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This puts together all the theories of the abstract development›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>All_Abstract</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Abstract_First_Goedel</span><span>
</span><span>  </span><span>Abstract_First_Goedel_Rosser</span><span>
</span><span>  </span><span>Abstract_Second_Goedel</span><span>
</span><span>  </span><span>Jeroslow_Original</span><span>
</span><span>  </span><span>Jeroslow_Simplified</span><span>
</span><span>  </span><span>Loeb</span><span>
</span><span>  </span><span>Tarski</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div>