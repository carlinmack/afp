<div id="Decreasing_Diagrams_II_Aux">
<div class="head"><h1>Theory Decreasing_Diagrams_II_Aux</h1>
<span class="command">theory</span> <span class="name">Decreasing_Diagrams_II_Aux</span><br/>
<span class="keyword">imports</span> <a href="Multiset_Extension.html"><span class="name">Multiset_Extension</span></a> <a href="Well_Quasi_Orders.html"><span class="name">Well_Quasi_Orders</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title:      Decreasing Diagrams II  
   Author:     Bertram Felgenhauer (2015)
   Maintainer: Bertram Felgenhauer &lt;bertram.felgenhauer@uibk.ac.at&gt;
   License:    LGPL or BSD

License clarification: This file is also licensed under the BSD license to facilitate reuse
and moving snippets from here to more suitable places.
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Preliminaries›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Decreasing_Diagrams_II_Aux</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Well_Quasi_Orders.Multiset_Extension</span><span>
</span><span>  </span><span>Well_Quasi_Orders.Well_Quasi_Orders</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Trivialities›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* move to Relation.thy? *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>asymI2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀a b. (a,b) ∈ R ⟹ (b,a) ∉ R) ⟹ asym R"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>asymI</span><span> </span><span>irrefl_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* move to Relation.thy? *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_order R ≡ irrefl R ∧ trans R"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* move to Relation.thy? *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>order_asym</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans R ⟹ asym R = irrefl R"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>asym.simps</span><span> </span><span>irrefl_def</span><span> </span><span>trans_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* move to Relation.thy? *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strict_order_strict</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_order q ⟹ strict (λa b. (a, b) ∈ q<span class="hidden">⇧</span><sup>=</sup>) = (λa b. (a, b) ∈ q)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>trans_def</span><span> </span><span>irrefl_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* move to Wellfounded.thy? *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_lex1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono (λr. lex_prod r s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mono_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* move to Wellfounded.thy? *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_lex2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono (lex_prod r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mono_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* move to Wellfounded.thy? *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>irrefl_lex_prod</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"irrefl R ⟹ irrefl S ⟹ irrefl (R &lt;*lex*&gt; S)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lex_prod_def</span><span> </span><span>irrefl_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>converse_inward</span><span> </span><span class="delimiter">=</span><span> </span><span>rtrancl_converse</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>converse_Un</span><span> </span><span>converse_UNION</span><span> </span><span>converse_relcomp</span><span>
</span><span>  </span><span>converse_converse</span><span> </span><span>converse_Id</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Complete lattices and least fixed points›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>complete_lattice</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A chain-based induction principle›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>set_chain</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"set_chain C ≡ ∀x ∈ C. ∀y ∈ C. x ≤ y ∨ y ≤ x"</span></span></span><span>
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lfp_chain_induct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono f"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. P x ⟹ P (f x)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>chain</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀C. set_chain C ⟹ ∀ x ∈ C. P x ⟹ P (Sup C)"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P (lfp f)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lfp_eq_fixp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mono</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fixp_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"monotone (≤) (≤) f"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mono</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>order_class.mono_def</span><span> </span><span>monotone_def</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P (Sup {})"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>chain</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"{}"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ccpo.admissible Sup (≤) P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>chain</span><span> </span><span>ccpo.admissible_def</span><span> </span><span>Complete_Partial_Order.chain_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>fact</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Preservation of transitivity, asymmetry, irreflexivity by suprema›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trans_Sup_of_chain</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_chain C"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀R. R ∈ C ⟹ trans R"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans (Sup C)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>transI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x,y) ∈ Sup C"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(y,z) ∈ Sup C"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(x,y) ∈ Sup C›</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>R</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"R ∈ C"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x,y) ∈ R"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(y,z) ∈ Sup C›</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>S</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ∈ C"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(y,z) ∈ S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹R ∈ C›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹S ∈ C›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹set_chain C›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"R ∪ S = R ∨ R ∪ S = S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹R ∈ C›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹S ∈ C›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"R ∪ S ∈ C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(x,y) ∈ R›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(y,z) ∈ S›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trans</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"R ∪ S"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x,z) ∈ R ∪ S"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>trans_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹R ∪ S ∈ C›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x,z) ∈ ⋃C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>asym_Sup_of_chain</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_chain C"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>asym</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ R. R ∈ C ⟹ asym R"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"asym (Sup C)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>asymI2</span><span> </span><span>notI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>b</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a,b) ∈ Sup C"</span></span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"R"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"R ∈ C"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a,b) ∈ R"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(b,a) ∈ Sup C"</span></span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ∈ C"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(b,a) ∈ S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹R ∈ C›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹S ∈ C›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹set_chain C›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"R ∪ S = R ∨ R ∪ S = S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹R ∈ C›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹S ∈ C›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"R ∪ S ∈ C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(a,b) ∈ R›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(b,a) ∈ S›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>asym</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>asym.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strict_order_lfp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mono f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀R. strict_order R ⟹ strict_order (f R)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_order (lfp f)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>lfp_chain_induct</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span> </span><span>strict_order</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('b × 'b) set set"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_chain C"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀R ∈ C. strict_order R"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_order (Sup C)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>asym_Sup_of_chain</span><span> </span><span>trans_Sup_of_chain</span><span> </span><span>order_asym</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trans_lfp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mono f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀R. trans R ⟹ trans (f R)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans (lfp f)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>lfp_chain_induct</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span> </span><span>trans</span><span class="delimiter">]</span><span> </span><span>assms</span><span> </span><span>trans_Sup_of_chain</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* complete_lattice *)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Multiset extension›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mulex_iff_mult</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mulex r M N ⟷ (M,N) ∈ mult {(M,N) . r M N}"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mulex_on_def</span><span> </span><span>restrict_to_def</span><span> </span><span>mult_def</span><span> </span><span>mulex1_def</span><span> </span><span>tranclp_unfold</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>multI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M = I + K"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N = I + J"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"J ≠ {#}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀k ∈ set_mset K. ∃j ∈ set_mset J. (k,j) ∈ r"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,N) ∈ mult r"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>one_step_implies_mult</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>multE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,N) ∈ mult r"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>I</span><span> </span><span>J</span><span> </span><span>K</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M = I + K"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N = I + J"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"J ≠ {#}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀k ∈ set_mset K. ∃j ∈ set_mset J. (k,j) ∈ r"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mult_implies_one_step</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mult_on_union</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,N) ∈ mult r ⟹ (K + M, K + N) ∈ mult r"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mulex_on_union</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λx y. (x,y) ∈ r"</span></span></span><span> </span><span>UNIV</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mulex_iff_mult</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mult_on_union'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,N) ∈ mult r ⟹ (M + K, N + K) ∈ mult r"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mulex_on_union'</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λx y. (x,y) ∈ r"</span></span></span><span> </span><span>UNIV</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mulex_iff_mult</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mult_on_add_mset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,N) ∈ mult r ⟹ (add_mset k M, add_mset k N) ∈ mult r"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>add_mset_add_single</span><span class="delimiter">[</span><span>of</span><span> </span><span>k</span><span> </span><span>M</span><span class="delimiter">]</span><span> </span><span>add_mset_add_single</span><span class="delimiter">[</span><span>of</span><span> </span><span>k</span><span> </span><span>N</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mult_on_union'</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mult_empty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(M,{#}) ∉ mult R"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult_def</span><span> </span><span>not_less_empty</span><span> </span><span>trancl.cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mult_singleton</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ r ⟹ (add_mset x M, add_mset y M) ∈ mult r"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>add_mset_add_single</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>M</span><span class="delimiter">]</span><span> </span><span>add_mset_add_single</span><span class="delimiter">[</span><span>of</span><span> </span><span>y</span><span> </span><span>M</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mult_on_union</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mult1_singleton</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>r</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mult_def</span><span> </span><span>mult_on_union</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>empty_mult</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"({#},N) ∈ mult R ⟷ N ≠ {#}"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>empty_mulex_on</span><span class="delimiter">[</span><span>of</span><span> </span><span>N</span><span> </span><span>UNIV</span><span> </span><span class="string"><span class="delete"><span class="delete">"λM N. (M,N) ∈ R"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mulex_iff_mult</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trans_mult</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans (mult R)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mult_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strict_order_mult</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"irrefl R"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans R"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"irrefl (mult R)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans (mult R)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"irrefl (mult R)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>irrefl_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>notI</span><span class="delimiter">,</span><span> </span><span>elim</span><span> </span><span>multE</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trans R›</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>M</span><span> </span><span>I</span><span> </span><span>J</span><span> </span><span>K</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M = I + J"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M = I + K"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"J ≠ {#}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀k ∈ set_mset K. ∃j ∈ set_mset J. (k, j) ∈ R"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹M = I + J›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹M = I + K›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"J = K"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (set_mset J)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset J = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹J = K›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>finite_induct</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>assms</span><span> </span><span>insert_absorb</span><span> </span><span>insert_iff</span><span> </span><span>insert_not_empty</span><span> </span><span>irrefl_def</span><span> </span><span>transD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹J ≠ {#}›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trans_mult</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mult_of_image_mset</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans R"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans R'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x y. x ∈ set_mset N ⟹ y ∈ set_mset M ⟹ (x,y) ∈ R ⟹ (f x, f y) ∈ R'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(N, M) ∈ mult R"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(image_mset f N, image_mset f M) ∈ mult R'"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>elim</span><span> </span><span>multE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>I</span><span> </span><span>J</span><span> </span><span>K</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N = I + K"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M = I + J"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"J ≠ {#}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀k ∈ set_mset K. ∃j ∈ set_mset J. (k, j) ∈ R"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(image_mset f N, image_mset f M) ∈ mult R'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>multI</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Incrementality of @{term mult1} and @{term mult}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_mult1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono mult1"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mono_def</span><span> </span><span>mult1_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_mult</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono mult"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mono_def</span><span> </span><span>mult_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>R</span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"R ⊆ S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ (mult1 R)<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ (mult1 S)<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mono_mult1</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>mono_def</span><span class="delimiter">]</span><span> </span><span>trancl_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span class="string"><span class="delete"><span class="delete">"mult1 R"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mult1 S"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Well-orders and well-quasi-orders›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_iff_wfp_on</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wf p ⟷ wfp_on (λa b. (a, b) ∈ p) UNIV"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wfp_on_iff_inductive_on</span><span> </span><span>wf_def</span><span> </span><span>inductive_on_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>well_order_implies_wqo</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"well_order r"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wqo_on (λa b. (a, b) ∈ r) UNIV"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>wqo_onI</span><span> </span><span>almost_full_onI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"transp_on (λa b. (a, b) ∈ r) UNIV"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>well_order_on_def</span><span> </span><span>linear_order_on_def</span><span> </span><span>partial_order_on_def</span><span> </span><span>preorder_on_def</span><span>
</span><span>    </span><span>trans_def</span><span> </span><span>transp_on_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ 'a"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"good (λa b. (a, b) ∈ r) f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>well_order_on_def</span><span> </span><span>wf_iff_wfp_on</span><span> </span><span>wfp_on_def</span><span> </span><span>not_ex</span><span> </span><span>not_all</span><span> </span><span>de_Morgan_conj</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>conjE</span><span> </span><span>allE</span><span> </span><span>exE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"linear_order r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f x ∉ UNIV ∨ (f (Suc x), f x) ∉ r - Id"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(f x, f (Suc x)) ∈ r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹linear_order r›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>linear_order_on_def</span><span> </span><span>Relation.total_on_def</span><span> </span><span>partial_order_on_def</span><span> </span><span>preorder_on_def</span><span>
</span><span>      </span><span>refl_on_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"good (λa b. (a, b) ∈ r) f"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>good_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Splitting lists into prefix, element, and suffix›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>list_splits</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list ⇒ ('a list × 'a × 'a list) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"list_splits [] = []"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"list_splits (x # xs) = ([], x, xs) # map (λ(xs, x', xs'). (x # xs, x', xs')) (list_splits xs)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_splits_empty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"list_splits xs = [] ⟷ xs = []"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>elem_list_splits_append</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ys, y, zs) ∈ set (list_splits xs)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ys @ [y] @ zs = xs"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>ys</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>elem_list_splits_length</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ys, y, zs) ∈ set (list_splits xs)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ys &lt; length xs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length zs &lt; length xs"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>elem_list_splits_append</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>elem_list_splits_elem</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(xs, y, ys) ∈ set (list_splits zs)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ set zs"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>elem_list_splits_append</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_splits_append</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"list_splits (xs @ ys) = map (λ(xs', x', ys'). (xs', x', ys' @ ys)) (list_splits xs) @
                           map (λ(xs', x', ys'). (xs @ xs', x', ys')) (list_splits ys)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_splits_rev</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"list_splits (rev xs) = map (λ(xs, x, ys). (rev ys, x, rev xs)) (rev (list_splits xs))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>list_splits_append</span><span> </span><span>comp_def</span><span> </span><span>prod.case_distrib</span><span> </span><span>rev_map</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_splits_map</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"list_splits (map f xs) = map (λ(xs, x, ys). (map f xs, f x, map f ys)) (list_splits xs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Decreasing_Diagrams_II_Aux *)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="Decreasing_Diagrams_II">
<div class="head"><h1>Theory Decreasing_Diagrams_II</h1>
<span class="command">theory</span> <span class="name">Decreasing_Diagrams_II</span><br/>
<span class="keyword">imports</span> <a href="Decreasing_Diagrams_II_Aux.html"><span class="name">Decreasing_Diagrams_II_Aux</span></a> <a href="Wellorder_Extension.html"><span class="name">Wellorder_Extension</span></a> <a href="../Abstract-Rewriting/Abstract_Rewriting.html"><span class="name">Abstract_Rewriting</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
 * Title:      Decreasing Diagrams II  
 * Author:     Bertram Felgenhauer (2015)
 * Maintainer: Bertram Felgenhauer &lt;bertram.felgenhauer@uibk.ac.at&gt;
 * License:    LGPL
 *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Decreasing Diagrams›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Decreasing_Diagrams_II</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Decreasing_Diagrams_II_Aux</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Cardinals.Wellorder_Extension"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Abstract-Rewriting.Abstract_Rewriting"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Greek accents›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>accent</span><span> </span><span class="delimiter">=</span><span> </span><span>Acute</span><span> </span><span class="delimiter">|</span><span> </span><span>Grave</span><span> </span><span class="delimiter">|</span><span> </span><span>Macron</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>UNIV_accent</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"UNIV = { Acute, Grave, Macron }"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>accent.nchotomy</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_accent</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (UNIV :: accent set)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>UNIV_accent</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>letter</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"accent × 'a"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>letter_less</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a × 'a) set ⇒ ('a letter × 'a letter) set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"letter_less R = {(a,b). (snd a, snd b) ∈ R}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_letter_less</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono letter_less"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mono_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Comparing Greek strings›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>greek</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a letter list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>adj_msog</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a greek ⇒ 'a greek ⇒ ('a letter × 'a greek) ⇒ ('a letter × 'a greek)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"adj_msog xs zs l ≡
    case l of (y,ys) ⇒ (y, case fst y of Acute ⇒ ys @ zs | Grave ⇒ xs @ ys | Macron ⇒ ys)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ms_of_greek</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a greek ⇒ ('a letter × 'a greek) multiset"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ms_of_greek as = mset
    (map (λ(xs, y, zs) ⇒ adj_msog xs zs (y, [])) (list_splits as))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adj_msog_adj_msog</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"adj_msog xs zs (adj_msog xs' zs' y) = adj_msog (xs @ xs') (zs' @ zs) y"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>adj_msog_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>accent.splits</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>compose_adj_msog</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"adj_msog xs zs ∘ adj_msog xs' zs' = adj_msog (xs @ xs') (zs' @ zs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>comp_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adj_msog_single</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"adj_msog xs zs (x,[]) = (x, (case fst x of Grave ⇒ xs | Acute ⇒ zs | Macron ⇒ []))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>adj_msog_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>accent.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ms_of_greek_elem</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x,xs) ∈ set_mset (ms_of_greek ys)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ set ys"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>elem_list_splits_elem</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>adj_msog_def</span><span> </span><span>ms_of_greek_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ms_of_greek_shorter</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, t) ∈# ms_of_greek s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length s &gt; length t"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>ms_of_greek_def</span><span> </span><span>in_multiset_in_set</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>elem_list_splits_length</span><span> </span><span>adj_msog_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>accent.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>msog_append</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ms_of_greek (xs @ ys) = image_mset (adj_msog [] ys) (ms_of_greek xs) +
  image_mset (adj_msog xs []) (ms_of_greek ys)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ms_of_greek_def</span><span> </span><span>list_splits_append</span><span> </span><span>multiset.map_comp</span><span> </span><span>comp_def</span><span> </span><span>prod.case_distrib</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>nest</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a × 'a) set ⇒ ('a greek × 'a greek) set ⇒ ('a greek × 'a greek) set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nest r s = {(a,b). (ms_of_greek a, ms_of_greek b) ∈ mult (letter_less r &lt;*lex*&gt; s)}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_nest</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono (nest r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mono_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>R</span><span> </span><span>S</span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"R ⊆ S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ nest r R"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mult (letter_less r &lt;*lex*&gt; R) ⊆ mult (letter_less r &lt;*lex*&gt; S)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mono_mult</span><span> </span><span>mono_lex2</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"letter_less r"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mono_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ nest r S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nest_mono</span><span class="delimiter">[</span><span>mono_set</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊆ y ⟹ (a,b) ∈ nest r x ⟶ (a,b) ∈ nest r y"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mono_nest</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>mono_def</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>r</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>greek_less</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a × 'a) set ⇒ ('a greek × 'a greek) set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"greek_less r = lfp (nest r)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>greek_less_unfold</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"greek_less r = nest r (greek_less r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mono_nest</span><span class="delimiter">[</span><span>of</span><span> </span><span>r</span><span class="delimiter">]</span><span> </span><span>lfp_unfold</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"nest r"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>greek_less_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Preservation of strict partial orders›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strict_order_letter_less</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_order r"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_order (letter_less r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>irrefl_def</span><span> </span><span>trans_def</span><span> </span><span>letter_less_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strict_order_nest</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_order r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_order R"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_order (nest r R)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_order (mult (letter_less r &lt;*lex*&gt; R))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>strict_order_letter_less</span><span class="delimiter">[</span><span>of</span><span> </span><span>r</span><span class="delimiter">]</span><span> </span><span>irrefl_lex_prod</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"letter_less r"</span></span></span><span> </span><span>R</span><span class="delimiter">]</span><span>
</span><span>    </span><span>trans_lex_prod</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"letter_less r"</span></span></span><span> </span><span>R</span><span class="delimiter">]</span><span> </span><span>strict_order_mult</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"letter_less r &lt;*lex*&gt; R"</span></span></span><span class="delimiter">]</span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_order (nest r R)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>nest_def</span><span> </span><span>trans_def</span><span> </span><span>irrefl_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strict_order_greek_less</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_order r"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strict_order (greek_less r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>greek_less_def</span><span> </span><span>strict_order_lfp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mono_nest</span><span> </span><span>strict_order_nest</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trans_letter_less</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans (letter_less r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>trans_def</span><span> </span><span>letter_less_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trans_order_nest</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans (nest r R)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>trans_mult</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>nest_def</span><span> </span><span>trans_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trans_greek_less</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans (greek_less r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>greek_less_unfold</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>trans_order_nest</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_greek_less</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono greek_less"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>greek_less_def</span><span> </span><span>mono_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span> </span><span>lfp_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>r</span><span> </span><span>s</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a × 'a) set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a greek × 'a greek) set"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r ⊆ s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"letter_less r &lt;*lex*&gt; R ⊆ letter_less s &lt;*lex*&gt; R"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mono_letter_less</span><span> </span><span>mono_lex1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mono_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nest r R ⊆ nest s R"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mono_mult</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>nest_def</span><span> </span><span>mono_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Involution›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>inv_letter</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a letter ⇒ 'a letter"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"inv_letter l ≡
    case l of (a, x) ⇒ (case a of Grave ⇒ Acute | Acute ⇒ Grave | Macron ⇒ Macron, x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_letter_pair</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"inv_letter (a, x) = (case a of Grave ⇒ Acute | Acute ⇒ Grave | Macron ⇒ Macron, x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_letter_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snd_inv_letter</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"snd (inv_letter x) = snd x"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_letter_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_letter_invol</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"inv_letter (inv_letter x) = x"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_letter_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span> </span><span>accent.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_letter_mono</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ letter_less r"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(inv_letter x, inv_letter y) ∈ letter_less r"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>inv_greek</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a greek ⇒ 'a greek"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"inv_greek s = rev (map inv_letter s)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_greek_invol</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"inv_greek (inv_greek s) = s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_greek_def</span><span> </span><span>rev_map</span><span> </span><span>comp_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_greek_append</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"inv_greek (s @ t) = inv_greek t @ inv_greek s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_greek_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>inv_msog</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a letter × 'a greek) multiset ⇒ ('a letter × 'a greek) multiset"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"inv_msog M = image_mset (λ(x, t). (inv_letter x, inv_greek t)) M"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_msog_invol</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"inv_msog (inv_msog M) = M"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_msog_def</span><span> </span><span>multiset.map_comp</span><span> </span><span>comp_def</span><span> </span><span>prod.case_distrib</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ms_of_greek_inv_greek</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ms_of_greek (inv_greek M) = inv_msog (ms_of_greek M)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_msog_def</span><span> </span><span>inv_greek_def</span><span> </span><span>ms_of_greek_def</span><span> </span><span>list_splits_rev</span><span> </span><span>list_splits_map</span><span> </span><span>mset_map</span><span>
</span><span>  </span><span>multiset.map_comp</span><span> </span><span>mset_rev</span><span> </span><span>inv_letter_def</span><span> </span><span>adj_msog_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"image_mset"</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>refl</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>accent.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_greek_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s, t) ∈ greek_less r"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(inv_greek s, inv_greek t) ∈ greek_less r"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"length s + length t"</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>less_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>*</span><span> </span><span class="delimiter">=</span><span> </span><span>trans_lex_prod</span><span class="delimiter">[</span><span>OF</span><span> </span><span>trans_letter_less</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trans r›</span></span></span><span class="delimiter">]</span><span> </span><span>trans_greek_less</span><span class="delimiter">[</span><span>of</span><span> </span><span>r</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>less</span><span> </span><span>s</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(inv_msog (ms_of_greek s), inv_msog (ms_of_greek t)) ∈ mult (letter_less r &lt;*lex*&gt; greek_less r)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_msog_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>mult_of_image_mset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>*</span><span> </span><span>*</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>less</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ms_of_greek_shorter</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>less</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>greek_less_unfold</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>greek_less_unfold</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ms_of_greek_inv_greek</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Monotonicity of @{term "greek_less r"}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>greek_less_rempty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(a,[]) ∈ greek_less r ⟷ False"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>greek_less_unfold</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ms_of_greek_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>greek_less_nonempty</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ≠ []"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a,b) ∈ greek_less r ⟷ (a,b) ∈ nest r (greek_less r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>greek_less_unfold</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>greek_less_lempty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"([],b) ∈ greek_less r ⟷ b ≠ []"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"([],b) ∈ greek_less r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ≠ []"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>greek_less_rempty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ≠ []"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"([],b) ∈ greek_less r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>greek_less_nonempty</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹b ≠ []›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ms_of_greek_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>greek_less_singleton</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(a, b) ∈ letter_less r ⟹ ([a], [b]) ∈ greek_less r"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>greek_less_unfold</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>accent.splits</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>adj_msog_def</span><span> </span><span>ms_of_greek_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ms_of_greek_cons</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ms_of_greek (x # s) = {# adj_msog [] s (x,[]) #} + image_mset (adj_msog [x] []) (ms_of_greek s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>msog_append</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"[x]"</span></span></span><span> </span><span>s</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>adj_msog_def</span><span> </span><span>ms_of_greek_def</span><span> </span><span>accent.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>greek_less_cons_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s, t) ∈ greek_less r ⟹ (x # s, x # t) ∈ greek_less r"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"length s + length t"</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>less_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>*</span><span> </span><span class="delimiter">=</span><span> </span><span>trans_lex_prod</span><span class="delimiter">[</span><span>OF</span><span> </span><span>trans_letter_less</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trans r›</span></span></span><span class="delimiter">]</span><span> </span><span>trans_greek_less</span><span class="delimiter">[</span><span>of</span><span> </span><span>r</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>less</span><span> </span><span>s</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M + image_mset (adj_msog [x] []) (ms_of_greek s),
      M + image_mset (adj_msog [x] []) (ms_of_greek t)) ∈ mult (letter_less r &lt;*lex*&gt; greek_less r)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mult_on_union</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>mult_of_image_mset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>*</span><span> </span><span>*</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>adj_msog_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>less</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span> </span><span>accent.splits</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ms_of_greek_shorter</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>less</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>greek_less_unfold</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>N</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"({# adj_msog [] s (x,[]) #} + N,{# adj_msog [] t (x,[]) #} + N) ∈
      (mult (letter_less r &lt;*lex*&gt; greek_less r))<span class="hidden">⇧</span><sup>=</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>adj_msog_def</span><span> </span><span>less</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>accent.splits</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>transD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>trans_mult</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>greek_less_unfold</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ms_of_greek_cons</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>greek_less_app_mono2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s, t) ∈ greek_less r"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(p @ s, p @ t) ∈ greek_less r"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>p</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>greek_less_cons_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>greek_less_app_mono1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s, t) ∈ greek_less r"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s @ p, t @ p) ∈ greek_less r"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv_greek_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>r</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_greek p @ inv_greek s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_greek p @ inv_greek t"</span></span></span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>inv_greek_append</span><span> </span><span>inv_greek_mono</span><span> </span><span>greek_less_app_mono2</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Well-founded-ness of @{term "greek_less r"}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>greek_embed</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"list_emb (λa b. (a, b): reflcl (letter_less r)) a b ⟹ (a, b) ∈ reflcl (greek_less r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>list_emb.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>list_emb_Cons</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>y</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>trans_greek_less</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>trans_def</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trans r›</span></span></span><span>
</span><span>    </span><span>greek_less_app_mono1</span><span class="delimiter">[</span><span>of</span><span> </span><span>r</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[y]"</span></span></span><span> </span><span>a</span><span class="delimiter">]</span><span> </span><span>greek_less_app_mono2</span><span class="delimiter">[</span><span>of</span><span> </span><span>r</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="string"><span class="delete"><span class="delete">"[y]"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>list_emb_Cons2</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>trans_greek_less</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>trans_def</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trans r›</span></span></span><span> </span><span>greek_less_singleton</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>r</span><span class="delimiter">]</span><span>
</span><span>    </span><span>greek_less_app_mono1</span><span class="delimiter">[</span><span>of</span><span> </span><span>r</span><span> </span><span class="string"><span class="delete"><span class="delete">"[x]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[y]"</span></span></span><span> </span><span>a</span><span class="delimiter">]</span><span> </span><span>greek_less_app_mono2</span><span class="delimiter">[</span><span>of</span><span> </span><span>r</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="string"><span class="delete"><span class="delete">"[y]"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wqo_letter_less</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>w</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wqo_on (λa b. (a, b) ∈ r<span class="hidden">⇧</span><sup>=</sup>) UNIV"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wqo_on (λa b. (a, b) ∈ (letter_less r)<span class="hidden">⇧</span><sup>=</sup>) UNIV"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wqo_on_hom</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>id</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"prod_le (=) (λa b. (a, b) ∈ r<span class="hidden">⇧</span><sup>=</sup>)"</span></span></span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>image_id</span><span> </span><span>id_apply</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wqo_on (prod_le ((=) :: accent ⇒ accent ⇒ bool) (λa b. (a, b) ∈ r<span class="hidden">⇧</span><sup>=</sup>)) UNIV"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>dickson</span><span class="delimiter">[</span><span>OF</span><span> </span><span>finite_eq_wqo_on</span><span class="delimiter">[</span><span>OF</span><span> </span><span>finite_accent</span><span class="delimiter">]</span><span> </span><span>w</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>UNIV_Times_UNIV</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>t</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>transp_on_def</span><span> </span><span>trans_def</span><span> </span><span>prod_le_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_greek_less</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf (greek_less r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>q</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r ⊆ q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"well_order q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>total_well_order_extension</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹wf r›</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>q'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q' = q - Id"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹well_order q›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reflcl q' = q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>well_order_on_def</span><span> </span><span>linear_order_on_def</span><span> </span><span>partial_order_on_def</span><span> </span><span>preorder_on_def</span><span>
</span><span>      </span><span>refl_on_def</span><span> </span><span>q'_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹well_order q›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans q'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"irrefl q'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>well_order_on_def</span><span> </span><span>linear_order_on_def</span><span> </span><span>partial_order_on_def</span><span> </span><span>preorder_on_def</span><span> </span><span>antisym_def</span><span>
</span><span>    </span><span>trans_def</span><span> </span><span>irrefl_def</span><span> </span><span>q'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹r ⊆ q›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹wf r›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r ⊆ q'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>q'_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wqo_on (λa b. (a,b) ∈ (greek_less q')<span class="hidden">⇧</span><sup>=</sup>) UNIV"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>wqo_on_hom</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(λa b. (a, b) ∈ (greek_less q')<span class="hidden">⇧</span><sup>=</sup>)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"id"</span></span></span><span> </span><span>UNIV</span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">"list_emb (λa b. (a, b) ∈ (letter_less q')<span class="hidden">⇧</span><sup>=</sup>)"</span></span></span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>surj_id</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"transp_on (λa b. (a, b) ∈ (greek_less q')<span class="hidden">⇧</span><sup>=</sup>) UNIV"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>trans_greek_less</span><span class="delimiter">[</span><span>of</span><span> </span><span>q'</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>trans_def</span><span> </span><span>transp_on_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x∈UNIV. ∀y∈UNIV. list_emb (λa b. (a, b) ∈ (letter_less q')<span class="hidden">⇧</span><sup>=</sup>) x y ⟶
          (id x, id y) ∈ (greek_less q')<span class="hidden">⇧</span><sup>=</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>greek_embed</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trans q'›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wqo_on (list_emb (λa b. (a, b) ∈ (letter_less q')<span class="hidden">⇧</span><sup>=</sup>)) UNIV"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>higman</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wqo_letter_less</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trans q'›</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹well_order q›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹reflcl q' = q›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>well_order_implies_wqo</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>wqo_on_imp_wfp_on</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span>strict_order_strict</span><span class="delimiter">[</span><span>OF</span><span> </span><span>strict_order_greek_less</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">‹irrefl q'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trans q'›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wfp_on (λa b. (a, b) ∈ greek_less q') UNIV"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mono_greek_less</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹r ⊆ q'›</span></span></span><span> </span><span>wf_subset</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_iff_wfp_on</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>mono_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Basic Comparisons›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pairwise_imp_mult</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N ≠ {#}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ set_mset M. ∃y ∈ set_mset N. (x, y) ∈ r"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(M, N) ∈ mult r"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>one_step_implies_mult</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"{#}"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>singleton_greek_less</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>as</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set as ⊆ under r b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(as, [(a,b)]) ∈ greek_less r"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ set_mset (ms_of_greek as)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>as</span><span> </span><span>ms_of_greek_elem</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>as</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(e, ((a,b),[])) ∈ letter_less r &lt;*lex*&gt; greek_less r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>e</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>adj_msog_def</span><span> </span><span>under_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ms_of_greek [(a,b)] = {# ((a,b),[]) #}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ms_of_greek_def</span><span> </span><span>adj_msog_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>accent.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>greek_less_unfold</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>pairwise_imp_mult</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>peak_greek_less</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>as</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set as ⊆ under r a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b' ∈ {[(Grave,b)],[]}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set cs ⊆ under r a ∪ under r b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a' ∈ {[(Acute,a)],[]}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set bs ⊆ under r b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(as @ b' @ cs @ a' @ bs, [(Acute,a),(Grave,b)]) ∈ greek_less r"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?A</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Acute,a)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="var">?B</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Grave,b)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ms_of_greek (as @ b' @ cs @ a' @ bs), ms_of_greek [?A,?B]) ∈ mult (letter_less r &lt;*lex*&gt; greek_less r)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>pairwise_imp_mult</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* we distinguish 5 cases depending on where in xs an element e originates *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ set_mset (ms_of_greek as)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>as</span><span> </span><span>ms_of_greek_elem</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>as</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(adj_msog [] (b' @ cs @ a' @ bs) e, (?A,[?B])) ∈ letter_less r &lt;*lex*&gt; greek_less r"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>e</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>adj_msog_def</span><span> </span><span>under_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ set_mset (ms_of_greek b')"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b'</span><span> </span><span>singleton_greek_less</span><span class="delimiter">[</span><span>OF</span><span> </span><span>as</span><span class="delimiter">]</span><span> </span><span>ms_of_greek_elem</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>b'</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(adj_msog as (cs @ a' @ bs) e, (?B,[?A])) ∈ letter_less r &lt;*lex*&gt; greek_less r"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>e</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>adj_msog_def</span><span> </span><span>ms_of_greek_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ set_mset (ms_of_greek cs)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>cs</span><span> </span><span>ms_of_greek_elem</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>cs</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(adj_msog (as @ b') (a' @ bs) e, (?A,[?B])) ∈ letter_less r &lt;*lex*&gt; greek_less r ∨
            (adj_msog (as @ b') (a' @ bs) e, (?B,[?A])) ∈ letter_less r &lt;*lex*&gt; greek_less r"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>e</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>adj_msog_def</span><span> </span><span>under_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ set_mset (ms_of_greek a')"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>a'</span><span> </span><span>singleton_greek_less</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bs</span><span class="delimiter">]</span><span> </span><span>ms_of_greek_elem</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>a'</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(adj_msog (as @ b' @ cs) bs e, (?A,[?B])) ∈ letter_less r &lt;*lex*&gt; greek_less r"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>e</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>adj_msog_def</span><span> </span><span>ms_of_greek_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ set_mset (ms_of_greek bs)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>bs</span><span> </span><span>ms_of_greek_elem</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>bs</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(adj_msog (as @ b' @ cs @ a') [] e, (?B,[?A])) ∈ letter_less r &lt;*lex*&gt; greek_less r"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>e</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>adj_msog_def</span><span> </span><span>under_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ms_of_greek [?A,?B] = {# (?B,[?A]), (?A,[?B]) #}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>adj_msog_def</span><span> </span><span>ms_of_greek_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x∈set_mset (ms_of_greek (as @ b' @ cs @ a' @ bs)).
      ∃y∈set_mset (ms_of_greek [?A,?B]). (x, y) ∈ letter_less r &lt;*lex*&gt; greek_less r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>msog_append</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ms_of_greek_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>greek_less_unfold</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rcliff_greek_less1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* unused assumption kept for symmetry with lcliff_greek_less1 *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>as</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set as ⊆ under r a ∩ under r b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b' ∈ {[(Grave,b)],[]}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set cs ⊆ under r b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a' = [(Macron,a)]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set bs ⊆ under r b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(as @ b' @ cs @ a' @ bs, [(Macron,a),(Grave,b)]) ∈ greek_less r"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?A</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Macron,a)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="var">?B</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Grave,b)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ms_of_greek [?A,?B] = {#(?B,[?A]), (?A,[])#}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ms_of_greek [?A] = {#(?A,[])#}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ms_of_greek_def</span><span> </span><span>adj_msog_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>**</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ms_of_greek [(Macron, a), (Grave, b)] - {#((Macron, a), [])#} ≠ {#}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* we distinguish 5 cases depending on where in xs an element e originates *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ set_mset (ms_of_greek as)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>as</span><span> </span><span>ms_of_greek_elem</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>as</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(adj_msog [] (b' @ cs @ a' @ bs) e, (?B,[?A])) ∈ letter_less r &lt;*lex*&gt; greek_less r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>e</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>adj_msog_def</span><span> </span><span>under_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ set_mset (ms_of_greek b')"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b'</span><span> </span><span>singleton_greek_less</span><span> </span><span>as</span><span> </span><span>ms_of_greek_elem</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>b'</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(adj_msog as (cs @ a' @ bs) e, (?B,[?A])) ∈ letter_less r &lt;*lex*&gt; greek_less r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>e</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>adj_msog_def</span><span> </span><span>ms_of_greek_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ set_mset (ms_of_greek cs)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>cs</span><span> </span><span>ms_of_greek_elem</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>cs</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(adj_msog (as @ b') (a' @ bs) e, (?B,[?A])) ∈ letter_less r &lt;*lex*&gt; greek_less r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>e</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>adj_msog_def</span><span> </span><span>under_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ set_mset (ms_of_greek bs)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>bs</span><span> </span><span>ms_of_greek_elem</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>bs</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(adj_msog (as @ b' @ cs @ a') [] e, (?B,[?A])) ∈ letter_less r &lt;*lex*&gt; greek_less r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>e</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>adj_msog_def</span><span> </span><span>under_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ms_of_greek [?A,?B] = {# (?B,[?A]), (?A,[]) #}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>adj_msog_def</span><span> </span><span>ms_of_greek_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x∈set_mset (ms_of_greek (as @ b' @ cs @ a' @ bs) - {#(?A,[])#}).
    ∃y∈set_mset (ms_of_greek [?A,?B] - {#(?A,[])#}). (x, y) ∈ letter_less r &lt;*lex*&gt; greek_less r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>msog_append</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>a'</span><span> </span><span>msog_append</span><span> </span><span>ac_simps</span><span> </span><span>*</span><span> </span><span>adj_msog_single</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>one_step_implies_mult</span><span class="delimiter">[</span><span>OF</span><span> </span><span>**</span><span> </span><span>this</span><span class="delimiter">,</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"{#(?A,[])#}"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ms_of_greek (as @ b' @ cs @ a' @ bs), ms_of_greek [?A,?B]) ∈ mult (letter_less r &lt;*lex*&gt; greek_less r)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>a'</span><span> </span><span>msog_append</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>a'</span><span> </span><span>ac_simps</span><span> </span><span>*</span><span> </span><span>adj_msog_single</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>greek_less_unfold</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rcliff_greek_less2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* unused assumption kept for symmetry with lcliff_greek_less2 *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>as</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set as ⊆ under r a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b' ∈ {[(Grave,b)],[]}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set cs ⊆ under r a ∪ under r b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(as @ b' @ cs, [(Macron,a),(Grave,b)]) ∈ greek_less r"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?A</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Macron,a)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="var">?B</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Grave,b)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ms_of_greek (as @ b' @ cs), ms_of_greek [?A,?B]) ∈ mult (letter_less r &lt;*lex*&gt; greek_less r)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>pairwise_imp_mult</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* we distinguish 3 cases depending on where in xs an element e originates *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ set_mset (ms_of_greek as)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>as</span><span> </span><span>ms_of_greek_elem</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>as</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(adj_msog [] (b' @ cs) e, (?A,[])) ∈ letter_less r &lt;*lex*&gt; greek_less r"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>e</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>adj_msog_def</span><span> </span><span>under_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ set_mset (ms_of_greek b')"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b'</span><span> </span><span>singleton_greek_less</span><span class="delimiter">[</span><span>OF</span><span> </span><span>as</span><span class="delimiter">]</span><span> </span><span>ms_of_greek_elem</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>b'</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(adj_msog as (cs) e, (?B,[?A])) ∈ letter_less r &lt;*lex*&gt; greek_less r"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>e</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>adj_msog_def</span><span> </span><span>ms_of_greek_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>e</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ set_mset (ms_of_greek cs)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>cs</span><span> </span><span>ms_of_greek_elem</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>cs</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(adj_msog (as @ b') [] e, (?A,[])) ∈ letter_less r &lt;*lex*&gt; greek_less r ∨
            (adj_msog (as @ b') [] e, (?B,[?A])) ∈ letter_less r &lt;*lex*&gt; greek_less r"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>e</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>adj_msog_def</span><span> </span><span>under_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ms_of_greek [?A,?B] = {# (?B,[?A]), (?A,[]) #}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>adj_msog_def</span><span> </span><span>ms_of_greek_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x∈set_mset (ms_of_greek (as @ b' @ cs)).
      ∃y∈set_mset (ms_of_greek [?A,?B]). (x, y) ∈ letter_less r &lt;*lex*&gt; greek_less r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>msog_append</span><span> </span><span>adj_msog_single</span><span> </span><span>ac_simps</span><span> </span><span>*</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ms_of_greek_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>greek_less_unfold</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snd_inv_greek</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set (inv_greek as) = snd ` set as"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inv_greek_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lcliff_greek_less1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>as</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set as ⊆ under r a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b' = [(Macron,b)]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set cs ⊆ under r a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a' ∈ {[(Acute,a)],[]}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set bs ⊆ under r a ∩ under r b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(as @ b' @ cs @ a' @ bs, [(Acute,a),(Macron,b)]) ∈ greek_less r"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_greek [(Acute,a),(Macron,b)] = [(Macron,b),(Grave,a)]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_greek_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(inv_greek (inv_greek (as @ b' @ cs @ a' @ bs)),
   inv_greek (inv_greek ([(Acute,a),(Macron,b)]))) ∈ greek_less r"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>inv_greek_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trans r›</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>inv_greek_append</span><span> </span><span>append_assoc</span><span> </span><span>*</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rcliff_greek_less1</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inv_greek_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lcliff_greek_less2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set cs ⊆ under r a ∪ under r b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a' ∈ {[(Acute,a)],[]}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set bs ⊆ under r b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(cs @ a' @ bs, [(Acute,a),(Macron,b)]) ∈ greek_less r"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_greek [(Acute,a),(Macron,b)] = [(Macron,b),(Grave,a)]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_greek_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(inv_greek (inv_greek (cs @ a' @ bs)),
    inv_greek (inv_greek ([(Acute,a),(Macron,b)]))) ∈ greek_less r"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>inv_greek_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trans r›</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>inv_greek_append</span><span> </span><span>append_assoc</span><span> </span><span>*</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rcliff_greek_less2</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inv_greek_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Labeled abstract rewriting›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>L</span><span> </span><span>R</span><span> </span><span>E</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b ⇒ 'a rel"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lstep</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b letter ⇒ 'a rel"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lstep x = (case x of (a, i) ⇒ (case a of Acute ⇒ (L i)¯ | Grave ⇒ R i | Macron ⇒ E i))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>lconv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b greek ⇒ 'a rel"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lconv [] = Id"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"lconv (x # xs) = lstep x O lconv xs"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lconv_append</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lconv (xs @ ys) = lconv xs O lconv ys"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conversion_join_or_peak_or_cliff</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span class="delimiter">(</span><span>join</span><span class="delimiter">)</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>cs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set as ⊆ {Grave}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set bs ⊆ {Macron}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set cs ⊆ {Acute}"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ds = as @ bs @ cs"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>peak</span><span class="delimiter">)</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ds = as @ ([Acute] @ [Grave]) @ bs"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>lcliff</span><span class="delimiter">)</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ds = as @ ([Acute] @ [Macron]) @ bs"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>rcliff</span><span class="delimiter">)</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ds = as @ ([Macron] @ [Grave]) @ bs"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ds</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>thesis</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>d</span><span> </span><span>ds</span><span> </span><span>thesis</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>IH</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ds = as @ ([Acute] @ [Grave]) @ bs"</span></span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"d # as"</span></span></span><span> </span><span>bs</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ds = as @ ([Acute] @ [Macron]) @ bs"</span></span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"d # as"</span></span></span><span> </span><span>bs</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ds = as @ ([Macron] @ [Grave]) @ bs"</span></span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"d # as"</span></span></span><span> </span><span>bs</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>cs</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set as ⊆ {Grave}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set bs ⊆ {Macron}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set cs ⊆ {Acute}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ds = as @ bs @ cs"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>d</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Grave</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span> </span><span>IH</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"d # as"</span></span></span><span> </span><span>bs</span><span> </span><span>cs</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Macron</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>as</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span> </span><span>Macron</span><span> </span><span>IH</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>as</span><span> </span><span class="string"><span class="delete"><span class="delete">"d # bs"</span></span></span><span> </span><span>cs</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>as</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span> </span><span>Macron</span><span> </span><span>IH</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as @ bs @ cs"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Acute</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>as</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>as</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bs</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span> </span><span>as</span><span> </span><span>Acute</span><span> </span><span>IH</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d # cs"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>b</span><span> </span><span>bs</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span> </span><span>as</span><span> </span><span>Acute</span><span> </span><span>IH</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bs @ cs"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>as</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span> </span><span>Acute</span><span> </span><span>IH</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as @ bs @ cs"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_eq_append_split</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map f xs = ys1 @ ys2"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>xs1</span><span> </span><span>xs2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ys1 = map f xs1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ys2 = map f xs2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs = xs1 @ xs2"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>ys1</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>xs</span><span> </span><span>thesis</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>y</span><span> </span><span>ys</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs'</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>IH</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>xs1</span><span> </span><span>xs2</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ys = map f xs1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ys2 = map f xs2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs' = xs1 @ xs2"</span></span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span>IH</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"x # xs1"</span></span></span><span> </span><span>xs2</span><span class="delimiter">]</span><span> </span><span>IH</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map f xs' = ys @ ys2"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span>IH</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>Cons</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>map_eq_append_splits</span><span> </span><span class="delimiter">=</span><span> </span><span>map_eq_append_split</span><span> </span><span>map_eq_append_split</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sym</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"conversion' M ≡ ((⋃i ∈ M. R i) ∪ (⋃i ∈ M. E i) ∪ (⋃i ∈ M. L i)¯)<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valley' M ≡  (⋃i ∈ M. R i)<span class="hidden">⇧</span><sup>*</sup> O (⋃i ∈ M. E i)<span class="hidden">⇧</span><sup>*</sup> O ((⋃i ∈ M. L i)¯)<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conversion_to_lconv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u, v) ∈ conversion' M"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>xs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set xs ⊆ M"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u, v) ∈ lconv xs"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>thesis</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>converse_rtrancl_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>base</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>base</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step</span><span> </span><span>u'</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>step</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd p ∈ M"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u', x) ∈ lstep p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>accent.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set xs ⊆ M"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, v) ∈ lconv xs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>step</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"p # xs"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lpeak</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b rel ⇒ 'b ⇒ 'b ⇒ 'b greek ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lpeak r a b xs ⟷ (∃as b' cs a' bs. snd ` set as ⊆ under r a ∧ b' ∈ {[(Grave,b)],[]} ∧
    snd ` set cs ⊆ under r a ∪ under r b ∧ a' ∈ {[(Acute,a)],[]} ∧
    snd ` set bs ⊆ under r b ∧ xs = as @ b' @ cs @ a' @ bs)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lcliff</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b rel ⇒ 'b ⇒ 'b ⇒ 'b greek ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lcliff r a b xs ⟷ (∃as b' cs a' bs. snd ` set as ⊆ under r a ∧ b' = [(Macron,b)] ∧
    snd ` set cs ⊆ under r a ∧ a' ∈ {[(Acute,a)],[]} ∧
    snd ` set bs ⊆ under r a ∩ under r b ∧ xs = as @ b' @ cs @ a' @ bs) ∨
    (∃cs a' bs. snd ` set cs ⊆ under r a ∪ under r b ∧ a' ∈ {[(Acute,a)],[]} ∧
    snd ` set bs ⊆ under r b ∧ xs = cs @ a' @ bs)"</span></span></span><span>
</span><span>    
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rcliff</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b rel ⇒ 'b ⇒ 'b ⇒ 'b greek ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rcliff r a b xs ⟷ (∃as b' cs a' bs. snd ` set as ⊆ under r a ∩ under r b ∧ b' ∈ {[(Grave,b)],[]} ∧
    snd ` set cs ⊆ under r b ∧ a' = [(Macron,a)] ∧
    snd ` set bs ⊆ under r b ∧ xs = as @ b' @ cs @ a' @ bs) ∨
    (∃as b' cs. snd ` set as ⊆ under r a ∧ b' ∈ {[(Grave,b)],[]} ∧
    snd ` set cs ⊆ under r a ∪ under r b ∧ xs = as @ b' @ cs)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dd_commute_modulo_conv</span><span class="delimiter">[</span><span>case_names</span><span> </span><span>wf</span><span> </span><span>trans</span><span> </span><span>peak</span><span> </span><span>lcliff</span><span> </span><span>rcliff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pk</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a b s t u. (s, t) ∈ L a ⟹ (s, u) ∈ R b ⟹ ∃xs. lpeak r a b xs ∧ (t, u) ∈ lconv xs"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a b s t u. (s, t) ∈ L a ⟹ (s, u) ∈ E b ⟹ ∃xs. lcliff r a b xs ∧ (t, u) ∈ lconv xs"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a b s t u. (s, t) ∈ (E a)¯ ⟹ (s, u) ∈ R b ⟹ ∃xs. rcliff r a b xs ∧ (t, u) ∈ lconv xs"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"conversion' UNIV ⊆ valley' UNIV"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>subrelI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>u</span><span> </span><span>v</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u,v) ∈ conversion' UNIV"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u, v) ∈ lconv xs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>conversion_to_lconv</span><span class="delimiter">[</span><span>of</span><span> </span><span>u</span><span> </span><span>v</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u, v) ∈ valley' UNIV"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wf_induct</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"greek_less r"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_greek_less</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹wf r›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trans r›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conversion_join_or_peak_or_cliff</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"map fst xs"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>cs</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set as ⊆ {Grave}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set bs ⊆ {Macron}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set cs ⊆ {Acute}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map fst xs = as @ bs @ cs"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u, v) ∈ valley' UNIV"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>map_eq_append_splits</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>as'</span><span> </span><span>bs'</span><span> </span><span>cs'</span><span> </span><span>bcs'</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set as ⊆ {Grave}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = map fst as'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>bs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set bs ⊆ {Macron}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bs = map fst bs'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>cs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set cs ⊆ {Acute}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cs = map fst cs'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>xs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"xs = as' @ bcs'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bcs' = bs' @ cs'"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>as</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>as</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>as'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x y. (x,y) ∈ lconv as' ⟹ (x,y) ∈ (⋃a. R a)<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>as'</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x'</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x y z i. (x,y) ∈ R i ⟹ (y,z) ∈ (⋃a. R a)<span class="hidden">⇧</span><sup>*</sup> ⟹ (x,z) ∈ (⋃a. R a)<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rtrancl_trans</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>bs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>bs</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bs'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x y. (x,y) ∈ lconv bs' ⟹ (x,y) ∈ (⋃a. E a)<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>bs'</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x'</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x y z i. (x,y) ∈ E i ⟹ (y,z) ∈ (⋃a. E a)<span class="hidden">⇧</span><sup>*</sup> ⟹ (x,z) ∈ (⋃a. E a)<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rtrancl_trans</span><span class="delimiter">)</span><span> </span><span>auto</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>cs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>cs</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cs'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x y. (x,y) ∈ lconv cs' ⟹ (x,y) ∈ ((⋃a. L a)¯)<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>cs'</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x'</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x y z i. (x,y) ∈ (L i)¯ ⟹ (y,z) ∈ ((⋃a. L a)¯)<span class="hidden">⇧</span><sup>*</sup> ⟹ (x,z) ∈ ((⋃a. L a)¯)<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rtrancl_trans</span><span class="delimiter">)</span><span> </span><span>auto</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>2</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>as'</span><span> </span><span>bs'</span><span> </span><span>cs'</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u, v) ∈ valley' UNIV"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>xs</span><span> </span><span>lconv_append</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>relcomp.simps</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"map fst xs = as @ ([Acute] @ [Grave]) @ bs"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>p</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>q</span><span> </span><span>t'</span><span> </span><span>s'</span><span> </span><span>u'</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>xs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"xs = p @ [(Acute,a),(Grave,b)] @ q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(u,t') ∈ lconv p"</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s',t') ∈ L a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s',u') ∈ R b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(u',v) ∈ lconv q"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>js</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>lp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lpeak r a b js"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>js</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(t',u') ∈ lconv js"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pk</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>lp</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(js, [(Acute,a),(Grave,b)]) ∈ greek_less r"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lpeak_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>peak_greek_less</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>r</span><span> </span><span>a</span><span> </span><span>_</span><span> </span><span>b</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(p @ js @ q, xs) ∈ greek_less r"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>xs</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>greek_less_app_mono1</span><span> </span><span>greek_less_app_mono2</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trans r›</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u, v) ∈ lconv (p @ js @ q)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span> </span><span>q</span><span> </span><span>js</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u, v) ∈ valley' UNIV"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>*</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u, v) ∈ valley' UNIV"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>map_eq_append_splits</span><span> </span><span>relcompEpair</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>append.simps</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"map fst xs = as @ ([Acute] @ [Macron]) @ bs"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>p</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>q</span><span> </span><span>t'</span><span> </span><span>s'</span><span> </span><span>u'</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>xs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"xs = p @ [(Acute,a),(Macron,b)] @ q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(u,t') ∈ lconv p"</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s',t') ∈ L a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s',u') ∈ E b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(u',v) ∈ lconv q"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>js</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>lp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lcliff r a b js"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>js</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(t',u') ∈ lconv js"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>lp</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(js, [(Acute,a),(Macron,b)]) ∈ greek_less r"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lcliff_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lcliff_greek_less1</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trans r›</span></span></span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>a</span><span> </span><span>_</span><span> </span><span>b</span><span class="delimiter">]</span><span> </span><span>lcliff_greek_less2</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trans r›</span></span></span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(p @ js @ q, xs) ∈ greek_less r"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>xs</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>greek_less_app_mono1</span><span> </span><span>greek_less_app_mono2</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trans r›</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u, v) ∈ lconv (p @ js @ q)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span> </span><span>q</span><span> </span><span>js</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u, v) ∈ valley' UNIV"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>*</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u, v) ∈ valley' UNIV"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>map_eq_append_splits</span><span> </span><span>relcompEpair</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>append.simps</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"map fst xs = as @ ([Macron] @ [Grave]) @ bs"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>p</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>q</span><span> </span><span>t'</span><span> </span><span>s'</span><span> </span><span>u'</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>xs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"xs = p @ [(Macron,a),(Grave,b)] @ q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(u,t') ∈ lconv p"</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s',t') ∈ (E a)¯"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s',u') ∈ R b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(u',v) ∈ lconv q"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>js</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>lp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rcliff r a b js"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>js</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(t',u') ∈ lconv js"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>lp</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(js, [(Macron,a),(Grave,b)]) ∈ greek_less r"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rcliff_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rcliff_greek_less1</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trans r›</span></span></span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">]</span><span> </span><span>rcliff_greek_less2</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trans r›</span></span></span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>a</span><span> </span><span>_</span><span> </span><span>b</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(p @ js @ q, xs) ∈ greek_less r"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>xs</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>greek_less_app_mono1</span><span> </span><span>greek_less_app_mono2</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trans r›</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u, v) ∈ lconv (p @ js @ q)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span> </span><span>q</span><span> </span><span>js</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u, v) ∈ valley' UNIV"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>*</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(u, v) ∈ valley' UNIV"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>map_eq_append_splits</span><span> </span><span>relcompEpair</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>append.simps</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Results›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Church-Rosser modulo›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Decreasing diagrams for Church-Rosser modulo, commutation version.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dd_commute_modulo</span><span class="delimiter">[</span><span>case_names</span><span> </span><span>wf</span><span> </span><span>trans</span><span> </span><span>peak</span><span> </span><span>lcliff</span><span> </span><span>rcliff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pk</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a b s t u. (s, t) ∈ L a ⟹ (s, u) ∈ R b ⟹
    (t, u) ∈ conversion' (under r a) O (R b)<span class="hidden">⇧</span><sup>=</sup> O conversion' (under r a ∪ under r b) O
      ((L a)¯)<span class="hidden">⇧</span><sup>=</sup> O conversion' (under r b)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a b s t u. (s, t) ∈ L a ⟹ (s, u) ∈ E b ⟹
    (t, u) ∈ conversion' (under r a) O E b O conversion' (under r a) O
      ((L a)¯)<span class="hidden">⇧</span><sup>=</sup> O conversion' (under r a ∩ under r b) ∨
    (t, u) ∈ conversion' (under r a ∪ under r b) O ((L a )¯)<span class="hidden">⇧</span><sup>=</sup> O conversion' (under r b)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a b s t u. (s, t) ∈ (E a)¯ ⟹ (s, u) ∈ R b ⟹
    (t, u) ∈ conversion' (under r a ∩ under r b) O (R b)<span class="hidden">⇧</span><sup>=</sup> O conversion' (under r b) O
      E a O conversion' (under r b) ∨
    (t, u) ∈ conversion' (under r a) O (R b)<span class="hidden">⇧</span><sup>=</sup> O conversion' (under r a ∪ under r b)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"conversion' UNIV ⊆ valley' UNIV"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>dd_commute_modulo_conv</span><span class="delimiter">[</span><span>of</span><span> </span><span>r</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>peak</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>w</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(t, w) ∈ conversion' (under r a)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>conversion_to_lconv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>as</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set as ⊆ under r a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(t, w) ∈ lconv as"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(w, x) ∈ (R b)<span class="hidden">⇧</span><sup>=</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b' ∈ {[(Grave,b)],[]}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(w, x) ∈ lconv b'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ conversion' (under r a ∪ under r b)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>conversion_to_lconv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set cs ⊆ under r a ∪ under r b"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ lconv cs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(y, z) ∈ ((L a)¯)<span class="hidden">⇧</span><sup>=</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a' ∈ {[(Acute,a)],[]}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(y, z) ∈ lconv a'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(z, u) ∈ conversion' (under r b)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>conversion_to_lconv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>bs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set bs ⊆ under r b"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(z, u) ∈ lconv bs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃xs. lpeak r a b xs ∧ (t, u) ∈ lconv xs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"as @ b' @ cs @ a' @ bs"</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>lconv_append</span><span> </span><span>lpeak_def</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pk</span><span class="delimiter">[</span><span>OF</span><span> </span><span>peak</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lcliff</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>w</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(t, w) ∈ conversion' (under r a)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>conversion_to_lconv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>as</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set as ⊆ under r a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(t, w) ∈ lconv as"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(w, x) ∈ E b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b' = [(Macron,b)]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(w, x) ∈ lconv b'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ conversion' (under r a)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>conversion_to_lconv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set cs ⊆ under r a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ lconv cs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(y, z) ∈ ((L a)¯)<span class="hidden">⇧</span><sup>=</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a' ∈ {[(Acute,a)],[]}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(y, z) ∈ lconv a'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(z, u) ∈ conversion' (under r a ∩ under r b)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>conversion_to_lconv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>bs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set bs ⊆ under r a ∩ under r b"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(z, u) ∈ lconv bs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃xs. lcliff r a b xs ∧ (t, u) ∈ lconv xs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"as @ b' @ cs @ a' @ bs"</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>lconv_append</span><span> </span><span>lcliff_def</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>w</span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(t, w) ∈ conversion' (under r a ∪ under r b)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>conversion_to_lconv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set cs ⊆ under r a ∪ under r b"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(t, w) ∈ lconv cs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(w, x) ∈ ((L a)¯)<span class="hidden">⇧</span><sup>=</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a' ∈ {[(Acute,a)],[]}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(w, x) ∈ lconv a'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, u) ∈ conversion' (under r b)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>conversion_to_lconv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>bs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set bs ⊆ under r b"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, u) ∈ lconv bs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃xs. lcliff r a b xs ∧ (t, u) ∈ lconv xs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"cs @ a' @ bs"</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>lconv_append</span><span> </span><span>lcliff_def</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>lcliff</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>rcliff</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>w</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(t, w) ∈ conversion' (under r a ∩ under r b)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>conversion_to_lconv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>as</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set as ⊆ under r a ∩ under r b"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(t, w) ∈ lconv as"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(w, x) ∈ (R b)<span class="hidden">⇧</span><sup>=</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b' ∈ {[(Grave,b)],[]}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(w, x) ∈ lconv b'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ conversion' (under r b)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>conversion_to_lconv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set cs ⊆ under r b"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ lconv cs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(y, z) ∈ E a"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a' = [(Macron,a)]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(y, z) ∈ lconv a'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(z, u) ∈ conversion' (under r b)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>conversion_to_lconv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>bs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set bs ⊆ under r b"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(z, u) ∈ lconv bs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃xs. rcliff r a b xs ∧ (t, u) ∈ lconv xs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"as @ b' @ cs @ a' @ bs"</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>lconv_append</span><span> </span><span>rcliff_def</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>w</span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(t, w) ∈ conversion' (under r a)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>conversion_to_lconv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>as</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set as ⊆ under r a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(t, w) ∈ lconv as"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(w, x) ∈ (R b)<span class="hidden">⇧</span><sup>=</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b' ∈ {[(Grave,b)],[]}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(w, x) ∈ lconv b'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, u) ∈ conversion' (under r a ∪ under r b)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>conversion_to_lconv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set cs ⊆ under r a ∪ under r b"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, u) ∈ lconv cs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃xs. rcliff r a b xs ∧ (t, u) ∈ lconv xs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"as @ b' @ cs"</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>lconv_append</span><span> </span><span>rcliff_def</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>rcliff</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* context *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Decreasing diagrams for Church-Rosser modulo.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dd_cr_modulo</span><span class="delimiter">[</span><span>case_names</span><span> </span><span>wf</span><span> </span><span>trans</span><span> </span><span>symE</span><span> </span><span>peak</span><span> </span><span>cliff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>E</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. sym (E i)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pk</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a b s t u. (s, t) ∈ L a ⟹ (s, u) ∈ L b ⟹
    (t, u) ∈ conversion' L L E (under r a) O (L b)<span class="hidden">⇧</span><sup>=</sup> O conversion' L L E (under r a ∪ under r b) O
      ((L a)¯)<span class="hidden">⇧</span><sup>=</sup> O conversion' L L E (under r b)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a b s t u. (s, t) ∈ L a ⟹ (s, u) ∈ E b ⟹
    (t, u) ∈ conversion' L L E (under r a) O E b O conversion' L L E (under r a) O
      ((L a)¯)<span class="hidden">⇧</span><sup>=</sup> O conversion' L L E (under r a ∩ under r b) ∨
    (t, u) ∈ conversion' L L E (under r a ∪ under r b) O ((L a )¯)<span class="hidden">⇧</span><sup>=</sup> O conversion' L L E (under r b)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"conversion' L L E UNIV ⊆ valley' L L E UNIV"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>dd_commute_modulo</span><span class="delimiter">[</span><span>of</span><span> </span><span>r</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>E'</span><span> </span><span class="delimiter">=</span><span> </span><span>E</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>sym_conv_converse_eq</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>rcliff</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>u</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>rcliff</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>rcliff</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>E'</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>converse_iff</span><span class="delimiter">[</span><span>of</span><span> </span><span>t</span><span> </span><span>u</span><span class="delimiter">,</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>ac_simps</span><span> </span><span>E'</span><span> </span><span>converse_inward</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Commutation and confluence›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"conversion'' L R M ≡ ((⋃i ∈ M. R i) ∪ (⋃i ∈ M. L i)¯)<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valley'' L R M ≡ (⋃i ∈ M. R i)<span class="hidden">⇧</span><sup>*</sup> O ((⋃i ∈ M. L i)¯)<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Decreasing diagrams for commutation.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dd_commute</span><span class="delimiter">[</span><span>case_names</span><span> </span><span>wf</span><span> </span><span>trans</span><span> </span><span>peak</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pk</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a b s t u. (s, t) ∈ L a ⟹ (s, u) ∈ R b ⟹
    (t, u) ∈ conversion'' L R (under r a) O (R b)<span class="hidden">⇧</span><sup>=</sup> O conversion'' L R (under r a ∪ under r b) O
      ((L a)¯)<span class="hidden">⇧</span><sup>=</sup> O conversion'' L R (under r b)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"commute (⋃i. L i) (⋃i. R i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((⋃i. L i)¯)<span class="hidden">⇧</span><sup>*</sup> O (⋃i. R i)<span class="hidden">⇧</span><sup>*</sup> ⊆ conversion'' L R UNIV"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>regexp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ⊆ valley'' L R UNIV"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dd_commute_modulo</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>L</span><span> </span><span>R</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_. {}"</span></span></span><span class="delimiter">]</span><span> </span><span>pk</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>commute_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Decreasing diagrams for confluence.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>dd_cr</span><span class="delimiter">[</span><span>case_names</span><span> </span><span>wf</span><span> </span><span>trans</span><span> </span><span>peak</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>dd_commute</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>L</span><span> </span><span>L</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>CR_iff_self_commute</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Extended decreasing diagrams›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>r</span><span> </span><span>q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b rel"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"refl q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>compat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r O q ⊆ r"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>down</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('b ⇒ 'a rel) ⇒ ('b ⇒ 'a rel)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"down L ≡ λi. ⋃j ∈ under q i. L j"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Union_down</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋃i. down L i) = (⋃i. L i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹refl q›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>refl_on_def</span><span> </span><span>under_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Extended decreasing diagrams for commutation.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>edd_commute</span><span class="delimiter">[</span><span>case_names</span><span> </span><span>wf</span><span> </span><span>transr</span><span> </span><span>transq</span><span> </span><span>reflq</span><span> </span><span>compat</span><span> </span><span>peak</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>pk</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a b s t u. (s, t) ∈ L a ⟹ (s, u) ∈ R b ⟹
    (t, u) ∈ conversion'' L R (under r a) O (down R b)<span class="hidden">⇧</span><sup>=</sup> O conversion'' L R (under r a ∪ under r b) O
      ((down L a)¯)<span class="hidden">⇧</span><sup>=</sup> O conversion'' L R (under r b)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"commute (⋃i. L i) (⋃i. R i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Union_down</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>Union_down</span><span class="delimiter">[</span><span>of</span><span> </span><span>R</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>dd_commute</span><span class="delimiter">[</span><span>of</span><span> </span><span>r</span><span> </span><span class="string"><span class="delete"><span class="delete">"down L"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"down R"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>peak</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a'</span><span> </span><span>b'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a', a) ∈ q"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s, t) ∈ L a'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(b', b) ∈ q"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s, u) ∈ R b'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>under_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a' a. (a',a) ∈ q ⟹ under r a' ⊆ under r a"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>under_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>aux1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a' a L. (a',a) ∈ q ⟹ (⋃i ∈ under r a'. L i) ⊆ (⋃i ∈ under r a. L i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>aux2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a' a L. (a',a) ∈ q ⟹ down L a' ⊆ down L a"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trans q›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>under_def</span><span> </span><span>trans_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>aux3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a L. (⋃i ∈ under r a. L i) ⊆ (⋃i ∈ under r a. down L i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹refl q›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>under_def</span><span> </span><span>refl_on_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>aux1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>L</span><span class="delimiter">]</span><span> </span><span>aux1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>R</span><span class="delimiter">]</span><span> </span><span>aux2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>L</span><span class="delimiter">]</span><span>
</span><span>       </span><span>aux1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>b'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>L</span><span class="delimiter">]</span><span> </span><span>aux1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>b'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>R</span><span class="delimiter">]</span><span> </span><span>aux2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>b'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>R</span><span class="delimiter">]</span><span>
</span><span>       </span><span>aux3</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span class="delimiter">]</span><span> </span><span>aux3</span><span class="delimiter">[</span><span>of</span><span> </span><span>R</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>subsetD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>pk</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(s, t) ∈ L a'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(s, u) ∈ R b'›</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>UN_Un</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>intro</span><span> </span><span>relcomp_mono</span><span> </span><span>rtrancl_mono</span><span> </span><span>Un_mono</span><span> </span><span>iffD2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>converse_mono</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>fast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Extended decreasing diagrams for confluence.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>edd_cr</span><span class="delimiter">[</span><span>case_names</span><span> </span><span>wf</span><span> </span><span>transr</span><span> </span><span>transq</span><span> </span><span>reflq</span><span> </span><span>compat</span><span> </span><span>peak</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>edd_commute</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span> </span><span>L</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>CR_iff_self_commute</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* context *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Decreasing_Diagrams_II *)</span></span></span></span></span><span>
</span></pre>
</div>
</div>