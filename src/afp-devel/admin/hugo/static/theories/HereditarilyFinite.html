<div id="HF">
<div class="head"><h1>Theory HF</h1>
<span class="command">theory</span> <span class="name">HF</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL-Library/Nat_Bijection.html"><span class="name">Nat_Bijection</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The Hereditarily Finite Sets›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>HF</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Nat_Bijection"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">abbrevs</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&lt;:"</span></span></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"<span class="hidden">❙</span><span class="bold">∈</span>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"~&lt;:"</span></span></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"<span class="hidden">❙</span><span class="bold">∉</span>"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹From "Finite sets and Gödel's Incompleteness Theorems" by S. Swierczkowski.
      Thanks for Brian Huffman for this development, up to the cases and induct rules.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Basic Definitions and Lemmas›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">typedef</span></span><span> </span><span>hf</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"UNIV :: nat set"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hfset</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ hf set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hfset a = Abs_hf ` set_decode (Rep_hf a)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>HF</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf set ⇒ hf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"HF A = Abs_hf (set_encode (Rep_hf ` A))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hinsert</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ hf ⇒ hf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hinsert a b = HF (insert a (hfset b))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hmem</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ hf ⇒ bool"</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"<span class="hidden">❙</span><span class="bold">∈</span>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hmem a b ⟷ a ∈ hfset b"</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>not_hmem</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ hf ⇒ bool"</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"<span class="hidden">❙</span><span class="bold">∉</span>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a <span class="hidden">❙</span><span class="bold">∉</span> b ≡ ¬ a <span class="hidden">❙</span><span class="bold">∈</span> b"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span class="delimiter">(</span><span>ASCII</span><span class="delimiter">)</span><span>
</span><span>  </span><span>hmem</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"&lt;:"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>hf</span><span> </span><span class="delimiter">::</span><span> </span><span>zero</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Zero_hf_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 = HF {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Abs_hf_0</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Abs_hf 0 = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>HF_def</span><span> </span><span>Zero_hf_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹HF Set enumerations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>inserthf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ hf ⇒ hf"</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"◃"</span></span></span><span> </span><span>60</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ◃ x ≡ hinsert x y"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span> </span><span class="delimiter">(</span><span>ASCII</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_HFinset"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"args ⇒ hf"</span></span></span><span>      </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"{|(_)|}"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_HFinset"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"args ⇒ hf"</span></span></span><span>      </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">translations</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃x, y⦄"</span></span></span><span> </span><span class="delimiter">⇌</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃y⦄ ◃ x"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃x⦄"</span></span></span><span>    </span><span class="delimiter">⇌</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ◃ x"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_hfset</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (hfset a)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hfset_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HF_hfset</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"HF (hfset a) = a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>HF_def</span><span> </span><span>hfset_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>image_image</span><span> </span><span>Abs_hf_inverse</span><span> </span><span>Rep_hf_inverse</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfset_HF</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite A ⟹ hfset (HF A) = A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>HF_def</span><span> </span><span>hfset_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>image_image</span><span> </span><span>Abs_hf_inverse</span><span> </span><span>Rep_hf_inverse</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inj_on_HF</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inj_on HF (Collect finite)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hfset_HF</span><span> </span><span>inj_onI</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hmem_hempty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a <span class="hidden">❙</span><span class="bold">∉</span> 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hmem_def</span><span> </span><span>Zero_hf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>hemptyE</span><span> </span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hmem_hempty</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>notE</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hmem_hinsert</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hmem a (c ◃ b) ⟷ a = b ∨ a <span class="hidden">❙</span><span class="bold">∈</span> c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hmem_def</span><span> </span><span>hinsert_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hf_ext</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a = b ⟷ (∀x. x <span class="hidden">❙</span><span class="bold">∈</span> a ⟷ x <span class="hidden">❙</span><span class="bold">∈</span> b)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hmem_def</span><span> </span><span>set_eq_iff</span><span> </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>HF_hfset</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_cases</span><span> </span><span class="delimiter">[</span><span>consumes</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>empty</span><span> </span><span>insert</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦finite F; F = {} ⟹ P; ⋀A x. ⟦F = insert x A; x ∉ A; finite A⟧ ⟹ P⟧ ⟹ P"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>F</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>finite_induct</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hf_cases</span><span> </span><span class="delimiter">[</span><span>cases</span><span> </span><span>type</span><span class="delimiter">:</span><span> </span><span>hf</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>0</span><span> </span><span>hinsert</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y = 0"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y = b ◃ a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a <span class="hidden">❙</span><span class="bold">∉</span> b"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (hfset y)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>finite_hfset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Zero_hf_def</span><span> </span><span>finite_cases</span><span> </span><span>hf_ext</span><span> </span><span>hfset_HF</span><span> </span><span>hinsert_def</span><span> </span><span>hmem_def</span><span> </span><span>that</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Rep_hf_hinsert</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"a <span class="hidden">❙</span><span class="bold">∉</span> b ⟹ Rep_hf (hinsert a b) = 2 ^ (Rep_hf a) + Rep_hf b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hinsert_def</span><span> </span><span>HF_def</span><span> </span><span>hfset_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>image_image</span><span> </span><span>Abs_hf_inverse</span><span> </span><span>Rep_hf_inverse</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>set_encode_insert</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hmem_def</span><span> </span><span>hfset_def</span><span> </span><span>image_def</span><span>
</span><span>    </span><span>Rep_hf_inject</span><span> </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>Abs_hf_inverse</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>less_two_power</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n &lt; 2 ^ n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Verifying the Axioms of HF›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹HF1›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hempty_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z=0 ⟷ (∀x. x <span class="hidden">❙</span><span class="bold">∉</span> z)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hf_ext</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹HF2›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hinsert_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z = x ◃ y ⟷ (∀u. u <span class="hidden">❙</span><span class="bold">∈</span> z ⟷ u <span class="hidden">❙</span><span class="bold">∈</span> x ∨ u = y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hf_ext</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹HF induction›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hf_induct</span><span> </span><span class="delimiter">[</span><span>induct</span><span> </span><span>type</span><span class="delimiter">:</span><span> </span><span>hf</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>0</span><span> </span><span>hinsert</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P 0"</span></span></span><span>
</span><span>                  </span><span class="string"><span class="delete"><span class="delete">"⋀x y. ⟦P x; P y; x <span class="hidden">❙</span><span class="bold">∉</span> y⟧ ⟹ P (y ◃ x)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P z"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>z</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wf_induct</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>r</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"measure Rep_hf"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>wf_measure</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>hf_cases</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>hinsert</span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Rep_hf_hinsert</span><span>
</span><span>                      </span><span>less_le_trans</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>less_two_power</span><span> </span><span>le_add1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹HF3›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hf_induct_ax</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦P 0; ∀x. P x ⟶ (∀y. P y ⟶ P (x ◃ y))⟧ ⟹ P x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>x</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hf_equalityI</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀x. x <span class="hidden">❙</span><span class="bold">∈</span> a ⟷ x <span class="hidden">❙</span><span class="bold">∈</span> b) ⟹ a = b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hf_ext</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hinsert_nonempty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ◃ a ≠ 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hf_ext</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hinsert_commute</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(z ◃ y) ◃ x = (z ◃ x) ◃ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hf_ext</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hmem_HF_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x <span class="hidden">❙</span><span class="bold">∈</span> HF A ⟷ x ∈ A ∧ finite A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite A"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hmem_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hmem_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>HF_def</span><span> </span><span>Rep_hf_inject</span><span> </span><span>Abs_hf_0</span><span> </span><span>finite_imageD</span><span> </span><span>hempty_iff</span><span> </span><span>inj_onI</span><span> </span><span>set_encode_inf</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ordered Pairs, from ZF/ZF.thy›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>singleton_eq_iff</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃a⦄ = ⦃b⦄ ⟷ a=b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hmem_hempty</span><span> </span><span>hmem_hinsert</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>doubleton_eq_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃a,b⦄ = ⦃c,d⦄ ⟷ (a=c ∧ b=d) ∨ (a=d ∧ b=c)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hmem_hempty</span><span> </span><span>hmem_hinsert</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hpair</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ hf ⇒ hf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hpair a b = ⦃⦃a⦄,⦃a,b⦄⦄"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hfst</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ hf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hfst p ≡ THE x. ∃y. p = hpair x y"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hsnd</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ hf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hsnd p ≡ THE y. ∃x. p = hpair x y"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hsplit</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[[hf, hf] ⇒ 'a, hf] ⇒ 'a::{}"</span></span></span><span>  </span><span class="comment">― ‹for pattern-matching›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hsplit c ≡ λp. c (hfst p) (hsnd p)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ordered Pairs, from ZF/ZF.thy›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">nonterminal</span></span><span> </span><span>hfs</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span> </span><span class="delimiter">(</span><span>ASCII</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_Tuple"</span></span></span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[hf, hfs] ⇒ hf"</span></span></span><span>              </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"&lt;(_,/ _)&gt;"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_hpattern"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[pttrn, patterns] ⇒ pttrn"</span></span></span><span>   </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"&lt;_,/ _&gt;"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">""</span></span></span><span>          </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ hfs"</span></span></span><span>                    </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_Enum"</span></span></span><span>     </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[hf, hfs] ⇒ hfs"</span></span></span><span>             </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_,/ _"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_Tuple"</span></span></span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[hf, hfs] ⇒ hf"</span></span></span><span>              </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨(_,/ _)⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_hpattern"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[pttrn, patterns] ⇒ pttrn"</span></span></span><span>   </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_,/ _⟩"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">translations</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;x, y, z&gt;"</span></span></span><span>    </span><span class="delimiter">⇌</span><span> </span><span class="string"><span class="delete"><span class="delete">"&lt;x, &lt;y, z&gt;&gt;"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;x, y&gt;"</span></span></span><span>       </span><span class="delimiter">⇌</span><span> </span><span class="string"><span class="delete"><span class="delete">"CONST hpair x y"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"&lt;x, y, z&gt;"</span></span></span><span>    </span><span class="delimiter">⇌</span><span> </span><span class="string"><span class="delete"><span class="delete">"&lt;x, &lt;y, z&gt;&gt;"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"λ&lt;x,y,zs&gt;. b"</span></span></span><span> </span><span class="delimiter">⇌</span><span> </span><span class="string"><span class="delete"><span class="delete">"CONST hsplit(λx &lt;y,zs&gt;. b)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"λ&lt;x,y&gt;. b"</span></span></span><span>    </span><span class="delimiter">⇌</span><span> </span><span class="string"><span class="delete"><span class="delete">"CONST hsplit(λx y. b)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hpair_def'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hpair a b = ⦃⦃a,a⦄,⦃a,b⦄⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hf_ext</span><span> </span><span>hpair_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hpair_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hpair a b = hpair a' b' ⟷ a=a' ∧ b=b'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hpair_def'</span><span> </span><span>doubleton_eq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>hpair_inject</span><span> </span><span class="delimiter">=</span><span> </span><span>hpair_iff</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>conjE</span><span class="delimiter">,</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfst_conv</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hfst ⟨a,b⟩ = a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hfst_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hsnd_conv</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hsnd ⟨a,b⟩ = b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hsnd_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hsplit</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hsplit c ⟨a,b⟩ = c a b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hsplit_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Unions, Comprehensions, Intersections›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Unions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Theorem 1.5 (Existence of the union of two sets).›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>binary_union</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃z. ∀u. u <span class="hidden">❙</span><span class="bold">∈</span> z ⟷ u <span class="hidden">❙</span><span class="bold">∈</span> x ∨ u <span class="hidden">❙</span><span class="bold">∈</span> y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>hf_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>hinsert</span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hmem_hinsert</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Theorem 1.6 (Existence of the union of a set of sets).›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>union_of_set</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃z. ∀u. u <span class="hidden">❙</span><span class="bold">∈</span> z ⟷ (∃y. y <span class="hidden">❙</span><span class="bold">∈</span> x ∧ u <span class="hidden">❙</span><span class="bold">∈</span> y)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>hf_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hmem_hempty</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>hinsert</span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hmem_hinsert</span><span> </span><span>binary_union</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Set comprehensions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Theorem 1.7, comprehension scheme›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comprehension</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃z. ∀u. u <span class="hidden">❙</span><span class="bold">∈</span> z ⟷ u <span class="hidden">❙</span><span class="bold">∈</span> x ∧ P u"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>hf_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hmem_hempty</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>hinsert</span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hmem_hinsert</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>HCollect</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(hf ⇒ bool) ⇒ hf ⇒ hf"</span></span></span><span> </span><span class="comment">― ‹comprehension›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"HCollect P A = (THE z. ∀u. u <span class="hidden">❙</span><span class="bold">∈</span> z = (P u ∧ u <span class="hidden">❙</span><span class="bold">∈</span> A))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span> </span><span class="delimiter">(</span><span>ASCII</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_HCollect"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"idt ⇒ hf ⇒ bool ⇒ hf"</span></span></span><span>    </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(1⦃_ &lt;:/ _./ _⦄)"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_HCollect"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"idt ⇒ hf ⇒ bool ⇒ hf"</span></span></span><span>    </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(1⦃_ <span class="hidden">❙</span><span class="bold">∈</span>/ _./ _⦄)"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">translations</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃x <span class="hidden">❙</span><span class="bold">∈</span> A. P⦄"</span></span></span><span> </span><span class="delimiter">⇌</span><span> </span><span class="string"><span class="delete"><span class="delete">"CONST HCollect (λx. P) A"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HCollect_iff</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hmem x (HCollect P A) ⟷ P x ∧ x <span class="hidden">❙</span><span class="bold">∈</span> A"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>comprehension</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>P</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>HCollect_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>theI2</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hf_ext</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HCollectI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a <span class="hidden">❙</span><span class="bold">∈</span> A ⟹ P a ⟹ hmem a ⦃x <span class="hidden">❙</span><span class="bold">∈</span> A. P x⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HCollectE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a <span class="hidden">❙</span><span class="bold">∈</span> ⦃x <span class="hidden">❙</span><span class="bold">∈</span> A. P x⦄"</span></span></span><span> </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a <span class="hidden">❙</span><span class="bold">∈</span> A"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HCollect_hempty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"HCollect P 0 = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hf_ext</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Union operators›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>hf</span><span> </span><span class="delimiter">::</span><span> </span><span>sup</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sup a b = (THE z. ∀u. u <span class="hidden">❙</span><span class="bold">∈</span> z ⟷ u <span class="hidden">❙</span><span class="bold">∈</span> a ∨ u <span class="hidden">❙</span><span class="bold">∈</span> b)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>hunion</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ hf ⇒ hf"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊔"</span></span></span><span> </span><span>65</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hunion ≡ sup"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hunion_iff</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hmem x (a ⊔ b) ⟷ x <span class="hidden">❙</span><span class="bold">∈</span> a ∨ x <span class="hidden">❙</span><span class="bold">∈</span> b"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>binary_union</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sup_hf_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>theI2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hf_ext</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>HUnion</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ hf"</span></span></span><span>        </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⨆_"</span></span></span><span> </span><span class="delimiter">[</span><span>900</span><span class="delimiter">]</span><span> </span><span>900</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"HUnion A = (THE z. ∀u. u <span class="hidden">❙</span><span class="bold">∈</span> z ⟷ (∃y. y <span class="hidden">❙</span><span class="bold">∈</span> A ∧ u <span class="hidden">❙</span><span class="bold">∈</span> y))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HUnion_iff</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hmem x (⨆ A) ⟷ (∃y. y <span class="hidden">❙</span><span class="bold">∈</span> A ∧ x <span class="hidden">❙</span><span class="bold">∈</span> y)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>union_of_set</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>HUnion_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>theI2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hf_ext</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HUnion_hempty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⨆ 0 = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hf_ext</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HUnion_hinsert</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⨆(A ◃ a) = a ⊔ ⨆A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hf_ext</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HUnion_hunion</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⨆(A ⊔ B) =  ⨆A ⊔ ⨆B"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition 1.8, Intersections›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>hf</span><span> </span><span class="delimiter">::</span><span> </span><span>inf</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inf a b = ⦃x <span class="hidden">❙</span><span class="bold">∈</span> a. x <span class="hidden">❙</span><span class="bold">∈</span> b⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>hinter</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ hf ⇒ hf"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊓"</span></span></span><span> </span><span>70</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hinter ≡ inf"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hinter_iff</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hmem u (x ⊓ y) ⟷ u <span class="hidden">❙</span><span class="bold">∈</span> x ∧ u <span class="hidden">❙</span><span class="bold">∈</span> y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>HCollect_iff</span><span> </span><span>inf_hf_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>HInter</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ hf"</span></span></span><span>           </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⨅_"</span></span></span><span> </span><span class="delimiter">[</span><span>900</span><span class="delimiter">]</span><span> </span><span>900</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"HInter(A) = ⦃x <span class="hidden">❙</span><span class="bold">∈</span> HUnion(A). ∀y. y <span class="hidden">❙</span><span class="bold">∈</span> A ⟶ x <span class="hidden">❙</span><span class="bold">∈</span> y⦄"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HInter_hempty</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⨅ 0 = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>HCollect_hempty</span><span> </span><span>HUnion_hempty</span><span> </span><span>HInter_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HInter_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A≠0 ⟹ hmem x (⨅ A) ⟷ (∀y. y <span class="hidden">❙</span><span class="bold">∈</span> A ⟶ x <span class="hidden">❙</span><span class="bold">∈</span> y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>HInter_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HInter_hinsert</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A≠0 ⟹ ⨅(A ◃ a) = a ⊓ ⨅A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hf_ext</span><span> </span><span>HInter_iff</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>hinsert_nonempty</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Set Difference›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>hf</span><span> </span><span class="delimiter">::</span><span> </span><span>minus</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A - B = ⦃x <span class="hidden">❙</span><span class="bold">∈</span> A. x <span class="hidden">❙</span><span class="bold">∉</span> B⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hdiff_iff</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hmem u (x - y) ⟷ u <span class="hidden">❙</span><span class="bold">∈</span> x ∧ u <span class="hidden">❙</span><span class="bold">∉</span> y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>minus_hf_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hdiff_zero</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span>hf</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x - 0) = x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zero_hdiff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span>hf</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(0 - x) = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hdiff_insert</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A - (B ◃ a) = A - B - ⦃a⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hinsert_hdiff_if</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(A ◃ x) - B = (if x <span class="hidden">❙</span><span class="bold">∈</span> B then A - B else (A - B) ◃ x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Replacement›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Theorem 1.9 (Replacement Scheme).›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>replacement</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(∀u v v'. u <span class="hidden">❙</span><span class="bold">∈</span> x ⟶ R u v ⟶ R u v' ⟶ v'=v) ⟹ ∃z. ∀v. v <span class="hidden">❙</span><span class="bold">∈</span> z ⟷ (∃u. u <span class="hidden">❙</span><span class="bold">∈</span> x ∧ R u v)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>hf_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hmem_hempty</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>hinsert</span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hmem_hinsert</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>replacement_fun</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃z. ∀v. v <span class="hidden">❙</span><span class="bold">∈</span> z ⟷ (∃u. u <span class="hidden">❙</span><span class="bold">∈</span> x ∧ v = f u)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>replacement</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>R</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λu v. v = f u"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>PrimReplace</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ (hf ⇒ hf ⇒ bool) ⇒ hf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"PrimReplace A R = (THE z. ∀v. v <span class="hidden">❙</span><span class="bold">∈</span> z ⟷ (∃u. u <span class="hidden">❙</span><span class="bold">∈</span> A ∧ R u v))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Replace</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ (hf ⇒ hf ⇒ bool) ⇒ hf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Replace A R = PrimReplace A (λx y. (∃!z. R x z) ∧ R x y)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>RepFun</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ (hf ⇒ hf) ⇒ hf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"RepFun A f = Replace A (λx y. y = f x)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span> </span><span class="delimiter">(</span><span>ASCII</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_HReplace"</span></span></span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[pttrn, pttrn, hf, bool] ⇒ hf"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(1{|_ ./ _&lt;: _, _|})"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_HRepFun"</span></span></span><span>   </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[hf, pttrn, hf] ⇒ hf"</span></span></span><span>          </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(1{|_ ./ _&lt;: _|})"</span></span></span><span> </span><span class="delimiter">[</span><span>51</span><span class="delimiter">,</span><span>0</span><span class="delimiter">,</span><span>51</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_HINTER"</span></span></span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[pttrn, hf, hf] ⇒ hf"</span></span></span><span>          </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(3INT _&lt;:_./ _)"</span></span></span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_HUNION"</span></span></span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[pttrn, hf, hf] ⇒ hf"</span></span></span><span>          </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(3UN _&lt;:_./ _)"</span></span></span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_HReplace"</span></span></span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[pttrn, pttrn, hf, bool] ⇒ hf"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(1⦃_ ./ _ <span class="hidden">❙</span><span class="bold">∈</span> _, _⦄)"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_HRepFun"</span></span></span><span>   </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[hf, pttrn, hf] ⇒ hf"</span></span></span><span>          </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(1⦃_ ./ _ <span class="hidden">❙</span><span class="bold">∈</span> _⦄)"</span></span></span><span> </span><span class="delimiter">[</span><span>51</span><span class="delimiter">,</span><span>0</span><span class="delimiter">,</span><span>51</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_HINTER"</span></span></span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[pttrn, hf, hf] ⇒ hf"</span></span></span><span>          </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(3⨅_<span class="hidden">❙</span><span class="bold">∈</span>_./ _)"</span></span></span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_HUNION"</span></span></span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[pttrn, hf, hf] ⇒ hf"</span></span></span><span>          </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(3⨆_<span class="hidden">❙</span><span class="bold">∈</span>_./ _)"</span></span></span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">translations</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃y. x<span class="hidden">❙</span><span class="bold">∈</span>A, Q⦄"</span></span></span><span> </span><span class="delimiter">⇌</span><span> </span><span class="string"><span class="delete"><span class="delete">"CONST Replace A (λx y. Q)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃b. x<span class="hidden">❙</span><span class="bold">∈</span>A⦄"</span></span></span><span>    </span><span class="delimiter">⇌</span><span> </span><span class="string"><span class="delete"><span class="delete">"CONST RepFun A (λx. b)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⨅x<span class="hidden">❙</span><span class="bold">∈</span>A. B"</span></span></span><span>    </span><span class="delimiter">⇌</span><span> </span><span class="string"><span class="delete"><span class="delete">"CONST HInter(CONST RepFun A (λx. B))"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⨆x<span class="hidden">❙</span><span class="bold">∈</span>A. B"</span></span></span><span>    </span><span class="delimiter">⇌</span><span> </span><span class="string"><span class="delete"><span class="delete">"CONST HUnion(CONST RepFun A (λx. B))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>PrimReplace_iff</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>sv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀u v v'. u <span class="hidden">❙</span><span class="bold">∈</span> A ⟶ R u v ⟶ R u v' ⟶ v'=v"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v <span class="hidden">❙</span><span class="bold">∈</span> (PrimReplace A R) ⟷ (∃u. u <span class="hidden">❙</span><span class="bold">∈</span> A ∧ R u v)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>replacement</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>sv</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>PrimReplace_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>theI2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hf_ext</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Replace_iff</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"v <span class="hidden">❙</span><span class="bold">∈</span> Replace A R ⟷ (∃u. u <span class="hidden">❙</span><span class="bold">∈</span> A ∧ R u v ∧ (∀y. R u y ⟶ y=v))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Replace_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>PrimReplace_iff</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Replace_0</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Replace 0 R = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Replace_hunion</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Replace (A ⊔ B) R = Replace A R  ⊔  Replace B R"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Replace_cong</span><span> </span><span class="delimiter">[</span><span>cong</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⟦ A=B;  ⋀x y. x <span class="hidden">❙</span><span class="bold">∈</span> B ⟹ P x y ⟷ Q x y ⟧  ⟹ Replace A P = Replace B Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hf_ext</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>conj_cong</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>RepFun_iff</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v <span class="hidden">❙</span><span class="bold">∈</span> (RepFun A f) ⟷ (∃u. u <span class="hidden">❙</span><span class="bold">∈</span> A ∧ v = f u)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>RepFun_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>RepFun_cong</span><span> </span><span class="delimiter">[</span><span>cong</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⟦ A=B;  ⋀x. x <span class="hidden">❙</span><span class="bold">∈</span> B ⟹ f(x)=g(x) ⟧  ⟹ RepFun A f = RepFun B g"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>RepFun_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>triv_RepFun</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"RepFun A (λx. x) = A"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>RepFun_0</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"RepFun 0 f = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>RepFun_hinsert</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"RepFun (hinsert a b) f = hinsert (f a) (RepFun b f)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>RepFun_hunion</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"RepFun (A ⊔ B) f = RepFun A f  ⊔  RepFun B f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HF_HUnion</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦finite A; ⋀x. x∈A ⟹ finite (B x)⟧ ⟹ HF (⋃x ∈ A. B x) = (⨆x<span class="hidden">❙</span><span class="bold">∈</span>HF A. HF (B x))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hf_equalityI</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Subset relation and the Lattice Properties›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition 1.10 (Subset relation).›</span></span></span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>hf</span><span> </span><span class="delimiter">::</span><span> </span><span>order</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>less_eq_hf</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ≤ B ⟷ (∀x. x <span class="hidden">❙</span><span class="bold">∈</span> A ⟶ x <span class="hidden">❙</span><span class="bold">∈</span> B)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>less_hf</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A &lt; B ⟷ A ≤ B ∧ A ≠ (B::hf)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>less_eq_hf_def</span><span> </span><span>less_hf_def</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Rules for subsets›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hsubsetI</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(⋀x. x<span class="hidden">❙</span><span class="bold">∈</span>A ⟹ x<span class="hidden">❙</span><span class="bold">∈</span>B) ⟹ A ≤ B"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>less_eq_hf_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Classical elimination rule›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hsubsetCE</span><span> </span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ A ≤ B;  c<span class="hidden">❙</span><span class="bold">∉</span>A ⟹ P;  c<span class="hidden">❙</span><span class="bold">∈</span>B ⟹ P ⟧  ⟹ P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>less_eq_hf_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Rule in Modus Ponens style›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hsubsetD</span><span> </span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ A ≤ B;  c<span class="hidden">❙</span><span class="bold">∈</span>A ⟧ ⟹ c<span class="hidden">❙</span><span class="bold">∈</span>B"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>less_eq_hf_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sometimes useful with premises in this order›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rev_hsubsetD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ c<span class="hidden">❙</span><span class="bold">∈</span>A; A≤B ⟧ ⟹ c<span class="hidden">❙</span><span class="bold">∈</span>B"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>contra_hsubsetD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ A ≤ B; c ∉ B ⟧  ⟹ c ∉ A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rev_contra_hsubsetD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ c ∉ B;  A ≤ B ⟧  ⟹ c ∉ A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hf_equalityE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>A</span><span> </span><span class="delimiter">::</span><span> </span><span>hf</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A = B ⟹ (A ≤ B ⟹ B ≤ A ⟹ P) ⟹ P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>order_refl</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lattice properties›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>hf</span><span> </span><span class="delimiter">::</span><span> </span><span>distrib_lattice</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>less_eq_hf_def</span><span> </span><span>less_hf_def</span><span> </span><span>inf_hf_def</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>hf</span><span> </span><span class="delimiter">::</span><span> </span><span>bounded_lattice_bot</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bot = (0::hf)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>less_eq_hf_def</span><span> </span><span>bot_hf_def</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hinter_hempty_left</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ⊓ A = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>bot_hf_def</span><span> </span><span>inf_bot_left</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hinter_hempty_right</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ⊓ 0 = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>bot_hf_def</span><span> </span><span>inf_bot_right</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hunion_hempty_left</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ⊔ A = A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>bot_hf_def</span><span> </span><span>sup_bot_left</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hunion_hempty_right</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ⊔ 0 = A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>bot_hf_def</span><span> </span><span>sup_bot_right</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>less_eq_hempty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u ≤ 0 ⟷ u = (0::hf)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hempty_iff</span><span> </span><span>less_eq_hf_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>less_eq_insert1_iff</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(hinsert x y) ≤ z ⟷ x <span class="hidden">❙</span><span class="bold">∈</span> z ∧ y ≤ z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>less_eq_hf_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>less_eq_insert2_iff</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"z ≤ (hinsert x y) ⟷ z ≤ y ∨ (∃u. hinsert x u = z ∧ x <span class="hidden">❙</span><span class="bold">∉</span> u ∧ u ≤ y)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"x <span class="hidden">❙</span><span class="bold">∈</span> z"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hinsert x (z - ⦃x⦄) = z"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ≤ (hinsert x y)"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ≤ y ∨ (∃u. hinsert x u = z ∧ x <span class="hidden">❙</span><span class="bold">∉</span> u ∧ u ≤ y)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>less_eq_hf_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>u</span><span> </span><span>hdiff_iff</span><span> </span><span>hmem_hinsert</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ≤ y ∨ (∃u. hinsert x u = z ∧ x <span class="hidden">❙</span><span class="bold">∉</span> u ∧ u ≤ y)"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ≤ (hinsert x y)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>less_eq_hf_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hmem_hinsert</span><span> </span><span>less_eq_hf_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zero_le</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ (x::hf)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hinsert_eq_sup</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ◃ a = b ⊔ ⦃a⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hunion_hinsert_left</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hinsert x A ⊔ B = hinsert x (A ⊔ B)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hunion_hinsert_right</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"B ⊔ hinsert x A = hinsert x (B ⊔ A)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hinter_hinsert_left</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hinsert x A ⊓ B = (if x <span class="hidden">❙</span><span class="bold">∈</span> B then hinsert x (A ⊓ B) else A ⊓ B)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hinter_hinsert_right</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"B ⊓ hinsert x A = (if x <span class="hidden">❙</span><span class="bold">∈</span> B then hinsert x (B ⊓ A) else B ⊓ A)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Foundation, Cardinality, Powersets›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Foundation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Theorem 1.13: Foundation (Regularity) Property.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>foundation</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>z</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z ≠ 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃w. w <span class="hidden">❙</span><span class="bold">∈</span> z ∧ w ⊓ z = 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>z</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀w. w <span class="hidden">❙</span><span class="bold">∈</span> z ⟶ w ⊓ z ≠ 0)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x <span class="hidden">❙</span><span class="bold">∉</span> z ∧ x ⊓ z = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>hf_induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hinter_hempty_left</span><span> </span><span>z</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>hinsert</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hinter_hinsert_left</span><span> </span><span>z</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>z</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>z</span><span> </span><span>hempty_iff</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hmem_not_refl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x <span class="hidden">❙</span><span class="bold">∉</span> x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>foundation</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃x⦄"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hinter_iff</span><span> </span><span>hmem_hempty</span><span> </span><span>hmem_hinsert</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hmem_not_sym</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (x <span class="hidden">❙</span><span class="bold">∈</span> y ∧ y <span class="hidden">❙</span><span class="bold">∈</span> x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>foundation</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃x,y⦄"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hinter_iff</span><span> </span><span>hmem_hempty</span><span> </span><span>hmem_hinsert</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hmem_ne</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x <span class="hidden">❙</span><span class="bold">∈</span> y ⟹ x ≠ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hmem_not_refl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hmem_Sup_ne</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x <span class="hidden">❙</span><span class="bold">∈</span> y ⟹ ⨆x ≠ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>HUnion_iff</span><span> </span><span>hmem_not_sym</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hpair_neq_fst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨a,b⟩ ≠ a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hpair_def</span><span> </span><span>hinsert_iff</span><span> </span><span>hmem_not_sym</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hpair_neq_snd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨a,b⟩ ≠ b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hpair_def</span><span> </span><span>hinsert_iff</span><span> </span><span>hmem_not_sym</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hpair_nonzero</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨x,y⟩ ≠ 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hpair_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zero_notin_hpair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 <span class="hidden">❙</span><span class="bold">∉</span> ⟨x,y⟩"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hpair_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Cardinality›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹First we need to hack the underlying representation›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfset_0</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hfset 0 = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Zero_hf_def</span><span> </span><span>finite.emptyI</span><span> </span><span>hfset_HF</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfset_hinsert</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hfset (b ◃ a) = insert a (hfset b)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>finite_insert</span><span> </span><span>hinsert_def</span><span> </span><span>HF.finite_hfset</span><span> </span><span>hfset_HF</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfset_hdiff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hfset (x - y) = hfset x - hfset y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>x</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>y</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>hf_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>hinsert</span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hfset_hinsert</span><span> </span><span>Set.insert_Diff_if</span><span> </span><span>hinsert_hdiff_if</span><span> </span><span>hmem_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hcard</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ nat"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hcard x = card (hfset x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hcard_0</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hcard 0 = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hcard_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hcard_hinsert_if</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hcard (hinsert x y) = (if x <span class="hidden">❙</span><span class="bold">∈</span> y then hcard y else Suc (hcard y))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hcard_def</span><span> </span><span>hfset_hinsert</span><span> </span><span>card_insert_if</span><span> </span><span>hmem_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hcard_union_inter</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hcard (x ⊔ y) + hcard (x ⊓ y) = hcard x + hcard y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>x</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>y</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>hf_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hcard_hinsert_if</span><span> </span><span>hunion_hinsert_left</span><span> </span><span>hinter_hinsert_left</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hcard_hdiff1_less</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x <span class="hidden">❙</span><span class="bold">∈</span> z ⟹ hcard (z - ⦃x⦄) &lt; hcard z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hcard_def</span><span> </span><span>hfset_hdiff</span><span> </span><span>hfset_hinsert</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>metis</span><span> </span><span>card_Diff1_less</span><span> </span><span>finite_hfset</span><span> </span><span>hmem_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Powerset Operator›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Theorem 1.11 (Existence of the power set).›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>powerset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃z. ∀u. u <span class="hidden">❙</span><span class="bold">∈</span> z ⟷ u ≤ x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>hf_induct</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hmem_hempty</span><span> </span><span>hmem_hinsert</span><span> </span><span>less_eq_hempty</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>hinsert</span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Pb</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Pb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀u. u <span class="hidden">❙</span><span class="bold">∈</span> Pb ⟷ u ≤ b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>RPb</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>RPb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀v. v <span class="hidden">❙</span><span class="bold">∈</span> RPb ⟷ (∃u. u <span class="hidden">❙</span><span class="bold">∈</span> Pb ∧ v = hinsert a u)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>replacement_fun</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Pb</span><span> </span><span>binary_union</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>Pb</span><span> </span><span>RPb</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>less_eq_insert2_iff</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>z</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hinsert.hyps</span><span> </span><span>less_eq_hf_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>HPow</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ hf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"HPow x = (THE z. ∀u. u <span class="hidden">❙</span><span class="bold">∈</span> z ⟷ u ≤ x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HPow_iff</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u <span class="hidden">❙</span><span class="bold">∈</span> HPow x ⟷ u ≤ x"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>powerset</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>HPow_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>theI2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hf_ext</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HPow_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ y ⟹ HPow x ≤ HPow y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>HPow_iff</span><span> </span><span>less_eq_hf_def</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HPow_mono_strict</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x &lt; y ⟹ HPow x &lt; HPow y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>HPow_iff</span><span> </span><span>HPow_mono</span><span> </span><span>less_le_not_le</span><span> </span><span>order_eq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HPow_mono_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"HPow x ≤ HPow y ⟷ x ≤ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>HPow_iff</span><span> </span><span>HPow_mono</span><span> </span><span>hsubsetCE</span><span> </span><span>order_refl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HPow_mono_strict_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"HPow x &lt; HPow y ⟷ x &lt; y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>HPow_mono_iff</span><span> </span><span>less_le_not_le</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Bounded Quantifiers›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>HBall</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ (hf ⇒ bool) ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HBall A P ⟷ (∀x. x <span class="hidden">❙</span><span class="bold">∈</span> A ⟶ P x)"</span></span></span><span>   </span><span class="comment">― ‹bounded universal quantifiers›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>HBex</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ (hf ⇒ bool) ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HBex A P ⟷ (∃x. x <span class="hidden">❙</span><span class="bold">∈</span> A ∧ P x)"</span></span></span><span>   </span><span class="comment">― ‹bounded existential quantifiers›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span> </span><span class="delimiter">(</span><span>ASCII</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_HBall"</span></span></span><span>       </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"pttrn ⇒ hf ⇒ bool ⇒ bool"</span></span></span><span>      </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(3ALL _&lt;:_./ _)"</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>10</span><span class="delimiter">]</span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_HBex"</span></span></span><span>        </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"pttrn ⇒ hf ⇒ bool ⇒ bool"</span></span></span><span>      </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(3EX _&lt;:_./ _)"</span></span></span><span>  </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>10</span><span class="delimiter">]</span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_HBex1"</span></span></span><span>       </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"pttrn ⇒ hf ⇒ bool ⇒ bool"</span></span></span><span>      </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(3EX! _&lt;:_./ _)"</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>10</span><span class="delimiter">]</span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_HBall"</span></span></span><span>       </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"pttrn ⇒ hf ⇒ bool ⇒ bool"</span></span></span><span>      </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(3∀_<span class="hidden">❙</span><span class="bold">∈</span>_./ _)"</span></span></span><span>  </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>10</span><span class="delimiter">]</span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_HBex"</span></span></span><span>        </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"pttrn ⇒ hf ⇒ bool ⇒ bool"</span></span></span><span>      </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(3∃_<span class="hidden">❙</span><span class="bold">∈</span>_./ _)"</span></span></span><span>  </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>10</span><span class="delimiter">]</span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_HBex1"</span></span></span><span>       </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"pttrn ⇒ hf ⇒ bool ⇒ bool"</span></span></span><span>      </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(3∃!_<span class="hidden">❙</span><span class="bold">∈</span>_./ _)"</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>10</span><span class="delimiter">]</span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">translations</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀x<span class="hidden">❙</span><span class="bold">∈</span>A. P"</span></span></span><span> </span><span class="delimiter">⇌</span><span> </span><span class="string"><span class="delete"><span class="delete">"CONST HBall A (λx. P)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃x<span class="hidden">❙</span><span class="bold">∈</span>A. P"</span></span></span><span> </span><span class="delimiter">⇌</span><span> </span><span class="string"><span class="delete"><span class="delete">"CONST HBex A (λx. P)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃!x<span class="hidden">❙</span><span class="bold">∈</span>A. P"</span></span></span><span> </span><span class="delimiter">⇀</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃!x. x∈A ∧ P"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hball_cong</span><span> </span><span class="delimiter">[</span><span>cong</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⟦ A=A';  ⋀x. x <span class="hidden">❙</span><span class="bold">∈</span> A' ⟹ P(x) ⟷ P'(x) ⟧  ⟹ (∀x<span class="hidden">❙</span><span class="bold">∈</span>A. P(x)) ⟷ (∀x<span class="hidden">❙</span><span class="bold">∈</span>A'. P'(x))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>HBall_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hballI</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀x. x<span class="hidden">❙</span><span class="bold">∈</span>A ⟹ P x) ⟹ ∀x<span class="hidden">❙</span><span class="bold">∈</span>A. P x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>HBall_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hbspec</span><span> </span><span class="delimiter">[</span><span>dest</span><span class="delimiter">?</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x<span class="hidden">❙</span><span class="bold">∈</span>A. P x ⟹ x<span class="hidden">❙</span><span class="bold">∈</span>A ⟹ P x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>HBall_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hballE</span><span> </span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x<span class="hidden">❙</span><span class="bold">∈</span>A. P x ⟹ (P x ⟹ Q) ⟹ (x <span class="hidden">❙</span><span class="bold">∉</span> A ⟹ Q) ⟹ Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>HBall_def</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hbex_cong</span><span> </span><span class="delimiter">[</span><span>cong</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⟦ A=A';  ⋀x. x <span class="hidden">❙</span><span class="bold">∈</span> A' ⟹ P(x) ⟷ P'(x) ⟧  ⟹ (∃x<span class="hidden">❙</span><span class="bold">∈</span>A. P(x)) ⟷ (∃x<span class="hidden">❙</span><span class="bold">∈</span>A'. P'(x))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>HBex_def</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>conj_cong</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hbexI</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P x ⟹ x<span class="hidden">❙</span><span class="bold">∈</span>A ⟹ ∃x<span class="hidden">❙</span><span class="bold">∈</span>A. P x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>HBex_def</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rev_hbexI</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">?</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x<span class="hidden">❙</span><span class="bold">∈</span>A ⟹ P x ⟹ ∃x<span class="hidden">❙</span><span class="bold">∈</span>A. P x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>HBex_def</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bexCI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀x<span class="hidden">❙</span><span class="bold">∈</span>A. ¬ P x ⟹ P a) ⟹ a<span class="hidden">❙</span><span class="bold">∈</span>A ⟹ ∃x<span class="hidden">❙</span><span class="bold">∈</span>A. P x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>HBex_def</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hbexE</span><span> </span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x<span class="hidden">❙</span><span class="bold">∈</span>A. P x ⟹ (⋀x. x<span class="hidden">❙</span><span class="bold">∈</span>A ⟹ P x ⟹ Q) ⟹ Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>HBex_def</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hball_triv</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀x<span class="hidden">❙</span><span class="bold">∈</span>A. P) = ((∃x. x<span class="hidden">❙</span><span class="bold">∈</span>A) ⟶ P)"</span></span></span><span>
</span><span>  </span><span class="comment">― ‹Trival rewrite rule.›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>HBall_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hbex_triv</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃x<span class="hidden">❙</span><span class="bold">∈</span>A. P) = ((∃x. x<span class="hidden">❙</span><span class="bold">∈</span>A) ∧ P)"</span></span></span><span>
</span><span>  </span><span class="comment">― ‹Dual form for existentials.›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>HBex_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hbex_triv_one_point1</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃x<span class="hidden">❙</span><span class="bold">∈</span>A. x = a) = (a<span class="hidden">❙</span><span class="bold">∈</span>A)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hbex_triv_one_point2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃x<span class="hidden">❙</span><span class="bold">∈</span>A. a = x) = (a<span class="hidden">❙</span><span class="bold">∈</span>A)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hbex_one_point1</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃x<span class="hidden">❙</span><span class="bold">∈</span>A. x = a ∧ P x) = (a<span class="hidden">❙</span><span class="bold">∈</span>A ∧ P a)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hbex_one_point2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃x<span class="hidden">❙</span><span class="bold">∈</span>A. a = x ∧ P x) = (a<span class="hidden">❙</span><span class="bold">∈</span>A ∧ P a)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hball_one_point1</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀x<span class="hidden">❙</span><span class="bold">∈</span>A. x = a ⟶ P x) = (a<span class="hidden">❙</span><span class="bold">∈</span>A ⟶ P a)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hball_one_point2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀x<span class="hidden">❙</span><span class="bold">∈</span>A. a = x ⟶ P x) = (a<span class="hidden">❙</span><span class="bold">∈</span>A ⟶ P a)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hball_conj_distrib</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(∀x<span class="hidden">❙</span><span class="bold">∈</span>A. P x ∧ Q x) ⟷ ((∀x<span class="hidden">❙</span><span class="bold">∈</span>A. P x) ∧ (∀x<span class="hidden">❙</span><span class="bold">∈</span>A. Q x))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hbex_disj_distrib</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(∃x<span class="hidden">❙</span><span class="bold">∈</span>A. P x ∨ Q x) ⟷ ((∃x<span class="hidden">❙</span><span class="bold">∈</span>A. P x) ∨ (∃x<span class="hidden">❙</span><span class="bold">∈</span>A. Q x))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hb_all_simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>no_atp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀A P Q. (∀x <span class="hidden">❙</span><span class="bold">∈</span> A. P x ∨ Q) ⟷ ((∀x <span class="hidden">❙</span><span class="bold">∈</span> A. P x) ∨ Q)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀A P Q. (∀x <span class="hidden">❙</span><span class="bold">∈</span> A. P ∨ Q x) ⟷ (P ∨ (∀x <span class="hidden">❙</span><span class="bold">∈</span> A. Q x))"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀A P Q. (∀x <span class="hidden">❙</span><span class="bold">∈</span> A. P ⟶ Q x) ⟷ (P ⟶ (∀x <span class="hidden">❙</span><span class="bold">∈</span> A. Q x))"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀A P Q. (∀x <span class="hidden">❙</span><span class="bold">∈</span> A. P x ⟶ Q) ⟷ ((∃x <span class="hidden">❙</span><span class="bold">∈</span> A. P x) ⟶ Q)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀P. (∀x <span class="hidden">❙</span><span class="bold">∈</span> 0. P x) ⟷ True"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀a B P. (∀x <span class="hidden">❙</span><span class="bold">∈</span> B ◃ a. P x) ⟷ (P a ∧ (∀x <span class="hidden">❙</span><span class="bold">∈</span> B. P x))"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀P Q. (∀x <span class="hidden">❙</span><span class="bold">∈</span> HCollect Q A. P x) ⟷ (∀x <span class="hidden">❙</span><span class="bold">∈</span> A. Q x ⟶ P x)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀A P. (¬ (∀x <span class="hidden">❙</span><span class="bold">∈</span> A. P x)) ⟷ (∃x <span class="hidden">❙</span><span class="bold">∈</span> A. ¬ P x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hb_ex_simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>no_atp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀A P Q. (∃x <span class="hidden">❙</span><span class="bold">∈</span> A. P x ∧ Q) ⟷ ((∃x <span class="hidden">❙</span><span class="bold">∈</span> A. P x) ∧ Q)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀A P Q. (∃x <span class="hidden">❙</span><span class="bold">∈</span> A. P ∧ Q x) ⟷ (P ∧ (∃x <span class="hidden">❙</span><span class="bold">∈</span> A. Q x))"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀P. (∃x <span class="hidden">❙</span><span class="bold">∈</span> 0. P x) ⟷ False"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀a B P. (∃x <span class="hidden">❙</span><span class="bold">∈</span> B ◃ a. P x) ⟷ (P a ∨ (∃x <span class="hidden">❙</span><span class="bold">∈</span> B. P x))"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀P Q. (∃x <span class="hidden">❙</span><span class="bold">∈</span> HCollect Q A. P x) ⟷ (∃x <span class="hidden">❙</span><span class="bold">∈</span> A. Q x ∧ P x)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀A P. (¬(∃x <span class="hidden">❙</span><span class="bold">∈</span> A. P x)) ⟷ (∀x <span class="hidden">❙</span><span class="bold">∈</span> A. ¬ P x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>le_HCollect_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ≤ ⦃x <span class="hidden">❙</span><span class="bold">∈</span> B. P x⦄ ⟷ A ≤ B ∧ (∀x <span class="hidden">❙</span><span class="bold">∈</span> A. P x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Relations and Functions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_hpair</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_hpair z = (∃x y. z = ⟨x,y⟩)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hconverse</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ hf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hconverse(r) = ⦃z. w <span class="hidden">❙</span><span class="bold">∈</span> r, ∃x y. w = ⟨x,y⟩ ∧ z = ⟨y,x⟩⦄"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hdomain</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ hf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hdomain(r) = ⦃x. w <span class="hidden">❙</span><span class="bold">∈</span> r, ∃y. w = ⟨x,y⟩⦄"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hrange</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ hf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hrange(r) = hdomain(hconverse(r))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hrelation</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hrelation(r) = (∀z. z <span class="hidden">❙</span><span class="bold">∈</span> r ⟶ is_hpair z)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hrestrict</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ hf ⇒ hf"</span></span></span><span>
</span><span>  </span><span class="comment">― ‹Restrict the relation r to the domain A›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hrestrict r A = ⦃z <span class="hidden">❙</span><span class="bold">∈</span> r. ∃x <span class="hidden">❙</span><span class="bold">∈</span> A. ∃y. z = ⟨x,y⟩⦄"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>nonrestrict</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ hf ⇒ hf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nonrestrict r A = ⦃z <span class="hidden">❙</span><span class="bold">∈</span> r. ∀x <span class="hidden">❙</span><span class="bold">∈</span> A. ∀y. z ≠ ⟨x,y⟩⦄"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hfunction</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hfunction(r) = (∀x y. ⟨x,y⟩ <span class="hidden">❙</span><span class="bold">∈</span> r ⟶ (∀y'. ⟨x,y'⟩ <span class="hidden">❙</span><span class="bold">∈</span> r ⟶ y=y'))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>app</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ hf ⇒ hf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"app f x = (THE y. ⟨x, y⟩ <span class="hidden">❙</span><span class="bold">∈</span> f)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hrestrict_iff</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"z <span class="hidden">❙</span><span class="bold">∈</span> hrestrict r A ⟷ z <span class="hidden">❙</span><span class="bold">∈</span> r ∧ (∃ x y. z = ⟨x, y⟩ ∧ x <span class="hidden">❙</span><span class="bold">∈</span> A)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hrestrict_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hrelation_0</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hrelation 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hrelation_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hrelation_restr</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hrelation (hrestrict r x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hrelation_def</span><span> </span><span>hrestrict_iff</span><span> </span><span>is_hpair_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hrelation_hunion</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hrelation (f ⊔ g) ⟷ hrelation f ∧ hrelation g"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hrelation_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfunction_restr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hfunction r ⟹ hfunction (hrestrict r x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hfunction_def</span><span> </span><span>hrestrict_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hdomain_restr</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hdomain (hrestrict r x) = hdomain r ⊓ x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hdomain_def</span><span> </span><span>hrestrict_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hdomain_0</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hdomain 0 = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hdomain_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hdomain_ins</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hdomain (r ◃ ⟨x, y⟩) = hdomain r ◃ x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hdomain_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hdomain_hunion</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hdomain (f ⊔ g) = hdomain f ⊔ hdomain g"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hdomain_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hdomain_not_mem</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨hdomain r, a⟩ <span class="hidden">❙</span><span class="bold">∉</span> r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hdomain_ins</span><span> </span><span>hinter_hinsert_right</span><span> </span><span>hmem_hinsert</span><span> </span><span>hmem_not_refl</span><span>
</span><span>            </span><span>hunion_hinsert_right</span><span> </span><span>sup_inf_absorb</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>app_singleton</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"app ⦃⟨x, y⟩⦄ x = y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>app_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>app_equality</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hfunction f ⟹ ⟨x, y⟩ <span class="hidden">❙</span><span class="bold">∈</span> f ⟹ app f x = y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>app_def</span><span> </span><span>hfunction_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>the1I2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>app_ins2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x' ≠ x ⟹ app (f ◃ ⟨x, y⟩) x' = app f x'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>app_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfunction_0</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hfunction 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hfunction_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfunction_ins</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hfunction f ⟹ x <span class="hidden">❙</span><span class="bold">∉</span> hdomain f ⟹ hfunction (f◃ ⟨x, y⟩)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hfunction_def</span><span> </span><span>hdomain_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hdomainI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨x, y⟩ <span class="hidden">❙</span><span class="bold">∈</span> f ⟹ x <span class="hidden">❙</span><span class="bold">∈</span> hdomain f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hdomain_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfunction_hunion</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hdomain f ⊓ hdomain g = 0
            ⟹ hfunction (f ⊔ g) ⟷ hfunction f ∧ hfunction g"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hfunction_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hdomainI</span><span> </span><span>hinter_iff</span><span> </span><span>hmem_hempty</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>app_hrestrict</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x <span class="hidden">❙</span><span class="bold">∈</span> A ⟹ app (hrestrict f A) x = app f x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hrestrict_def</span><span> </span><span>app_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Operations on families of sets›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>HLambda</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ (hf ⇒ hf) ⇒ hf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"HLambda A b = RepFun A (λx. ⟨x, b x⟩)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>HSigma</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ (hf ⇒ hf) ⇒ hf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"HSigma A B = (⨆x<span class="hidden">❙</span><span class="bold">∈</span>A. ⨆y<span class="hidden">❙</span><span class="bold">∈</span>B(x). ⦃⟨x,y⟩⦄)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>HPi</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ (hf ⇒ hf) ⇒ hf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"HPi A B = ⦃ f <span class="hidden">❙</span><span class="bold">∈</span> HPow(HSigma A B). A ≤ hdomain(f) ∧ hfunction(f)⦄"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span> </span><span class="delimiter">(</span><span>ASCII</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_PROD"</span></span></span><span>     </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[pttrn, hf, hf] ⇒ hf"</span></span></span><span>        </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(3PROD _&lt;:_./ _)"</span></span></span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_SUM"</span></span></span><span>      </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[pttrn, hf, hf] ⇒ hf"</span></span></span><span>        </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(3SUM _&lt;:_./ _)"</span></span></span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_lam"</span></span></span><span>      </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[pttrn, hf, hf] ⇒ hf"</span></span></span><span>        </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(3lam _&lt;:_./ _)"</span></span></span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_PROD"</span></span></span><span>     </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[pttrn, hf, hf] ⇒ hf"</span></span></span><span>        </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(3∏_<span class="hidden">❙</span><span class="bold">∈</span>_./ _)"</span></span></span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_SUM"</span></span></span><span>      </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[pttrn, hf, hf] ⇒ hf"</span></span></span><span>        </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(3∑_<span class="hidden">❙</span><span class="bold">∈</span>_./ _)"</span></span></span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_lam"</span></span></span><span>      </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[pttrn, hf, hf] ⇒ hf"</span></span></span><span>        </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(3λ_<span class="hidden">❙</span><span class="bold">∈</span>_./ _)"</span></span></span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">translations</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∏x<span class="hidden">❙</span><span class="bold">∈</span>A. B"</span></span></span><span> </span><span class="delimiter">⇌</span><span> </span><span class="string"><span class="delete"><span class="delete">"CONST HPi A (λx. B)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∑x<span class="hidden">❙</span><span class="bold">∈</span>A. B"</span></span></span><span> </span><span class="delimiter">⇌</span><span> </span><span class="string"><span class="delete"><span class="delete">"CONST HSigma A (λx. B)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"λx<span class="hidden">❙</span><span class="bold">∈</span>A. f"</span></span></span><span>  </span><span class="delimiter">⇌</span><span> </span><span class="string"><span class="delete"><span class="delete">"CONST HLambda A (λx. f)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Rules for Unions and Intersections of families›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HUN_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b <span class="hidden">❙</span><span class="bold">∈</span> (⨆x<span class="hidden">❙</span><span class="bold">∈</span>A. B(x)) ⟷ (∃x<span class="hidden">❙</span><span class="bold">∈</span>A. b <span class="hidden">❙</span><span class="bold">∈</span> B(x))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*The order of the premises presupposes that A is rigid; b may be flexible*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HUN_I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ a <span class="hidden">❙</span><span class="bold">∈</span> A;  b <span class="hidden">❙</span><span class="bold">∈</span> B(a) ⟧  ⟹ b <span class="hidden">❙</span><span class="bold">∈</span> (⨆x<span class="hidden">❙</span><span class="bold">∈</span>A. B(x))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HUN_E</span><span> </span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b <span class="hidden">❙</span><span class="bold">∈</span> (⨆x<span class="hidden">❙</span><span class="bold">∈</span>A. B(x))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x <span class="hidden">❙</span><span class="bold">∈</span> A"</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"b <span class="hidden">❙</span><span class="bold">∈</span> B(x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HINT_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b <span class="hidden">❙</span><span class="bold">∈</span> (⨅x<span class="hidden">❙</span><span class="bold">∈</span>A. B(x)) ⟷ (∀x<span class="hidden">❙</span><span class="bold">∈</span>A. b <span class="hidden">❙</span><span class="bold">∈</span> B(x)) ∧ A≠0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>HInter_def</span><span> </span><span>HBall_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>foundation</span><span> </span><span>hmem_hempty</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HINT_I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ ⋀x. x <span class="hidden">❙</span><span class="bold">∈</span> A ⟹ b <span class="hidden">❙</span><span class="bold">∈</span> B(x);  A≠0 ⟧ ⟹ b <span class="hidden">❙</span><span class="bold">∈</span> (⨅x<span class="hidden">❙</span><span class="bold">∈</span>A. B(x))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>HINT_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HINT_E</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ b <span class="hidden">❙</span><span class="bold">∈</span> (⨅x<span class="hidden">❙</span><span class="bold">∈</span>A. B(x));  a <span class="hidden">❙</span><span class="bold">∈</span> A ⟧ ⟹ b <span class="hidden">❙</span><span class="bold">∈</span> B(a)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>HINT_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Generalized Cartesian product›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HSigma_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨a,b⟩ <span class="hidden">❙</span><span class="bold">∈</span> HSigma A B ⟷ a <span class="hidden">❙</span><span class="bold">∈</span> A ∧ b <span class="hidden">❙</span><span class="bold">∈</span> B(a)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>HSigma_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HSigmaI</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ a <span class="hidden">❙</span><span class="bold">∈</span> A;  b <span class="hidden">❙</span><span class="bold">∈</span> B(a) ⟧  ⟹ ⟨a,b⟩ <span class="hidden">❙</span><span class="bold">∈</span> HSigma A B"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>HSigmaD1</span><span> </span><span class="delimiter">=</span><span> </span><span>HSigma_iff</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>conjunct1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>HSigmaD2</span><span> </span><span class="delimiter">=</span><span> </span><span>HSigma_iff</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The general elimination rule›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HSigmaE</span><span> </span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c <span class="hidden">❙</span><span class="bold">∈</span> HSigma A B"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x <span class="hidden">❙</span><span class="bold">∈</span> A"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y <span class="hidden">❙</span><span class="bold">∈</span> B(x)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c=⟨x,y⟩"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>HSigma_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HSigmaE2</span><span> </span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨a,b⟩ <span class="hidden">❙</span><span class="bold">∈</span> HSigma A B"</span></span></span><span> </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a <span class="hidden">❙</span><span class="bold">∈</span> A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b <span class="hidden">❙</span><span class="bold">∈</span> B(a)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HSigma_empty1</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"HSigma 0 B = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>hf</span><span> </span><span class="delimiter">::</span><span> </span><span>times</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A * B = HSigma A (λx. B)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>times_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨a,b⟩ <span class="hidden">❙</span><span class="bold">∈</span> A * B ⟷ a <span class="hidden">❙</span><span class="bold">∈</span> A ∧ b <span class="hidden">❙</span><span class="bold">∈</span> B"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>times_hf_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>timesI</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ a <span class="hidden">❙</span><span class="bold">∈</span> A;  b <span class="hidden">❙</span><span class="bold">∈</span> B ⟧  ⟹ ⟨a,b⟩ <span class="hidden">❙</span><span class="bold">∈</span> A * B"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>timesD1</span><span> </span><span class="delimiter">=</span><span> </span><span>times_iff</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>conjunct1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>timesD2</span><span> </span><span class="delimiter">=</span><span> </span><span>times_iff</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The general elimination rule›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>timesE</span><span> </span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c <span class="hidden">❙</span><span class="bold">∈</span> A * B"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x <span class="hidden">❙</span><span class="bold">∈</span> A"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y <span class="hidden">❙</span><span class="bold">∈</span> B"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c=⟨x,y⟩"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>times_hf_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹...and a specific one›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>timesE2</span><span> </span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨a,b⟩ <span class="hidden">❙</span><span class="bold">∈</span> A * B"</span></span></span><span> </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a <span class="hidden">❙</span><span class="bold">∈</span> A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b <span class="hidden">❙</span><span class="bold">∈</span> B"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>times_empty1</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 * B = (0::hf)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>times_empty2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A*0 = (0::hf)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>times_empty_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A*B=0 ⟷ A=0 ∨ B=(0::hf)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>times_hf_def</span><span> </span><span>hf_ext</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>hf</span><span> </span><span class="delimiter">::</span><span> </span><span>mult_zero</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span>auto</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Disjoint Sum›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>hf</span><span> </span><span class="delimiter">::</span><span> </span><span>zero_neq_one</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>One_hf_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 = ⦃0⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>One_hf_def</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>hf</span><span> </span><span class="delimiter">::</span><span> </span><span>plus</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A + B = (⦃0⦄ * A) ⊔ (⦃1⦄ * B)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Inl</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf⇒hf"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"Inl(a) ≡ ⟨0,a⟩"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Inr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf⇒hf"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"Inr(b) ≡ ⟨1,b⟩"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>sum_defs</span><span> </span><span class="delimiter">=</span><span> </span><span>plus_hf_def</span><span> </span><span>Inl_def</span><span> </span><span>Inr_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Inl_nonzero</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Inl x ≠ 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Inl_def</span><span> </span><span>hpair_nonzero</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Inr_nonzero</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Inr x ≠ 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Inr_def</span><span> </span><span>hpair_nonzero</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Introduction rules for the injections (as equivalences)›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Inl_in_sum_iff</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Inl(a) <span class="hidden">❙</span><span class="bold">∈</span> A+B ⟷ a <span class="hidden">❙</span><span class="bold">∈</span> A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sum_defs</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Inr_in_sum_iff</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Inr(b) <span class="hidden">❙</span><span class="bold">∈</span> A+B ⟷ b <span class="hidden">❙</span><span class="bold">∈</span> B"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sum_defs</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Elimination rule›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sumE</span><span> </span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u <span class="hidden">❙</span><span class="bold">∈</span> A+B"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x <span class="hidden">❙</span><span class="bold">∈</span> A"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u=Inl(x)"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y <span class="hidden">❙</span><span class="bold">∈</span> B"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u=Inr(y)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sum_defs</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Injection and freeness equivalences, for rewriting›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Inl_iff</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Inl(a)=Inl(b) ⟷ a=b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sum_defs</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Inr_iff</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Inr(a)=Inr(b) ⟷ a=b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sum_defs</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Inl_Inr_iff</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Inl(a)=Inr(b) ⟷ False"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sum_defs</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Inr_Inl_iff</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Inr(b)=Inl(a) ⟷ False"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sum_defs</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_empty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0+0 = (0::hf)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sum_defs</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u <span class="hidden">❙</span><span class="bold">∈</span> A+B ⟷ (∃x. x <span class="hidden">❙</span><span class="bold">∈</span> A ∧ u=Inl(x)) ∨ (∃y. y <span class="hidden">❙</span><span class="bold">∈</span> B ∧ u=Inr(y))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_subset_iff</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>A</span><span> </span><span class="delimiter">::</span><span> </span><span>hf</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A+B ≤ C+D ⟷ A≤C ∧ B≤D"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_equal_iff</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>A</span><span> </span><span class="delimiter">::</span><span> </span><span>hf</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A+B = C+D ⟷ A=C ∧ B=D"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hf_ext</span><span> </span><span>sum_subset_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_hsum</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_hsum z = (∃x. z = Inl x ∨ z = Inr x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>sum_case</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(hf ⇒ 'a) ⇒ (hf ⇒ 'a) ⇒ hf ⇒ 'a"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sum_case f g a ≡
    THE z. (∀x. a = Inl x ⟶ z = f x) ∧ (∀y. a = Inr y ⟶ z = g y) ∧ (¬ is_hsum a ⟶ z = undefined)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_case_Inl</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sum_case f g (Inl x) = f x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sum_case_def</span><span> </span><span>is_hsum_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_case_Inr</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sum_case f g (Inr y) = g y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sum_case_def</span><span> </span><span>is_hsum_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_case_non</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_hsum a ⟹ sum_case f g a = undefined"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sum_case_def</span><span> </span><span>is_hsum_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_hsum_cases</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃x. z = Inl x ∨ z = Inr x) ∨ ¬ is_hsum z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_hsum_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_case_split</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"P (sum_case f g a) ⟷ (∀x. a = Inl x ⟶ P(f x)) ∧ (∀y. a = Inr y ⟶ P(g y)) ∧ (¬ is_hsum a ⟶ P undefined)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_hsum a"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_hsum_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_case_split_asm</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"P (sum_case f g a) ⟷ ¬ ((∃x. a = Inl x ∧ ¬ P(f x)) ∨ (∃y. a = Inr y ∧ ¬ P(g y)) ∨ (¬ is_hsum a ∧ ¬ P undefined))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sum_case_split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Ordinal">
<div class="head"><h1>Theory Ordinal</h1>
<span class="command">theory</span> <span class="name">Ordinal</span><br/>
<span class="keyword">imports</span> <a href="HF.html"><span class="name">HF</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ordinals, Sequences and Ordinal Recursion›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Ordinal</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>HF</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ordinals›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Basic Definitions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition 2.1. We say that x is transitive if every element of x is a subset of x.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>Transset</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ bool"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Transset(x) ≡ ∀y. y <span class="hidden">❙</span><span class="bold">∈</span> x ⟶ y ≤ x"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Transset_sup</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Transset x ⟹ Transset y ⟹ Transset (x ⊔ y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Transset_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Transset_inf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Transset x ⟹ Transset y ⟹ Transset (x ⊓ y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Transset_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Transset_hinsert</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Transset x ⟹ y ≤ x ⟹ Transset (x ◃ y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Transset_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹In HF, the ordinals are simply the natural numbers. But the definitions are the same
      as for transfinite ordinals.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>Ord</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ bool"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Ord(k)      ≡ Transset(k) ∧ (∀x <span class="hidden">❙</span><span class="bold">∈</span> k. Transset(x))"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition 2.2 (Successor).›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>succ</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ hf"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"succ(x)      ≡ hinsert x x"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>succ_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x <span class="hidden">❙</span><span class="bold">∈</span> succ y ⟷ x=y ∨ x <span class="hidden">❙</span><span class="bold">∈</span> y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>succ_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>succ_ne_self</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ≠ succ i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hmem_ne</span><span> </span><span>succ_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>succ_notin_self</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"succ i <span class="hidden">❙</span><span class="bold">∉</span> i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hmem_ne</span><span> </span><span>succ_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>succE</span><span> </span><span class="delimiter">[</span><span>elim</span><span class="delimiter">?</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x <span class="hidden">❙</span><span class="bold">∈</span> succ y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x=y"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"x <span class="hidden">❙</span><span class="bold">∈</span> y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>succ_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hmem_succ_ne</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"succ x <span class="hidden">❙</span><span class="bold">∈</span> y ⟹ x ≠ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hmem_not_refl</span><span> </span><span>succ_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hball_succ</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀x <span class="hidden">❙</span><span class="bold">∈</span> succ k. P x) ⟷ P k ∧ (∀x <span class="hidden">❙</span><span class="bold">∈</span> k. P x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>HBall_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hbex_succ</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃x <span class="hidden">❙</span><span class="bold">∈</span> succ k. P x) ⟷ P k ∨ (∃x <span class="hidden">❙</span><span class="bold">∈</span> k. P x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>HBex_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>One_hf_eq_succ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 = succ 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_hf_def</span><span> </span><span>succ_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zero_hmem_one</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x <span class="hidden">❙</span><span class="bold">∈</span> 1 ⟷ x = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_hf_eq_succ</span><span> </span><span>hmem_hempty</span><span> </span><span>succ_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hball_One</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀x<span class="hidden">❙</span><span class="bold">∈</span>1. P x) = P 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>One_hf_eq_succ</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hbex_One</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃x<span class="hidden">❙</span><span class="bold">∈</span>1. P x) = P 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>One_hf_eq_succ</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hpair_neq_succ</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨x,y⟩ ≠ succ k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>succ_def</span><span> </span><span>hpair_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hemptyE</span><span> </span><span>hmem_hinsert</span><span> </span><span>hmem_ne</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>succ_neq_hpair</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"succ k ≠ ⟨x,y⟩ "</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hpair_neq_succ</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hpair_neq_one</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨x,y⟩ ≠ 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_hf_eq_succ</span><span> </span><span>hpair_neq_succ</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>one_neq_hpair</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 ≠ ⟨x,y⟩"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hpair_neq_one</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hmem_succ_self</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"k <span class="hidden">❙</span><span class="bold">∈</span> succ k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>succ_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hmem_succ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l <span class="hidden">❙</span><span class="bold">∈</span> k ⟹ l <span class="hidden">❙</span><span class="bold">∈</span> succ k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>succ_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Theorem 2.3.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_0</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Ord_def</span><span> </span><span>Transset_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_succ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(k) ⟹ Ord(succ(k))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Ord_def</span><span> </span><span>Transset_def</span><span> </span><span>succ_def</span><span> </span><span>less_eq_insert2_iff</span><span> </span><span>HBall_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_1</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_hf_def</span><span> </span><span>Ord_0</span><span> </span><span>Ord_succ</span><span> </span><span>succ_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdmemD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(k) ⟹ j <span class="hidden">❙</span><span class="bold">∈</span> k ⟹ j ≤ k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Ord_def</span><span> </span><span>Transset_def</span><span> </span><span>HBall_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ i<span class="hidden">❙</span><span class="bold">∈</span>j;  j<span class="hidden">❙</span><span class="bold">∈</span>k;  Ord(k) ⟧  ⟹ i<span class="hidden">❙</span><span class="bold">∈</span>k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>OrdmemD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hmem_0_Ord</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(k)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>knz</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"k ≠ 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 <span class="hidden">❙</span><span class="bold">∈</span> k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>foundation</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>knz</span><span class="delimiter">]</span><span> </span><span>Ord_trans</span><span> </span><span>hempty_iff</span><span> </span><span>hinter_iff</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_in_Ord</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ Ord(k);  m <span class="hidden">❙</span><span class="bold">∈</span> k ⟧  ⟹ Ord(m)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Ord_def</span><span> </span><span>Transset_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Induction, Linearity, etc.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_induct</span><span> </span><span class="delimiter">[</span><span>consumes</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>step</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(k)"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x.⟦ Ord(x);  ⋀y. y <span class="hidden">❙</span><span class="bold">∈</span> x ⟹ P(y) ⟧  ⟹ P(x)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P(k)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀m <span class="hidden">❙</span><span class="bold">∈</span> k. Ord(m) ⟶ P(m)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>k</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>hf_induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>hinsert</span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Ord_in_Ord</span><span> </span><span>step</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>k</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Ord_in_Ord</span><span> </span><span>step</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Theorem 2.4 (Comparability of ordinals).›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_linear</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(k) ⟹ Ord(l) ⟹ k<span class="hidden">❙</span><span class="bold">∈</span>l ∨ k=l ∨ l<span class="hidden">❙</span><span class="bold">∈</span>k"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>k</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>l</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>Ord_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>step_k</span><span> </span><span class="delimiter">=</span><span> </span><span>step</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(l)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>l</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>Ord_induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step</span><span> </span><span>l</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_k</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_trans</span><span> </span><span>hf_equalityI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The trichotomy law for ordinals›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_linear_lt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>o</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(k)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(l)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span class="delimiter">(</span><span>lt</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"k<span class="hidden">❙</span><span class="bold">∈</span>l"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>eq</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"k=l"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>gt</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"l<span class="hidden">❙</span><span class="bold">∈</span>k"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_linear</span><span> </span><span>o</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_linear2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>o</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(k)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(l)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span class="delimiter">(</span><span>lt</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"k<span class="hidden">❙</span><span class="bold">∈</span>l"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>ge</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"l ≤ k"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_linear</span><span> </span><span>OrdmemD</span><span> </span><span>order_eq_refl</span><span> </span><span>o</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_linear_le</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>o</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(k)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(l)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span class="delimiter">(</span><span>le</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"k ≤ l"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>ge</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"l ≤ k"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_linear2</span><span> </span><span>OrdmemD</span><span> </span><span>o</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hunion_less_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦Ord i; Ord j⟧ ⟹ i ⊔ j &lt; k ⟷ i&lt;k ∧ j&lt;k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_linear_le</span><span> </span><span>le_iff_sup</span><span> </span><span>sup.order_iff</span><span> </span><span>sup.strict_boundedE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Theorem 2.5›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_mem_iff_lt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(k) ⟹ Ord(l) ⟹ k<span class="hidden">❙</span><span class="bold">∈</span>l ⟷ k &lt; l"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_linear</span><span> </span><span>OrdmemD</span><span> </span><span>hmem_not_refl</span><span> </span><span>less_hf_def</span><span> </span><span>less_le_not_le</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>le_succE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"succ i ≤ succ j ⟹ i ≤ j"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>less_eq_hf_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hmem_not_sym</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>le_succ_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord i ⟹ Ord j ⟹ succ i ≤ succ j ⟷ i ≤ j"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_linear_le</span><span> </span><span>Ord_succ</span><span> </span><span>le_succE</span><span> </span><span>order_antisym</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>succ_inject_iff</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"succ i = succ j ⟷ i = j"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>succ_def</span><span> </span><span>hmem_hinsert</span><span> </span><span>hmem_not_sym</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mem_succ_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord j ⟹ succ i <span class="hidden">❙</span><span class="bold">∈</span> succ j ⟷ i <span class="hidden">❙</span><span class="bold">∈</span> j"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_in_Ord</span><span> </span><span>Ord_mem_iff_lt</span><span> </span><span>Ord_succ</span><span> </span><span>succ_def</span><span> </span><span>less_eq_insert1_iff</span><span> </span><span>less_hf_def</span><span> </span><span>succ_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_mem_succ_cases</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(k)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l <span class="hidden">❙</span><span class="bold">∈</span> k"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"succ l = k ∨ succ l <span class="hidden">❙</span><span class="bold">∈</span> k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>mem_succ_iff</span><span> </span><span>succ_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Supremum and Infimum›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_Union</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ ⋀i. i<span class="hidden">❙</span><span class="bold">∈</span>A ⟹ Ord(i) ⟧  ⟹ Ord(⨆ A)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Ord_def</span><span> </span><span>Transset_def</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_Inter</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ ⋀i. i<span class="hidden">❙</span><span class="bold">∈</span>A ⟹ Ord(i) ⟧  ⟹ Ord(⨅ A)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"A=0"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Ord_def</span><span> </span><span>Transset_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hf_ext</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Theorem 2.7. Every set x of ordinals is ordered by the binary relation &lt;.
      Moreover if x = 0 then x has a smallest and a largest element.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hmem_Sup_Ords</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦A≠0; ⋀i. i<span class="hidden">❙</span><span class="bold">∈</span>A ⟹ Ord(i)⟧ ⟹ ⨆A <span class="hidden">❙</span><span class="bold">∈</span> A"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>A</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>hf_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>hinsert</span><span> </span><span>x</span><span> </span><span>A</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>A</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>hf_cases</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>hinsert</span><span> </span><span>y</span><span> </span><span>A'</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>UA</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⨆A <span class="hidden">❙</span><span class="bold">∈</span> A"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hinsert.IH</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>hinsert.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>hinsert_nonempty</span><span> </span><span>hmem_hinsert</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⨆A ≤ x ∨ x ≤ ⨆A"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_linear2</span><span> </span><span>OrdmemD</span><span> </span><span>hinsert.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>hmem_hinsert</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>HUnion_hinsert</span><span> </span><span>UA</span><span> </span><span>le_iff_sup</span><span> </span><span>less_eq_insert1_iff</span><span> </span><span>order_refl</span><span> </span><span>sup.commute</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hmem_Inf_Ords</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦A≠0; ⋀i. i<span class="hidden">❙</span><span class="bold">∈</span>A ⟹ Ord(i)⟧ ⟹ ⨅A <span class="hidden">❙</span><span class="bold">∈</span> A"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>A</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>hf_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>hinsert</span><span> </span><span>x</span><span> </span><span>A</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>A</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>hf_cases</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>hinsert</span><span> </span><span>y</span><span> </span><span>A'</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>IA</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⨅A <span class="hidden">❙</span><span class="bold">∈</span> A"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hinsert.IH</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>hinsert.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>hinsert_nonempty</span><span> </span><span>hmem_hinsert</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⨅A ≤ x ∨ x ≤ ⨅A"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_linear2</span><span> </span><span>OrdmemD</span><span> </span><span>hinsert.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>hmem_hinsert</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>HInter_hinsert</span><span> </span><span>IA</span><span> </span><span>hmem_hempty</span><span> </span><span>hmem_hinsert</span><span> </span><span>inf_absorb2</span><span> </span><span>le_iff_inf</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_pred</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦Ord(k); k ≠ 0⟧ ⟹ succ(⨆k) = k"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>HUnion_iff</span><span> </span><span>Ord_in_Ord</span><span> </span><span>Ord_mem_succ_cases</span><span> </span><span>hmem_Sup_Ords</span><span> </span><span>hmem_ne</span><span> </span><span>succ_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_cases</span><span> </span><span class="delimiter">[</span><span>cases</span><span> </span><span>type</span><span class="delimiter">:</span><span> </span><span>hf</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>0</span><span> </span><span>succ</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>Ok</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(k)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k = 0"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span>l</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord l"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"succ l = k"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ok</span><span> </span><span>Ord_in_Ord</span><span> </span><span>Ord_pred</span><span> </span><span>succ_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_induct2</span><span> </span><span class="delimiter">[</span><span>consumes</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>0</span><span> </span><span>succ</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>type</span><span class="delimiter">:</span><span> </span><span>hf</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(k)"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀k. Ord k ⟹ P k ⟹ P (succ k)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P k"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>k</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>k</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>Ord_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step</span><span> </span><span>k</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_cases</span><span> </span><span>P</span><span> </span><span>hmem_succ_self</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_succ_iff</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord (succ k) = Ord k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_in_Ord</span><span> </span><span>Ord_succ</span><span> </span><span>less_eq_insert1_iff</span><span> </span><span>order_refl</span><span> </span><span>succ_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"succ k ≠ 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hinsert_nonempty</span><span> </span><span>succ_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_Sup_succ_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord k ⟹ ⨆(succ k) = k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_pred</span><span> </span><span>Ord_succ_iff</span><span> </span><span>succ_inject_iff</span><span> </span><span>hinsert_nonempty</span><span> </span><span>succ_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_lt_succ_iff_le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord k ⟹ Ord l ⟹ k &lt; succ l ⟷ k ≤ l"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_mem_iff_lt</span><span> </span><span>Ord_succ_iff</span><span> </span><span>less_le_not_le</span><span> </span><span>order_eq_iff</span><span> </span><span>succ_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zero_in_Ord</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord k ⟹ k=0 ∨ 0 <span class="hidden">❙</span><span class="bold">∈</span> k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>k</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hpair_neq_Ord</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord k ⟹ ⟨x,y⟩ ≠ k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>k</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hpair_neq_Ord'</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord k"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k ≠ ⟨x,y⟩"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>k</span><span> </span><span>hpair_neq_Ord</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Not_Ord_hpair</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ Ord ⟨x,y⟩"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hpair_neq_Ord</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_hpair</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_hpair ⟨x,y⟩"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_hpair_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_not_hpair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord x ⟹ ¬ is_hpair x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Not_Ord_hpair</span><span> </span><span>is_hpair_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zero_in_succ</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord i ⟹ 0 <span class="hidden">❙</span><span class="bold">∈</span> succ i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>succ_iff</span><span> </span><span>zero_in_Ord</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Converting Between Ordinals and Natural Numbers›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>ord_of</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ hf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"ord_of 0 = 0"</span></span></span><span>
</span><span> </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ord_of (Suc k) = succ (ord_of k)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_ord_of</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord (ord_of k)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>k</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ord_of_inject</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ord_of i = ord_of j ⟷ i=j"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>i</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>j</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Zero_neq_Suc</span><span> </span><span>hempty_iff</span><span> </span><span>hmem_succ_self</span><span> </span><span>ord_of.elims</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>i</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>j</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Suc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ord_of_minus_1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n &gt; 0 ⟹ ord_of n = succ (ord_of (n - 1))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_diff_1</span><span> </span><span>ord_of.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>nat_of_ord</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ nat"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nat_of_ord x = (THE n. x = ord_of n)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nat_of_ord_ord_of</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat_of_ord (ord_of n) = n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nat_of_ord_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nat_of_ord_0</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat_of_ord 0 = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">)</span><span> </span><span>nat_of_ord_ord_of</span><span> </span><span>ord_of.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ord_of_nat_of_ord</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord x ⟹ ord_of (nat_of_ord x) = x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>Ord_induct2</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>nat_of_ord_ord_of</span><span> </span><span>ord_of.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nat_of_ord_inject</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord x ⟹ Ord y ⟹ nat_of_ord x = nat_of_ord y ⟷ x = y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ord_of_nat_of_ord</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nat_of_ord_succ</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord x ⟹ nat_of_ord (succ x) = Suc (nat_of_ord x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>nat_of_ord_ord_of</span><span> </span><span>ord_of.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>ord_of_nat_of_ord</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inj_ord_of</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inj_on ord_of A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inj_on_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfset_ord_of</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hfset (ord_of n) = ord_of ` {0..&lt;n}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hfset_hinsert</span><span> </span><span>succ_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bij_betw_ord_of</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bij_betw ord_of {0..&lt;n} (hfset (ord_of n))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bij_betw_def</span><span> </span><span>inj_ord_of</span><span> </span><span>hfset_ord_of</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bij_betw_ord_ofI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bij_betw h A {0..&lt;n} ⟹ bij_betw (ord_of ∘ h) A (hfset (ord_of n))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>bij_betw_ord_of</span><span> </span><span>bij_betw_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sequences and Ordinal Recursion›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition 3.2 (Sequence).›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Seq</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ hf ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Seq s k ⟷ hrelation s ∧ hfunction s ∧ k ≤ hdomain s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Seq_0</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Seq 0 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Seq_def</span><span> </span><span>hrelation_def</span><span> </span><span>hfunction_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Seq_succ_D</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Seq s (succ k) ⟹ Seq s k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Seq_def</span><span> </span><span>succ_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Seq_Ord_D</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Seq s k ⟹ l <span class="hidden">❙</span><span class="bold">∈</span> k ⟹ Ord k ⟹ Seq s l"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Seq_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Ord_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Seq_restr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Seq s (succ k) ⟹ Seq (hrestrict s k) k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Seq_def</span><span> </span><span>hfunction_restr</span><span> </span><span>succ_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Seq_Ord_restr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦Seq s k; l <span class="hidden">❙</span><span class="bold">∈</span> k; Ord k⟧ ⟹ Seq (hrestrict s l) l"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Seq_def</span><span> </span><span>hfunction_restr</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Ord_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Seq_ins</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦Seq s k; k <span class="hidden">❙</span><span class="bold">∉</span> hdomain s⟧ ⟹ Seq (s ◃ ⟨k, y⟩) (succ k)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Seq_def</span><span> </span><span>hrelation_def</span><span> </span><span>succ_def</span><span> </span><span>hfunction_def</span><span> </span><span>hdomainI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>insf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ hf ⇒ hf ⇒ hf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"insf s k y ≡ nonrestrict s ⦃k⦄ ◃ ⟨k, y⟩"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfunction_insf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hfunction s ⟹ hfunction (insf s k y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>insf_def</span><span> </span><span>hfunction_def</span><span> </span><span>nonrestrict_def</span><span> </span><span>hmem_not_refl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Seq_insf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Seq s k ⟹ Seq (insf s k y) (succ k)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Seq_def</span><span> </span><span>hrelation_def</span><span> </span><span>insf_def</span><span> </span><span>hfunction_def</span><span> </span><span>nonrestrict_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hdomain_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Seq_succ_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Seq s (succ k) ⟷ Seq s k ∧ (∃y. ⟨k, y⟩ <span class="hidden">❙</span><span class="bold">∈</span> s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Seq_def</span><span> </span><span>hdomain_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hfst_conv</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nonrestrictD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a <span class="hidden">❙</span><span class="bold">∈</span> nonrestrict s X ⟹ a <span class="hidden">❙</span><span class="bold">∈</span> s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nonrestrict_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hpair_in_nonrestrict_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨a,b⟩ <span class="hidden">❙</span><span class="bold">∈</span> nonrestrict s X ⟷ ⟨a,b⟩ <span class="hidden">❙</span><span class="bold">∈</span> s ∧ ¬ a <span class="hidden">❙</span><span class="bold">∈</span> X"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nonrestrict_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>app_nonrestrict_Seq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Seq s k ⟹ z <span class="hidden">❙</span><span class="bold">∉</span> X ⟹ app (nonrestrict s X) z = app s z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Seq_def</span><span> </span><span>nonrestrict_def</span><span> </span><span>app_def</span><span> </span><span>HBall_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>app_insf_Seq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Seq s k ⟹ app (insf s k y) k = y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Seq_def</span><span> </span><span>hfunction_insf</span><span> </span><span>app_equality</span><span> </span><span>hmem_hinsert</span><span> </span><span>insf_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>app_insf2_Seq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Seq s k ⟹ k' ≠ k ⟹ app (insf s k y) k' = app s k'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>app_nonrestrict_Seq</span><span> </span><span>insf_def</span><span> </span><span>app_ins2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>app_insf_Seq_if</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Seq s k ⟹ app (insf s k y) k' = (if k' = k then y else app s k')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>app_insf2_Seq</span><span> </span><span>app_insf_Seq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Seq_imp_eq_app</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦Seq s d; ⟨x,y⟩ <span class="hidden">❙</span><span class="bold">∈</span> s⟧ ⟹ app s x = y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Seq_def</span><span> </span><span>app_equality</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Seq_iff_app</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦Seq s d; x <span class="hidden">❙</span><span class="bold">∈</span> d⟧ ⟹ ⟨x,y⟩ <span class="hidden">❙</span><span class="bold">∈</span> s ⟷ app s x = y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Seq_def</span><span> </span><span>hdomain_def</span><span> </span><span>app_equality</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Exists_iff_app</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Seq s d ⟹ x <span class="hidden">❙</span><span class="bold">∈</span> d ⟹ (∃y. ⟨x, y⟩ <span class="hidden">❙</span><span class="bold">∈</span> s ∧ P y) = P (app s x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Seq_iff_app</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_trans2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦i2 <span class="hidden">❙</span><span class="bold">∈</span> i; i <span class="hidden">❙</span><span class="bold">∈</span> j;  j <span class="hidden">❙</span><span class="bold">∈</span> k;  Ord k⟧ ⟹ i2<span class="hidden">❙</span><span class="bold">∈</span>k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ord_rec_Seq</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ (hf ⇒ hf) ⇒ hf ⇒ hf ⇒ hf ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"ord_rec_Seq T G s k y ⟷
        (Seq s k ∧ y = G (app s (⨆k)) ∧ app s 0 = T ∧
                   (∀n. succ n <span class="hidden">❙</span><span class="bold">∈</span> k ⟶ app s (succ n) = G (app s n)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Seq_succ_insf</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Seq s (succ k)"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ y. s = insf s k y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨k, y⟩ <span class="hidden">❙</span><span class="bold">∈</span> s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Seq_succ_iff</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>yuniq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ y'. ⟨k, y'⟩ <span class="hidden">❙</span><span class="bold">∈</span> s ⟶ y' = y"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Seq_def</span><span> </span><span>hfunction_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>z</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>z</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z <span class="hidden">❙</span><span class="bold">∈</span> s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u</span><span> </span><span>v</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>uv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z = ⟨u, v⟩"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Seq_def</span><span> </span><span>hrelation_def</span><span> </span><span>is_hpair_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z <span class="hidden">❙</span><span class="bold">∈</span> insf s k y"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hemptyE</span><span> </span><span>hmem_hinsert</span><span> </span><span>hpair_in_nonrestrict_iff</span><span> </span><span>insf_def</span><span> </span><span>yuniq</span><span> </span><span>z</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>left2right</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s = insf s k y"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hf_equalityI</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hmem_hinsert</span><span> </span><span>insf_def</span><span> </span><span>left2right</span><span> </span><span>nonrestrictD</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ord_rec_Seq_succ_iff</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord k"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>knz</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"k ≠ 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ord_rec_Seq T G s (succ k) z ⟷ (∃ s' y. ord_rec_Seq T G s' k y ∧ z = G y ∧ s = insf s' k y)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>os</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ord_rec_Seq T G s (succ k) z"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃s' y. ord_rec_Seq T G s' k y ∧ z = G y ∧ s = insf s' k y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>s</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>os</span><span> </span><span>k</span><span> </span><span>knz</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Seq_insf</span><span> </span><span>ord_rec_Seq_def</span><span> </span><span>app_insf_Seq</span><span> </span><span>app_insf2_Seq</span><span>
</span><span>                          </span><span>hmem_succ_ne</span><span> </span><span>hmem_ne</span><span> </span><span>hmem_Sup_ne</span><span> </span><span>Seq_succ_iff</span><span> </span><span>hmem_0_Ord</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_pred</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_pred</span><span> </span><span>Seq_succ_iff</span><span> </span><span>Seq_succ_insf</span><span> </span><span>app_insf_Seq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ok</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃s' y. ord_rec_Seq T G s' k y ∧ z = G y ∧ s = insf s' k y"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ord_rec_Seq T G s (succ k) z"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ok</span><span> </span><span>k</span><span> </span><span>knz</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ord_rec_Seq_def</span><span> </span><span>app_insf_Seq_if</span><span> </span><span>hmem_ne</span><span> </span><span>hmem_succ_ne</span><span> </span><span>Seq_insf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ord_rec_Seq_functional</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"Ord k ⟹ k ≠ 0 ⟹ ord_rec_Seq T G s k y ⟹ ord_rec_Seq T G s' k y' ⟹ y' = y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>k</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>y</span><span> </span><span>y'</span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>Ord_induct2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ord_rec_Seq_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>succ</span><span> </span><span>k</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"k=0"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>succ</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ord_rec_Seq_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>succ</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ord_rec_Seq_succ_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ord_recp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ (hf ⇒ hf) ⇒ (hf ⇒ hf) ⇒ hf ⇒ hf ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"ord_recp T G H x y =
    (if x=0 then y = T
     else
       if Ord(x) then ∃ s. ord_rec_Seq T G s x y
       else y = H x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ord_recp_functional</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ord_recp T G H x y ⟹ ord_recp T G H x y' ⟹ y' = y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ord_recp_def</span><span> </span><span>ord_rec_Seq_functional</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ord_recp_succ_iff</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord k"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ord_recp T G H (succ k) z ⟷ (∃y. z = G y ∧ ord_recp T G H k y)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"k=0"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ord_recp_def</span><span> </span><span>ord_rec_Seq_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Seq_0</span><span> </span><span>Seq_insf</span><span> </span><span>app_insf_Seq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>k</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ord_recp_def</span><span> </span><span>ord_rec_Seq_succ_iff</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ord_rec</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ (hf ⇒ hf) ⇒ (hf ⇒ hf) ⇒ hf ⇒ hf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"ord_rec T G H x = (THE y. ord_recp T G H x y)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ord_rec_0</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ord_rec T G H 0 = T"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ord_recp_def</span><span> </span><span>ord_rec_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ord_recp_total</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃y. ord_recp T G H x y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord x"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>Ord_induct2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ord_recp_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>succ</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ord_recp_succ_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ord_recp_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ord_rec_succ</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord k"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ord_rec T G H (succ k) = G (ord_rec T G H k)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ord_recp_total</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>T</span><span> </span><span>G</span><span> </span><span>H</span><span> </span><span>k</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ord_recp T G H k y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>k</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ord_rec_def</span><span> </span><span>ord_recp_succ_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>theI2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>ord_recp_functional</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ord_rec_non</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ Ord x ⟹ ord_rec T G H x = H x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_0</span><span> </span><span>ord_rec_def</span><span> </span><span>ord_recp_def</span><span> </span><span>the_equality</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Rank">
<div class="head"><h1>Theory Rank</h1>
<span class="command">theory</span> <span class="name">Rank</span><br/>
<span class="keyword">imports</span> <a href="Ordinal.html"><span class="name">Ordinal</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹V-Sets, Epsilon Closure, Ranks›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Rank</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Ordinal</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹V-sets›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition 4.1›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Vset</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ hf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Vset x = ord_rec 0 HPow (λz. 0) x"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vset_0</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Vset 0 = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vset_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vset_succ</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord k ⟹ Vset (succ k) = HPow (Vset k)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vset_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vset_non</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ Ord x ⟹ Vset x = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Vset_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Theorem 4.2(a)›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vset_mono_strict</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord m"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n <span class="hidden">❙</span><span class="bold">∈</span> m"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Vset n &lt; Vset m"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord n"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_in_Ord</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord m ⟹ n <span class="hidden">❙</span><span class="bold">∈</span> m ⟹ Vset n &lt; Vset m"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>m</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>Ord_induct2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>HPow_iff</span><span> </span><span>Ord_cases</span><span> </span><span>Vset_0</span><span> </span><span>Vset_succ</span><span> </span><span>hemptyE</span><span> </span><span>le_imp_less_or_eq</span><span> </span><span>zero_le</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>succ</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord m›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_cases</span><span> </span><span>hemptyE</span><span> </span><span>HPow_mono_strict_iff</span><span> </span><span>Vset_succ</span><span> </span><span>mem_succ_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vset_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦Ord m; n ≤ m⟧ ⟹ Vset n ≤ Vset m"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_linear2</span><span> </span><span>Vset_mono_strict</span><span> </span><span>Vset_non</span><span> </span><span>order.order_iff_strict</span><span>
</span><span>            </span><span>order_class.order.antisym</span><span> </span><span>zero_le</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Theorem 4.2(b)›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vset_Transset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord m ⟹ Transset (Vset m)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>Ord_induct2</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Transset_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_sup</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord k ⟹ Ord l ⟹ Ord (k ⊔ l)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_linear_le</span><span> </span><span>le_iff_sup</span><span> </span><span>sup_absorb1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_inf</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord k ⟹ Ord l ⟹ Ord (k ⊓ l)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_linear_le</span><span> </span><span>inf_absorb2</span><span> </span><span>le_iff_inf</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Theorem 4.3›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vset_universal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃n. Ord n ∧ x <span class="hidden">❙</span><span class="bold">∈</span> Vset n"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>hf_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>HPow_iff</span><span> </span><span>Ord_0</span><span> </span><span>Ord_succ</span><span> </span><span>Vset_succ</span><span> </span><span>zero_le</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>hinsert</span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>na</span><span> </span><span>nb</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>nab</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord na"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a <span class="hidden">❙</span><span class="bold">∈</span> Vset na"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord nb"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b <span class="hidden">❙</span><span class="bold">∈</span> Vset nb"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ≤ Vset nb"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Vset_Transset</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>nb</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Transset_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ Vset (na ⊔ nb)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nab</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_sup</span><span> </span><span>Vset_mono</span><span> </span><span>sup_ge2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ◃ a <span class="hidden">❙</span><span class="bold">∈</span> Vset (succ (na ⊔ nb))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nab</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_sup</span><span> </span><span>Vset_mono</span><span> </span><span>sup_ge1</span><span> </span><span>rev_hsubsetD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nab</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_succ</span><span> </span><span>Ord_sup</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Least Ordinal Operator›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition 4.4. For every x, let rank(x) be the least ordinal n such that...›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_minimal</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"Ord k ⟹ P k ⟹ ∃n. Ord n ∧ P n ∧ (∀m. Ord m ∧ P m ⟶ n ≤ m)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>k</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>Ord_induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_linear2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdLeastI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord k ⟹ P k ⟹ P(LEAST n. Ord n ∧ P n)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>lifting</span><span class="delimiter">,</span><span> </span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Least_equality</span><span> </span><span>Ord_minimal</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdLeast_le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord k ⟹ P k ⟹ (LEAST n. Ord n ∧ P n) ≤ k"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>lifting</span><span class="delimiter">,</span><span> </span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Least_equality</span><span> </span><span>Ord_minimal</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdLeast_Ord</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord k"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P k"</span></span></span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(LEAST n. Ord n ∧ P n)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord n"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P n"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀m. Ord m ∧ P m ⟶ n ≤ m"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_minimal</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Least_equality</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Rank Function›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rank</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ hf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rank x = (LEAST n. Ord n ∧ x <span class="hidden">❙</span><span class="bold">∈</span> Vset (succ n))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank 0 = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rank_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>lifting</span><span class="delimiter">)</span><span> </span><span>HPow_iff</span><span> </span><span>Least_equality</span><span> </span><span>Ord_0</span><span> </span><span>Vset_succ</span><span> </span><span>zero_le</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_Vset_rank</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a <span class="hidden">❙</span><span class="bold">∈</span> Vset(succ(rank a))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Vset_universal</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>na</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>na</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord na"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a <span class="hidden">❙</span><span class="bold">∈</span> Vset (succ na)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_Union</span><span> </span><span>Ord_in_Ord</span><span> </span><span>Ord_pred</span><span> </span><span>Vset_0</span><span> </span><span>hempty_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>rank_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>OrdLeastI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_rank</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord (rank a)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_succ_iff</span><span> </span><span>Vset_non</span><span> </span><span>hemptyE</span><span> </span><span>in_Vset_rank</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>le_Vset_rank</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≤ Vset(rank a)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>HPow_iff</span><span> </span><span>Ord_succ_iff</span><span> </span><span>Vset_non</span><span> </span><span>Vset_succ</span><span> </span><span>hemptyE</span><span> </span><span>in_Vset_rank</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>VsetI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"succ(rank a) ≤ k ⟹ Ord k ⟹ a <span class="hidden">❙</span><span class="bold">∈</span> Vset k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Vset_mono</span><span> </span><span>hsubsetCE</span><span> </span><span>in_Vset_rank</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vset_succ_rank_le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord k ⟹ a <span class="hidden">❙</span><span class="bold">∈</span> Vset (succ k) ⟹ rank a ≤ k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>rank_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>OrdLeast_le</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Vset_rank_lt</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a <span class="hidden">❙</span><span class="bold">∈</span> Vset k"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rank a &lt; k"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord k"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>k</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>Ord_cases</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>succ</span><span> </span><span>l</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_lt_succ_iff_le</span><span> </span><span>Ord_succ_iff</span><span> </span><span>Vset_non</span><span> </span><span>Vset_succ_rank_le</span><span> </span><span>hemptyE</span><span> </span><span>in_Vset_rank</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Vset_non</span><span> </span><span>hemptyE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Theorem 4.5›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>rank_lt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a <span class="hidden">❙</span><span class="bold">∈</span> b ⟹ rank(a) &lt; rank(b)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Vset_rank_lt</span><span> </span><span>hsubsetD</span><span> </span><span>le_Vset_rank</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rank_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ y ⟹ rank x ≤ rank y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>HPow_iff</span><span> </span><span>Ord_rank</span><span> </span><span>Vset_succ</span><span> </span><span>Vset_succ_rank_le</span><span> </span><span>dual_order.trans</span><span> </span><span>le_Vset_rank</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rank_sup</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank (a ⊔ b) = rank a ⊔ rank b"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>o</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord (rank a ⊔ rank b)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rank (a ⊔ b) ≤ rank a ⊔ rank b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Vset_succ_rank_le</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>le_Vset_rank</span><span> </span><span>order_trans</span><span> </span><span>Vset_mono</span><span> </span><span>sup_ge1</span><span> </span><span>sup_ge2</span><span> </span><span>o</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rank a ⊔ rank b ≤ rank (a ⊔ b)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>le_supI</span><span> </span><span>le_supI1</span><span> </span><span>le_supI2</span><span> </span><span>order_eq_refl</span><span> </span><span>rank_mono</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rank_singleton</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank ⦃a⦄ = succ(rank a)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>oba</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord (succ (rank a))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rank ⦃a⦄ ≤ succ (rank a)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Vset_succ_rank_le</span><span> </span><span>HPow_iff</span><span> </span><span>Vset_succ</span><span> </span><span>in_Vset_rank</span><span> </span><span>less_eq_insert1_iff</span><span> </span><span>oba</span><span> </span><span>zero_le</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"succ (rank a) ≤ rank⦃a⦄"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_linear_le</span><span> </span><span>Ord_lt_succ_iff_le</span><span> </span><span>rank_lt</span><span> </span><span>Ord_rank</span><span> </span><span>hmem_hinsert</span><span> </span><span>less_le_not_le</span><span> </span><span>oba</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rank_hinsert</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank (b ◃ a) = rank b ⊔ succ(rank a)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hinsert_eq_sup</span><span> </span><span>rank_singleton</span><span> </span><span>rank_sup</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition 4.6. The transitive closure of @{term x} is
 the minimal transitive set @{term y} such that @{term"x≤y"}.›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Epsilon Closure›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>eclose</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ hf"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"eclose X = ⨅ ⦃Y <span class="hidden">❙</span><span class="bold">∈</span> HPow(Vset (rank X)). Transset Y ∧ X≤Y⦄"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eclose_facts</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>Transset_eclose</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Transset (eclose X)"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span>le_eclose</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ≤ eclose X"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nz</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃Y <span class="hidden">❙</span><span class="bold">∈</span> HPow(Vset (rank X)). Transset Y ∧ X≤Y⦄ ≠ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eclose_def</span><span> </span><span>hempty_iff</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_rank</span><span> </span><span>Vset_Transset</span><span> </span><span>le_Vset_rank</span><span> </span><span>order_refl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Transset (eclose X)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ≤ eclose X"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HInter_iff</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>nz</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eclose_def</span><span> </span><span>Transset_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eclose_minimal</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>Y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Transset Y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X≤Y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eclose X ≤ Y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃Y <span class="hidden">❙</span><span class="bold">∈</span> HPow(Vset (rank X)). Transset Y ∧ X≤Y⦄ ≠ 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eclose_def</span><span> </span><span>hempty_iff</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_rank</span><span> </span><span>Vset_Transset</span><span> </span><span>le_Vset_rank</span><span> </span><span>order_refl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Transset (Y ⊓ Vset (rank X))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_rank</span><span> </span><span>Transset_inf</span><span> </span><span>Vset_Transset</span><span> </span><span>Y</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ≤ Y ⊓ Vset (rank X)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Y</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>le_Vset_rank</span><span> </span><span>le_inf_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eclose X ≤ Y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eclose_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hinter_iff</span><span> </span><span>le_inf_iff</span><span> </span><span>order_refl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eclose_0</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"eclose 0 = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_0</span><span> </span><span>Vset_0</span><span> </span><span>Vset_Transset</span><span> </span><span>eclose_minimal</span><span> </span><span>less_eq_hempty</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eclose_sup</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"eclose (a ⊔ b) = eclose a ⊔ eclose b"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eclose (a ⊔ b) ≤ eclose a ⊔ eclose b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Transset_eclose</span><span> </span><span>Transset_sup</span><span> </span><span>eclose_minimal</span><span> </span><span>le_eclose</span><span> </span><span>sup_mono</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eclose a ⊔ eclose b ≤ eclose (a ⊔ b)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Transset_eclose</span><span> </span><span>eclose_minimal</span><span> </span><span>le_eclose</span><span> </span><span>le_sup_iff</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eclose_singleton</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"eclose ⦃a⦄ = (eclose a) ◃ a"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eclose ⦃a⦄ ≤ eclose a ◃ a"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>eclose_minimal</span><span> </span><span>Transset_eclose</span><span> </span><span>Transset_hinsert</span><span>
</span><span>              </span><span>le_eclose</span><span> </span><span>less_eq_insert1_iff</span><span> </span><span>order_refl</span><span> </span><span>zero_le</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eclose a ◃ a ≤ eclose ⦃a⦄"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Transset_def</span><span> </span><span>Transset_eclose</span><span> </span><span>eclose_minimal</span><span> </span><span>le_eclose</span><span> </span><span>less_eq_insert1_iff</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eclose_hinsert</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"eclose (b ◃ a) = eclose b ⊔ (eclose a ◃ a)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>eclose_singleton</span><span> </span><span>eclose_sup</span><span> </span><span>hinsert_eq_sup</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eclose_succ</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"eclose (succ a) = eclose a ◃ a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>succ_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fst_in_eclose</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x <span class="hidden">❙</span><span class="bold">∈</span> eclose ⟨x, y⟩"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>eclose_hinsert</span><span> </span><span>hmem_hinsert</span><span> </span><span>hpair_def</span><span> </span><span>hunion_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snd_in_eclose</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y <span class="hidden">❙</span><span class="bold">∈</span> eclose ⟨x, y⟩"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>eclose_hinsert</span><span> </span><span>hmem_hinsert</span><span> </span><span>hpair_def</span><span> </span><span>hunion_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Theorem 4.7. rank(x) = rank(cl(x)).›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rank_eclose</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rank (eclose x) = rank x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>hf_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>hinsert</span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hinsert_eq_sup</span><span> </span><span>succ_def</span><span> </span><span>sup.left_idem</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Epsilon-Recursion›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Theorem 4.9.  Definition of a function by recursion on rank.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hmem_induct</span><span> </span><span class="delimiter">[</span><span>case_names</span><span> </span><span>step</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ih</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. (⋀y. y <span class="hidden">❙</span><span class="bold">∈</span> x ⟹ P y) ⟹ P x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀y. y <span class="hidden">❙</span><span class="bold">∈</span> x ⟹ P y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>hf_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>hinsert</span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>hmem_hinsert</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ih</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>hmem_rel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(hf * hf) set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hmem_rel = trancl {(x,y). x <span class="hidden">❙</span><span class="bold">∈</span> y}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_hmem_rel</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf hmem_rel"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf {(x,y). x <span class="hidden">❙</span><span class="bold">∈</span> y}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>hmem_induct</span><span> </span><span>wfPUNIVI</span><span> </span><span>wfP_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hmem_rel_def</span><span> </span><span>wf_trancl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hmem_eclose_le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y <span class="hidden">❙</span><span class="bold">∈</span> x ⟹ eclose y ≤ eclose x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Transset_def</span><span> </span><span>Transset_eclose</span><span> </span><span>eclose_minimal</span><span> </span><span>hsubsetD</span><span> </span><span>le_eclose</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hmem_rel_iff_hmem_eclose</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x,y) ∈ hmem_rel ⟷ x <span class="hidden">❙</span><span class="bold">∈</span> eclose y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>hmem_rel_def</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ trancl {(x, y). x <span class="hidden">❙</span><span class="bold">∈</span> y}"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x <span class="hidden">❙</span><span class="bold">∈</span> eclose y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>trancl_induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>base</span><span> </span><span>y</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hsubsetCE</span><span> </span><span>le_eclose</span><span> </span><span>mem_Collect_eq</span><span> </span><span>split_conv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step</span><span> </span><span>y</span><span> </span><span>z</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hmem_eclose_le</span><span> </span><span>hsubsetD</span><span> </span><span>mem_Collect_eq</span><span> </span><span>split_conv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Transset ⦃x <span class="hidden">❙</span><span class="bold">∈</span> eclose y. (x, y) ∈ hmem_rel⦄"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Transset_eclose</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Transset_def</span><span> </span><span>hmem_rel_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>trancl_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eclose y ≤ ⦃x <span class="hidden">❙</span><span class="bold">∈</span> eclose y. (x, y) ∈ hmem_rel⦄"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>eclose_minimal</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>le_HCollect_iff</span><span> </span><span>le_eclose</span><span> </span><span>hmem_rel_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x <span class="hidden">❙</span><span class="bold">∈</span> eclose y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ trancl {(x, y). x <span class="hidden">❙</span><span class="bold">∈</span> y}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>HCollect_iff</span><span> </span><span>hmem_rel_def</span><span> </span><span>hsubsetD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hmemrec</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"((hf ⇒ 'a) ⇒ hf ⇒ 'a) ⇒ hf ⇒ 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hmemrec G ≡ wfrec hmem_rel G"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ecut</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(hf ⇒ 'a) ⇒ hf ⇒ hf ⇒ 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ecut f x ≡ (λy. if y <span class="hidden">❙</span><span class="bold">∈</span> eclose x then f y else undefined)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hmemrec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hmemrec G a = G (ecut (hmemrec G) a) a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cut_def</span><span> </span><span>ecut_def</span><span> </span><span>hmem_rel_iff_hmem_eclose</span><span> </span><span>def_wfrec</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>hmemrec_def</span><span> </span><span>wf_hmem_rel</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This form avoids giant explosions in proofs.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>def_hmemrec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ≡ hmemrec G ⟹ f a = G (ecut (hmemrec G) a) a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hmemrec</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ecut_apply</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y <span class="hidden">❙</span><span class="bold">∈</span> eclose x ⟹ ecut f x y = f y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ecut_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>RepFun_ecut</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ≤ z ⟹ RepFun y (ecut f z) = RepFun y f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hf_ext</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ecut_def</span><span> </span><span>hsubsetD</span><span> </span><span>le_eclose</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ecut_apply</span><span> </span><span>le_eclose</span><span> </span><span>hsubsetD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Now, a stronger induction rule, for the transitive closure of membership›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hmem_rel_induct</span><span> </span><span class="delimiter">[</span><span>case_names</span><span> </span><span>step</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ih</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. (⋀y. (y,x) ∈ hmem_rel ⟹ P y) ⟹ P x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀y. (y,x) ∈ hmem_rel ⟹ P y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>hf_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>eclose_0</span><span> </span><span>hmem_hempty</span><span> </span><span>hmem_rel_iff_hmem_eclose</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>hinsert</span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>eclose_hinsert</span><span> </span><span>hmem_hinsert</span><span> </span><span>hmem_rel_iff_hmem_eclose</span><span> </span><span>hunion_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rank_HUnion_less</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x ≠ 0 ⟹ rank (⨆x) &lt; rank x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>hf_induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hmem_hinsert</span><span> </span><span>rank_hinsert</span><span> </span><span>rank_lt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>HUnion_hempty</span><span> </span><span>Ord_lt_succ_iff_le</span><span> </span><span>Ord_rank</span><span> </span><span>hunion_hempty_right</span><span>
</span><span>               </span><span>less_supI1</span><span> </span><span>less_supI2</span><span> </span><span>rank_sup</span><span> </span><span>sup.cobounded2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>Sup_ne</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≠ 0 ⟹ ⨆x ≠ x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>less_irrefl</span><span> </span><span>rank_HUnion_less</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Finite_Automata">
<div class="head"><h1>Theory Finite_Automata</h1>
<span class="command">theory</span> <span class="name">Finite_Automata</span><br/>
<span class="keyword">imports</span> <a href="Ordinal.html"><span class="name">Ordinal</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹An Application: Finite Automata›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Finite_Automata</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Ordinal</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The point of this example is that the HF sets are closed under disjoint sums and Cartesian products,
 allowing the theory of finite state machines to be developed without issues of polymorphism
 or any tricky encodings of states.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">record</span></span><span> </span><span class="tfree">'a</span><span> </span><span>fsm</span><span> </span><span class="delimiter">=</span><span> </span><span>states</span><span> </span><span class="delimiter">::</span><span> </span><span>hf</span><span>
</span><span>                </span><span>init</span><span> </span><span class="delimiter">::</span><span> </span><span>hf</span><span>
</span><span>                </span><span>final</span><span> </span><span class="delimiter">::</span><span> </span><span>hf</span><span>
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"next"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ 'a ⇒ hf ⇒ bool"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>reaches</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"['a fsm, hf, 'a list, hf] ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>Nil</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"st <span class="hidden">❙</span><span class="bold">∈</span> states fsm ⟹ reaches fsm st [] st"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦next fsm st x st''; reaches fsm st'' xs st'; st <span class="hidden">❙</span><span class="bold">∈</span> states fsm⟧ ⟹ reaches fsm st (x#xs) st'"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>reaches.intros</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">inductive_simps</span></span><span> </span><span>reaches_Nil</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"reaches fsm st [] st'"</span></span></span><span>
</span><span class="keyword1"><span class="command">inductive_simps</span></span><span> </span><span>reaches_Cons</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reaches fsm st (x#xs) st'"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reaches_imp_states</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reaches fsm st xs st' ⟹ st <span class="hidden">❙</span><span class="bold">∈</span> states fsm ∧ st' <span class="hidden">❙</span><span class="bold">∈</span> states fsm"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>st</span><span> </span><span>st'</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reaches_append_iff</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"reaches fsm st (xs@ys) st' ⟷ (∃st''. reaches fsm st xs st'' ∧ reaches fsm st'' ys st')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>ys</span><span> </span><span>st</span><span> </span><span>st'</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>reaches_imp_states</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>accepts</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a fsm ⇒ 'a list ⇒ bool"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"accepts fsm xs ≡ ∃st st'. reaches fsm st xs st' ∧ st <span class="hidden">❙</span><span class="bold">∈</span> init fsm ∧ st' <span class="hidden">❙</span><span class="bold">∈</span> final fsm"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>regular</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list set ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"regular S ≡ ∃fsm. S = {xs. accepts fsm xs}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Null</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Null = ⦇states = 0, init = 0, final = 0, next = λst x st'. False⦈"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>regular_empty</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"regular {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>regular_def</span><span> </span><span>accepts_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hempty_iff</span><span> </span><span>simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>NullStr</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"NullStr ≡ ⦇states = 1, init = 1, final = 1, next = λst x st'. False⦈"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>regular_emptystr</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"regular {[]}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>regular_def</span><span> </span><span>accepts_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>NullStr</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>x</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>SingStr</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"SingStr a ≡ ⦇states = ⦃0, 1⦄, init = ⦃0⦄, final = ⦃1⦄, next = λst x st'. st=0 ∧ x=a ∧ st'=1⦈"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>regular_singstr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"regular {[a]}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>regular_def</span><span> </span><span>accepts_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"SingStr a"</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>x</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>list</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Reverse</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Reverse fsm = ⦇states = states fsm, init = final fsm, final = init fsm,
                  next = λst x st'. next fsm st' x st⦈"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Reverse_Reverse_ident</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Reverse (Reverse fsm) = fsm"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Reverse_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reaches_Reverse_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"reaches (Reverse fsm) st (rev xs) st' ⟷ reaches fsm st' xs st"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>st</span><span> </span><span>st'</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Reverse_def</span><span> </span><span>reaches_append_iff</span><span> </span><span>reaches_imp_states</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reaches_Reverse_iff2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"reaches (Reverse fsm) st' xs st ⟷ reaches fsm st (rev xs) st'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>reaches_Reverse_iff</span><span> </span><span>rev_rev_ident</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"init (Reverse fsm) = final fsm"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Reverse_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"final (Reverse fsm) = init fsm"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Reverse_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>regular_rev</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"regular S ⟹ regular (rev ` S)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>regular_def</span><span> </span><span>accepts_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"Reverse fsm"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Times</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Times fsm1 fsm2 = ⦇states = states fsm1 * states fsm2,
                      init = init fsm1 * init fsm2,
                      final = final fsm1 * final fsm2,
                      next = λst x st'. (∃st1 st2 st1' st2'. st = ⟨st1,st2⟩ ∧ st' = ⟨st1',st2'⟩ ∧
                                      next fsm1 st1 x st1' ∧ next fsm2 st2 x st2')⦈"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>states_Times</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"states (Times fsm1 fsm2) = states fsm1 * states fsm2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Times_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>init_Times</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"init (Times fsm1 fsm2) = init fsm1 * init fsm2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Times_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>final_Times</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"final (Times fsm1 fsm2) = final fsm1 * final fsm2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Times_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>next_Times</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"next (Times fsm1 fsm2) ⟨st1,st2⟩ x st' ⟷
    (∃st1' st2'. st' = ⟨st1',st2'⟩ ∧ next fsm1 st1 x st1' ∧ next fsm2 st2 x st2')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Times_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reaches_Times_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"reaches (Times fsm1 fsm2) ⟨st1,st2⟩ xs ⟨st1',st2'⟩ ⟷
      reaches fsm1 st1 xs st1' ∧ reaches fsm2 st2 xs st2'"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>st1</span><span> </span><span>st2</span><span> </span><span>st1'</span><span> </span><span>st2'</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>next_Times</span><span> </span><span>Times_def</span><span> </span><span>reaches.Cons</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>accepts_Times_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"accepts (Times fsm1 fsm2) xs ⟷
      accepts fsm1 xs ∧ accepts fsm2 xs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>accepts_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>regular_Int</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"regular S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>T</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"regular T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"regular (S ∩ T)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>fsmS</span><span> </span><span>fsmT</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S = {xs. accepts fsmS xs}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T = {xs. accepts fsmT xs}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S</span><span> </span><span>T</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>regular_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ∩ T = {xs. accepts (Times fsmS fsmT) xs}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>accepts_Times_iff</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>fsmS</span><span> </span><span>fsmT</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>regular_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Plus</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Plus fsm1 fsm2 = ⦇states = states fsm1 + states fsm2,
                      init = init fsm1 + init fsm2,
                      final = final fsm1 + final fsm2,
                      next = λst x st'. (∃st1 st1'. st = Inl st1 ∧ st' = Inl st1' ∧ next fsm1 st1 x st1') ∨
                                       (∃st2 st2'. st = Inr st2 ∧ st' = Inr st2' ∧ next fsm2 st2 x st2')⦈"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>states_Plus</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"states (Plus fsm1 fsm2) = states fsm1 + states fsm2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Plus_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>init_Plus</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"init (Plus fsm1 fsm2) = init fsm1 + init fsm2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Plus_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>final_Plus</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"final (Plus fsm1 fsm2) = final fsm1 + final fsm2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Plus_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>next_Plus1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"next (Plus fsm1 fsm2) (Inl st1) x st' ⟷ (∃st1'. st' = Inl st1' ∧ next fsm1 st1 x st1')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Plus_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>next_Plus2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"next (Plus fsm1 fsm2) (Inr st2) x st' ⟷ (∃st2'. st' = Inr st2' ∧ next fsm2 st2 x st2')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Plus_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reaches_Plus_iff1</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"reaches (Plus fsm1 fsm2) (Inl st1) xs st' ⟷
      (∃st1'. st' = Inl st1' ∧ reaches fsm1 st1 xs st1')"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>st1</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>next_Plus1</span><span> </span><span>reaches.Cons</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reaches_Plus_iff2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"reaches (Plus fsm1 fsm2) (Inr st2) xs st' ⟷
      (∃st2'. st' = Inr st2' ∧ reaches fsm2 st2 xs st2')"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>st2</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>next_Plus2</span><span> </span><span>reaches.Cons</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reaches_Plus_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"reaches (Plus fsm1 fsm2) st xs st' ⟷
      (∃st1 st1'. st = Inl st1 ∧ st' = Inl st1' ∧ reaches fsm1 st1 xs st1') ∨
      (∃st2 st2'. st = Inr st2 ∧ st' = Inr st2' ∧ reaches fsm2 st2 xs st2')"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>st</span><span> </span><span>st'</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>next_Plus1</span><span> </span><span>next_Plus2</span><span> </span><span>Plus_def</span><span> </span><span>reaches.Cons</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Plus_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>accepts_Plus_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"accepts (Plus fsm1 fsm2) xs ⟷ accepts fsm1 xs ∨ accepts fsm2 xs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>accepts_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sum_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>regular_Un</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"regular S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>T</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"regular T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"regular (S ∪ T)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>fsmS</span><span> </span><span>fsmT</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S = {xs. accepts fsmS xs}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T = {xs. accepts fsmT xs}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S</span><span> </span><span>T</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>regular_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ∪ T = {xs. accepts (Plus fsmS fsmT) xs}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>accepts_Plus_iff</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>fsmS</span><span> </span><span>fsmT</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>regular_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Finitary">
<div class="head"><h1>Theory Finitary</h1>
<span class="command">theory</span> <span class="name">Finitary</span><br/>
<span class="keyword">imports</span> <a href="Ordinal.html"><span class="name">Ordinal</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Finitary</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Ordinal</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>finitary</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>hf_of</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ hf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>inj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inj hf_of"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hf_of_eq_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf_of x = hf_of y ⟷ x=y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inj</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inj_on_def</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>unit</span><span> </span><span class="delimiter">::</span><span> </span><span>finitary</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hf_of_unit_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf_of (u::unit) ≡ 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inj_on_def</span><span> </span><span>hf_of_unit_def</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>bool</span><span> </span><span class="delimiter">::</span><span> </span><span>finitary</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hf_of_bool_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf_of b ≡ if b then 1 else 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inj_on_def</span><span> </span><span>hf_of_bool_def</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>nat</span><span> </span><span class="delimiter">::</span><span> </span><span>finitary</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hf_of_nat_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf_of ≡ ord_of"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inj_on_def</span><span> </span><span>hf_of_nat_def</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>int</span><span> </span><span class="delimiter">::</span><span> </span><span>finitary</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hf_of_int_def</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"hf_of i ≡ if i≥(0::int) then ⟨0, hf_of (nat i)⟩ else ⟨1, hf_of (nat (-i))⟩"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inj_on_def</span><span> </span><span>hf_of_int_def</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Strings are char lists, and are not considered separately.›</span></span></span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>char</span><span> </span><span class="delimiter">::</span><span> </span><span>finitary</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hf_of_char_def</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"hf_of x ≡ hf_of (of_char x :: nat)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inj_on_def</span><span> </span><span>hf_of_char_def</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>prod</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>finitary</span><span class="delimiter">,</span><span>finitary</span><span class="delimiter">)</span><span> </span><span>finitary</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hf_of_prod_def</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"hf_of ≡ λ(x,y). ⟨hf_of x, hf_of y⟩"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inj_on_def</span><span> </span><span>hf_of_prod_def</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>sum</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>finitary</span><span class="delimiter">,</span><span>finitary</span><span class="delimiter">)</span><span> </span><span>finitary</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hf_of_sum_def</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"hf_of ≡ case_sum (HF.Inl o hf_of) (HF.Inr o hf_of)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inj_on_def</span><span> </span><span>hf_of_sum_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>sum.split_asm</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>option</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>finitary</span><span class="delimiter">)</span><span> </span><span>finitary</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hf_of_option_def</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"hf_of ≡ case_option 0 (λx. ⦃hf_of x⦄)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inj_on_def</span><span> </span><span>hf_of_option_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split_asm</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>list</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>finitary</span><span class="delimiter">)</span><span> </span><span>finitary</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>hf_of_list</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"hf_of_list Nil = 0"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf_of_list (x#xs) = ⟨hf_of x, hf_of_list xs⟩"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hf_of x = hf_of y ⟹ x = y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>x</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>y</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">)</span><span> </span><span>hf_of_list.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>hpair_nonzero</span><span> </span><span>neq_Nil_conv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>y</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inj_on_def</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="OrdArith">
<div class="head"><h1>Theory OrdArith</h1>
<span class="command">theory</span> <span class="name">OrdArith</span><br/>
<span class="keyword">imports</span> <a href="Rank.html"><span class="name">Rank</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Addition, Sequences and their Concatenation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>OrdArith</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Rank</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Generalised Addition --- Also for Ordinals›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Source: Laurence Kirby, Addition and multiplication of sets
      Math. Log. Quart. 53, No. 1, 52-65 (2007) / DOI 10.1002/malq.200610026
      @{url "http://faculty.baruch.cuny.edu/lkirby/mlqarticlejan2007.pdf"}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>hadd</span><span>      </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ hf ⇒ hf"</span></span></span><span>           </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"@+"</span></span></span><span> </span><span>65</span><span class="delimiter">)</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"hadd x ≡ hmemrec (λf z. x ⊔ RepFun z f)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hadd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x @+ y = x ⊔ RepFun y (λz. x @+ z)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>def_hmemrec</span><span> </span><span>RepFun_ecut</span><span> </span><span>hadd_def</span><span> </span><span>order_refl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hmem_hadd_E</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l <span class="hidden">❙</span><span class="bold">∈</span> x @+ y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l <span class="hidden">❙</span><span class="bold">∈</span> x"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span>z</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z <span class="hidden">❙</span><span class="bold">∈</span> y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l = x @+ z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hadd</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hadd_0_right</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x @+ 0 = x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>hadd</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hadd_hinsert_right</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x @+ hinsert y z = hinsert (x @+ y) (x @+ z)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hadd</span><span> </span><span>hunion_hinsert_right</span><span> </span><span>RepFun_hinsert</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hadd_succ_right</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x @+ succ y = succ (x @+ y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hadd_hinsert_right</span><span> </span><span>succ_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_add_less_right</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (x @+ y &lt; x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>y</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>less_supI1</span><span> </span><span>hadd</span><span> </span><span>order_less_le</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_add_mem_right</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (x @+ y <span class="hidden">❙</span><span class="bold">∈</span> x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hadd</span><span> </span><span>hmem_not_refl</span><span> </span><span>hunion_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hadd_0_left</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 @+ x = x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hadd_hinsert_right</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hadd_succ_left</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord y ⟹ succ x @+ y = succ (x @+ y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>y</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>Ord_induct2</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hadd_assoc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x @+ y) @+ z = x @+ (y @+ z)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>z</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hadd_hinsert_right</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>RepFun_hadd_disjoint</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊓ RepFun y ((@+) x) = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hf_equalityI</span><span> </span><span>RepFun_iff</span><span> </span><span>hinter_iff</span><span> </span><span>not_add_mem_right</span><span> </span><span>hmem_hempty</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Cancellation laws for addition›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Rep_le_Cancel</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊔ RepFun y ((@+) x) ≤ x ⊔ RepFun z ((@+) x)
                      ⟹ RepFun y ((@+) x) ≤ RepFun z ((@+) x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>not_add_mem_right</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hadd_cancel_right</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x @+ y = x @+ z ⟷ y=z"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>y</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>z</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>hmem_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step</span><span> </span><span>y</span><span> </span><span>z</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x @+ y = x @+ z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"RepFun y ((@+) x) = RepFun z ((@+) x)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hadd</span><span> </span><span>Rep_le_Cancel</span><span> </span><span>order_antisym</span><span> </span><span>order_refl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"y = z"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hf_equalityI</span><span> </span><span>RepFun_iff</span><span> </span><span>step</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>RepFun_hadd_cancel</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"RepFun y (λz. x @+ z) = RepFun z (λz. x @+ z) ⟷ y=z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hadd</span><span> </span><span>hadd_cancel_right</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hadd_hmem_cancel</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x @+ y <span class="hidden">❙</span><span class="bold">∈</span> x @+ z ⟷ y <span class="hidden">❙</span><span class="bold">∈</span> z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hadd</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>y</span><span class="delimiter">]</span><span> </span><span>hadd</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>z</span><span class="delimiter">]</span><span> </span><span>not_add_mem_right</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hmem_not_refl</span><span> </span><span>hunion_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hadd</span><span> </span><span>hadd_cancel_right</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ord_of_add</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ord_of (i+j) = ord_of i @+ ord_of j"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>j</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_hadd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord x ⟹ Ord y ⟹ Ord (x @+ y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>Ord_induct2</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hmem_self_hadd</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"k1 <span class="hidden">❙</span><span class="bold">∈</span> k1 @+ k2 ⟷ 0 <span class="hidden">❙</span><span class="bold">∈</span> k2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hadd_0_right</span><span> </span><span>hadd_hmem_cancel</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hadd_commute</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord x ⟹ Ord y ⟹ x @+ y = y @+ x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>Ord_induct2</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hadd_cancel_left</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord x ⟹ y @+ x = z @+ x ⟷ y=z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>Ord_induct2</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The predecessor function›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>pred</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ hf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pred x ≡ (THE y. succ y = x ∨ x=0 ∧ y=0)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pred_succ</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pred (succ x) = x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pred_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pred_0</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pred 0 = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pred_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>succ_pred</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord x ⟹ x ≠ 0 ⟹ succ (pred x) = x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_cases</span><span> </span><span>pred_succ</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pred_mem</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord x ⟹ x ≠ 0 ⟹ pred x <span class="hidden">❙</span><span class="bold">∈</span> x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>succ_iff</span><span> </span><span>succ_pred</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_pred</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord x ⟹ Ord (pred x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_in_Ord</span><span> </span><span>pred_0</span><span> </span><span>pred_mem</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hadd_pred_right</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord y ⟹ y ≠ 0 ⟹ x @+ pred y = pred (x @+ y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hadd_succ_right</span><span> </span><span>pred_succ</span><span> </span><span>succ_pred</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_pred_HUnion</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(k) ⟹ pred k = ⨆k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>HUnion_hempty</span><span> </span><span>Ordinal.Ord_pred</span><span> </span><span>pred_0</span><span> </span><span>pred_succ</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A Concatentation Operation for Sequences›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>shift</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ hf ⇒ hf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"shift f delta = ⦃v . u <span class="hidden">❙</span><span class="bold">∈</span> f, ∃n y. u = ⟨n, y⟩ ∧ v = ⟨delta @+ n, y⟩⦄"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>shiftD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x <span class="hidden">❙</span><span class="bold">∈</span> shift f delta ⟹ ∃u. u <span class="hidden">❙</span><span class="bold">∈</span> f ∧ x = ⟨delta @+ hfst u, hsnd u⟩"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>shift_def</span><span> </span><span>hsplit_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hmem_shift_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨m, y⟩ <span class="hidden">❙</span><span class="bold">∈</span> shift f delta ⟷ (∃n. m = delta @+ n ∧ ⟨n, y⟩ <span class="hidden">❙</span><span class="bold">∈</span> f)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>shift_def</span><span> </span><span>hrelation_def</span><span> </span><span>is_hpair_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hmem_shift_add_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨delta @+ n, y⟩ <span class="hidden">❙</span><span class="bold">∈</span> shift f delta ⟷ ⟨n, y⟩ <span class="hidden">❙</span><span class="bold">∈</span> f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hadd_cancel_right</span><span> </span><span>hmem_shift_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hrelation_shift</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hrelation (shift f delta)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>shift_def</span><span> </span><span>hrelation_def</span><span> </span><span>hsplit_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>app_shift</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"app (shift f k) (k @+ j) = app f j"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>app_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfunction_shift_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hfunction (shift f delta) = hfunction f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hfunction_def</span><span> </span><span>hmem_shift_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hdomain_shift_add</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hdomain (shift f delta) = ⦃delta @+ n . n <span class="hidden">❙</span><span class="bold">∈</span> hdomain f⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span>  </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hf_equalityI</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hdomain_def</span><span> </span><span>hmem_shift_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hdomain_shift_disjoint</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"delta ⊓ hdomain (shift f delta) = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hdomain_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>hf_equalityI</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>metis</span><span> </span><span>shiftD</span><span> </span><span>hpair_inject</span><span> </span><span>not_add_mem_right</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>seq_append</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ hf ⇒ hf ⇒ hf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"seq_append k f g ≡ hrestrict f k ⊔ shift g k"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hrelation_seq_append</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hrelation (seq_append k f g)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>seq_append_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Seq_append</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Seq s1 k1 ⟹ Seq s2 k2 ⟹ Seq (seq_append k1 s1 s2) (k1 @+ k2)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Seq_def</span><span> </span><span>seq_append_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hdomain_restr</span><span> </span><span>hdomain_shift_disjoint</span><span> </span><span>hfunction_hunion</span><span> </span><span>hfunction_restr</span><span> </span><span>hfunction_shift_iff</span><span> </span><span>inf_absorb2</span><span> </span><span>seq_append_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hdomain_shift_add</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hmem_hadd_E</span><span> </span><span>rev_hsubsetD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>hmem_hadd_E</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Seq_def</span><span> </span><span>Seq_iff_app</span><span> </span><span>hdomainI</span><span> </span><span>hmem_shift_add_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>app_hunion1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x <span class="hidden">❙</span><span class="bold">∉</span> hdomain g ⟹ app (f ⊔ g) x = app f x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>app_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hdomainI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>app_hunion2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x <span class="hidden">❙</span><span class="bold">∉</span> hdomain f ⟹ app (f ⊔ g) x = app g x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>app_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hdomainI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Seq_append_app1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Seq s k ⟹ l <span class="hidden">❙</span><span class="bold">∈</span> k ⟹ app (seq_append k s s') l = app s l"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Seq_def</span><span> </span><span>seq_append_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>app_hunion1</span><span> </span><span>hdomain_shift_disjoint</span><span> </span><span>hemptyE</span><span> </span><span>hinter_iff</span><span> </span><span>app_hrestrict</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Seq_append_app2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Seq s1 k1 ⟹ Seq s2 k2 ⟹ l = k1 @+ j ⟹ app (seq_append k1 s1 s2) l = app s2 j"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>seq_append_def</span><span> </span><span>app_hunion2</span><span> </span><span>app_shift</span><span> </span><span>hdomain_restr</span><span> </span><span>hinter_iff</span><span> </span><span>not_add_mem_right</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Nonempty sequences indexed by ordinals›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>OrdDom</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"OrdDom r ≡ ∀x y. ⟨x,y⟩ <span class="hidden">❙</span><span class="bold">∈</span> r ⟶ Ord x"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdDom_insf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦OrdDom s; Ord k⟧ ⟹ OrdDom (insf s (succ k) y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>insf_def</span><span> </span><span>OrdDom_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdDom_hunion</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"OrdDom (s1 ⊔ s2) ⟷ OrdDom s1 ∧ OrdDom s2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>OrdDom_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdDom_hrestrict</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"OrdDom s ⟹ OrdDom (hrestrict s A)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>OrdDom_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OrdDom_shift</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦OrdDom s; Ord k⟧ ⟹ OrdDom (shift s k)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>OrdDom_def</span><span> </span><span>shift_def</span><span> </span><span>Ord_hadd</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A sequence of positive length ending with @{term y}›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>LstSeq</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ hf ⇒ hf ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LstSeq s k y ≡ Seq s (succ k) ∧ Ord k ∧ ⟨k,y⟩ <span class="hidden">❙</span><span class="bold">∈</span> s ∧ OrdDom s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LstSeq_imp_Seq_succ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"LstSeq s k y ⟹ Seq s (succ k)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>LstSeq_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LstSeq_imp_Seq_same</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"LstSeq s k y ⟹ Seq s k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>LstSeq_imp_Seq_succ</span><span> </span><span>Seq_succ_D</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LstSeq_imp_Ord</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"LstSeq s k y ⟹ Ord k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>LstSeq_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LstSeq_trunc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"LstSeq s k y ⟹ l <span class="hidden">❙</span><span class="bold">∈</span> k ⟹ LstSeq s l (app s l)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>LstSeq_def</span><span> </span><span>Seq_iff_app</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_succ</span><span> </span><span>Seq_Ord_D</span><span> </span><span>mem_succ_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_in_Ord</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LstSeq_insf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"LstSeq s k z ⟹ LstSeq (insf s (succ k) y) (succ k) y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>OrdDom_insf</span><span> </span><span>LstSeq_def</span><span> </span><span>Ord_succ_iff</span><span> </span><span>Seq_imp_eq_app</span><span> </span><span>Seq_insf</span><span> </span><span>Seq_succ_iff</span><span> </span><span>app_insf_Seq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>app_insf_LstSeq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"LstSeq s k z ⟹ app (insf s (succ k) y) (succ k) = y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>LstSeq_imp_Seq_succ</span><span> </span><span>app_insf_Seq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>app_insf2_LstSeq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"LstSeq s k z ⟹ k' ≠ succ k ⟹ app (insf s (succ k) y) k' = app s k'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>LstSeq_imp_Seq_succ</span><span> </span><span>app_insf2_Seq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>app_insf_LstSeq_if</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"LstSeq s k z ⟹ app (insf s (succ k) y) k' = (if k' = succ k then y else app s k')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>app_insf2_LstSeq</span><span> </span><span>app_insf_LstSeq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LstSeq_append_app1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"LstSeq s k y ⟹ l <span class="hidden">❙</span><span class="bold">∈</span> succ k ⟹ app (seq_append (succ k) s s') l = app s l"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>LstSeq_imp_Seq_succ</span><span> </span><span>Seq_append_app1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LstSeq_append_app2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦LstSeq s1 k1 y1; LstSeq s2 k2 y2; l = succ k1 @+ j⟧
   ⟹ app (seq_append (succ k1) s1 s2) l = app s2 j"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>LstSeq_imp_Seq_succ</span><span> </span><span>Seq_append_app2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Seq_append_pair</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦Seq s1 k1; Seq s2 (succ n);  ⟨n, y⟩ <span class="hidden">❙</span><span class="bold">∈</span> s2; Ord n⟧ ⟹ ⟨k1 @+ n, y⟩ <span class="hidden">❙</span><span class="bold">∈</span> (seq_append k1 s1 s2)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hmem_shift_add_iff</span><span> </span><span>hunion_iff</span><span> </span><span>seq_append_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Seq_append_OrdDom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦Ord k; OrdDom s1; OrdDom s2⟧ ⟹ OrdDom (seq_append k s1 s2)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>seq_append_def</span><span> </span><span>OrdDom_hrestrict</span><span> </span><span>OrdDom_shift</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LstSeq_append</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦LstSeq s1 k1 y1; LstSeq s2 k2 y2⟧ ⟹ LstSeq (seq_append (succ k1) s1 s2) (succ (k1 @+ k2)) y2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>LstSeq_def</span><span> </span><span>Seq_append</span><span> </span><span>Ord_hadd</span><span> </span><span>Seq_append_pair</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Seq_append</span><span> </span><span>hadd_succ_left</span><span> </span><span>hadd_succ_right</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Seq_append_pair</span><span> </span><span>hadd_succ_left</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ord_succ</span><span> </span><span>Seq_append_OrdDom</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LstSeq_app</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"LstSeq s k y ⟹ app s k = y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>LstSeq_def</span><span> </span><span>Seq_imp_eq_app</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sequence-building operators›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Builds</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(hf ⇒ bool) ⇒ (hf ⇒ hf ⇒ hf ⇒ bool) ⇒ hf ⇒ hf ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Builds B C s l ≡ B (app s l) ∨ (∃m <span class="hidden">❙</span><span class="bold">∈</span> l. ∃n <span class="hidden">❙</span><span class="bold">∈</span> l. C (app s l) (app s m) (app s n))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>BuildSeq</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(hf ⇒ bool) ⇒ (hf ⇒ hf ⇒ hf ⇒ bool) ⇒ hf ⇒ hf ⇒ hf ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"BuildSeq B C s k y ≡ LstSeq s k y ∧ (∀l <span class="hidden">❙</span><span class="bold">∈</span> succ k. Builds B C s l)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BuildSeqI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"LstSeq s k y ⟹ (⋀l. l <span class="hidden">❙</span><span class="bold">∈</span> succ k ⟹ Builds B C s l) ⟹ BuildSeq B C s k y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>BuildSeq_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BuildSeq_imp_LstSeq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BuildSeq B C s k y ⟹ LstSeq s k y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>BuildSeq_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BuildSeq_imp_Seq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BuildSeq B C s k y ⟹ Seq s (succ k)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>LstSeq_imp_Seq_succ</span><span> </span><span>BuildSeq_imp_LstSeq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BuildSeq_conj_distrib</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"BuildSeq (λx. B x ∧ P x) (λx y z. C x y z ∧ P x) s k y ⟷
  BuildSeq B C s k y ∧ (∀l <span class="hidden">❙</span><span class="bold">∈</span> succ k. P (app s l))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>BuildSeq_def</span><span> </span><span>Builds_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BuildSeq_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BuildSeq B C s k y"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. B x ⟹ B' x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x y z. C x y z ⟹ C' x y z"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"BuildSeq B' C' s k y"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>BuildSeq_def</span><span> </span><span>Builds_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>B</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BuildSeq_trunc</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BuildSeq B C s k y"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l <span class="hidden">❙</span><span class="bold">∈</span> k"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"BuildSeq B C s l (app s l)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>j</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j <span class="hidden">❙</span><span class="bold">∈</span> succ l"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord k"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>BuildSeq_imp_LstSeq</span><span> </span><span>LstSeq_def</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Builds B C s j"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>BuildSeq_def</span><span> </span><span>OrdmemD</span><span> </span><span>b</span><span> </span><span>hballE</span><span> </span><span>hsubsetD</span><span> </span><span>j</span><span> </span><span>l</span><span> </span><span>succ_iff</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b</span><span> </span><span>l</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>BuildSeq_def</span><span> </span><span>LstSeq_trunc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Showing that Sequences can be Constructed›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Builds_insf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Builds B C s l ⟹ LstSeq s k z ⟹ l <span class="hidden">❙</span><span class="bold">∈</span> succ k ⟹ Builds B C (insf s (succ k) y) l"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>HBall_def</span><span> </span><span>hmem_not_refl</span><span> </span><span>Builds_def</span><span> </span><span>app_insf_LstSeq_if</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>succ_iff</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hmem_not_sym</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BuildSeq_insf</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BuildSeq B C s k z"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m <span class="hidden">❙</span><span class="bold">∈</span> succ k"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n <span class="hidden">❙</span><span class="bold">∈</span> succ k"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"B y ∨ C y (app s m) (app s n)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"BuildSeq B C (insf s (succ k) y) (succ k) y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>BuildSeqI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LstSeq (insf s (succ k) y) (succ k) y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>BuildSeq_imp_LstSeq</span><span> </span><span>LstSeq_insf</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>l</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l <span class="hidden">❙</span><span class="bold">∈</span> succ (succ k)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Builds B C (insf s (succ k) y) l"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l = succ k"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B (app (insf s l y) l) ∨ C (app (insf s l y) l) (app (insf s l y) m) (app (insf s l y) n)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>BuildSeq_imp_Seq</span><span> </span><span>app_insf_Seq_if</span><span> </span><span>b</span><span> </span><span>hmem_not_refl</span><span> </span><span>l</span><span> </span><span>m</span><span> </span><span>n</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Builds B C (insf s (succ k) y) l"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>m</span><span> </span><span>n</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Builds_def</span><span> </span><span>l</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l <span class="hidden">❙</span><span class="bold">∈</span> succ k"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"LstSeq s k z"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>BuildSeq_imp_LstSeq</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Builds B C (insf s (succ k) y) l"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b</span><span> </span><span>l</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hballE</span><span> </span><span>Builds_insf</span><span> </span><span>BuildSeq_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BuildSeq_insf1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BuildSeq B C s k z"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"B y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"BuildSeq B C (insf s (succ k) y) (succ k) y"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>BuildSeq_insf</span><span> </span><span>b</span><span> </span><span>succ_iff</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BuildSeq_insf2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BuildSeq B C s k z"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m <span class="hidden">❙</span><span class="bold">∈</span> k"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n <span class="hidden">❙</span><span class="bold">∈</span> k"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"C y (app s m) (app s n)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"BuildSeq B C (insf s (succ k) y) (succ k) y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>BuildSeq_insf</span><span> </span><span>b</span><span> </span><span>m</span><span> </span><span>n</span><span> </span><span>succ_iff</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BuildSeq_append</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>s1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BuildSeq B C s1 k1 y1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BuildSeq B C s2 k2 y2"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"BuildSeq B C (seq_append (succ k1) s1 s2) (succ (k1 @+ k2)) y2"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>BuildSeqI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LstSeq (seq_append (succ k1) s1 s2) (succ (k1 @+ k2)) y2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>BuildSeq_imp_LstSeq</span><span> </span><span>LstSeq_append</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>l</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s1L</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"LstSeq s1 k1 y1"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s1BC</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀l. l <span class="hidden">❙</span><span class="bold">∈</span> succ k1 ⟹ Builds B C s1 l"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s2L</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"LstSeq s2 k2 y2"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s2BC</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀l. l <span class="hidden">❙</span><span class="bold">∈</span> succ k2 ⟹ Builds B C s2 l"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s1</span><span> </span><span>s2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>BuildSeq_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l <span class="hidden">❙</span><span class="bold">∈</span> succ (succ (k1 @+ k2))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"l <span class="hidden">❙</span><span class="bold">∈</span> succ k1 @+ succ k2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>LstSeq_imp_Ord</span><span> </span><span>hadd_succ_left</span><span> </span><span>hadd_succ_right</span><span> </span><span>s2L</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Builds B C (seq_append (succ k1) s1 s2) l"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hmem_hadd_E</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>l1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l <span class="hidden">❙</span><span class="bold">∈</span> succ k1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B (app s1 l) ∨ (∃m<span class="hidden">❙</span><span class="bold">∈</span>l. ∃n<span class="hidden">❙</span><span class="bold">∈</span>l. C (app s1 l) (app s1 m) (app s1 n))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s1BC</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Builds_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B (app s1 l)"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Builds_def</span><span> </span><span>LstSeq_append_app1</span><span> </span><span>l1</span><span> </span><span>s1L</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃m<span class="hidden">❙</span><span class="bold">∈</span>l. ∃n<span class="hidden">❙</span><span class="bold">∈</span>l. C (app s1 l) (app s1 m) (app s1 n)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>mn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m <span class="hidden">❙</span><span class="bold">∈</span> l"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n <span class="hidden">❙</span><span class="bold">∈</span> l"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"C (app s1 l) (app s1 m) (app s1 n)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m <span class="hidden">❙</span><span class="bold">∈</span> succ k1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n <span class="hidden">❙</span><span class="bold">∈</span> succ k1"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>LstSeq_def</span><span> </span><span>Ord_trans</span><span> </span><span>l1</span><span> </span><span>mn</span><span> </span><span>s1L</span><span> </span><span>succ_iff</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C (app (seq_append (succ k1) s1 s2) l)
                         (app (seq_append (succ k1) s1 s2) m)
                         (app (seq_append (succ k1) s1 s2) n)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s1L</span><span> </span><span>l1</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>LstSeq_append_app1</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Builds B C (seq_append (succ k1) s1 s2) l"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mn</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Builds_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>z</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>z</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z <span class="hidden">❙</span><span class="bold">∈</span> succ k2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>l2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l = succ k1 @+ z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B (app s2 z) ∨ (∃m<span class="hidden">❙</span><span class="bold">∈</span>z. ∃n<span class="hidden">❙</span><span class="bold">∈</span>z. C (app s2 z) (app s2 m) (app s2 n))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s2BC</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Builds_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B (app s2 z)"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Builds_def</span><span> </span><span>LstSeq_append_app2</span><span> </span><span>l2</span><span> </span><span>s1L</span><span> </span><span>s2L</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃m<span class="hidden">❙</span><span class="bold">∈</span>z. ∃n<span class="hidden">❙</span><span class="bold">∈</span>z. C (app s2 z) (app s2 m) (app s2 n)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>mn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m <span class="hidden">❙</span><span class="bold">∈</span> z"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n <span class="hidden">❙</span><span class="bold">∈</span> z"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"C (app s2 z) (app s2 m) (app s2 n)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m <span class="hidden">❙</span><span class="bold">∈</span> succ k2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n <span class="hidden">❙</span><span class="bold">∈</span> succ k2"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mn</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>LstSeq_def</span><span> </span><span>Ord_trans</span><span> </span><span>z</span><span> </span><span>s2L</span><span> </span><span>succ_iff</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C (app (seq_append (succ k1) s1 s2) l)
                         (app (seq_append (succ k1) s1 s2) (succ k1 @+ m))
                         (app (seq_append (succ k1) s1 s2) (succ k1 @+ n))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s1L</span><span> </span><span>s2L</span><span> </span><span>l2</span><span> </span><span>z</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>LstSeq_append_app2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Builds B C (seq_append (succ k1) s1 s2) l"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mn</span><span> </span><span>l2</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Builds_def</span><span> </span><span>HBall_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BuildSeq_combine</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>b1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BuildSeq B C s1 k1 y1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BuildSeq B C s2 k2 y2"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"C y y1 y2"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"BuildSeq B C (insf (seq_append (succ k1) s1 s2) (succ (succ (k1 @+ k2))) y) (succ (succ (k1 @+ k2))) y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>k2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord k2"</span></span></span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>BuildSeq_def</span><span> </span><span>LstSeq_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>BuildSeq_insf</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>k1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"succ(k1@+k2)"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"BuildSeq B C (seq_append (succ k1) s1 s2) (succ (k1 @+ k2)) y2"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>BuildSeq_append</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>b1</span><span> </span><span>b2</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k1 <span class="hidden">❙</span><span class="bold">∈</span> succ (succ (k1 @+ k2))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>k2</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hadd_0_right</span><span> </span><span>hmem_0_Ord</span><span> </span><span>hmem_self_hadd</span><span> </span><span>succ_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"succ (k1 @+ k2) <span class="hidden">❙</span><span class="bold">∈</span> succ (succ (k1 @+ k2))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>succ_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"app (seq_append (succ k1) s1 s2) k1 = y1"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>b1</span><span> </span><span>BuildSeq_imp_LstSeq</span><span> </span><span>LstSeq_app</span><span> </span><span>LstSeq_append_app1</span><span> </span><span>succ_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"app (seq_append (succ k1) s1 s2) (succ (k1 @+ k2)) = y2"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>b1</span><span> </span><span>b2</span><span> </span><span>k2</span><span> </span><span>BuildSeq_imp_LstSeq</span><span> </span><span>LstSeq_app</span><span> </span><span>LstSeq_append_app2</span><span> </span><span>hadd_succ_left</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B y ∨
          C y (app (seq_append (succ k1) s1 s2) k1)
              (app (seq_append (succ k1) s1 s2) (succ (k1 @+ k2)))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>y</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LstSeq_1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"LstSeq ⦃⟨0, y⟩⦄ 0 y"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>LstSeq_def</span><span> </span><span>One_hf_eq_succ</span><span> </span><span>Seq_ins</span><span> </span><span>OrdDom_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BuildSeq_1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"B y ⟹ BuildSeq B C ⦃⟨0, y⟩⦄ 0 y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>BuildSeq_def</span><span> </span><span>Builds_def</span><span> </span><span>LstSeq_1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BuildSeq_exI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"B t ⟹ ∃s k. BuildSeq B C s k t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>BuildSeq_1</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Proving Properties of Given Sequences›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BuildSeq_succ_E</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BuildSeq B C s k y"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B y"</span></span></span><span> </span><span class="delimiter">|</span><span>  </span><span>m</span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m <span class="hidden">❙</span><span class="bold">∈</span> k"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n <span class="hidden">❙</span><span class="bold">∈</span> k"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C y (app s m) (app s n)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Bs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Builds B C s k"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>apps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"app s k = y"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s</span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>BuildSeq_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B y ∨ (∃m <span class="hidden">❙</span><span class="bold">∈</span> k. ∃n <span class="hidden">❙</span><span class="bold">∈</span> k. C y (app s m) (app s n))"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Builds_def</span><span> </span><span>apps</span><span> </span><span>Bs</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BuildSeq_induct</span><span> </span><span class="delimiter">[</span><span>consumes</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>B</span><span> </span><span>C</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>major</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BuildSeq B C s k a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. B x ⟹ P x"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x y z. C x y z ⟹ P y ⟹ P z ⟹ P x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P a"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord k"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>BuildSeq_def</span><span> </span><span>LstSeq_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a s. BuildSeq B C s k a ⟹ P a"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>k</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>Ord_induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>BuildSeq_trunc</span><span> </span><span>BuildSeq_succ_E</span><span> </span><span>B</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>major</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>BuildSeq2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[[hf,hf] ⇒ bool, [hf,hf,hf,hf,hf,hf] ⇒ bool, hf, hf, hf, hf] ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"BuildSeq2 B C s k y y' ≡
         BuildSeq (λp. ∃x x'. p = ⟨x,x'⟩ ∧ B x x')
                  (λp q r. ∃x x' y y' z z'. p = ⟨x,x'⟩ ∧ q = ⟨y,y'⟩ ∧ r = ⟨z,z'⟩ ∧ C x x' y y' z z')
                  s k ⟨y,y'⟩"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BuildSeq2_combine</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>b1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BuildSeq2 B C s1 k1 y1 y1'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BuildSeq2 B C s2 k2 y2 y2'"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"C y y' y1 y1' y2 y2'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"BuildSeq2 B C (insf (seq_append (succ k1) s1 s2) (succ (succ (k1 @+ k2))) ⟨y, y'⟩)
                       (succ (succ (k1 @+ k2))) y y'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>BuildSeq2_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>BuildSeq_combine</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BuildSeq2_1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"B y y' ⟹ BuildSeq2 B C ⦃⟨0, y, y'⟩⦄ 0 y y'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>BuildSeq2_def</span><span> </span><span>BuildSeq_1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BuildSeq2_exI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"B t t' ⟹ ∃s k. BuildSeq2 B C s k t t'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>BuildSeq2_1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BuildSeq2_induct</span><span> </span><span class="delimiter">[</span><span>consumes</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>B</span><span> </span><span>C</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"BuildSeq2 B C s k a a'"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x x'. B x x' ⟹ P x x'"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x x' y y' z z'. C x x' y y' z z' ⟹ P y y' ⟹ P z z' ⟹ P x x'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P a a'"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>BuildSeq2_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>BuildSeq_induct</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ⟨x,x'⟩. P x x'"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>B</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>BuildSeq3</span><span>
</span><span>   </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[[hf,hf,hf] ⇒ bool, [hf,hf,hf,hf,hf,hf,hf,hf,hf] ⇒ bool, hf, hf, hf, hf, hf] ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"BuildSeq3 B C s k y y' y'' ≡
         BuildSeq (λp. ∃x x' x''. p = ⟨x,x',x''⟩ ∧ B x x' x'')
                  (λp q r. ∃x x' x'' y y' y'' z z' z''.
                           p = ⟨x,x',x''⟩ ∧ q = ⟨y,y',y''⟩ ∧ r = ⟨z,z',z''⟩ ∧
                           C x x' x'' y y' y'' z z' z'')
                  s k ⟨y,y',y''⟩"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BuildSeq3_combine</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>b1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BuildSeq3 B C s1 k1 y1 y1' y1''"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"BuildSeq3 B C s2 k2 y2 y2' y2''"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"C y y' y'' y1 y1' y1'' y2 y2' y2''"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"BuildSeq3 B C (insf (seq_append (succ k1) s1 s2) (succ (succ (k1 @+ k2))) ⟨y, y', y''⟩)
                       (succ (succ (k1 @+ k2))) y y' y''"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>BuildSeq3_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>BuildSeq_combine</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BuildSeq3_1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"B y y' y'' ⟹ BuildSeq3 B C ⦃⟨0, y, y', y''⟩⦄ 0 y y' y''"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>BuildSeq3_def</span><span> </span><span>BuildSeq_1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BuildSeq3_exI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"B t t' t'' ⟹ ∃s k. BuildSeq3 B C s k t t' t''"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>BuildSeq3_1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BuildSeq3_induct</span><span> </span><span class="delimiter">[</span><span>consumes</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>B</span><span> </span><span>C</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"BuildSeq3 B C s k a a' a''"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x x' x''. B x x' x'' ⟹ P x x' x''"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x x' x'' y y' y'' z z' z''. C x x' x'' y y' y'' z z' z'' ⟹ P y y' y'' ⟹ P z z' z'' ⟹ P x x' x''"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P a a' a''"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>BuildSeq3_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>BuildSeq_induct</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ⟨x,x',x''⟩. P x x' x''"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>B</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A Unique Predecessor for every non-empty set›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Rep_hf_0</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Rep_hf 0 = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Abs_hf_inverse</span><span> </span><span>HF.HF_def</span><span> </span><span>UNIV_I</span><span> </span><span>Zero_hf_def</span><span> </span><span>image_empty</span><span> </span><span>set_encode_empty</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hmem_imp_less</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x <span class="hidden">❙</span><span class="bold">∈</span> y ⟹ Rep_hf x &lt; Rep_hf y"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hmem_def</span><span> </span><span>hfset_def</span><span> </span><span>set_decode_def</span><span> </span><span>Abs_hf_inverse</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>div_less</span><span> </span><span>even_zero</span><span> </span><span>le_less_trans</span><span> </span><span>less_two_power</span><span> </span><span>not_less</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hsubset_imp_le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ y ⟹ Rep_hf x ≤ Rep_hf y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>less_eq_hf_def</span><span> </span><span>hmem_def</span><span> </span><span>hfset_def</span><span> </span><span>Abs_hf_inverse</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>Abs_hf_cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>y</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>Abs_hf_cases</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subset_decode_imp_le</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Abs_hf_inverse</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>UNIV_I</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Abs_hf_inverse</span><span> </span><span>UNIV_I</span><span> </span><span>imageE</span><span> </span><span>imageI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_hmem_imp_less</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x <span class="hidden">❙</span><span class="bold">∈</span> y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Rep_hf (y - ⦃x⦄) &lt; Rep_hf y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"Rep_hf (y - ⦃x⦄) ≤ Rep_hf y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>hdiff_iff</span><span> </span><span>hsubsetI</span><span> </span><span>hsubset_imp_le</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Rep_hf (y - ⦃x⦄) ≠ Rep_hf y"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Rep_hf_inject</span><span> </span><span>hdiff_iff</span><span> </span><span>hinsert_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>le_neq_implies_less</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>least</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"hf ⇒ hf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"least a ≡ (THE x. x <span class="hidden">❙</span><span class="bold">∈</span> a ∧ (∀y. y <span class="hidden">❙</span><span class="bold">∈</span> a ⟶ Rep_hf x ≤ Rep_hf y))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>least_equality</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x <span class="hidden">❙</span><span class="bold">∈</span> a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀y. y <span class="hidden">❙</span><span class="bold">∈</span> a ⟹ Rep_hf x ≤ Rep_hf y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"least a = x"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>least_def</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>the_equality</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Rep_hf_inverse</span><span> </span><span>assms</span><span> </span><span>eq_iff</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>leastI2_order</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x <span class="hidden">❙</span><span class="bold">∈</span> a"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀y. y <span class="hidden">❙</span><span class="bold">∈</span> a ⟹ Rep_hf x ≤ Rep_hf y"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀z. z <span class="hidden">❙</span><span class="bold">∈</span> a ⟹ ∀y. y <span class="hidden">❙</span><span class="bold">∈</span> a ⟶ Rep_hf z ≤ Rep_hf y ⟹ Q z"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Q (least a)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>least_equality</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nonempty_imp_ex_least</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≠ 0 ⟹ ∃x. x <span class="hidden">❙</span><span class="bold">∈</span> a ∧ (∀y. y <span class="hidden">❙</span><span class="bold">∈</span> a ⟶ Rep_hf x ≤ Rep_hf y)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>a</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>hf_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>hinsert</span><span> </span><span>u</span><span> </span><span>v</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"v=0"</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>u</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>dual_order.trans</span><span> </span><span>eq_iff</span><span> </span><span>hinsert.IH</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>hmem_hinsert</span><span>
</span><span>                  </span><span>less_eq_insert1_iff</span><span> </span><span>linear</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>least_hmem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≠ 0 ⟹ least a <span class="hidden">❙</span><span class="bold">∈</span> a"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>nonempty_imp_ex_least</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>leastI2_order</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>