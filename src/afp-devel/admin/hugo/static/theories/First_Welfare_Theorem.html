<div id="Syntax">
<div class="head"><h1>Theory Syntax</h1>
<span class="command">theory</span> <span class="name">Syntax</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* License: LGPL *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
Author: Julian Parsert &lt;julian.parsert@gmail.com&gt;
Author: Cezary Kaliszyk
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Introducing Syntax ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Syntax, abbreviations and type-synonyms ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Syntax</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>relation</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a × 'a) set"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>gen_weak_stx</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a relation ⇒ 'a ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ≽[_] _"</span></span></span><span> </span><span class="delimiter">[</span><span>51</span><span class="delimiter">,</span><span>100</span><span class="delimiter">,</span><span>51</span><span class="delimiter">]</span><span> </span><span>60</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"x ≽[P] y ≡ (x, y) ∈ P"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>gen_indif_stx</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a relation ⇒ 'a ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ≈[_] _"</span></span></span><span> </span><span class="delimiter">[</span><span>51</span><span class="delimiter">,</span><span>100</span><span class="delimiter">,</span><span>51</span><span class="delimiter">]</span><span> </span><span>60</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"x ≈[P] y ≡ x ≽[P] y ∧ y ≽[P] x "</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>gen_strc_stx</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a relation ⇒ 'a ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ≻[_] _"</span></span></span><span> </span><span class="delimiter">[</span><span>51</span><span class="delimiter">,</span><span>100</span><span class="delimiter">,</span><span>51</span><span class="delimiter">]</span><span> </span><span>60</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"x ≻[P] y ≡  x ≽[P] y ∧ ¬y ≽[P] x "</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Argmax">
<div class="head"><h1>Theory Argmax</h1>
<span class="command">theory</span> <span class="name">Argmax</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Complex_Main.html"><span class="name">Complex_Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* License: LGPL *)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Arg Min and Arg Max sets›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Argmax</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Complex_Main"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Definitions and Lemmas by Julian Parsert ›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ definition of argmax and argmin returing a set. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>arg_min_set</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b::ord) ⇒ 'a set ⇒ 'a set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"arg_min_set f S = {x. is_arg_min f (λx. x∈S) x}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>arg_max_set</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b::ord) ⇒ 'a set ⇒ 'a set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"arg_max_set f S = {x. is_arg_max f (λx. x∈S) x}"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Useful lemmas for @{term "arg_max_set"} and @{term "arg_min_set"}. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_better_in_s</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ arg_max_set f S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∄y. y ∈ S ∧ (f y) &gt; (f x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>arg_max_set_def</span><span> </span><span>assms</span><span> </span><span>is_arg_max_def</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>argmax_sol_in_s</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ arg_max_set f S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>CollectD</span><span> </span><span>arg_max_set_def</span><span> </span><span>assms</span><span> </span><span>is_arg_max_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>leq_all_in_sol</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ ('b :: preorder)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ arg_max_set f S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀y ∈ S. f y ≥ f x ⟶ y ∈ arg_max_set f S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>le_less_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>arg_max_set_def</span><span> </span><span>is_arg_max_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_leq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ ('b :: linorder)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ arg_max_set f S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀y ∈ S. f x ≥ f y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>assms</span><span> </span><span>leI</span><span> </span><span>no_better_in_s</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_in_argmax_equal</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ ('b :: linorder)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ arg_max_set f S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀y ∈ arg_max_set f S. f x = f y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>all_leq</span><span> </span><span>argmax_sol_in_s</span><span> </span><span>assms</span><span> </span><span>le_less</span><span> </span><span>no_better_in_s</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Preferences">
<div class="head"><h1>Theory Preferences</h1>
<span class="command">theory</span> <span class="name">Preferences</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL-Analysis/Multivariate_Analysis.html"><span class="name">Multivariate_Analysis</span></a> <a href="Syntax.html"><span class="name">Syntax</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* License: LGPL *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
Author: Julian Parsert &lt;julian.parsert@gmail.com&gt;
Author: Cezary Kaliszyk
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Preference Relations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Preferences modeled as a set of pairs ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Preferences</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"HOL-Analysis.Multivariate_Analysis"</span></span></span><span>
</span><span>    </span><span>Syntax</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Basic Preference Relation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Basic preference relation locale with carrier and relation modeled as a set of pairs. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>preference</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>carrier</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>relation</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a relation"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>not_outside</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x,y) ∈ relation ⟹ x ∈ carrier"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x,y) ∈ relation ⟹ y ∈ carrier"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>trans_refl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"preorder_on  carrier relation"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>preference</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>geq</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ≽ _"</span></span></span><span> </span><span class="delimiter">[</span><span>51</span><span class="delimiter">,</span><span>51</span><span class="delimiter">]</span><span> </span><span>60</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"x ≽ y ≡ x ≽[relation] y"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>str_gr</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ≻ _"</span></span></span><span> </span><span class="delimiter">[</span><span>51</span><span class="delimiter">,</span><span>51</span><span class="delimiter">]</span><span> </span><span>60</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"x ≻ y ≡ x ≽ y ∧ ¬y ≽ x"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>indiff</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ≈ _"</span></span></span><span> </span><span class="delimiter">[</span><span>51</span><span class="delimiter">,</span><span>51</span><span class="delimiter">]</span><span> </span><span>60</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"x ≈ y ≡ x ≽ y ∧ y ≽ x"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reflexivity</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"refl_on carrier relation"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>preorder_on_def</span><span> </span><span>trans_refl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>transitivity</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans relation"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>preorder_on_def</span><span> </span><span>trans_refl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>indiff_trans</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≈ y ⟹ y ≈ z ⟹ x ≈ z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>transE</span><span> </span><span>transitivity</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Contour sets ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>at_least_as_good</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a set ⇒ 'a relation ⇒ 'a set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"at_least_as_good x B P = {y ∈ B. y ≽[P] x }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>no_better_than</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a set ⇒ 'a relation ⇒ 'a set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"no_better_than x B P = {y ∈ B. x ≽[P] y}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>as_good_as</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a set ⇒ 'a relation ⇒ 'a set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"as_good_as x B P = {y ∈ B. x ≈[P] y}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>at_lst_asgd_ge</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ at_least_as_good y B Pr"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≽[Pr] y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>at_least_as_good_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strict_contour_is_diff</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"{a ∈ B. a ≻[Pr] y} = at_least_as_good y B Pr - as_good_as y B Pr"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>at_least_as_good_def</span><span> </span><span>as_good_as_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strict_countour_def</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(at_least_as_good y B Pr) - as_good_as y B Pr = {x ∈ B. x ≻[Pr] y}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>as_good_as_def</span><span> </span><span>at_least_as_good_def</span><span> </span><span>strict_contour_is_diff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>at_least_as_goodD</span><span> </span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∈ at_least_as_good y B Pr"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ≽[Pr] y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>at_least_as_good_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Rational Preference Relation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Rational preferences add totality to the basic preferences. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>rational_preference</span><span> </span><span class="delimiter">=</span><span> </span><span>preference</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>total</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"total_on carrier relation"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>compl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ carrier . ∀y∈ carrier . x ≽ y ∨ y ≽ x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>refl_onD</span><span> </span><span>reflexivity</span><span> </span><span>total</span><span> </span><span>total_on_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strict_not_refl_weak</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ carrier ∧ y ∈ carrier ⟹ ¬ (y ≽ x) ⟷ x ≻ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>refl_onD</span><span> </span><span>reflexivity</span><span> </span><span>total</span><span> </span><span>total_on_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strict_trans</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≻ y ⟹ y ≻ z ⟹ x ≻ z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>transE</span><span> </span><span>transitivity</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>completeD</span><span> </span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ carrier ⟹ y ∈ carrier ⟹ x ≠ y ⟹ x ≽ y ∨ y ≽ x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pref_in_at_least_as</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≽ y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ at_least_as_good y carrier relation"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>CollectI</span><span> </span><span>assms</span><span>
</span><span>      </span><span>at_least_as_good_def</span><span> </span><span>preference.not_outside</span><span> </span><span>preference_axioms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>worse_in_no_better</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≽ y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ no_better_than y carrier relation"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>CollectI</span><span> </span><span>assms</span><span> </span><span>no_better_than_def</span><span>
</span><span>      </span><span>preference_axioms</span><span> </span><span>preference_def</span><span> </span><span>strict_not_refl_weak</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strict_is_neg_transitive</span><span> </span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ carrier ∧ y ∈ carrier ∧ z ∈ carrier"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≻ y ⟹ x ≻ z ∨ z ≻ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>assms</span><span> </span><span>compl</span><span> </span><span>transE</span><span> </span><span>transitivity</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>weak_is_transitive</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ carrier ∧ y ∈ carrier ∧ z ∈ carrier"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≽ y ⟹ y ≽ z ⟹ x ≽ z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>transD</span><span> </span><span>transitivity</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_better_than_nonepty</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"carrier ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. x ∈ carrier ⟹ (no_better_than x carrier relation) ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>empty_iff</span><span> </span><span>mem_Collect_eq</span><span>
</span><span>      </span><span>no_better_than_def</span><span> </span><span>refl_onD</span><span> </span><span>reflexivity</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_better_subset_pref</span><span> </span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≽ y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"no_better_than y carrier relation ⊆ no_better_than x carrier relation"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ no_better_than y carrier relation"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ no_better_than x carrier relation"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>assms</span><span> </span><span>mem_Collect_eq</span><span> </span><span>no_better_than_def</span><span> </span><span>transE</span><span> </span><span>transitivity</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_better_thansubset_rel</span><span> </span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ carrier"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ carrier"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"no_better_than y carrier relation ⊆ no_better_than x carrier relation"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≽ y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"{a ∈ carrier. y ≽ a} ⊆ {a ∈ carrier. x ≽ a}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>no_better_than_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Collect_mono_iff</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>compl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nbt_nest</span><span> </span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(no_better_than y carrier relation ⊆ no_better_than x carrier relation) ∨
        (no_better_than x carrier relation ⊆ no_better_than y carrier relation)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>CollectD</span><span> </span><span>compl</span><span> </span><span>no_better_subset_pref</span><span> </span><span>no_better_than_def</span><span> </span><span>not_outside</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>at_lst_asgd_not_ge</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"carrier ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ carrier"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ carrier"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ at_least_as_good y carrier relation"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ x ≽ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>CollectI</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>at_least_as_good_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>as_good_as_sameIff</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"z ∈ as_good_as y carrier relation ⟷ z ≽ y ∧ y ≽ z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>as_good_as_def</span><span> </span><span>mem_Collect_eq</span><span> </span><span>not_outside</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>same_at_least_as_equal</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ≈ y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"at_least_as_good z carrier relation =
         at_least_as_good y carrier relation"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?az = ?ay"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∈ carrier ∧ y ∈ carrier"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>assms</span><span> </span><span>refl_onD2</span><span> </span><span>reflexivity</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ carrier. x ≽ z ⟶ x ≽ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>assms</span><span> </span><span>transD</span><span> </span><span>transitivity</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?az ⊆ ?ay"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>at_lst_asgd_ge</span><span> </span><span>at_lst_asgd_not_ge</span><span>
</span><span>        </span><span>equals0D</span><span> </span><span>not_outside</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∈ carrier ∧ y ∈ carrier"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>assms</span><span> </span><span>refl_onD2</span><span> </span><span>reflexivity</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ carrier. x ≽ y ⟶ x ≽ z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>assms</span><span> </span><span>transD</span><span> </span><span>transitivity</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?ay ⊆ ?az"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>at_lst_asgd_ge</span><span> </span><span>at_lst_asgd_not_ge</span><span>
</span><span>        </span><span>equals0D</span><span> </span><span>not_outside</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>as_good_asIff</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x ∈ as_good_as y carrier relation ⟷ x ≈[relation] y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nbt_subset</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite carrier"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ carrier"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ carrier"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"no_better_than x carrier relation ⊆ no_better_than x carrier relation ∨
         no_better_than x carrier relation ⊆ no_better_than x carrier relation"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fnt_carrier_fnt_rel</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite carrier ⟹ finite relation"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>finite_SigmaI</span><span> </span><span>refl_on_def</span><span> </span><span>reflexivity</span><span> </span><span>rev_finite_subset</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nbt_subset_carrier</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ carrier"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"no_better_than x carrier relation ⊆ carrier"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_better_than_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>xy_in_eachothers_nbt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ carrier"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ carrier"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ no_better_than y carrier relation ∨
         y ∈ no_better_than x carrier relation"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>contra_subsetD</span><span> </span><span>nbt_nest</span><span> </span><span>refl_onD</span><span> </span><span>reflexivity</span><span> </span><span>worse_in_no_better</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>same_nbt_same_pref</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ carrier"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ carrier"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ no_better_than y carrier relation ∧
         y ∈ no_better_than x carrier relation ⟷ x ≈ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>CollectD</span><span> </span><span>contra_subsetD</span><span> </span><span>no_better_subset_pref</span><span>
</span><span>        </span><span>no_better_than_def</span><span> </span><span>worse_in_no_better</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>indifferent_imp_weak_pref</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≈ y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span class="string"><span class="delete"><span class="delete">" x ≽ y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ≽ x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Finite carrier›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite carrier"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fnt_carrier_fnt_nbt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x∈carrier. finite (no_better_than x carrier relation)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ carrier"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (no_better_than x carrier relation)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>finite_subset</span><span> </span><span>nbt_subset_carrier</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹finite carrier›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nbt_subset_imp_card_leq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ carrier"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ carrier"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"no_better_than x carrier relation ⊆ no_better_than y carrier relation ⟷
  card (no_better_than x carrier relation) ≤ card  (no_better_than y carrier relation)"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?nbt ⟷ ?card"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?nbt"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?card"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>card_mono</span><span> </span><span>fnt_carrier_fnt_nbt</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?card"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?nbt"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span>  </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>card_seteq</span><span> </span><span>fnt_carrier_fnt_nbt</span><span> </span><span>nbt_nest</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>card_leq_pref</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ carrier"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ carrier"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (no_better_than x carrier relation) ≤ card (no_better_than y carrier relation)
   ⟷ y ≽ x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>nbt_subset_imp_card_leq</span><span> </span><span>no_better_thansubset_rel</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>nbt_subset_imp_card_leq</span><span> </span><span>no_better_subset_pref</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_ne_remove_induct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite B"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B ≠ {}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⋀A. finite A  ⟹ A ⊆ B ⟹ A ≠ {} ⟹
         (⋀x. x ∈ A ⟹ A - {x} ≠ {} ⟹ P (A - {x})) ⟹ P A"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P B"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>finite_remove_induct</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λF. F = {} ∨ P F"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>P</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_nempty_preorder_has_max</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite B"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B ≠ {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"refl_on B R"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans R"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"total_on B R"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x ∈ B. ∀y ∈ B. (x, y) ∈ R"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>subset_refl</span><span class="delimiter">[</span><span>of</span><span> </span><span>B</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>B</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>finite_subset_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>x</span><span> </span><span>F</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span>-</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"F = {}"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>refl_onD</span><span> </span><span>total_on_def</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>refl_onD2</span><span> </span><span>transE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_nempty_preorder_has_min</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite B"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B ≠ {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"refl_on B R"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans R"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"total_on B R"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x ∈ B. ∀y ∈ B. (y, x) ∈ R"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>subset_refl</span><span class="delimiter">[</span><span>of</span><span> </span><span>B</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>B</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>finite_subset_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>x</span><span> </span><span>F</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span>-</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"F = {}"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>refl_onD</span><span> </span><span>total_on_def</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>refl_onD2</span><span> </span><span>transE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_nonempty_carrier_has_maximum</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"carrier ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃e ∈ carrier. ∀m ∈ carrier. e ≽[relation] m"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_nempty_preorder_has_max</span><span class="delimiter">[</span><span>of</span><span> </span><span>carrier</span><span> </span><span>relation</span><span class="delimiter">]</span><span> </span><span>assms</span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">‹finite carrier›</span></span></span><span> </span><span>reflexivity</span><span> </span><span>total</span><span> </span><span>transitivity</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_nonempty_carrier_has_minimum</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"carrier ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃e ∈ carrier. ∀m ∈ carrier. m ≽[relation] e"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_nempty_preorder_has_min</span><span class="delimiter">[</span><span>of</span><span> </span><span>carrier</span><span> </span><span>relation</span><span class="delimiter">]</span><span> </span><span>assms</span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">‹finite carrier›</span></span></span><span> </span><span>reflexivity</span><span> </span><span>total</span><span> </span><span>transitivity</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*finite carrier*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_carrier_ex_sub_rel</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀c ⊆ carrier. ∃r ⊆ relation. rational_preference c r"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span>standard</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>c</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>c_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ⊆ carrier"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>r'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"r' = {(x,y) ∈ relation. x ∈ c ∧ y ∈ c}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>r'_sub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r' ⊆ c × c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>r'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ c. x ≽[r'] x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>CollectI</span><span> </span><span>c_in</span><span> </span><span>case_prodI</span><span> </span><span>compl</span><span> </span><span>r'_def</span><span> </span><span>subsetCE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>refl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"refl_on c r'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>r'_sub</span><span> </span><span>refl_onI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans r'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≽[r'] y"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ≽[r'] z"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" x ≽[r'] z"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>CollectD</span><span> </span><span>CollectI</span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>case_prodD</span><span> </span><span>case_prodI</span><span> </span><span>r'_def</span><span> </span><span>transE</span><span> </span><span>transitivity</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>total</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"total_on c r'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x ∈ c"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ c"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≠ y"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≽[r'] y ∨ y ≽[r'] x "</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>CollectI</span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>c_in</span><span> </span><span>case_prodI</span><span> </span><span>compl</span><span> </span><span>r'_def</span><span> </span><span>subset_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rational_preference c r'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>local.refl</span><span> </span><span>local.trans</span><span> </span><span>preference.intro</span><span> </span><span>preorder_on_def</span><span> </span><span>rational_preference.intro</span><span> 
</span><span>        </span><span>rational_preference_axioms.intro</span><span> </span><span>refl_on_domain</span><span> </span><span>total</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃r⊆relation. rational_preference c r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>CollectD</span><span> </span><span>case_prodD</span><span> </span><span>r'_def</span><span> </span><span>subrelI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*rational preference*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Local Non-Satiation ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Defining local non-satiation. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>local_nonsatiation</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"local_nonsatiation B P ⟷
   (∀x∈B. ∀e&gt;0. ∃y∈B. norm (y - x) ≤ e ∧ y ≻[P] x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Alternate definitions and intro/dest rules with them ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lns_alt_def1</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span> </span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_nonsatiation B P ⟷ (∀x ∈ B. ∀e&gt;0. (∃y ∈ B. dist y x ≤ e ∧ y ≻[P] x))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span> </span><span class="delimiter">:</span><span> </span><span>dist_norm</span><span> </span><span>local_nonsatiation_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lns_normI</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x e. x ∈ B ⟹ e &gt; 0 ⟹ (∃y∈B. norm (y - x) ≤ e ∧ y ≻[P] x)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_nonsatiation B P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>dist_norm</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lns_distI</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x e. x ∈ B ⟹ e &gt; 0 ⟹ (∃y∈B. (dist y x) ≤ e ∧ y ≻[P] x)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_nonsatiation B P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>lns_alt_def1</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lns_alt_def2</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"local_nonsatiation B P ⟷ (∀x∈B. ∀e&gt;0. (∃y.  y ∈ (ball x e) ∧ y ∈ B ∧ y ≻[P] x))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_nonsatiation B P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x∈B. ∀e&gt;0. ∃x'. x' ∈ ball x e ∧ x' ∈ B ∧ x' ≻[P] x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span> </span><span class="delimiter">:</span><span> </span><span>ball_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>dense</span><span> </span><span>le_less_trans</span><span> </span><span>dist_commute</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x∈B. ∀e&gt;0. ∃y. y ∈ ball x e ∧ y ∈ B ∧ y ≻[P] x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_nonsatiation B P"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>ball_def</span><span> </span><span>dist_commute</span><span>
</span><span>        </span><span>less_le_not_le</span><span> </span><span>lns_alt_def1</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lns_normD</span><span> </span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_nonsatiation B P"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ B. ∀e&gt;0. ∃y ∈ B. (norm (y - x) ≤ e ∧ y ≻[P] x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>assms</span><span> </span><span>local_nonsatiation_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Convex preferences ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>weak_convex_pref</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::real_vector) relation ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"weak_convex_pref Pr ⟷ (∀x y. x ≽[Pr] y ⟶
      (∀α β. α + β = 1 ∧ α &gt; 0 ∧ β &gt; 0 ⟶ α *<span class="hidden">⇩</span><sub>R</sub> x + β *<span class="hidden">⇩</span><sub>R</sub> y ≽[Pr] y))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>convex_pref</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::real_vector) relation ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"convex_pref Pr ⟷ (∀x y. x ≻[Pr] y ⟶
      (∀α. 1 &gt; α ∧ α &gt; 0 ⟶ α *<span class="hidden">⇩</span><sub>R</sub> x + (1-α) *<span class="hidden">⇩</span><sub>R</sub> y ≻[Pr] y))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>strict_convex_pref</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::real_vector) relation ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"strict_convex_pref Pr ⟷ (∀x y. x ≽[Pr] y ∧ x ≠ y ⟶
      (∀α. 1 &gt; α ∧ α &gt; 0 ⟶ α *<span class="hidden">⇩</span><sub>R</sub> x + (1-α) *<span class="hidden">⇩</span><sub>R</sub> y ≻[Pr] y))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>convex_ge_imp_conved</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x y. x ≽[Pr] y ⟶ (∀α β. α + β = 1 ∧ α ≥ 0 ∧ β ≥ 0 ⟶ α *<span class="hidden">⇩</span><sub>R</sub> x + β *<span class="hidden">⇩</span><sub>R</sub> y ≽[Pr] y)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"weak_convex_pref Pr"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>weak_convex_pref_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>weak_convexI</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x y α β. x ≽[Pr] y ⟹ α + β = 1 ⟹ 0 &lt; α ⟹ 0 &lt; β ⟹ α *<span class="hidden">⇩</span><sub>R</sub> x + β *<span class="hidden">⇩</span><sub>R</sub> y ≽[Pr] y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"weak_convex_pref Pr"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>weak_convex_pref_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>weak_convexD</span><span> </span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"weak_convex_pref Pr"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≽[Pr] y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; u"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; v"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u + v = 1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u *<span class="hidden">⇩</span><sub>R</sub> x + v *<span class="hidden">⇩</span><sub>R</sub> y ≽[Pr] y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>weak_convex_pref_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Real Vector Preferences ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Preference relations on real vector type class. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>real_vector_rpr</span><span> </span><span class="delimiter">=</span><span> </span><span>rational_preference</span><span> </span><span>carrier</span><span> </span><span>relation</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>carrier</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::real_vector set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>relation</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a relation"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span>  </span><span>real_vector_rpr</span><span> </span><span class="delimiter">⊆</span><span> </span><span>rational_preference</span><span> </span><span>carrier</span><span> </span><span>relation</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rational_preference_axioms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>real_vector_rpr</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>have_rpr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rational_preference carrier relation"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rational_preference_axioms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Multiple convexity alternate definitions intro/dest rules. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>weak_convex1D</span><span> </span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"weak_convex_pref relation"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≽[relation] y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ u"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ v"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u + v = 1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u *<span class="hidden">⇩</span><sub>R</sub> x + v *<span class="hidden">⇩</span><sub>R</sub> y ≽[relation] y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>u_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u = 0 ⟶ u *<span class="hidden">⇩</span><sub>R</sub> x + v *<span class="hidden">⇩</span><sub>R</sub> y ≽[relation] y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>u_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v = 1"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>u_0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?thesis"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add.left_neutral</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>preference.reflexivity</span><span> </span><span>preference_axioms</span><span>
</span><span>          </span><span>real_vector.scale_zero_left</span><span> </span><span>refl_onD2</span><span> </span><span>scaleR_one</span><span> </span><span>strict_not_refl_weak</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u *<span class="hidden">⇩</span><sub>R</sub> x + v *<span class="hidden">⇩</span><sub>R</sub> y ≽[relation] y "</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u_0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u ≠ 0 ∧ u ≠ 1 ⟶ u *<span class="hidden">⇩</span><sub>R</sub> x + v *<span class="hidden">⇩</span><sub>R</sub> y ≽[relation] y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_cancel_right_right</span><span> </span><span>antisym_conv</span><span> </span><span>not_le</span><span> </span><span>assms</span><span> </span><span>weak_convexD</span><span> </span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>u_0</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>5</span><span class="delimiter">)</span><span> </span><span>add_cancel_right_right</span><span> </span><span>real_vector.scale_zero_left</span><span> </span><span>scaleR_one</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>weak_convex1I</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span> </span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. convex (at_least_as_good x carrier relation)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"weak_convex_pref relation"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>weak_convexI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>α</span><span> </span><span>β</span><span> </span><span class="delimiter">::</span><span> </span><span>real</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assum</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≽[relation] y"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>reals</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; α"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; β"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">" α + β = 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ carrier"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>assum</span><span> </span><span>preference.not_outside</span><span> </span><span>rational_preference.axioms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>have_rpr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ carrier"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>assum</span><span> </span><span>refl_onD2</span><span> </span><span>reflexivity</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>y_in_upper_cont</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ (at_least_as_good y carrier relation)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>rational_preference.at_lst_asgd_not_ge</span><span>
</span><span>      </span><span>rational_preference.compl</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>empty_iff</span><span> </span><span>have_rpr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ (at_least_as_good y carrier relation)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assum</span><span> </span><span>pref_in_at_least_as</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ β"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ α"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>reals</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(α *<span class="hidden">⇩</span><sub>R</sub> x + β *<span class="hidden">⇩</span><sub>R</sub> y) ≽[relation] y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>at_least_as_goodD</span><span> </span><span>convexD</span><span> </span><span>reals</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>y_in_upper_cont</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Definition of convexity in "Handbook of Social Choice and Welfare"@{cite "arrow2010handbook"}. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>convex_def_alt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rational_preference carrier relation"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"weak_convex_pref relation"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀x ∈ carrier. convex (at_least_as_good x carrier relation))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>x_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ carrier"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"convex (at_least_as_good x carrier relation)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"convex ?x"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>convexI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span>α</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>β</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ ?x"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>b_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ ?x"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>reals</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" 0 ≤ α"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ β"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α + β = 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a_g_x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≽[relation] x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_in</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b_g_x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ≽[relation] x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b_in</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≽[relation] b ∨ b ≽[relation] a"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>a_in</span><span> </span><span>at_least_as_goodD</span><span> </span><span>b_in</span><span> </span><span>preference.not_outside</span><span>
</span><span>          </span><span>rational_preference.compl</span><span> </span><span>rational_preference_def</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α *<span class="hidden">⇩</span><sub>R</sub> a + β *<span class="hidden">⇩</span><sub>R</sub> b ∈ ?x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≽[relation] b"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α *<span class="hidden">⇩</span><sub>R</sub> a + β *<span class="hidden">⇩</span><sub>R</sub> b  ≽[relation] b"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>reals</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α *<span class="hidden">⇩</span><sub>R</sub> a + β *<span class="hidden">⇩</span><sub>R</sub> b ≽[relation] x"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>b_g_x</span><span>  </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>preference.not_outside</span><span> </span><span>x_in</span><span>
</span><span>            </span><span>rational_preference.strict_is_neg_transitive</span><span>
</span><span>            </span><span>rational_preference.strict_not_refl_weak</span><span> </span><span>rational_preference_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>CollectI</span><span>  </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>            </span><span>at_least_as_good_def</span><span> </span><span>preference_def</span><span> </span><span>rational_preference_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ≽[relation] a"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α *<span class="hidden">⇩</span><sub>R</sub> a + β *<span class="hidden">⇩</span><sub>R</sub> b ≽[relation] a"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add.commute</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>reals</span><span> </span><span>weak_convex1D</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α *<span class="hidden">⇩</span><sub>R</sub> a + β *<span class="hidden">⇩</span><sub>R</sub> b ≽[relation] a"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>as</span><span> </span><span>add.commute</span><span>  </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>            </span><span>reals</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>weak_convex1D</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α *<span class="hidden">⇩</span><sub>R</sub> a + β *<span class="hidden">⇩</span><sub>R</sub> b ≽[relation] x"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>a_g_x</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>preference.indiff_trans</span><span> </span><span>x_in</span><span>
</span><span>            </span><span>preference.not_outside</span><span> </span><span>rational_preference.axioms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>            </span><span>rational_preference.strict_is_neg_transitive</span><span> </span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pref_in_at_least_as</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>convex_imp_convex_str_upper_cnt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ carrier. convex (at_least_as_good x carrier relation)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"convex (at_least_as_good x carrier relation - as_good_as x carrier relation)"</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"convex ( ?a - ?b)"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>convexI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>y</span><span> </span><span>u</span><span> </span><span>v</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as_a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ ?a - ?b"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as_y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ ?a - ?b"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>reals</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ (u::real)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ v"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u + v = 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cvx</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"weak_convex_pref relation "</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>assms</span><span> </span><span>at_least_as_goodD</span><span> </span><span>convexI</span><span> </span><span>have_rpr</span><span>
</span><span>        </span><span>preference_def</span><span> </span><span>rational_preference.axioms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>weak_convex1I</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a_g_x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≻[relation] x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>as_a</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>y_gt_x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ≻[relation] x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>as_y</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u *<span class="hidden">⇩</span><sub>R</sub> a + v *<span class="hidden">⇩</span><sub>R</sub> y ∈ ?a - ?b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u *<span class="hidden">⇩</span><sub>R</sub> a + v *<span class="hidden">⇩</span><sub>R</sub> y ∈ ?a"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>DiffD1</span><span> </span><span>a_g_x</span><span> </span><span>as_a</span><span> </span><span>as_y</span><span> </span><span>assms</span><span> </span><span>convexD</span><span> </span><span>reals</span><span> </span><span>have_rpr</span><span>
</span><span>          </span><span>preference_def</span><span> </span><span>rational_preference.axioms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≽[relation] y ∨ y ≽[relation] a"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>a_g_x</span><span> </span><span>y_gt_x</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>preference.not_outside</span><span> </span><span>have_rpr</span><span>
</span><span>          </span><span>rational_preference.axioms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>rational_preference.strict_not_refl_weak</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u *<span class="hidden">⇩</span><sub>R</sub> a + v *<span class="hidden">⇩</span><sub>R</sub> y ∉ ?b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≽[relation] y"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u *<span class="hidden">⇩</span><sub>R</sub> a + v *<span class="hidden">⇩</span><sub>R</sub> y ≽[relation] y"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cvx</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>reals</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u *<span class="hidden">⇩</span><sub>R</sub> a + v *<span class="hidden">⇩</span><sub>R</sub> y ≻[relation] x"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>y_gt_x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>rational_preference.axioms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>have_rpr</span><span>
</span><span>            </span><span>rational_preference.strict_is_neg_transitive</span><span> </span><span>preference_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u *<span class="hidden">⇩</span><sub>R</sub> a + v *<span class="hidden">⇩</span><sub>R</sub> y ∉ as_good_as x carrier relation"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ≽[relation] a"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u *<span class="hidden">⇩</span><sub>R</sub> a + v *<span class="hidden">⇩</span><sub>R</sub> y ≽[relation] a"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cvx</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>reals</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add.commute</span><span> </span><span>weak_convex1D</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u *<span class="hidden">⇩</span><sub>R</sub> a + v *<span class="hidden">⇩</span><sub>R</sub> y ≻[relation] x"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>a_g_x</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>rational_preference.strict_is_neg_transitive</span><span>
</span><span>            </span><span>rational_preference.axioms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>preference_def</span><span> </span><span>have_rpr</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u *<span class="hidden">⇩</span><sub>R</sub> a + v *<span class="hidden">⇩</span><sub>R</sub> y ∉ ?b"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Monotone preferences ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>weak_monotone_prefs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set ⇒ ('a::ord) relation ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"weak_monotone_prefs B P ⟷ (∀x ∈ B. ∀y ∈ B. x ≥ y ⟶ x ≽[P]y)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>monotone_preference</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set ⇒ ('a::ord) relation ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"monotone_preference B P ⟷ (∀x ∈ B. ∀y ∈ B. x &gt; y ⟶ x ≻[P] y)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Given a carrier set that is unbounded above (not the "standard" mathematical definition),
       monotonicity implies local non-satiation. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unbounded_above_mono_imp_lns</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀M ∈ carrier. (∀x &gt; M. x ∈ carrier)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"monotone_preference (carrier:: 'a::ordered_euclidean_space set) relation"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_nonsatiation carrier relation"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>lns_distI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>e</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"real"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>x_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ carrier"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>gz</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e &gt; 0"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃y∈carrier. dist y x ≤ e ∧ y ≽[relation] x ∧ (x, y) ∉ relation"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>v</span><span> </span><span class="delimiter">::</span><span> </span><span>real</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>v</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"v &lt; e"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; v"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gz</span><span> </span><span>dense</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>i</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(i::'a) ∈ Basis"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>y_value</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y = x + v *<span class="hidden">⇩</span><sub>R</sub> i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ge</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"y ≥ x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>y_value</span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>y_value</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>v</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>zero_le_scaleR_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ≠ x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>y_value</span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>y_value</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>v</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>y_str_g_x</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y &gt; x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ge</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>y_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ carrier"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>x_in</span><span> </span><span>y_str_g_x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>y_pref_x</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ≻[relation] x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>y_str_g_x</span><span> </span><span>x_in</span><span> </span><span>mono</span><span> </span><span>monotone_preference_def</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" norm (y - x) ≤ e"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &lt; v›</span></span></span><span> </span><span>y_value</span><span> </span><span>y_value</span><span> </span><span>i</span><span> </span><span>v</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>dist_less_e</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dist y x ≤ e"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dist_norm</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>y_pref_x</span><span> </span><span>dist_less_e</span><span> </span><span>y_in</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="Utility_Functions">
<div class="head"><h1>Theory Utility_Functions</h1>
<span class="command">theory</span> <span class="name">Utility_Functions</span><br/>
<span class="keyword">imports</span> <a href="Preferences.html"><span class="name">Preferences</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* License: LGPL *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
Author: Julian Parsert &lt;julian.parsert@gmail.com&gt;
Author: Cezary Kaliszyk
*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Utility Functions ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Utility functions and results involving them. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Utility_Functions</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>    </span><span>Preferences</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ordinal utility functions"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Ordinal utility function locale ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>ordinal_utility</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>carrier</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>relation</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a relation"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>u</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ real"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>util_def</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ carrier ⟹ y ∈ carrier ⟹ x ≽[relation] y ⟷ u x ≥ u y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>not_outside</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≽[relation] y ⟹ x ∈ carrier"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≽[relation] y ⟹ y ∈ carrier"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>util_def_conf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ carrier ⟹ y ∈ carrier ⟹ u x ≥ u y ⟷ x ≽[relation] y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>util_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>relation_subset_crossp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"relation ⊆ carrier × carrier"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ relation"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀(a,b) ∈ relation. a ∈ carrier ∧ b ∈ carrier"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>case_prod_conv</span><span> </span><span>ordinal_utility_axioms</span><span> </span><span>ordinal_utility_def</span><span> </span><span>surj_pair</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ carrier × carrier"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∈ relation›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Utility function implies totality of relation ›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>util_imp_total</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"total_on carrier relation"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>x_inc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ carrier"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y_inc</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ carrier"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fst</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u x ≥ u y ∨ u y ≥ u x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>util_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"x ≽[relation] y ∨ y ≽[relation] x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>x_inc</span><span> </span><span>y_inc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>x_y_in_carrier</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≽[relation] y ⟹ x ∈ carrier ∧ y ∈ carrier"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>ordinal_utility_axioms</span><span> </span><span>ordinal_utility_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Utility function implies transitivity of relation. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>util_imp_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans relation"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>transI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>z</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>x_y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≽[relation] y"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>y_z</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ≽[relation] z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x_ge_y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≽[relation] y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x_y</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x_y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u x ≥ u y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>x_y_in_carrier</span><span> </span><span>ordinal_utility_axioms</span><span> </span><span>util_def</span><span> </span><span>x_y</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u y ≥ u z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>y_z</span><span> </span><span>ordinal_utility_axioms</span><span> </span><span>ordinal_utility_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ carrier"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x_y_in_carrier</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">]</span><span> </span><span>x_ge_y</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u x ≥ u z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹u z ≤ u y›</span></span></span><span> </span><span>order_trans</span><span> </span><span>x_y</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≽[relation] z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∈ carrier›</span></span></span><span> </span><span>ordinal_utility_axioms</span><span> </span><span>ordinal_utility_def</span><span> </span><span>y_z</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≽[relation] z"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>util_imp_refl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"refl_on carrier relation"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>refl_on_def</span><span> </span><span>relation_subset_crossp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>affine_trans_is_u</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀α&gt;0. (∀β. ordinal_utility  carrier relation (λx. u(x)*α + β))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>impI</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>allI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>α</span><span class="delimiter">::</span><span>real</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>β</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>*</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"α &gt; 0"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ordinal_utility carrier relation (λx. u x * α + β)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>ordinal_utility_def</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>*</span><span> </span><span>add.commute</span><span> </span><span>add_le_cancel_left</span><span> </span><span>not_le</span><span> </span><span>real_mult_less_iff1</span><span> </span><span>util_def_conf</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>refl_on_domain</span><span> </span><span>util_imp_refl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ This utility function definition is ordinal.
        Hence they are only unique up to a monotone transformation. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ordinality_of_utility_function</span><span> </span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real ⇒ real"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>monot</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"monotone (&gt;) (&gt;) f"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(f ∘ u) x &gt; (f ∘ u) y ⟷ u x &gt; u y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?func</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(λx. f(u x))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀m n . u m ≥ u n ⟷ ?func m ≥ ?func n"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>le_less</span><span> </span><span>monot</span><span> </span><span>monotone_def</span><span> </span><span>not_less</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u x &gt; u y ⟷ ?func x &gt; ?func y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>utility_prefs_corresp</span><span> </span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real ⇒ real"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>monotonicity</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"monotone (&gt;) (&gt;) f"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x∈carrier. ∀y∈carrier. (x,y) ∈ relation ⟷ (f ∘ u) x ≥ (f ∘ u) y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>monotonicity</span><span> </span><span>not_less</span><span> </span><span>ordinality_of_utility_function</span><span> </span><span>util_def_conf</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>monotone_comp_is_utility</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real ⇒ real"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>monot</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"monotone (&gt;) (&gt;) f"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ordinal_utility carrier relation (f ∘ u)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ordinal_utility.intro</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>monot</span><span> </span><span>utility_prefs_corresp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_outside</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x_y_in_carrier</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ordinal_utility_left</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≽[relation] y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u x ≥ u y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>x_y_in_carrier</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>add_right</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x y. x ≽[relation] y ⟹ f x ≥ f y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"ordinal_utility carrier relation (λx. u x + f x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ordinal_utility.intro</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>xy</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ carrier"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ carrier"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u x ≤ u y ⟶ (∃r. ((x, y) ∉ relation ∧ ¬ r ≤ u x + f x) ∧ r ≤ u y + f y) ∨ u y ≤ u x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>add_le_cancel_left</span><span> </span><span>add_le_cancel_right</span><span> </span><span>assms</span><span> </span><span>util_def</span><span> </span><span>xy</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>xy</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>add_mono</span><span> </span><span>assms</span><span> </span><span>calculation</span><span> </span><span>le_cases</span><span> </span><span>order_trans</span><span> </span><span>util_def</span><span> </span><span>xy</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>xy</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_outside</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x_y_in_carrier</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>add_left</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x y. x ≽[relation] y ⟹ f x ≥ f y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ordinal_utility carrier relation (λx. f x + u x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ordinal_utility carrier relation (λx. u x + f x)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add_right</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Groups.ab_semigroup_add_class.add.commute</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add.commute</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ordinal_utility_scale_transl</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c::real) &gt; 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ordinal_utility carrier relation (λx. c * (u x) + d)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"monotone (&gt;) (&gt;) (λx. c * x + d)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"monotone (&gt;) (&gt;) ?fn"</span></span></span><span> </span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>monotone_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>monotone_comp_is_utility</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ordinal_utility carrier relation (?fn ∘ u)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?fn ∘ u =  (λx. c * (u x) + d)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strict_prefernce_iff_strict_utility</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ carrier"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ carrier"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≻[relation] y ⟷ u x &gt; u y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>less_eq_real_def</span><span> </span><span>not_less</span><span> </span><span>util_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ A utility function implies a rational preference relation.
      Hence a utility function contains exactly the same amount of information as a RPR ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>ordinal_utility</span><span> </span><span class="delimiter">⊆</span><span> </span><span>rational_preference</span><span> </span><span>carrier</span><span> </span><span>relation</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>xy</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≽[relation] y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ carrier"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ carrier"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_outside</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>meson</span><span> </span><span>xy</span><span> </span><span>refl_onD2</span><span> </span><span>util_imp_refl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"preorder_on carrier relation"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans relation"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>util_imp_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"preorder_on carrier relation"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>preorder_on_def</span><span> </span><span>util_imp_refl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"total_on carrier relation"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>util_imp_total</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Given a finite carrier set. We can guarantee that given a rational preference
       relation, there must also exist a utility function representing this relation.
       Construction of witness roughly follows from.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>fnt_carrier_exists_util_fun</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite carrier"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rational_preference carrier relation"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃u. ordinal_utility carrier relation u"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f = (λx. card (no_better_than x carrier relation))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ordinal_utility carrier relation f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>x_c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ carrier"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>y_c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ carrier"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≽[relation] y ⟷ (real (f y) ≤ real (f x))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≽[relation] y"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>yn</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>        </span><span>yn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"yn = no_better_than y carrier relation"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>xn</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>        </span><span>xn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"xn = no_better_than x carrier relation"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"yn ⊆ xn"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>asm</span><span> </span><span>yn</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>rational_preference.no_better_subset_pref</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card yn ≤ card xn"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>x_c</span><span> </span><span>y_c</span><span> </span><span>asm</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>rational_preference.card_leq_pref</span><span> </span><span>xn</span><span> </span><span>yn</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(real (f y) ≤ real (f x))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>f</span><span> </span><span>xn</span><span> </span><span>yn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"real (f y) ≤ real (f x)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≽[relation] y"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>f</span><span> </span><span>rational_preference.card_leq_pref</span><span> </span><span>x_c</span><span> </span><span>y_c</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≽[relation] y"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ carrier"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>asm</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>preference.not_outside</span><span> </span><span>rational_preference.axioms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ carrier"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>asm</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>preference_def</span><span> </span><span>rational_preference_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>obt_u_fnt_carrier</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite carrier"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rational_preference carrier relation"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>u</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ordinal_utility carrier relation u"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>fnt_carrier_exists_util_fun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>ordinal_util_imp_rat_prefs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ordinal_utility carrier relation u"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rational_preference carrier relation"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>assms</span><span> </span><span>order_on_defs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>ordinal_utility.util_imp_refl</span><span> 
</span><span>      </span><span>ordinal_utility.util_imp_total</span><span> </span><span>ordinal_utility.util_imp_trans</span><span> </span><span>ordinal_utility_def</span><span> 
</span><span>      </span><span>preference.intro</span><span> </span><span>rational_preference.intro</span><span> </span><span>rational_preference_axioms_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Utility function on  Euclidean Space ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>eucl_ordinal_utility</span><span> </span><span class="delimiter">=</span><span> </span><span>ordinal_utility</span><span> </span><span>carrier</span><span> </span><span>relation</span><span> </span><span>u</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>carrier</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::euclidean_space) set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>relation</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a relation"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ real"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>eucl_ordinal_utility</span><span> </span><span class="delimiter">⊆</span><span> </span><span>rational_preference</span><span> </span><span>carrier</span><span> </span><span>relation</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rational_preference_axioms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ord_eucl_utility_imp_rpr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"eucl_ordinal_utility s rel u ⟶ real_vector_rpr s rel"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eucl_ordinal_utility.axioms</span><span> </span><span>ordinal_util_imp_rat_prefs</span><span> </span><span>real_vector_rpr.intro</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>eucl_ordinal_utility</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Local non-satiation on utility functions ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lns_pref_lns_util</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"local_nonsatiation carrier relation ⟷
  (∀x∈carrier. ∀e &gt; 0. ∃y∈carrier.
  norm (y - x) ≤ e ∧ u y &gt; u x)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ ⟷ ?alt"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>lns</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"local_nonsatiation carrier relation"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a b. a ≻ b ⟶ u a &gt; u b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>less_eq_real_def</span><span> </span><span>util_def</span><span> </span><span>x_y_in_carrier</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?alt"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>lns</span><span> </span><span>local_nonsatiation_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>lns</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?alt"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_nonsatiation carrier relation"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>lns_normI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>e</span><span class="delimiter">::</span><span>real</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>x_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ carrier"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e &gt; 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x ∈ carrier. ∀e&gt;0. ∃y∈carrier. norm (y - x) ≤ e ∧ y ≻ x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>less_eq_real_def</span><span> </span><span>linorder_not_less</span><span> </span><span>lns</span><span> </span><span>util_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃y∈carrier. norm (y - x) ≤ e ∧ u y &gt; u x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>e</span><span> </span><span>x_in</span><span> </span><span>lns</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃y∈carrier. norm (y - x) ≤ e ∧ y ≻ x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>compl</span><span> </span><span>not_less</span><span> </span><span>util_def</span><span> </span><span>x_in</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_carrier_rpr_iff_u</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite carrier"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(relation::'a relation) ⊆ carrier × carrier"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rational_preference carrier relation ⟷ (∃u. ordinal_utility carrier relation u)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rational_preference carrier relation"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃u. ordinal_utility carrier relation u"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>fnt_carrier_exists_util_fun</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃u. ordinal_utility carrier relation u"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rational_preference carrier relation"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>order_on_defs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>ordinal_utility.util_imp_refl</span><span> 
</span><span>        </span><span>ordinal_utility.util_imp_total</span><span> </span><span>ordinal_utility.util_imp_trans</span><span> </span><span>ordinal_utility_def</span><span> 
</span><span>        </span><span>preference.intro</span><span> </span><span>rational_preference_axioms_def</span><span> </span><span>rational_preference_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="Consumers">
<div class="head"><h1>Theory Consumers</h1>
<span class="command">theory</span> <span class="name">Consumers</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL-Analysis/Multivariate_Analysis.html"><span class="name">Multivariate_Analysis</span></a> <a href="Syntax.html"><span class="name">Syntax</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* License: LGPL *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
Author: Julian Parsert &lt;julian.parsert@gmail.com&gt;
Author: Cezary Kaliszyk
*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Consumers  ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Consumption sets ›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Consumers</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span>                 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"HOL-Analysis.Multivariate_Analysis"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"../Syntax"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Pre Arrow-Debreu consumption set ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ It turns out that the First Welfare Theorem does
       not require any particular limitations on the consumption set ›</span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>pre_arrow_debreu_consumption_set</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>consumption_set</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::euclidean_space) set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ (UNIV:: 'a set) ⟹ x ∈ consumption_set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Arrow-Debreu model consumption set›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ The Arrow-Debreu model consumption set includes more and stricter
        assumptions which are necessary for further results. ›</span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>gen_pre_arrow_debreu_consum_set</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>consumption_set</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::ordered_euclidean_space) set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>arrow_debreu_consum_set</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>consumption_set</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::ordered_euclidean_space) set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>r_plus</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"consumption_set ⊆ {(x::'a). x ≥ 0}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>closed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"closed consumption_set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>convex</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"convex consumption_set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>non_empty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"consumption_set ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀M ∈ consumption_set. (∀x &gt; M. x ∈ consumption_set)"</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*unbounded above*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>x_larger_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ consumption_set ⟹ x ≥ 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>r_plus</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>larger_in_consump_set</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x ∈ consumption_set ∧ y ≥ x ⟹ y ∈ consumption_set"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>arrow_debreu_consum_set_axioms</span><span> </span><span>arrow_debreu_consum_set_def</span><span>
</span><span>    </span><span>dual_order.order_iff_strict</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="Common">
<div class="head"><h1>Theory Common</h1>
<span class="command">theory</span> <span class="name">Common</span><br/>
<span class="keyword">imports</span> <a href="Utility_Functions.html"><span class="name">Utility_Functions</span></a> <a href="Argmax.html"><span class="name">Argmax</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* License: LGPL *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
Author: Julian Parsert &lt;julian.parsert@gmail.com&gt;
Author: Cezary Kaliszyk
*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Common</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"../Preferences"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"../Utility_Functions"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"../Argmax"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Pareto Ordering ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Allows us to define a Pareto Ordering. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>pareto_ordering</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>agents</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'i set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>U</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'i ⇒ 'a ⇒ real"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>U</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"U[_]"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>pareto_dominating</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"≻Pareto"</span></span></span><span>  </span><span>60</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"X ≻Pareto Y ⟷
      (∀i ∈ agents. U[i] (X i) ≥ U[i] (Y i)) ∧
      (∃i ∈ agents. U[i] (X i) &gt; U[i] (Y i))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trans_strict_pareto</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ≻Pareto Y ⟹ Y ≻Pareto Z ⟹ X ≻Pareto Z"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ≻Pareto Y"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Y ≻Pareto Z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i ∈ agents. U[i] (Z i) ≤ U[i] (X i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>a1</span><span> </span><span>order_trans</span><span> </span><span>pareto_dominating_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃i ∈ agents. ¬ U[i] (X i) ≤ U[i] (Y i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>pareto_dominating_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Y ≻Pareto Z›</span></span></span><span> </span><span>less_eq_real_def</span><span> </span><span>pareto_dominating_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>anti_sym_strict_pareto</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ≻Pareto Y ⟹ ¬Y ≻Pareto X"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pareto_dominating_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Budget constraint›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Definition returns all afforedable bundles given wealth W ›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ f is a function that computes the value given a bundle›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>budget_constraint</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"budget_constraint f S W = {x ∈ S. f x ≤ W}"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Feasiblity ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>feasible_private_ownership</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"feasible_private_ownership A F ℰ Cs Ps X Y ⟷
      (∑i∈A. X i) ≤ (∑i∈A. ℰ i) + (∑j∈F. Y j) ∧
      (∀i∈A. X i ∈ Cs) ∧ (∀j∈F. Y j ∈ Ps j)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>feasible_private_ownershipD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"feasible_private_ownership A F ℰ Cs Ps X Y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑i∈A. X i) ≤ (∑i∈A. ℰ i) + (∑j∈F. Y j)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀i∈A. X i ∈ Cs)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀j∈F. Y j ∈ Ps j)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>feasible_private_ownership_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>assms</span><span> </span><span>feasible_private_ownership_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>meson</span><span> </span><span>assms</span><span> </span><span>feasible_private_ownership_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Exchange_Economy">
<div class="head"><h1>Theory Exchange_Economy</h1>
<span class="command">theory</span> <span class="name">Exchange_Economy</span><br/>
<span class="keyword">imports</span> <a href="Consumers.html"><span class="name">Consumers</span></a> <a href="Common.html"><span class="name">Common</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* License: LGPL *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
Author: Julian Parsert &lt;julian.parsert@gmail.com&gt;
Author: Cezary Kaliszyk
*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Exchange_Economy</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"../Preferences"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"../Utility_Functions"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"../Argmax"</span></span></span><span>
</span><span>    </span><span>Consumers</span><span>
</span><span>    </span><span>Common</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Exchange Economy ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Define the exchange economy model ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>exchange_economy</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>consumption_set</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::ordered_euclidean_space) set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>agents</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'i set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>ℰ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'i ⇒ 'a"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>Pref</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'i ⇒ 'a relation"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>U</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'i ⇒ 'a ⇒ real"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>cons_set_props</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pre_arrow_debreu_consumption_set consumption_set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>agent_props</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ agents ⟹ eucl_ordinal_utility consumption_set (Pref i) (U i)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>finite_agents</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite agents"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"agents ≠ {}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>exchange_economy</span><span> </span><span class="delimiter">⊆</span><span> </span><span>pareto_ordering</span><span> </span><span>agents</span><span> </span><span>U</span><span>
</span><span>  </span><span class="keyword1"><span class="command">.</span></span><span>                                 
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>exchange_economy</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> 
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>U</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"U[_]"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>Pref</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"Pr[_]"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>ℰ</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"ℰ[_]"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>base_pref_is_ord_eucl_rpr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ agents ⟹ rational_preference consumption_set Pr[i]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>exchange_economy.agent_props</span><span> </span><span>exchange_economy_axioms</span><span>
</span><span>      </span><span>ord_eucl_utility_imp_rpr</span><span> </span><span>real_vector_rpr.have_rpr</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>calculate_value</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"calculate_value P x ≡ P ∙ x"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Feasibility ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>feasible_allocation</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"feasible_allocation A E ⟷
      (∑i∈agents. A i) ≤ (∑i∈agents. E i)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Pareto optimality ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>pareto_optimal_endow</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"pareto_optimal_endow X E ⟷
              (feasible_allocation X E ∧
              (∄X'. feasible_allocation X' E ∧ X' ≻Pareto X))"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Competitive Equilibrium in Exchange Economy ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Competitive Equilibirum or Walrasian Equilibrium definition. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>comp_equilib_endow</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"comp_equilib_endow P X E ≡
      feasible_allocation X E ∧
      (∀i ∈ agents. X i ∈ arg_max_set U[i]
        (budget_constraint (calculate_value P) consumption_set (P ∙ E i)))"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Lemmas for final result ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>utility_function_def</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ agents"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U[i] x ≥ U[i] y ⟷ x ≽[Pr[i]] y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ordinal_utility consumption_set (Pref i) (U[i])"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>agent_props</span><span> </span><span>assms</span><span> </span><span>eucl_ordinal_utility_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" U[i] y ≤  U[i] x ⟹ x ≽[Pref i] y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>UNIV_I</span><span> </span><span>cons_set_props</span><span> </span><span>ordinal_utility.util_def_conf</span><span>
</span><span>        </span><span>pre_arrow_debreu_consumption_set_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≽[Pref i] y ⟹ U[i] y ≤ U[i] x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>agent_props</span><span> </span><span>assms</span><span> </span><span>ordinal_utility_def</span><span> </span><span>eucl_ordinal_utility_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>budget_constraint_is_feasible</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ agents"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ (budget_constraint (calculate_value P) consumption_set (P ∙ ℰ[i]))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙ X ≤ P ∙ ℰ[i]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>budget_constraint_def</span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>budget_constraint_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>arg_max_set_therefore_no_better</span><span> </span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ agents"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ arg_max_set U[i] (budget_constraint (calculate_value P) consumption_set (P ∙ ℰ[i]))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U[i] y &gt; U[i] x ⟶ y ∉ budget_constraint (calculate_value P) consumption_set (P ∙ ℰ[i])"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>no_better_in_s</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Since we need no restriction on the consumption set for the First Welfare Theorem ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>consumption_set_member</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. x ∈ consumption_set"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀(x::'a). x ∈ consumption_set"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cons_set_props</span><span> </span><span>pre_arrow_debreu_consumption_set_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pre_arrow_debreu_consumption_set_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Under the assumption of Local non-satiation, agents will utilise their entire budget. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>argmax_entire_budget</span><span> </span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ agents"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_nonsatiation consumption_set Pr[i]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ arg_max_set U[i] (budget_constraint (calculate_value P) consumption_set (P ∙ ℰ[i]))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙ X = P ∙ ℰ[i]"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>leq</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(P ∙ X) ≤ (P ∙ ℰ[i])"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ budget_constraint (calculate_value P) consumption_set (P ∙ ℰ[i])"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>argmax_sol_in_s</span><span class="delimiter">[</span><span>of</span><span> </span><span>X</span><span> </span><span class="string"><span class="delete"><span class="delete">"U[i]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"budget_constraint (calculate_value P) consumption_set (P ∙ ℰ[i])"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>budget_constraint_is_feasible</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>not_less</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(P ∙ X &lt; P ∙ ℰ[i])"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>cpos</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(P ∙ X) &lt; (P ∙ ℰ[i])"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>lesS</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lesS = {x. P ∙ x &lt; P ∙ ℰ[i]}"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>e</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; e"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ball X e ⊆ lesS"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>cpos</span><span> </span><span>lesS_def</span><span> </span><span>mem_Collect_eq</span><span>
</span><span>          </span><span>open_contains_ball_eq</span><span> </span><span>open_halfspace_lt</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>Y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Y ≻[Pref i] X "</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Y ∈ ball X e"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>e</span><span> </span><span>consumption_set_member</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Y ∈ consumption_set"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>consumption_set_member</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Y ∈ budget_constraint (calculate_value P) consumption_set (P ∙ ℰ[i])"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>budget_constraint_def</span><span> </span><span>e</span><span> </span><span>lesS_def</span><span>
</span><span>        </span><span>less_eq_real_def</span><span> </span><span>Y</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>assms</span><span> </span><span>Y</span><span> </span><span>all_leq</span><span> </span><span>utility_function_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>leq</span><span> </span><span>not_less</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ All bundles that would be strictly preferred to any argmax result, are more expensive. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pref_more_expensive</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ agents"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ arg_max_set U[i] (budget_constraint (calculate_value P) consumption_set (P ∙ ℰ[i]))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U[i] y &gt; U[i] x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∙ P &gt; P ∙ ℰ[i]"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>cpos</span><span> </span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬(y ∙ P &gt; P ∙ ℰ[i])"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xp_leq</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∙ P ≤ P ∙  ℰ[i]"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ budget_constraint (calculate_value P) consumption_set (P ∙ ℰ[i])"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>argmax_sol_in_s</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span class="string"><span class="delete"><span class="delete">" U[i]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"budget_constraint (calculate_value P) consumption_set (P ∙ ℰ[i])"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>xp_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ budget_constraint (calculate_value P) consumption_set (P ∙ ℰ[i])"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙ y ≤ P ∙ ℰ[i]"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>xp_leq</span><span> </span><span>inner_commute</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>consumption_set_member</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>budget_constraint_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ≻[Pref i] x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>arg_max_set_therefore_no_better</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ≻[Pref i] x ∧ y ∈ budget_constraint (calculate_value P) consumption_set (P ∙ ℰ[i])"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xp_in</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ arg_max_set U[i] (budget_constraint (calculate_value P) consumption_set (P ∙ ℰ[i]))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>assms</span><span> </span><span>exchange_economy.arg_max_set_therefore_no_better</span><span>
</span><span>        </span><span>exchange_economy_axioms</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Greater or equal utility implies greater or equal price. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>same_util_is_equal_or_more_expensive</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ agents"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_nonsatiation consumption_set Pr[i]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ arg_max_set U[i] (budget_constraint (calculate_value P) consumption_set (P ∙ ℰ[i]))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U[i] y ≥ U[i] x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∙ P ≥ P ∙ ℰ[i]"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>not_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∉ arg_max_set U[i] (budget_constraint (calculate_value P) consumption_set (P ∙ ℰ[i]))
    ⟹ y ∙ P &gt; P ∙ ℰ[i]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∉ arg_max_set U[i] (budget_constraint (calculate_value P) consumption_set (P ∙ ℰ[i]))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∉ budget_constraint (calculate_value P) consumption_set (P ∙ ℰ[i])"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>assms</span><span> </span><span>leq_all_in_sol</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>budget_constraint_def</span><span> </span><span>inner_commute</span><span>
</span><span>          </span><span>consumption_set_member</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>argmax_entire_budget</span><span> </span><span>not_in</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span>
</span><span>        </span><span>dual_order.order_iff_strict</span><span> </span><span>inner_commute</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_in_argmax_same_price</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ agents"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"local_nonsatiation consumption_set Pr[i]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ arg_max_set U[i] (budget_constraint (calculate_value P) consumption_set (P ∙ ℰ[i]))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"y ∈ arg_max_set U[i] (budget_constraint (calculate_value P) consumption_set (P ∙ ℰ[i]))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙ x = P ∙ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>argmax_entire_budget</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ All rationally acting agents (which is every agent by assumption)
        will not decrease his utility ›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>individual_rationalism</span><span> </span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"comp_equilib_endow P X ℰ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i ∈ agents. X i ≽[Pref i] ℰ[i]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>pref_more_expensive</span><span> </span><span>comp_equilib_endow_def</span><span> </span><span>assms</span><span>
</span><span>      </span><span>inner_commute</span><span> </span><span>less_irrefl</span><span> </span><span>not_le</span><span> </span><span>utility_function_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>walras_law_per_agent</span><span> </span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. i ∈ agents ⟹ local_nonsatiation consumption_set Pr[i]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"comp_equilib_endow P X ℰ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i ∈ agents. P ∙ X i = P ∙ ℰ[i]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>argmax_entire_budget</span><span> </span><span>comp_equilib_endow_def</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Walras Law holds in our Exchange Economy model. It states that in an equilibrium,
       demand equals supply ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>walras_law</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. i ∈ agents ⟹ local_nonsatiation consumption_set Pr[i]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"comp_equilib_endow P X ℰ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑i∈agents. P ∙ (X i)) - (∑i∈agents. P ∙ ℰ[i]) = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>walras_law_per_agent</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inner_with_ge_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(P::(real, 'n::finite) vec) &gt; 0 ⟹ A ≥ B ⟹  P ∙ A ≥ P ∙ B"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>dual_order.order_iff_strict</span><span> </span><span>inner_commute</span><span>
</span><span>      </span><span>interval_inner_leI</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>ord_class.atLeastAtMost_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ First Welfare Theorem in Exchange Economy ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ We prove the first welfare theorem in our Exchange Economy model. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>first_welfare_theorem_exchange</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>lns</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. i ∈ agents ⟹ local_nonsatiation consumption_set Pr[i]"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>price_cond</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Price &gt; 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>equilibrium</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"comp_equilib_endow Price 𝒳 ℰ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pareto_optimal_endow 𝒳 ℰ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>neg_ass</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ pareto_optimal_endow 𝒳 ℰ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>equili_feasible</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"feasible_allocation 𝒳 ℰ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_equilib_endow_def</span><span> </span><span>equilibrium</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>comp_equilib_endow_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>price_g_zero</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Price &gt; 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>price_cond</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>xprime_pareto</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"feasible_allocation Y ℰ ∧
            (∀i ∈ agents. U[i] (Y i) ≥ U[i] (𝒳 i)) ∧
            (∃i ∈ agents. U[i] (Y i) &gt; U[i] (𝒳 i))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>equili_feasible</span><span> </span><span>neg_ass</span><span> </span><span>pareto_dominating_def</span><span>
</span><span>      </span><span>pareto_optimal_endow_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>is_feasible</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"feasible_allocation Y ℰ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xprime_pareto</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>all_great_eq_value</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i ∈ agents. Price ∙ (Y i) ≥ Price ∙ (𝒳 i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ agents"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Price ∙ (Y i) ≥ Price ∙ (𝒳 i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x_in_agmx</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(𝒳 i) ∈ arg_max_set U[i] (budget_constraint (calculate_value Price) consumption_set (Price ∙ ℰ[i]))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i ∈ agents›</span></span></span><span> </span><span>comp_equilib_endow_def</span><span> </span><span>equilibrium</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"( U[i]) (𝒳 i) - U[i] (Y i) ≤ 0"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i ∈ agents›</span></span></span><span> </span><span>xprime_pareto</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Price ∙ (𝒳 i) - Price ∙ (Y i) ≤ 0"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i ∈ agents›</span></span></span><span> </span><span>argmax_entire_budget</span><span> </span><span>diff_le_0_iff_le</span><span> </span><span>x_in_agmx</span><span>
</span><span>            </span><span>inner_commute</span><span> </span><span>lns</span><span> </span><span>same_util_is_equal_or_more_expensive</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ex_greater_value</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃i ∈ agents. Price ∙ (Y i) &gt; Price ∙ (𝒳 i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(∃i ∈ agents. Price ∙ (Y i) &gt; Price ∙ (𝒳 i))"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>obt_witness</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ agents"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U[i] (Y i) &gt; ( U[i]) (𝒳 i)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xprime_pareto</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Price ∙ Y i ≠ Price ∙ 𝒳 i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Price ∙ Y i &gt; Price ∙ ℰ i"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>pref_more_expensive</span><span> </span><span>comp_equilib_endow_def</span><span>
</span><span>            </span><span>equilibrium</span><span> </span><span>inner_commute</span><span> </span><span>obt_witness</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>obt_witness</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Price ∙ ℰ i = Price ∙ 𝒳 i"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>equilibrium</span><span> </span><span>lns</span><span> </span><span>obt_witness</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>walras_law_per_agent</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Price ∙ ℰ i &lt; Price ∙ Y i›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>all_great_eq_value</span><span> </span><span>obt_witness</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dominating_more_exp</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Price ∙ (∑i∈agents. Y i) &gt; Price ∙ (∑i∈agents. 𝒳 i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>mp_rule</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑i∈agents. Price ∙ Y i) &gt; (∑i∈agents. Price ∙ 𝒳 i) ⟹ ?thesis"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inner_sum_right</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑i∈agents. Price ∙ Y i) &gt; (∑i∈agents. Price ∙ 𝒳 i)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>all_great_eq_value</span><span> </span><span>finite_agents</span><span> </span><span>ex_greater_value</span><span> </span><span>sum_strict_mono_ex1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Price ∙ (∑i∈agents. Y i) &gt; Price ∙ (∑i∈agents. 𝒳 i)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mp_rule</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>equili_walras_law</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Price ∙ (∑i∈agents. 𝒳 i) = Price ∙ (∑i∈agents. ℰ[i])"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">)</span><span> </span><span>eq_iff_diff_eq_0</span><span> </span><span>equilibrium</span><span>
</span><span>        </span><span>inner_sum_right</span><span> </span><span>lns</span><span> </span><span>walras_law</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dominating_feasible</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Price ∙ (∑i∈agents. 𝒳 i) ≥ Price ∙ (∑i∈agents. Y i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>atLeastAtMost_iff</span><span> </span><span>dual_order.order_iff_strict</span><span> </span><span>equili_walras_law</span><span>
</span><span>        </span><span>feasible_allocation_def</span><span> </span><span>inner_commute</span><span> </span><span>interval_inner_leI</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>is_feasible</span><span> </span><span>price_g_zero</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dominating_more_exp</span><span> </span><span>equili_walras_law</span><span> </span><span>dominating_feasible</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Monotone preferences can be used instead of local non-satiation.
       Many textbooks etc. do not introduce the concept of
       local non-satiation and use monotonicity instead. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>first_welfare_exch_thm_monot</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀M ∈ carrier. (∀x &gt; M. x ∈ carrier)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. i ∈ agents ⟹ monotone_preference consumption_set Pr[i]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>price_cond</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Price &gt; 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"comp_equilib_endow Price 𝒳 ℰ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pareto_optimal_endow 𝒳 ℰ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>assms</span><span> </span><span>exchange_economy.consumption_set_member</span><span>
</span><span>      </span><span>first_welfare_theorem_exchange</span><span> </span><span>exchange_economy_axioms</span><span> </span><span>unbounded_above_mono_imp_lns</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="Private_Ownership_Economy">
<div class="head"><h1>Theory Private_Ownership_Economy</h1>
<span class="command">theory</span> <span class="name">Private_Ownership_Economy</span><br/>
<span class="keyword">imports</span> <a href="Consumers.html"><span class="name">Consumers</span></a> <a href="Common.html"><span class="name">Common</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* License: LGPL *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
Author: Julian Parsert &lt;julian.parsert@gmail.com&gt;
Author: Cezary Kaliszyk
*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Pre Arrow-Debreu model ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Model similar to Arrow-Debreu model but with fewer assumptions,
       since we only need assumptions strong enough to proof the First Welfare Theorem. ›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Private_Ownership_Economy</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"../Preferences"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"../Preferences"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"../Utility_Functions"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"../Argmax"</span></span></span><span>
</span><span>    </span><span>Consumers</span><span>
</span><span>    </span><span>Common</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>pre_arrow_debreu_model</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>production_sets</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'f ⇒ ('a::ordered_euclidean_space) set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>consumption_set</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>agents</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'i set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>firms</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'f set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>ℰ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'i ⇒ 'a"</span></span></span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"ℰ[_]"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>Pref</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'i ⇒ 'a relation"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"Pr[_]"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>U</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'i ⇒ 'a ⇒ real"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"U[_]"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>Θ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'i ⇒ 'f ⇒ real"</span></span></span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"Θ[_,_]"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>cons_set_props</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pre_arrow_debreu_consumption_set consumption_set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>agent_props</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ agents ⟹ eucl_ordinal_utility consumption_set (Pr[i]) (U[i])"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>firms_comp_owned</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j ∈ firms ⟹ (∑i∈agents. Θ[i,j]) = 1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>finite_nonepty_agents</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite agents"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"agents ≠ {}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>pre_arrow_debreu_model</span><span> </span><span class="delimiter">⊆</span><span> </span><span>pareto_ordering</span><span> </span><span>agents</span><span> </span><span>U</span><span>
</span><span>  </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>pre_arrow_debreu_model</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ No restrictions on consumption set needed ›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_larger_zero_in_csset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. x ∈ consumption_set"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cons_set_props</span><span> </span><span>pre_arrow_debreu_consumption_set_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> 
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Calculate wealth of individual i in context of Private Ownership economy. ›</span></span></span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>poe_wealth</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"poe_wealth P i Y ≡ P ∙ ℰ[i] + (∑j∈firms. Θ[i,j] *<span class="hidden">⇩</span><sub>R</sub> (P ∙ Y j))"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Feasiblity ›</span></span></span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>feasible</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"feasible X Y ≡ feasible_private_ownership agents firms ℰ consumption_set production_sets X Y"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>calculate_value</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"calculate_value P x ≡ P ∙ x"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Profit maximisation ›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ In a production economy we need to specify profit maximisation. ›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>profit_maximisation</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"profit_maximisation P S = arg_max_set (λx. P ∙ x) S"</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Competitive Equilibirium ›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Competitive equilibrium in context of production economy with private ownership.
             This includes the profit maximisation condition. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>competitive_equilibrium</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"competitive_equilibrium P X Y ⟷ feasible X Y ∧
    (∀j ∈ firms. (Y j) ∈ profit_maximisation P (production_sets j)) ∧
    (∀i ∈ agents. (X i) ∈ arg_max_set U[i] (budget_constraint (calculate_value P) consumption_set (poe_wealth P i Y)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>competitive_equilibriumD</span><span> </span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"competitive_equilibrium P X Y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"feasible X Y ∧
         (∀j ∈ firms. (Y j) ∈ profit_maximisation P (production_sets j)) ∧
         (∀i ∈ agents. (X i) ∈ arg_max_set U[i] (budget_constraint (calculate_value P) consumption_set (poe_wealth P i Y)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>competitive_equilibrium_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>compet_max_profit</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ∈ firms"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"competitive_equilibrium P X Y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Y j ∈ profit_maximisation P (production_sets j)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Pareto Optimality ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>pareto_optimal</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"pareto_optimal X Y ⟷
              (feasible X Y ∧
              (∄X' Y'. feasible X' Y' ∧ X' ≻Pareto X))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pareto_optimalI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"feasible X Y"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∄X' Y'. feasible X' Y' ∧ X' ≻Pareto X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pareto_optimal X Y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pareto_optimal_def</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pareto_optimalD</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pareto_optimal X Y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"feasible X Y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∄X' Y'. feasible X' Y' ∧ X' ≻Pareto X"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pareto_optimal_def</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>util_fun_def_holds</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ agents ⟹ x ≽[Pr[i]] y ⟷ U[i] x ≥ U[i] y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>agent_props</span><span> </span><span>all_larger_zero_in_csset</span><span> </span><span>eucl_ordinal_utility_def</span><span> </span><span>ordinal_utility_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>base_pref_is_ord_eucl_rpr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ agents ⟹ rational_preference consumption_set Pr[i]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>agent_props</span><span> </span><span>ord_eucl_utility_imp_rpr</span><span> </span><span>real_vector_rpr.have_rpr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prof_max_ge_all_in_pset</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ∈ firms"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Y j ∈ profit_maximisation P (production_sets j)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀y ∈ production_sets j. P ∙ Y j ≥ P ∙ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_leq</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>profit_maximisation_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Lemmas for final result ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Strictly preferred bundles are strictly more expensive. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_prefered_are_more_expensive</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>i_agt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ agents"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>equil</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"competitive_equilibrium P 𝒳 𝒴"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∈ consumption_set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(U i) z &gt; (U i) (𝒳 i)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∙ P &gt; P ∙ (𝒳 i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>neg_as</span><span> </span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬(z ∙ P &gt; P ∙ (𝒳 i))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xp_leq</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∙ P ≤ P ∙  (𝒳 i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹¬z ∙ P &gt; P ∙ (𝒳 i)›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x_in_argmax</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(𝒳 i) ∈ arg_max_set U[i] (budget_constraint (calculate_value P) consumption_set (poe_wealth P i 𝒴))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>equil</span><span> </span><span>i_agt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>x_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒳 i ∈ (budget_constraint (calculate_value P) consumption_set (poe_wealth P i 𝒴))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>argmax_sol_in_s</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(𝒳 i)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U[i]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"budget_constraint (calculate_value P) consumption_set (poe_wealth P i 𝒴)"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>z_in_budget</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∈ (budget_constraint (calculate_value P) consumption_set (poe_wealth P i 𝒴))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>z_leq_endow</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙ z ≤ P ∙ (𝒳 i)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>xp_leq</span><span> </span><span>inner_commute</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>z_in_cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∈ consumption_set"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x_in</span><span> </span><span>budget_constraint_def</span><span> </span><span>z_leq_endow</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀r.  P ∙ 𝒳 i ≤ r ⟶ P ∙ z ≤ r"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>z_leq_endow</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>budget_constraint_def</span><span> </span><span>x_in</span><span> </span><span>z_in_cons</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>budget_constraint_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nex_prop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∄e. e ∈  (budget_constraint (calculate_value P) consumption_set (poe_wealth P i 𝒴)) ∧
        U[i] e &gt; U[i] (𝒳 i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_better_in_s</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒳 i"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U[i]"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"budget_constraint (calculate_value P) consumption_set (poe_wealth P i 𝒴)"</span></span></span><span class="delimiter">]</span><span> </span><span>x_in_argmax</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∈ budget_constraint (calculate_value P) consumption_set (poe_wealth P i 𝒴) ∧ U[i] z &gt; U[i] (𝒳 i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>z_in_budget</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nex_prop</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Given local non-satiation, argmax will use the entire budget. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>am_utilises_entire_bgt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>i_agts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ agents"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>lns</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"local_nonsatiation consumption_set Pr[i]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>argmax_sol</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ arg_max_set U[i] (budget_constraint (calculate_value P) consumption_set (poe_wealth P i Y))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙ X = P ∙ ℰ[i] + (∑j∈firms. Θ[i,j] *<span class="hidden">⇩</span><sub>R</sub> (P ∙ Y j))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?wlt</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙ ℰ[i] + (∑j∈firms. Θ[i,j] *<span class="hidden">⇩</span><sub>R</sub> (P ∙ Y j))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?bc</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"budget_constraint (calculate_value P) consumption_set (poe_wealth P i Y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ budget_constraint (calculate_value P) consumption_set (poe_wealth P i Y)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>argmax_sol_in_s</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"X"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U[i]"</span></span></span><span> </span><span class="var">?bc</span><span class="delimiter">]</span><span> </span><span>argmax_sol</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>is_leq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∙ P ≤ (poe_wealth P i Y)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>budget_constraint_def</span><span>
</span><span>        </span><span>inner_commute</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>not_less</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬X ∙ P &lt; (poe_wealth P i Y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>neg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∙ P &lt; (poe_wealth P i Y)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bgt_leq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x∈ ?bc. U[i] X ≥ U[i] x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>leq_all_in_sol</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"X"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U[i]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bc"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>all_leq</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"X"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U[i]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bc"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>argmax_sol</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>s_low</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"s_low = {x . P ∙ x &lt; ?wlt}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃e &gt; 0. ball X e ⊆ s_low"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x_in_budget</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙ X &lt; ?wlt"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inner_commute</span><span> </span><span>neg</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s_low_open</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"open s_low"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>open_halfspace_lt</span><span> </span><span>s_low_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s_low_open</span><span> </span><span>open_contains_ball_eq</span><span>
</span><span>          </span><span>s_low_def</span><span> </span><span>x_in_budget</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>e</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"e &gt; 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ball X e ⊆ s_low"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃e&gt;0. ball X e ⊆ s_low›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>y_props</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ ball X e"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ≻[Pref i] X"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &lt; e›</span></span></span><span> </span><span>all_larger_zero_in_csset</span><span> </span><span>lns</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ budget_constraint (calculate_value P) consumption_set (poe_wealth P i Y)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ s_low"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y ∈ ball X e›</span></span></span><span> </span><span>e</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>s_low_def</span><span> </span><span>all_larger_zero_in_csset</span><span>
</span><span>            </span><span>budget_constraint_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bgt_leq</span><span> </span><span>i_agts</span><span> </span><span>y_props</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>util_fun_def_holds</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inner_commute</span><span> </span><span>is_leq</span><span>
</span><span>        </span><span>less_eq_real_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>x_equil_x_ext_budget</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>i_agt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ agents"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>lns</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"local_nonsatiation consumption_set Pr[i]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>equilibrium</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"competitive_equilibrium P X Y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙ X i = P ∙ ℰ[i] + (∑j∈firms. Θ[i,j] *<span class="hidden">⇩</span><sub>R</sub> (P ∙ Y j))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X i ∈ arg_max_set U[i] (budget_constraint (calculate_value P) consumption_set (poe_wealth P i Y))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>equilibrium</span><span> </span><span>i_agt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>am_utilises_entire_bgt</span><span> </span><span>i_agt</span><span> </span><span>lns</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>same_price_in_argmax</span><span> </span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>i_agt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ agents"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>lns</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"local_nonsatiation consumption_set Pr[i]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ arg_max_set (U[i]) (budget_constraint (calculate_value P) consumption_set (poe_wealth P i Y))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ arg_max_set (U[i]) (budget_constraint (calculate_value P) consumption_set (poe_wealth P i Y))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(P ∙ x) = (P ∙ y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>am_utilises_entire_bgt</span><span> </span><span>assms</span><span> </span><span>lns</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>am_utilises_entire_bgt</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>i_agt</span><span> </span><span>lns</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Greater or equal utility implies greater or equal value. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>utility_ge_price_ge</span><span> </span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>agts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ agents"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>lns</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"local_nonsatiation consumption_set Pr[i]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>equil</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"competitive_equilibrium P X Y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>geq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"U[i] z ≥ U[i] (X i)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∈ consumption_set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙ z ≥ P ∙ (X i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?bc</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(budget_constraint (calculate_value P) consumption_set (poe_wealth P i Y))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>not_in</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∉ arg_max_set (U[i]) ?bc ⟹
    P ∙ z &gt; (P ∙ ℰ[i]) + (∑j∈(firms). (Θ[i,j] *<span class="hidden">⇩</span><sub>R</sub> (P ∙ Y j)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∉ arg_max_set (U[i]) ?bc"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X i ∈ arg_max_set (U[i]) ?bc"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>competitive_equilibriumD</span><span> </span><span>assms</span><span> </span><span>pareto_optimal_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∉ budget_constraint (calculate_value P) consumption_set (poe_wealth P i Y)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span>  </span><span>geq</span><span> </span><span>leq_all_in_sol</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>budget_constraint_def</span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>budget_constraint_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x_in_argmax</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(X i) ∈ arg_max_set U[i] ?bc"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>agts</span><span> </span><span>equil</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>x_in_budget</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(X i) ∈ ?bc"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>argmax_sol_in_s</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(X i)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U[i]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bc"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U[i] z = U[i] (X i) ⟹ P ∙ z ≥ P ∙ (X i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>contrapos_pp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>con_neg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ P ∙ z ≥ P ∙ (X i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙ z &lt; P ∙ (X i)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>z_in_argmax</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∈ arg_max_set U[i] ?bc"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙(X i) = P ∙ ℰ[i] + (∑j∈firms. Θ[i,j] *<span class="hidden">⇩</span><sub>R</sub> (P ∙ Y j))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>agts</span><span> </span><span>am_utilises_entire_bgt</span><span> </span><span>lns</span><span> </span><span>x_in_argmax</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>con_neg</span><span> </span><span>less_eq_real_def</span><span> </span><span>not_in</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>z_budget_utilisation</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙ z = P ∙ (X i)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>agts</span><span> </span><span>am_utilises_entire_bgt</span><span> </span><span>lns</span><span> </span><span>x_in_argmax</span><span> </span><span>z_in_argmax</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙ (X i) = P ∙ ℰ[i] + (∑j∈firms. Θ[i,j] *<span class="hidden">⇩</span><sub>R</sub> (P ∙ Y j))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>agts</span><span> </span><span>am_utilises_entire_bgt</span><span> </span><span>lns</span><span> </span><span>x_in_argmax</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ U[i] z = U[i] (X i)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>z_budget_utilisation</span><span> </span><span>con_neg</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>agts</span><span> </span><span>am_utilises_entire_bgt</span><span> </span><span>eq_iff</span><span> </span><span>eucl_less_le_not_le</span><span> </span><span>lns</span><span> </span><span>not_in</span><span> </span><span>x_in_argmax</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>commutativity_sums_over_funs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>X</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'x set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>Y</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'y set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑i∈X. ∑j∈Y. (f i j *<span class="hidden">⇩</span><sub>R</sub> C ∙ g j)) = (∑j∈Y.∑i∈X. (f i j *<span class="hidden">⇩</span><sub>R</sub> C ∙ g j))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Groups_Big.comm_monoid_add_class.sum.swap</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assoc_fun_over_sum</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>X</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'x set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>Y</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'y set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑j∈Y. ∑i∈X. f i j *<span class="hidden">⇩</span><sub>R</sub> C ∙ g j) = (∑j∈Y. (∑i∈X. f i j) *<span class="hidden">⇩</span><sub>R</sub> C ∙ g j)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inner_sum_left</span><span> </span><span>scaleR_left.sum</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Walras' law in context of production economy with private ownership.
       That is, in an equilibrium demand equals supply. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>walras_law</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. i∈agents ⟹ local_nonsatiation consumption_set Pr[i]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀i ∈ agents. (X i) ∈ arg_max_set U[i] (budget_constraint (calculate_value P) consumption_set (poe_wealth P i Y)))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙ (∑i∈agents. (X i)) = P ∙ ((∑i∈agents. ℰ[i]) + (∑j∈firms. Y j))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>value_equal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙ (∑i∈agents. (X i)) = P ∙ (∑i∈agents. ℰ[i]) + (∑i∈agents. ∑f∈firms. Θ[i,f] *<span class="hidden">⇩</span><sub>R</sub> (P ∙ Y f))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>all_exhaust_bgt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i∈agents. P ∙ (X i) = P ∙ ℰ[i] + (∑j∈firms. Θ[i,j] *<span class="hidden">⇩</span><sub>R</sub> (P ∙ (Y j)))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>am_utilises_entire_bgt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>all_exhaust_bgt</span><span> </span><span>inner_sum_right</span><span> </span><span>sum.distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eq_1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑i∈agents. ∑j∈firms. (Θ[i,j] *<span class="hidden">⇩</span><sub>R</sub> P ∙ Y j)) = (∑j∈firms. ∑i∈agents. (Θ[i,j] *<span class="hidden">⇩</span><sub>R</sub> P ∙ Y j))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>commutativity_sums_over_funs</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>Θ</span><span> </span><span>P</span><span> </span><span>Y</span><span> </span><span>firms</span><span> </span><span>agents</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>eq_2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙ (∑i∈agents. X i) = P ∙ (∑i∈agents. ℰ[i]) + (∑j∈firms. ∑i∈agents. Θ[i,j] *<span class="hidden">⇩</span><sub>R</sub> P ∙ Y j)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>value_equal</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eq_3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"...= P ∙ (∑i∈agents. ℰ[i]) + (∑j∈firms. (∑i∈agents. Θ[i,j]) *<span class="hidden">⇩</span><sub>R</sub> P ∙  Y j)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assoc_fun_over_sum</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Θ"</span></span></span><span> </span><span>P</span><span> </span><span>Y</span><span> </span><span>agents</span><span> </span><span>firms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eq_4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"... = P ∙ (∑i∈agents. ℰ[i]) + (∑f∈firms. P ∙  Y f)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>firms_comp_owned</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>comp_wise_inner</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙  (∑i∈agents. X i) - (P ∙ (∑i∈agents. ℰ[i])) - (∑f∈firms. P ∙ Y f) = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eq_1</span><span> </span><span>eq_2</span><span> </span><span>eq_3</span><span> </span><span>eq_4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inner_right_distrib</span><span> </span><span>inner_sum_right</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>walras_law_in_compeq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. i∈agents ⟹ local_nonsatiation consumption_set Pr[i]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"competitive_equilibrium P X Y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙ ((∑i∈agents. (X i)) - (∑i∈agents. ℰ[i]) - (∑j∈firms. Y j)) = 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙ (∑i∈agents. (X i)) = P ∙ ((∑i∈agents. ℰ[i]) + (∑j∈firms. Y j))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>walras_law</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inner_diff_right</span><span> </span><span>inner_right_distrib</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ First Welfare Theorem ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Proof of First Welfare Theorem in context of production economy with private ownership. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>first_welfare_theorem_priv_own</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. i ∈ agents ⟹ local_nonsatiation consumption_set Pr[i]"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Price &gt; 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"competitive_equilibrium Price 𝒳 𝒴"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pareto_optimal 𝒳 𝒴"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>neg_as</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ pareto_optimal 𝒳 𝒴"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>equili_feasible</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"feasible 𝒳 𝒴"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>competitive_equilibrium_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>X'</span><span> </span><span>Y'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>xprime_pareto</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"feasible X' Y' ∧
      (∀i ∈ agents. U[i] (X' i) ≥ U[i] (𝒳 i)) ∧
      (∃i ∈ agents. U[i] (X' i) &gt; U[i] (𝒳 i))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>equili_feasible</span><span> </span><span>pareto_optimal_def</span><span>
</span><span>      </span><span>pareto_dominating_def</span><span> </span><span>neg_as</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>is_feasible</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"feasible X' Y'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xprime_pareto</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xprime_leq_y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i ∈ agents. (Price ∙ (X' i) ≥
    (Price ∙ ℰ[i]) + (∑j∈(firms). Θ[i,j] *<span class="hidden">⇩</span><sub>R</sub> (Price ∙ 𝒴 j)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ agents"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xprime_cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X' i ∈ consumption_set"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>all_larger_zero_in_csset</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x_leq_xprime</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"U[i] (X' i) ≥ U[i] (𝒳 i)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i ∈ agents›</span></span></span><span> </span><span>xprime_pareto</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lns_pref</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"local_nonsatiation consumption_set Pr[i]"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>as</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>xprime_ge_x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Price ∙ (X' i) ≥ Price ∙ (𝒳 i)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x_leq_xprime</span><span> </span><span>xprime_cons</span><span> </span><span>as</span><span> </span><span>assms</span><span> </span><span>utility_ge_price_ge</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"Price ∙ (X' i) ≥ (Price ∙ ℰ[i]) + (∑j∈(firms). Θ[i,j] *<span class="hidden">⇩</span><sub>R</sub> (Price ∙ 𝒴 j))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xprime_ge_x</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i ∈ agents›</span></span></span><span> </span><span>lns_pref</span><span> </span><span>assms</span><span> </span><span>x_equil_x_ext_budget</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ex_greater_value</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃i ∈ agents. Price ∙ (X' i) &gt; Price ∙ (𝒳 i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>cpos</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(∃i ∈ agents. Price ∙ (X' i) &gt; Price ∙ (𝒳 i))"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>obt_witness</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ agents"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(U[i]) (X' i) &gt; U[i] (𝒳 i)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xprime_pareto</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>cpos</span><span> </span><span>all_larger_zero_in_csset</span><span> </span><span>all_prefered_are_more_expensive</span><span>
</span><span>          </span><span>inner_commute</span><span> </span><span>obt_witness</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>obt_witness</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dom_g</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Price ∙ (∑i∈agents. X' i) &gt; Price ∙ (∑i∈agents. (𝒳 i))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ &gt; _ ∙ ?x_sum"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑i∈agents. Price ∙ X' i) &gt; (∑i∈agents. Price ∙ (𝒳 i))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>xprime_leq_y</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>ex_greater_value</span><span>
</span><span>          </span><span>finite_nonepty_agents</span><span> </span><span>sum_strict_mono_ex1</span><span> </span><span>x_equil_x_ext_budget</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Price ∙ (∑i∈agents. X' i) &gt; Price ∙ ?x_sum"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inner_sum_right</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?y_sum</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑j∈firms. 𝒴 j)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>equili_walras_law</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Price ∙ ?x_sum =
    (∑i∈agents. Price ∙ ℰ[i] + (∑j∈firms. Θ[i,j] *<span class="hidden">⇩</span><sub>R</sub> (Price ∙ 𝒴 j)))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ = ?ws"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i∈agents. Price ∙ 𝒳 i = Price ∙ ℰ[i] + (∑j∈firms. Θ[i,j] *<span class="hidden">⇩</span><sub>R</sub> (Price ∙ 𝒴 j))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>x_equil_x_ext_budget</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inner_sum_right</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>remove_firm_pct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"... = Price ∙ (∑i∈agents. ℰ[i]) + (Price ∙ ?y_sum)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>equals_inner_price</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"0 = Price ∙ (?x_sum - ((∑i∈agents. ℰ i) + ?y_sum))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>diff_diff_add</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span>  </span><span>walras_law_in_compeq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Price ∙ ?x_sum = Price ∙ ((∑i∈agents. ℰ i) + ?y_sum)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>equals_inner_price</span><span> </span><span>inner_diff_right</span><span> </span><span>right_minus_eq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>equili_walras_law</span><span> </span><span>inner_right_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xp_l_yp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑i∈agents. X' i) ≤ (∑i∈agents. ℰ[i]) + (∑f∈firms. Y' f)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>is_feasible</span><span> </span><span>feasible_private_ownership_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>yprime_sgr_y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Price ∙ (∑i∈agents. ℰ[i]) + Price ∙ (∑f∈firms. Y' f) &gt; ?ws"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Price ∙ (∑i∈agents. X' i) ≤ Price ∙ ((∑i∈agents. ℰ[i]) + (∑j∈firms. Y' j))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>xp_l_yp</span><span> </span><span>atLeastAtMost_iff</span><span> </span><span>inner_commute</span><span>
</span><span>          </span><span>interval_inner_leI</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>less_imp_le</span><span> </span><span>order_refl</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?ws &lt; Price ∙ ((∑i∈agents. ℰ i) + (∑j∈firms. Y' j))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dom_g</span><span> </span><span>equili_walras_law</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inner_right_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Y_is_optimum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀j∈firms. ∀y ∈ production_sets j. Price ∙ 𝒴 j ≥ Price ∙ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>prof_max_ge_all_in_pset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>yprime_in_prod_set</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀j ∈ firms. Y' j ∈ production_sets j"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xprime_pareto</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>feasible_private_ownership_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀j ∈ firms. ∀y ∈ production_sets j. Price ∙ 𝒴 j ≥ Price ∙ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Y_is_optimum</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>Y_ge_yprime</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀j ∈ firms. Price ∙ 𝒴 j ≥ Price ∙ Y' j"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>yprime_in_prod_set</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>yprime_p_leq_Y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Price ∙ (∑f∈firms. Y' f) ≤ Price ∙ ?y_sum"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Y_ge_yprime</span><span> </span><span>inner_sum_right</span><span> </span><span>sum_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>remove_firm_pct</span><span> </span><span>yprime_sgr_y</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Equilibrium cannot be Pareto dominated. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>equilibria_dom_eachother</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. i ∈ agents ⟹ local_nonsatiation consumption_set Pr[i]"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Price &gt; 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>equil</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"competitive_equilibrium Price 𝒳 𝒴"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∄X' Y'. competitive_equilibrium P X' Y' ∧ X' ≻Pareto 𝒳"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pareto_optimal 𝒳 𝒴"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>assms</span><span> </span><span>equil</span><span> </span><span>first_welfare_theorem_priv_own</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∄X' Y'. feasible X' Y' ∧ X' ≻Pareto 𝒳"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pareto_optimal_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Using monotonicity instead of local non-satiation proves the First Welfare Theorem. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>first_welfare_thm_monotone</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀M ∈ carrier. (∀x &gt; M. x ∈ carrier)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. i ∈ agents ⟹ monotone_preference consumption_set Pr[i]"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Price &gt; 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"competitive_equilibrium Price 𝒳 𝒴"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pareto_optimal 𝒳 𝒴"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_larger_zero_in_csset</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> 
</span><span>    </span><span>first_welfare_theorem_priv_own</span><span> </span><span>unbounded_above_mono_imp_lns</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="Arrow_Debreu_Model">
<div class="head"><h1>Theory Arrow_Debreu_Model</h1>
<span class="command">theory</span> <span class="name">Arrow_Debreu_Model</span><br/>
<span class="keyword">imports</span> <a href="Consumers.html"><span class="name">Consumers</span></a> <a href="Common.html"><span class="name">Common</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* License: LGPL *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
Author: Julian Parsert &lt;julian.parsert@gmail.com&gt;
Author: Cezary Kaliszyk
*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Arrow-Debreu model ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Arrow_Debreu_Model</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"../Preferences"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"../Preferences"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"../Utility_Functions"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"../Argmax"</span></span></span><span>
</span><span>    </span><span>Consumers</span><span>
</span><span>    </span><span>Common</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>pre_arrow_debreu_model</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>production_sets</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'f ⇒ ('a::ordered_euclidean_space) set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>consumption_set</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>agents</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'i set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>firms</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'f set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>ℰ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'i ⇒ 'a"</span></span></span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"ℰ[_]"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>Pref</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'i ⇒ 'a relation"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"Pr[_]"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>U</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'i ⇒ 'a ⇒ real"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"U[_]"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>Θ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'i ⇒ 'f ⇒ real"</span></span></span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"Θ[_,_]"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>cons_set_props</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"arrow_debreu_consum_set consumption_set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>agent_props</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ agents ⟹ eucl_ordinal_utility consumption_set (Pr[i]) (U[i])"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>firms_comp_owned</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j ∈ firms ⟹ (∑i∈agents. Θ[i,j]) = 1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>finite_nonepty_agents</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite agents"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"agents ≠ {}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>pre_arrow_debreu_model</span><span> </span><span class="delimiter">⊆</span><span> </span><span>pareto_ordering</span><span> </span><span>agents</span><span> </span><span>U</span><span>
</span><span>  </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*sublocale pre_arrow_debreu_model ⊆ exchange_economy consumption_set agents ℰ Pref U Price
  by (metis exchange_economy.intro pre_arrow_debreu_model_axioms pre_arrow_debreu_model_def)
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>pre_arrow_debreu_model</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Calculate wealth of individual i in context of Private Ownership economy. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> 
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>poe_wealth</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"poe_wealth P i Y ≡ P ∙ ℰ[i] + (∑j∈firms. Θ[i,j] *<span class="hidden">⇩</span><sub>R</sub> (P ∙ Y j))"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Feasiblity ›</span></span></span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>feasible</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"feasible X Y ≡ feasible_private_ownership agents firms ℰ consumption_set production_sets X Y"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>calculate_value</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"calculate_value P x ≡ P ∙ x"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Profit maximisation ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ In a production economy (which this is) we need to specify profit maximisation. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>profit_maximisation</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"profit_maximisation P S = arg_max_set (λx. P ∙ x) S"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Competitive Equilibirium ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Competitive equilibrium in context of production economy with private ownership.
             This includes the profit maximisation condition. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>competitive_equilibrium</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"competitive_equilibrium P X Y ⟷ feasible X Y ∧
    (∀j ∈ firms. (Y j) ∈ profit_maximisation P (production_sets j)) ∧
    (∀i ∈ agents. (X i) ∈ arg_max_set U[i] (budget_constraint (calculate_value P) consumption_set (poe_wealth P i Y)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>competitive_equilibriumD</span><span> </span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"competitive_equilibrium P X Y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"feasible X Y ∧
         (∀j ∈ firms. (Y j) ∈ profit_maximisation P (production_sets j)) ∧
         (∀i ∈ agents. (X i) ∈ arg_max_set U[i] (budget_constraint (calculate_value P) consumption_set (poe_wealth P i Y)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>competitive_equilibrium_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>compet_max_profit</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ∈ firms"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"competitive_equilibrium P X Y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Y j ∈ profit_maximisation P (production_sets j)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Pareto Optimality ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>pareto_optimal</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"pareto_optimal X Y ⟷
              (feasible X Y ∧
              (∄X' Y'. feasible X' Y' ∧ X' ≻Pareto X))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pareto_optimalI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"feasible X Y"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∄X' Y'. feasible X' Y' ∧ X' ≻Pareto X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pareto_optimal X Y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pareto_optimal_def</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pareto_optimalD</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pareto_optimal X Y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"feasible X Y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∄X' Y'. feasible X' Y' ∧ X' ≻Pareto X"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pareto_optimal_def</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>util_fun_def_holds</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ agents"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ consumption_set"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ consumption_set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≽[Pr[i]] y ⟷ U[i] x ≥ U[i] y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≽[Pr[i]] y"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U[i] x ≥ U[i] y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ≽[Pr[i]] y›</span></span></span><span> </span><span>agent_props</span><span> </span><span>assms</span><span> </span><span>eucl_ordinal_utility_def</span><span> </span><span>ordinal_utility_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U[i] x ≥ U[i] y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eucl_ordinal_utility consumption_set (Pr[i]) (U[i])"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>agent_props</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≽[Pr[i]] y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹U[i] y ≤ U[i] x›</span></span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>eucl_ordinal_utility_def</span><span> </span><span>ordinal_utility.util_def_conf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>base_pref_is_ord_eucl_rpr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ agents ⟹ rational_preference consumption_set Pr[i]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>agent_props</span><span> </span><span>ord_eucl_utility_imp_rpr</span><span> </span><span>real_vector_rpr.have_rpr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prof_max_ge_all_in_pset</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ∈ firms"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Y j ∈ profit_maximisation P (production_sets j)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀y ∈ production_sets j. P ∙ Y j ≥ P ∙ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_leq</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>profit_maximisation_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Lemmas for final result ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Strictly preferred bundles are strictly more expensive. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_prefered_are_more_expensive</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>i_agt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ agents"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>equil</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"competitive_equilibrium P 𝒳 𝒴"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∈ consumption_set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(U i) z &gt; (U i) (𝒳 i)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∙ P &gt; P ∙ (𝒳 i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>neg_as</span><span> </span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬(z ∙ P &gt; P ∙ (𝒳 i))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xp_leq</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∙ P ≤ P ∙  (𝒳 i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹¬z ∙ P &gt; P ∙ (𝒳 i)›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x_in_argmax</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(𝒳 i) ∈ arg_max_set U[i] (budget_constraint (calculate_value P) consumption_set (poe_wealth P i 𝒴))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>equil</span><span> </span><span>i_agt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>x_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒳 i ∈ (budget_constraint (calculate_value P) consumption_set (poe_wealth P i 𝒴))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>argmax_sol_in_s</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(𝒳 i)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U[i]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"budget_constraint (calculate_value P) consumption_set (poe_wealth P i 𝒴)"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>z_in_budget</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∈ (budget_constraint (calculate_value P) consumption_set (poe_wealth P i 𝒴))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>z_leq_endow</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙ z ≤ P ∙ (𝒳 i)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>xp_leq</span><span> </span><span>inner_commute</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>z_in_cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∈ consumption_set"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x_in</span><span> </span><span>budget_constraint_def</span><span> </span><span>z_leq_endow</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀r.  P ∙ 𝒳 i ≤ r ⟶ P ∙ z ≤ r"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>z_leq_endow</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>budget_constraint_def</span><span> </span><span>x_in</span><span> </span><span>z_in_cons</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>budget_constraint_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nex_prop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∄e. e ∈  (budget_constraint (calculate_value P) consumption_set (poe_wealth P i 𝒴)) ∧
        U[i] e &gt; U[i] (𝒳 i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_better_in_s</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒳 i"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U[i]"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"budget_constraint (calculate_value P) consumption_set (poe_wealth P i 𝒴)"</span></span></span><span class="delimiter">]</span><span> </span><span>x_in_argmax</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∈ budget_constraint (calculate_value P) consumption_set (poe_wealth P i 𝒴) ∧ U[i] z &gt; U[i] (𝒳 i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>z_in_budget</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nex_prop</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Given local non-satiation, argmax will use the entire budget. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>am_utilises_entire_bgt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>i_agts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ agents"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>lns</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"local_nonsatiation consumption_set Pr[i]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>argmax_sol</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ arg_max_set U[i] (budget_constraint (calculate_value P) consumption_set (poe_wealth P i Y))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙ X = P ∙ ℰ[i] + (∑j∈firms. Θ[i,j] *<span class="hidden">⇩</span><sub>R</sub> (P ∙ Y j))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?wlt</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙ ℰ[i] + (∑j∈firms. Θ[i,j] *<span class="hidden">⇩</span><sub>R</sub> (P ∙ Y j))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?bc</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"budget_constraint (calculate_value P) consumption_set (poe_wealth P i Y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ budget_constraint (calculate_value P) consumption_set (poe_wealth P i Y)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>argmax_sol_in_s</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"X"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U[i]"</span></span></span><span> </span><span class="var">?bc</span><span class="delimiter">]</span><span> </span><span>argmax_sol</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>is_leq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∙ P ≤ (poe_wealth P i Y)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>budget_constraint_def</span><span>
</span><span>        </span><span>inner_commute</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>not_less</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬X ∙ P &lt; (poe_wealth P i Y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>neg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∙ P &lt; (poe_wealth P i Y)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bgt_leq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x∈ ?bc. U[i] X ≥ U[i] x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>leq_all_in_sol</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"X"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U[i]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bc"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>all_leq</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"X"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U[i]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bc"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>argmax_sol</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>s_low</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"s_low = {x . P ∙ x &lt; ?wlt}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃e &gt; 0. ball X e ⊆ s_low"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x_in_budget</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙ X &lt; ?wlt"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inner_commute</span><span> </span><span>neg</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s_low_open</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"open s_low"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>open_halfspace_lt</span><span> </span><span>s_low_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s_low_open</span><span> </span><span>open_contains_ball_eq</span><span>
</span><span>          </span><span>s_low_def</span><span> </span><span>x_in_budget</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>e</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"e &gt; 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ball X e ⊆ s_low"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∃e&gt;0. ball X e ⊆ s_low›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>y_props</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ ball X e"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ≻[Pref i] X"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &lt; e›</span></span></span><span> </span><span>xin</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>budget_constraint_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>lns_alt_def2</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ budget_constraint (calculate_value P) consumption_set (poe_wealth P i Y)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ s_low"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y ∈ ball X e›</span></span></span><span> </span><span>e</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ consumption_set"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>agent_props</span><span> </span><span>eucl_ordinal_utility_def</span><span> </span><span>i_agts</span><span> </span><span>ordinal_utility_def</span><span> </span><span>y_props</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙ y ≤ poe_wealth P i Y"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>calculation</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>s_low_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>budget_constraint_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bgt_leq</span><span> </span><span>i_agts</span><span> </span><span>y_props</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>util_fun_def_holds</span><span> </span><span>xin</span><span> </span><span>budget_constraint_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inner_commute</span><span> </span><span>is_leq</span><span>
</span><span>        </span><span>less_eq_real_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>x_equil_x_ext_budget</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>i_agt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ agents"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>lns</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"local_nonsatiation consumption_set Pr[i]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>equilibrium</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"competitive_equilibrium P X Y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙ X i = P ∙ ℰ[i] + (∑j∈firms. Θ[i,j] *<span class="hidden">⇩</span><sub>R</sub> (P ∙ Y j))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X i ∈ arg_max_set U[i] (budget_constraint (calculate_value P) consumption_set (poe_wealth P i Y))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>equilibrium</span><span> </span><span>i_agt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>am_utilises_entire_bgt</span><span> </span><span>i_agt</span><span> </span><span>lns</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>same_price_in_argmax</span><span> </span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>i_agt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ agents"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>lns</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"local_nonsatiation consumption_set Pr[i]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ arg_max_set (U[i]) (budget_constraint (calculate_value P) consumption_set (poe_wealth P i Y))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ arg_max_set (U[i]) (budget_constraint (calculate_value P) consumption_set (poe_wealth P i Y))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(P ∙ x) = (P ∙ y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>am_utilises_entire_bgt</span><span> </span><span>assms</span><span> </span><span>lns</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>am_utilises_entire_bgt</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>i_agt</span><span> </span><span>lns</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Greater or equal utility implies greater or equal value. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>utility_ge_price_ge</span><span> </span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>agts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ agents"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>lns</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"local_nonsatiation consumption_set Pr[i]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>equil</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"competitive_equilibrium P X Y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>geq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"U[i] z ≥ U[i] (X i)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∈ consumption_set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙ z ≥ P ∙ (X i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?bc</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(budget_constraint (calculate_value P) consumption_set (poe_wealth P i Y))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>not_in</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∉ arg_max_set (U[i]) ?bc ⟹
    P ∙ z &gt; (P ∙ ℰ[i]) + (∑j∈(firms). (Θ[i,j] *<span class="hidden">⇩</span><sub>R</sub> (P ∙ Y j)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∉ arg_max_set (U[i]) ?bc"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X i ∈ arg_max_set (U[i]) ?bc"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>competitive_equilibriumD</span><span> </span><span>assms</span><span> </span><span>pareto_optimal_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∉ budget_constraint (calculate_value P) consumption_set (poe_wealth P i Y)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span>  </span><span>geq</span><span> </span><span>leq_all_in_sol</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>budget_constraint_def</span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>budget_constraint_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x_in_argmax</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(X i) ∈ arg_max_set U[i] ?bc"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>agts</span><span> </span><span>equil</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>x_in_budget</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(X i) ∈ ?bc"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>argmax_sol_in_s</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(X i)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U[i]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bc"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"U[i] z = U[i] (X i) ⟹ P ∙ z ≥ P ∙ (X i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>contrapos_pp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>con_neg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ P ∙ z ≥ P ∙ (X i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙ z &lt; P ∙ (X i)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>z_in_argmax</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∈ arg_max_set U[i] ?bc"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙(X i) = P ∙ ℰ[i] + (∑j∈firms. Θ[i,j] *<span class="hidden">⇩</span><sub>R</sub> (P ∙ Y j))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>agts</span><span> </span><span>am_utilises_entire_bgt</span><span> </span><span>lns</span><span> </span><span>x_in_argmax</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>con_neg</span><span> </span><span>less_eq_real_def</span><span> </span><span>not_in</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>z_budget_utilisation</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙ z = P ∙ (X i)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>agts</span><span> </span><span>am_utilises_entire_bgt</span><span> </span><span>lns</span><span> </span><span>x_in_argmax</span><span> </span><span>z_in_argmax</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙ (X i) = P ∙ ℰ[i] + (∑j∈firms. Θ[i,j] *<span class="hidden">⇩</span><sub>R</sub> (P ∙ Y j))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>agts</span><span> </span><span>am_utilises_entire_bgt</span><span> </span><span>lns</span><span> </span><span>x_in_argmax</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ U[i] z = U[i] (X i)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>z_budget_utilisation</span><span> </span><span>con_neg</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>agts</span><span> </span><span>am_utilises_entire_bgt</span><span> </span><span>eq_iff</span><span> </span><span>eucl_less_le_not_le</span><span> </span><span>lns</span><span> </span><span>not_in</span><span> </span><span>x_in_argmax</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>commutativity_sums_over_funs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>X</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'x set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>Y</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'y set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑i∈X. ∑j∈Y. (f i j *<span class="hidden">⇩</span><sub>R</sub> C ∙ g j)) = (∑j∈Y.∑i∈X. (f i j *<span class="hidden">⇩</span><sub>R</sub> C ∙ g j))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Groups_Big.comm_monoid_add_class.sum.swap</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assoc_fun_over_sum</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>X</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'x set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>Y</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'y set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑j∈Y. ∑i∈X. f i j *<span class="hidden">⇩</span><sub>R</sub> C ∙ g j) = (∑j∈Y. (∑i∈X. f i j) *<span class="hidden">⇩</span><sub>R</sub> C ∙ g j)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inner_sum_left</span><span> </span><span>scaleR_left.sum</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Walras' law in context of production economy with private ownership.
       That is, in an equilibrium demand equals supply. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>walras_law</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. i∈agents ⟹ local_nonsatiation consumption_set Pr[i]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀i ∈ agents. (X i) ∈ arg_max_set U[i] (budget_constraint (calculate_value P) consumption_set (poe_wealth P i Y)))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙ (∑i∈agents. (X i)) = P ∙ ((∑i∈agents. ℰ[i]) + (∑j∈firms. Y j))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>value_equal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙ (∑i∈agents. (X i)) = P ∙ (∑i∈agents. ℰ[i]) + (∑i∈agents. ∑f∈firms. Θ[i,f] *<span class="hidden">⇩</span><sub>R</sub> (P ∙ Y f))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>all_exhaust_bgt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i∈agents. P ∙ (X i) = P ∙ ℰ[i] + (∑j∈firms. Θ[i,j] *<span class="hidden">⇩</span><sub>R</sub> (P ∙ (Y j)))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>am_utilises_entire_bgt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>all_exhaust_bgt</span><span> </span><span>inner_sum_right</span><span> </span><span>sum.distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eq_1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑i∈agents. ∑j∈firms. (Θ[i,j] *<span class="hidden">⇩</span><sub>R</sub> P ∙ Y j)) = (∑j∈firms. ∑i∈agents. (Θ[i,j] *<span class="hidden">⇩</span><sub>R</sub> P ∙ Y j))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>commutativity_sums_over_funs</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>Θ</span><span> </span><span>P</span><span> </span><span>Y</span><span> </span><span>firms</span><span> </span><span>agents</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>eq_2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙ (∑i∈agents. X i) = P ∙ (∑i∈agents. ℰ[i]) + (∑j∈firms. ∑i∈agents. Θ[i,j] *<span class="hidden">⇩</span><sub>R</sub> P ∙ Y j)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>value_equal</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eq_3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"...= P ∙ (∑i∈agents. ℰ[i]) + (∑j∈firms. (∑i∈agents. Θ[i,j]) *<span class="hidden">⇩</span><sub>R</sub> P ∙  Y j)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assoc_fun_over_sum</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Θ"</span></span></span><span> </span><span>P</span><span> </span><span>Y</span><span> </span><span>agents</span><span> </span><span>firms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eq_4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"... = P ∙ (∑i∈agents. ℰ[i]) + (∑f∈firms. P ∙  Y f)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>firms_comp_owned</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>comp_wise_inner</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙  (∑i∈agents. X i) - (P ∙ (∑i∈agents. ℰ[i])) - (∑f∈firms. P ∙ Y f) = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eq_1</span><span> </span><span>eq_2</span><span> </span><span>eq_3</span><span> </span><span>eq_4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inner_right_distrib</span><span> </span><span>inner_sum_right</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>walras_law_in_compeq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. i∈agents ⟹ local_nonsatiation consumption_set Pr[i]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"competitive_equilibrium P X Y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙ ((∑i∈agents. (X i)) - (∑i∈agents. ℰ[i]) - (∑j∈firms. Y j)) = 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ∙ (∑i∈agents. (X i)) = P ∙ ((∑i∈agents. ℰ[i]) + (∑j∈firms. Y j))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>walras_law</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inner_diff_right</span><span> </span><span>inner_right_distrib</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ First Welfare Theorem ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Proof of First Welfare Theorem in context of production economy with private ownership. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>first_welfare_theorem_priv_own</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. i ∈ agents ⟹ local_nonsatiation consumption_set Pr[i]"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Price &gt; 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"competitive_equilibrium Price 𝒳 𝒴"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pareto_optimal 𝒳 𝒴"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>neg_as</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ pareto_optimal 𝒳 𝒴"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>equili_feasible</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"feasible 𝒳 𝒴"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>competitive_equilibrium_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>X'</span><span> </span><span>Y'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>xprime_pareto</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"feasible X' Y' ∧
      (∀i ∈ agents. U[i] (X' i) ≥ U[i] (𝒳 i)) ∧
      (∃i ∈ agents. U[i] (X' i) &gt; U[i] (𝒳 i))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>equili_feasible</span><span> </span><span>pareto_optimal_def</span><span>
</span><span>      </span><span>pareto_dominating_def</span><span> </span><span>neg_as</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>is_feasible</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"feasible X' Y'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xprime_pareto</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xprime_leq_y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i ∈ agents. (Price ∙ (X' i) ≥
    (Price ∙ ℰ[i]) + (∑j∈(firms). Θ[i,j] *<span class="hidden">⇩</span><sub>R</sub> (Price ∙ 𝒴 j)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ agents"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xprime_cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X' i ∈ consumption_set"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>feasible_private_ownershipD</span><span> </span><span>as</span><span> </span><span>is_feasible</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x_leq_xprime</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"U[i] (X' i) ≥ U[i] (𝒳 i)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i ∈ agents›</span></span></span><span> </span><span>xprime_pareto</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lns_pref</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"local_nonsatiation consumption_set Pr[i]"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>as</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>xprime_ge_x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Price ∙ (X' i) ≥ Price ∙ (𝒳 i)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x_leq_xprime</span><span> </span><span>xprime_cons</span><span> </span><span>as</span><span> </span><span>assms</span><span> </span><span>utility_ge_price_ge</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"Price ∙ (X' i) ≥ (Price ∙ ℰ[i]) + (∑j∈(firms). Θ[i,j] *<span class="hidden">⇩</span><sub>R</sub> (Price ∙ 𝒴 j))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xprime_ge_x</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i ∈ agents›</span></span></span><span> </span><span>lns_pref</span><span> </span><span>assms</span><span> </span><span>x_equil_x_ext_budget</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ex_greater_value</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃i ∈ agents. Price ∙ (X' i) &gt; Price ∙ (𝒳 i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>cpos</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(∃i ∈ agents. Price ∙ (X' i) &gt; Price ∙ (𝒳 i))"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>obt_witness</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ agents"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(U[i]) (X' i) &gt; U[i] (𝒳 i)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xprime_pareto</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>all_prefered_are_more_expensive</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>cpos</span><span> 
</span><span>          </span><span>feasible_private_ownershipD</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>inner_commute</span><span> </span><span>xprime_pareto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dom_g</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Price ∙ (∑i∈agents. X' i) &gt; Price ∙ (∑i∈agents. (𝒳 i))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ &gt; _ ∙ ?x_sum"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑i∈agents. Price ∙ X' i) &gt; (∑i∈agents. Price ∙ (𝒳 i))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>xprime_leq_y</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>ex_greater_value</span><span>
</span><span>          </span><span>finite_nonepty_agents</span><span> </span><span>sum_strict_mono_ex1</span><span> </span><span>x_equil_x_ext_budget</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Price ∙ (∑i∈agents. X' i) &gt; Price ∙ ?x_sum"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inner_sum_right</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?y_sum</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑j∈firms. 𝒴 j)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>equili_walras_law</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Price ∙ ?x_sum =
    (∑i∈agents. Price ∙ ℰ[i] + (∑j∈firms. Θ[i,j] *<span class="hidden">⇩</span><sub>R</sub> (Price ∙ 𝒴 j)))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ = ?ws"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i∈agents. Price ∙ 𝒳 i = Price ∙ ℰ[i] + (∑j∈firms. Θ[i,j] *<span class="hidden">⇩</span><sub>R</sub> (Price ∙ 𝒴 j))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>x_equil_x_ext_budget</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inner_sum_right</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>remove_firm_pct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"... = Price ∙ (∑i∈agents. ℰ[i]) + (Price ∙ ?y_sum)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>equals_inner_price</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"0 = Price ∙ (?x_sum - ((∑i∈agents. ℰ i) + ?y_sum))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>diff_diff_add</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>walras_law_in_compeq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Price ∙ ?x_sum = Price ∙ ((∑i∈agents. ℰ i) + ?y_sum)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>equals_inner_price</span><span> </span><span>inner_diff_right</span><span> </span><span>right_minus_eq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>equili_walras_law</span><span> </span><span>inner_right_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xp_l_yp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑i∈agents. X' i) ≤ (∑i∈agents. ℰ[i]) + (∑f∈firms. Y' f)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>feasible_private_ownership_def</span><span> </span><span>is_feasible</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>yprime_sgr_y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Price ∙ (∑i∈agents. ℰ[i]) + Price ∙ (∑f∈firms. Y' f) &gt; ?ws"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Price ∙ (∑i∈agents. X' i) ≤ Price ∙ ((∑i∈agents. ℰ[i]) + (∑j∈firms. Y' j))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>xp_l_yp</span><span> </span><span>atLeastAtMost_iff</span><span> </span><span>inner_commute</span><span>
</span><span>          </span><span>interval_inner_leI</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>less_imp_le</span><span> </span><span>order_refl</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?ws &lt; Price ∙ ((∑i∈agents. ℰ i) + (∑j∈firms. Y' j))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dom_g</span><span> </span><span>equili_walras_law</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inner_right_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Y_is_optimum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀j∈firms. ∀y ∈ production_sets j. Price ∙ 𝒴 j ≥ Price ∙ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>prof_max_ge_all_in_pset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>yprime_in_prod_set</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀j ∈ firms. Y' j ∈ production_sets j"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>feasible_private_ownershipD</span><span> </span><span>xprime_pareto</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀j ∈ firms. ∀y ∈ production_sets j. Price ∙ 𝒴 j ≥ Price ∙ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Y_is_optimum</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>Y_ge_yprime</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀j ∈ firms. Price ∙ 𝒴 j ≥ Price ∙ Y' j"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>yprime_in_prod_set</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>yprime_p_leq_Y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Price ∙ (∑f∈firms. Y' f) ≤ Price ∙ ?y_sum"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Y_ge_yprime</span><span> </span><span>inner_sum_right</span><span> </span><span>sum_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>remove_firm_pct</span><span> </span><span>yprime_sgr_y</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Equilibrium cannot be Pareto dominated. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>equilibria_dom_eachother</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. i ∈ agents ⟹ local_nonsatiation consumption_set Pr[i]"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Price &gt; 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>equil</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"competitive_equilibrium Price 𝒳 𝒴"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∄X' Y'. competitive_equilibrium P X' Y' ∧ X' ≻Pareto 𝒳"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pareto_optimal 𝒳 𝒴"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>equil</span><span> </span><span>first_welfare_theorem_priv_own</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∄X' Y'. feasible X' Y' ∧ X' ≻Pareto 𝒳"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pareto_optimal_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Using monotonicity instead of local non-satiation proves the First Welfare Theorem. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>first_welfare_thm_monotone</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀M ∈ carrier. (∀x &gt; M. x ∈ carrier)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. i ∈ agents ⟹ monotone_preference consumption_set Pr[i]"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Price &gt; 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"competitive_equilibrium Price 𝒳 𝒴"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pareto_optimal 𝒳 𝒴"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>arrow_debreu_consum_set_def</span><span> </span><span>assms</span><span> </span><span>cons_set_props</span><span> </span><span>first_welfare_theorem_priv_own</span><span> </span><span>unbounded_above_mono_imp_lns</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>