<div id="Diffie_Hellman">
<div class="head">
<h1>Theory Diffie_Hellman</h1>
</div>
<pre class="source"><span class="comment1">(* Title: Diffie_Hellman.thy
  Author: Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Specifying security using games›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Diffie_Hellman <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../CryptHOL/Cyclic_Group_SPMF.html">CryptHOL.Cyclic_Group_SPMF</a>
  <a href="../CryptHOL/Computational_Model.html">CryptHOL.Computational_Model</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The DDH game›</span></span>

<span class="keyword1"><span class="command">locale</span></span> ddh <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">𝒢</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> cyclic_group"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="main">)</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'grp'</span> adversary <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp'</span> <span class="main">⇒</span> <span class="tfree">'grp'</span> <span class="main">⇒</span> <span class="tfree">'grp'</span> <span class="main">⇒</span> bool spmf"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ddh_0</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> adversary <span class="main">⇒</span> bool spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ddh_0</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
     <span class="bound">x</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
     <span class="bound">y</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
     <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">y</span><span class="main">)</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="bound">x</span> <span class="main">*</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ddh_1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> adversary <span class="main">⇒</span> bool spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ddh_1</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
     <span class="bound">x</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
     <span class="bound">y</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
     <span class="bound">z</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
     <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">y</span><span class="main">)</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">z</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">advantage</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> adversary <span class="main">⇒</span> real"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">advantage</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> <span class="main">¦</span>spmf <span class="main">(</span>ddh_0 <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span><span class="main">)</span> True <span class="main">-</span> spmf <span class="main">(</span>ddh_1 <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span><span class="main">)</span> True<span class="main">¦</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lossless</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> adversary <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">lossless</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">α</span> <span class="bound">β</span> <span class="bound">γ</span><span class="main">.</span> lossless_spmf <span class="main">(</span><span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="bound">α</span> <span class="bound">β</span> <span class="bound">γ</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_ddh_0<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> lossless <span class="free">𝒜</span><span class="main">;</span> <span class="main">0</span> <span class="main">&lt;</span> order <span class="free">𝒢</span> <span class="main">⟧</span>
  <span class="main">⟹</span> lossless_spmf <span class="main">(</span>ddh_0 <span class="free">𝒜</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lossless_def ddh_0_def split_def Let_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_ddh_1<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> lossless <span class="free">𝒜</span><span class="main">;</span> <span class="main">0</span> <span class="main">&lt;</span> order <span class="free">𝒢</span> <span class="main">⟧</span>
  <span class="main">⟹</span> lossless_spmf <span class="main">(</span>ddh_1 <span class="free">𝒜</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lossless_def ddh_1_def split_def Let_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The LCDH game›</span></span>

<span class="keyword1"><span class="command">locale</span></span> lcdh <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">𝒢</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> cyclic_group"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="main">)</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'grp'</span> adversary <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp'</span> <span class="main">⇒</span> <span class="tfree">'grp'</span> <span class="main">⇒</span> <span class="tfree">'grp'</span> set spmf"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lcdh</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> adversary <span class="main">⇒</span> bool spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">lcdh</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span> 
     <span class="bound">x</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
     <span class="bound">y</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
     <span class="bound">zs</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">y</span><span class="main">)</span><span class="main">;</span>
     return_spmf <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="bound">x</span> <span class="main">*</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="bound">zs</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">advantage</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> adversary <span class="main">⇒</span> real"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">advantage</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> spmf <span class="main">(</span>lcdh <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span><span class="main">)</span> True"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lossless</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> adversary <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">lossless</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">α</span> <span class="bound">β</span><span class="main">.</span> lossless_spmf <span class="main">(</span><span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="bound">α</span> <span class="bound">β</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_lcdh<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> lossless <span class="free">𝒜</span><span class="main">;</span> <span class="main">0</span> <span class="main">&lt;</span> order <span class="free">𝒢</span> <span class="main">⟧</span>
  <span class="main">⟹</span> lossless_spmf <span class="main">(</span>lcdh <span class="free">𝒜</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lossless_def lcdh_def split_def Let_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="IND_CCA2">
<div class="head">
<h1>Theory IND_CCA2</h1>
</div>
<pre class="source"><span class="comment1">(* Title: IND_CCA2.thy
  Author: Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">theory</span></span> IND_CCA2 <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../CryptHOL/Computational_Model.html">CryptHOL.Computational_Model</a>
  <a href="../CryptHOL/Negligible.html">CryptHOL.Negligible</a>
  <a href="../CryptHOL/Environment_Functor.html">CryptHOL.Environment_Functor</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">locale</span></span> pk_enc <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">key_gen</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'ekey</span> <span class="main">×</span> <span class="tfree">'dkey</span><span class="main">)</span> spmf"</span></span> <span class="comment1">― ‹probabilistic›</span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">encrypt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="tfree">'ekey</span> <span class="main">⇒</span> <span class="tfree">'plain</span> <span class="main">⇒</span> <span class="tfree">'cipher</span> spmf"</span></span>  <span class="comment1">― ‹probabilistic›</span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">decrypt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="tfree">'dkey</span> <span class="main">⇒</span> <span class="tfree">'cipher</span> <span class="main">⇒</span> <span class="tfree">'plain</span> option"</span></span> <span class="comment1">― ‹deterministic, but not used›</span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">valid_plain</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="tfree">'plain</span> <span class="main">⇒</span> bool"</span></span> <span class="comment1">― ‹checks whether a plain text is valid, i.e., has the right format›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The IND-CCA2 game for public-key encryption›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We model an IND-CCA2 security game in the multi-user setting as described in
  \cite{BellareBoldyrevaMicali2000EUROCRYPT}.
›</span></span>

<span class="keyword1"><span class="command">locale</span></span> ind_cca2 <span class="main">=</span> pk_enc <span class="main">+</span>
  <span class="keyword2"><span class="keyword">constrains</span></span> key_gen <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'ekey</span> <span class="main">×</span> <span class="tfree">'dkey</span><span class="main">)</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> encrypt <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="tfree">'ekey</span> <span class="main">⇒</span> <span class="tfree">'plain</span> <span class="main">⇒</span> <span class="tfree">'cipher</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> decrypt <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="tfree">'dkey</span> <span class="main">⇒</span> <span class="tfree">'cipher</span> <span class="main">⇒</span> <span class="tfree">'plain</span> option"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> valid_plain <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="tfree">'plain</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'ekey'</span><span class="main">,</span> <span class="tfree">'dkey'</span><span class="main">,</span> <span class="tfree">'cipher'</span><span class="main">)</span> state_oracle <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'ekey'</span> <span class="main">×</span> <span class="tfree">'dkey'</span> <span class="main">×</span> <span class="tfree">'cipher'</span> list<span class="main">)</span> option"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">decrypt_oracle</span>
  <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'ekey</span><span class="main">,</span> <span class="tfree">'dkey</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">)</span> state_oracle <span class="main">⇒</span> <span class="tfree">'cipher</span>
  <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'plain</span> option <span class="main">×</span> <span class="main">(</span><span class="tfree">'ekey</span><span class="main">,</span> <span class="tfree">'dkey</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">)</span> state_oracle<span class="main">)</span> spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">decrypt_oracle</span> <span class="free"><span class="bound"><span class="entity">η</span></span></span> None <span class="free"><span class="bound"><span class="entity">cipher</span></span></span> <span class="main">=</span> return_spmf <span class="main">(</span>None<span class="main">,</span> None<span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">decrypt_oracle</span> <span class="free"><span class="bound"><span class="entity">η</span></span></span> <span class="main">(</span>Some <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ekey</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">dkey</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">cstars</span></span></span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">cipher</span></span></span> <span class="main">=</span> return_spmf
   <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">cipher</span></span></span> <span class="main">∈</span> set <span class="free"><span class="bound"><span class="entity">cstars</span></span></span> <span class="keyword1">then</span> None <span class="keyword1">else</span> <span class="free">decrypt</span> <span class="free"><span class="bound"><span class="entity">η</span></span></span> <span class="free"><span class="bound"><span class="entity">dkey</span></span></span> <span class="free"><span class="bound"><span class="entity">cipher</span></span></span><span class="main">,</span> Some <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ekey</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">dkey</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">cstars</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">ekey_oracle</span>
  <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'ekey</span><span class="main">,</span> <span class="tfree">'dkey</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">)</span> state_oracle <span class="main">⇒</span> unit <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'ekey</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'ekey</span><span class="main">,</span> <span class="tfree">'dkey</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">)</span> state_oracle<span class="main">)</span> spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ekey_oracle</span> <span class="free"><span class="bound"><span class="entity">η</span></span></span> None <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="main">(</span><span class="bound">ekey</span><span class="main">,</span> <span class="bound">dkey</span><span class="main">)</span> <span class="main">←</span> <span class="free">key_gen</span> <span class="free"><span class="bound"><span class="entity">η</span></span></span><span class="main">;</span>
      return_spmf <span class="main">(</span><span class="bound">ekey</span><span class="main">,</span> Some <span class="main">(</span><span class="bound">ekey</span><span class="main">,</span> <span class="bound">dkey</span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ekey_oracle</span> <span class="free"><span class="bound"><span class="entity">η</span></span></span> <span class="main">(</span>Some <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ekey</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">rest</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> return_spmf <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ekey</span></span></span><span class="main">,</span> Some <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ekey</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">rest</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ekey_oracle_conv<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ekey_oracle <span class="free">η</span> <span class="free">σ</span> <span class="free">x</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> <span class="free">σ</span> <span class="keyword1">of</span> None <span class="main">⇒</span> map_spmf <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">ekey</span><span class="main">,</span> <span class="bound">dkey</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">ekey</span><span class="main">,</span> Some <span class="main">(</span><span class="bound">ekey</span><span class="main">,</span> <span class="bound">dkey</span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">key_gen</span> <span class="free">η</span><span class="main">)</span> 
   <span class="main">|</span> Some <span class="main">(</span><span class="bound">ekey</span><span class="main">,</span> <span class="bound">rest</span><span class="main">)</span> <span class="main">⇒</span> return_spmf <span class="main">(</span><span class="bound">ekey</span><span class="main">,</span> Some <span class="main">(</span><span class="bound">ekey</span><span class="main">,</span> <span class="bound">rest</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">σ</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_spmf_conv_bind_spmf split_def<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">notes</span></span> bind_spmf_cong<span class="main">[</span><span class="operator">fundef_cong</span><span class="main">]</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">function</span></span> <span class="entity">encrypt_oracle</span>
  <span class="main">::</span> <span class="quoted"><span class="quoted">"bool <span class="main">⇒</span> security <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'ekey</span><span class="main">,</span> <span class="tfree">'dkey</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">)</span> state_oracle <span class="main">⇒</span> <span class="tfree">'plain</span> <span class="main">×</span> <span class="tfree">'plain</span>
  <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'cipher</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'ekey</span><span class="main">,</span> <span class="tfree">'dkey</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">)</span> state_oracle<span class="main">)</span> spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">encrypt_oracle</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="free"><span class="bound"><span class="entity">η</span></span></span> None <span class="free"><span class="bound"><span class="entity">m01</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">←</span> ekey_oracle <span class="free"><span class="bound"><span class="entity">η</span></span></span> None <span class="main">()</span><span class="main">;</span> <span class="free">encrypt_oracle</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="free"><span class="bound"><span class="entity">η</span></span></span> <span class="bound">σ</span> <span class="free"><span class="bound"><span class="entity">m01</span></span></span> <span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">encrypt_oracle</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="free"><span class="bound"><span class="entity">η</span></span></span> <span class="main">(</span>Some <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ekey</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">dkey</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">cstars</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">m0</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">m1</span></span></span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">valid_plain</span> <span class="free"><span class="bound"><span class="entity">η</span></span></span> <span class="free"><span class="bound"><span class="entity">m0</span></span></span> <span class="main">∧</span> <span class="free">valid_plain</span> <span class="free"><span class="bound"><span class="entity">η</span></span></span> <span class="free"><span class="bound"><span class="entity">m1</span></span></span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>  
     <span class="keyword1">let</span> <span class="bound">pb</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">m0</span></span></span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">m1</span></span></span><span class="main">)</span><span class="main">;</span>
     <span class="bound">cstar</span> <span class="main">←</span> <span class="free">encrypt</span> <span class="free"><span class="bound"><span class="entity">η</span></span></span> <span class="free"><span class="bound"><span class="entity">ekey</span></span></span> <span class="bound">pb</span><span class="main">;</span>
     return_spmf <span class="main">(</span><span class="bound">cstar</span><span class="main">,</span> Some <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ekey</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">dkey</span></span></span><span class="main">,</span> <span class="bound">cstar</span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">cstars</span></span></span><span class="main">)</span><span class="main">)</span>
   <span class="main">}</span> <span class="keyword1">else</span> return_pmf None<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">pat_completeness</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">termination</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">"Wellfounded.measure <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">η</span><span class="main">,</span> <span class="bound">σ</span><span class="main">,</span> <span class="bound">m01</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">σ</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="main">1</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">0</span><span class="main">)</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Single-user setting›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'plain'</span><span class="main">,</span> <span class="tfree">'cipher'</span><span class="main">)</span> call<span class="hidden">⇩</span><sub>1</sub> <span class="main">=</span> <span class="quoted"><span class="quoted">"unit <span class="main">+</span> <span class="tfree">'cipher'</span> <span class="main">+</span> <span class="tfree">'plain'</span> <span class="main">×</span> <span class="tfree">'plain'</span>"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'ekey'</span><span class="main">,</span> <span class="tfree">'plain'</span><span class="main">,</span> <span class="tfree">'cipher'</span><span class="main">)</span> ret<span class="hidden">⇩</span><sub>1</sub> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ekey'</span> <span class="main">+</span> <span class="tfree">'plain'</span> option <span class="main">+</span> <span class="tfree">'cipher'</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">oracle<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"bool <span class="main">⇒</span> security 
  <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'ekey</span><span class="main">,</span> <span class="tfree">'dkey</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">)</span> state_oracle<span class="main">,</span> <span class="main">(</span><span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">)</span> call<span class="hidden">⇩</span><sub>1</sub><span class="main">,</span> <span class="main">(</span><span class="tfree">'ekey</span><span class="main">,</span> <span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">)</span> ret<span class="hidden">⇩</span><sub>1</sub><span class="main">)</span> oracle'"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">oracle<span class="hidden">⇩</span><sub>1</sub></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="free"><span class="bound"><span class="entity">η</span></span></span> <span class="main">=</span> ekey_oracle <span class="free"><span class="bound"><span class="entity">η</span></span></span> <span class="keyword1">⊕<span class="hidden">⇩</span><sub>O</sub></span> <span class="main">(</span>decrypt_oracle <span class="free"><span class="bound"><span class="entity">η</span></span></span> <span class="keyword1">⊕<span class="hidden">⇩</span><sub>O</sub></span> encrypt_oracle <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="free"><span class="bound"><span class="entity">η</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> oracle<span class="hidden">⇩</span><sub>1</sub>_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"oracle<span class="hidden">⇩</span><sub>1</sub> <span class="free">b</span> <span class="free">η</span> <span class="free">s</span> <span class="main">(</span>Inl <span class="free">x</span><span class="main">)</span> <span class="main">=</span> map_spmf <span class="main">(</span>apfst Inl<span class="main">)</span> <span class="main">(</span>ekey_oracle <span class="free">η</span> <span class="free">s</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"oracle<span class="hidden">⇩</span><sub>1</sub> <span class="free">b</span> <span class="free">η</span> <span class="free">s</span> <span class="main">(</span>Inr <span class="main">(</span>Inl <span class="free">y</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> map_spmf <span class="main">(</span>apfst <span class="main">(</span>Inr <span class="main">∘</span> Inl<span class="main">)</span><span class="main">)</span> <span class="main">(</span>decrypt_oracle <span class="free">η</span> <span class="free">s</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"oracle<span class="hidden">⇩</span><sub>1</sub> <span class="free">b</span> <span class="free">η</span> <span class="free">s</span> <span class="main">(</span>Inr <span class="main">(</span>Inr <span class="free">z</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> map_spmf <span class="main">(</span>apfst <span class="main">(</span>Inr <span class="main">∘</span> Inr<span class="main">)</span><span class="main">)</span> <span class="main">(</span>encrypt_oracle <span class="free">b</span> <span class="free">η</span> <span class="free">s</span> <span class="free">z</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle<span class="hidden">⇩</span><sub>1</sub>_def spmf.map_comp apfst_compose o_def<span class="main">)</span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'ekey'</span><span class="main">,</span> <span class="tfree">'plain'</span><span class="main">,</span> <span class="tfree">'cipher'</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>1</sub>' <span class="main">=</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>bool<span class="main">,</span> <span class="main">(</span><span class="tfree">'plain'</span><span class="main">,</span> <span class="tfree">'cipher'</span><span class="main">)</span> call<span class="hidden">⇩</span><sub>1</sub><span class="main">,</span> <span class="main">(</span><span class="tfree">'ekey'</span><span class="main">,</span> <span class="tfree">'plain'</span><span class="main">,</span> <span class="tfree">'cipher'</span><span class="main">)</span> ret<span class="hidden">⇩</span><sub>1</sub><span class="main">)</span> gpv"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'ekey'</span><span class="main">,</span> <span class="tfree">'plain'</span><span class="main">,</span> <span class="tfree">'cipher'</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>1</sub> <span class="main">=</span>
  <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'ekey'</span><span class="main">,</span> <span class="tfree">'plain'</span><span class="main">,</span> <span class="tfree">'cipher'</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>1</sub>'"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ind_cca2<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'ekey</span><span class="main">,</span> <span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>1</sub> <span class="main">⇒</span> security <span class="main">⇒</span> bool spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ind_cca2<span class="hidden">⇩</span><sub>1</sub></span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">η</span></span></span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
    <span class="main">(</span><span class="bound">guess</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="main">(</span>oracle<span class="hidden">⇩</span><sub>1</sub> <span class="bound">b</span> <span class="free"><span class="bound"><span class="entity">η</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">η</span></span></span><span class="main">)</span> None<span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">guess</span> <span class="main">=</span> <span class="bound">b</span><span class="main">)</span>
  <span class="main">}</span> <span class="keyword1">ELSE</span> coin_spmf"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">advantage<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'ekey</span><span class="main">,</span> <span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>1</sub> <span class="main">⇒</span> advantage"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">advantage<span class="hidden">⇩</span><sub>1</sub></span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">η</span></span></span> <span class="main">=</span> <span class="main">¦</span>spmf <span class="main">(</span>ind_cca2<span class="hidden">⇩</span><sub>1</sub> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">η</span></span></span><span class="main">)</span> True <span class="main">-</span> <span class="main">1</span><span class="main">/</span><span class="numeral">2</span><span class="main">¦</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> advantage<span class="hidden">⇩</span><sub>1</sub>_nonneg<span class="main">:</span> <span class="quoted"><span class="quoted">"advantage<span class="hidden">⇩</span><sub>1</sub> <span class="free">𝒜</span> <span class="free">η</span> <span class="main">≥</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> advantage<span class="hidden">⇩</span><sub>1</sub>_def<span class="main">)</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">secure_for<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'ekey</span><span class="main">,</span> <span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>1</sub> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">secure_for<span class="hidden">⇩</span><sub>1</sub></span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">≡</span> negligible <span class="main">(</span>advantage<span class="hidden">⇩</span><sub>1</sub> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ibounded_by<span class="hidden">⇩</span><sub>1</sub>'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'ekey</span><span class="main">,</span> <span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>1</sub>' <span class="main">⇒</span> nat <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ibounded_by<span class="hidden">⇩</span><sub>1</sub>'</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">=</span> interaction_any_bounded_by <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">q</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">ibounded_by<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'ekey</span><span class="main">,</span> <span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>1</sub> <span class="main">⇒</span> <span class="main">(</span>security <span class="main">⇒</span> nat<span class="main">)</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ibounded_by<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">≡</span> rel_envir ibounded_by<span class="hidden">⇩</span><sub>1</sub>'"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lossless<span class="hidden">⇩</span><sub>1</sub>'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'ekey</span><span class="main">,</span> <span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>1</sub>' <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">lossless<span class="hidden">⇩</span><sub>1</sub>'</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> lossless_gpv ℐ_full <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">lossless<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'ekey</span><span class="main">,</span> <span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>1</sub> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">lossless<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">≡</span> pred_envir lossless<span class="hidden">⇩</span><sub>1</sub>'"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_decrypt_oracle <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>decrypt_oracle <span class="free">η</span> <span class="free">σ</span> <span class="free">cipher</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">η</span><span class="main">,</span> <span class="free">σ</span><span class="main">,</span> <span class="free">cipher</span><span class="main">)</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> decrypt_oracle.cases<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_ekey_oracle <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>ekey_oracle <span class="free">η</span> <span class="free">σ</span> <span class="free">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">σ</span> <span class="main">=</span> None <span class="main">⟶</span> lossless_spmf <span class="main">(</span><span class="free">key_gen</span> <span class="free">η</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">η</span><span class="main">,</span> <span class="free">σ</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> ekey_oracle.cases<span class="main">)</span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_encrypt_oracle <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">σ</span> <span class="main">=</span> None <span class="main">⟹</span> lossless_spmf <span class="main">(</span><span class="free">key_gen</span> <span class="free">η</span><span class="main">)</span><span class="main">;</span>
    <span class="main">⋀</span><span class="bound">ekey</span> <span class="bound">m</span><span class="main">.</span> <span class="free">valid_plain</span> <span class="free">η</span> <span class="bound">m</span> <span class="main">⟹</span> lossless_spmf <span class="main">(</span><span class="free">encrypt</span> <span class="free">η</span> <span class="bound">ekey</span> <span class="bound">m</span><span class="main">)</span> <span class="main">⟧</span>
  <span class="main">⟹</span> lossless_spmf <span class="main">(</span>encrypt_oracle <span class="free">b</span> <span class="free">η</span> <span class="free">σ</span> <span class="main">(</span><span class="free">m0</span><span class="main">,</span> <span class="free">m1</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">valid_plain</span> <span class="free">η</span> <span class="free">m0</span> <span class="main">∧</span> <span class="free">valid_plain</span> <span class="free">η</span> <span class="free">m1</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">b</span><span class="main">,</span> <span class="free">η</span><span class="main">,</span> <span class="free">σ</span><span class="main">,</span> <span class="main">(</span><span class="free">m0</span><span class="main">,</span> <span class="free">m1</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> encrypt_oracle.cases<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lossless_spmfD_set_spmf_nonempty <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Multi-user setting›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">oracle<span class="hidden">⇩</span><sub>n</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"bool <span class="main">⇒</span> security
   <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'i</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'ekey</span><span class="main">,</span> <span class="tfree">'dkey</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">)</span> state_oracle<span class="main">,</span> <span class="tfree">'i</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">)</span> call<span class="hidden">⇩</span><sub>1</sub><span class="main">,</span> <span class="main">(</span><span class="tfree">'ekey</span><span class="main">,</span> <span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">)</span> ret<span class="hidden">⇩</span><sub>1</sub><span class="main">)</span> oracle'"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">oracle<span class="hidden">⇩</span><sub>n</sub></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="free"><span class="bound"><span class="entity">η</span></span></span> <span class="main">=</span> family_oracle <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> oracle<span class="hidden">⇩</span><sub>1</sub> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="free"><span class="bound"><span class="entity">η</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> oracle<span class="hidden">⇩</span><sub>n</sub>_apply <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"oracle<span class="hidden">⇩</span><sub>n</sub> <span class="free">b</span> <span class="free">η</span> <span class="free">s</span> <span class="main">(</span><span class="free">i</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> map_spmf <span class="main">(</span>apsnd <span class="main">(</span>fun_upd <span class="free">s</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>oracle<span class="hidden">⇩</span><sub>1</sub> <span class="free">b</span> <span class="free">η</span> <span class="main">(</span><span class="free">s</span> <span class="free">i</span><span class="main">)</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle<span class="hidden">⇩</span><sub>n</sub>_def<span class="main">)</span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'ekey'</span><span class="main">,</span> <span class="tfree">'plain'</span><span class="main">,</span> <span class="tfree">'cipher'</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>n</sub>' <span class="main">=</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>bool<span class="main">,</span> <span class="tfree">'i</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'plain'</span><span class="main">,</span> <span class="tfree">'cipher'</span><span class="main">)</span> call<span class="hidden">⇩</span><sub>1</sub><span class="main">,</span> <span class="main">(</span><span class="tfree">'ekey'</span><span class="main">,</span> <span class="tfree">'plain'</span><span class="main">,</span> <span class="tfree">'cipher'</span><span class="main">)</span> ret<span class="hidden">⇩</span><sub>1</sub><span class="main">)</span> gpv"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'ekey'</span><span class="main">,</span> <span class="tfree">'plain'</span><span class="main">,</span> <span class="tfree">'cipher'</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>n</sub> <span class="main">=</span>
  <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'ekey'</span><span class="main">,</span> <span class="tfree">'plain'</span><span class="main">,</span> <span class="tfree">'cipher'</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>n</sub>'"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ind_cca2<span class="hidden">⇩</span><sub>n</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'ekey</span><span class="main">,</span> <span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>n</sub> <span class="main">⇒</span> security <span class="main">⇒</span> bool spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ind_cca2<span class="hidden">⇩</span><sub>n</sub></span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">η</span></span></span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
    <span class="main">(</span><span class="bound">guess</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="main">(</span>oracle<span class="hidden">⇩</span><sub>n</sub> <span class="bound">b</span> <span class="free"><span class="bound"><span class="entity">η</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">η</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> None<span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">guess</span> <span class="main">=</span> <span class="bound">b</span><span class="main">)</span>
  <span class="main">}</span> <span class="keyword1">ELSE</span> coin_spmf"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">advantage<span class="hidden">⇩</span><sub>n</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'ekey</span><span class="main">,</span> <span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>n</sub> <span class="main">⇒</span> advantage"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">advantage<span class="hidden">⇩</span><sub>n</sub></span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">η</span></span></span> <span class="main">=</span> <span class="main">¦</span>spmf <span class="main">(</span>ind_cca2<span class="hidden">⇩</span><sub>n</sub> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">η</span></span></span><span class="main">)</span> True <span class="main">-</span> <span class="main">1</span><span class="main">/</span><span class="numeral">2</span><span class="main">¦</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> advantage<span class="hidden">⇩</span><sub>n</sub>_nonneg<span class="main">:</span> <span class="quoted"><span class="quoted">"advantage<span class="hidden">⇩</span><sub>n</sub> <span class="free">𝒜</span> <span class="free">η</span> <span class="main">≥</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> advantage<span class="hidden">⇩</span><sub>n</sub>_def<span class="main">)</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">secure_for<span class="hidden">⇩</span><sub>n</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'ekey</span><span class="main">,</span> <span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>n</sub> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">secure_for<span class="hidden">⇩</span><sub>n</sub></span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">≡</span> negligible <span class="main">(</span>advantage<span class="hidden">⇩</span><sub>n</sub> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ibounded_by<span class="hidden">⇩</span><sub>n</sub>'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'ekey</span><span class="main">,</span> <span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>n</sub>' <span class="main">⇒</span> nat <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ibounded_by<span class="hidden">⇩</span><sub>n</sub>'</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">=</span> interaction_any_bounded_by <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">q</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">ibounded_by<span class="hidden">⇩</span><sub>n</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'ekey</span><span class="main">,</span> <span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>n</sub> <span class="main">⇒</span> <span class="main">(</span>security <span class="main">⇒</span> nat<span class="main">)</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ibounded_by<span class="hidden">⇩</span><sub>n</sub></span> <span class="main">≡</span> rel_envir ibounded_by<span class="hidden">⇩</span><sub>n</sub>'"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lossless<span class="hidden">⇩</span><sub>n</sub>'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'ekey</span><span class="main">,</span> <span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>n</sub>' <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">lossless<span class="hidden">⇩</span><sub>n</sub>'</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> lossless_gpv ℐ_full <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">lossless<span class="hidden">⇩</span><sub>n</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'ekey</span><span class="main">,</span> <span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>n</sub> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">lossless<span class="hidden">⇩</span><sub>n</sub></span> <span class="main">≡</span> pred_envir lossless<span class="hidden">⇩</span><sub>n</sub>'"</span></span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">cipher_queries</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'i</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'ekey</span><span class="main">,</span> <span class="tfree">'dkey</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">)</span> state_oracle<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'cipher</span> set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">cipher_queries</span> <span class="free"><span class="bound"><span class="entity">ose</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">ciphers</span><span class="main">)</span><span class="main">∈</span>ran <span class="free"><span class="bound"><span class="entity">ose</span></span></span><span class="main">.</span> set <span class="bound">ciphers</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cipher_queriesI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">ose</span> <span class="free">n</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">ek</span><span class="main">,</span> <span class="free">dk</span><span class="main">,</span> <span class="free">ciphers</span><span class="main">)</span><span class="main">;</span> <span class="free">x</span> <span class="main">∈</span> set <span class="free">ciphers</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">∈</span> cipher_queries <span class="free">ose</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cipher_queries_def ran_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> cipher_queriesE<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> cipher_queries <span class="free">ose</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="main">(</span>cipher_queries<span class="main">)</span> <span class="free">n</span> <span class="free">ek</span> <span class="free">dk</span> <span class="free">ciphers</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ose</span> <span class="free">n</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">ek</span><span class="main">,</span> <span class="free">dk</span><span class="main">,</span> <span class="free">ciphers</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> set <span class="free">ciphers</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cipher_queries_def ran_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> cipher_queries_updE<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> cipher_queries <span class="main">(</span><span class="free">ose</span><span class="main">(</span><span class="free">n</span> <span class="main">↦</span> <span class="main">(</span><span class="free">ek</span><span class="main">,</span> <span class="free">dk</span><span class="main">,</span> <span class="free">ciphers</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="main">(</span>old<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> cipher_queries <span class="free">ose</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∉</span> set <span class="free">ciphers</span>"</span></span> <span class="main">|</span> <span class="main">(</span>new<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> set <span class="free">ciphers</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> set <span class="free">ciphers</span>"</span></span><span class="main">)</span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> cipher_queriesE <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> cipher_queriesI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cipher_queries_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"cipher_queries Map.empty <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cipher_queries_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="IND_CCA2_sym">
<div class="head">
<h1>Theory IND_CCA2_sym</h1>
</div>
<pre class="source"><span class="comment1">(* Title: IND_CCA2_sym.thy
  Author: Andreas Lochbihler, ETH Zurich 
  Author: S. Reza Sefidgar, ETH Zurich *)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The IND-CCA2 security for symmetric encryption schemes›</span></span>

<span class="keyword1"><span class="command">theory</span></span> IND_CCA2_sym <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../CryptHOL/Computational_Model.html">CryptHOL.Computational_Model</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">locale</span></span> ind_cca <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">key_gen</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'key</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">encrypt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'key</span> <span class="main">⇒</span> <span class="tfree">'message</span> <span class="main">⇒</span> <span class="tfree">'cipher</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">decrypt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'key</span> <span class="main">⇒</span> <span class="tfree">'cipher</span> <span class="main">⇒</span> <span class="tfree">'message</span> option"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">msg_predicate</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'message</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'message'</span><span class="main">,</span> <span class="tfree">'cipher'</span><span class="main">)</span> adversary <span class="main">=</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>bool<span class="main">,</span> <span class="tfree">'message'</span> <span class="main">×</span> <span class="tfree">'message'</span> <span class="main">+</span> <span class="tfree">'cipher'</span><span class="main">,</span> <span class="tfree">'cipher'</span> option <span class="main">+</span> <span class="tfree">'message'</span> option<span class="main">)</span> gpv"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">oracle_encrypt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'key</span> <span class="main">⇒</span> bool <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'message</span> <span class="main">×</span> <span class="tfree">'message</span><span class="main">,</span> <span class="tfree">'cipher</span> option<span class="main">,</span> <span class="tfree">'cipher</span> set<span class="main">)</span> callee"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">oracle_encrypt</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="free"><span class="bound"><span class="entity">L</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">msg1</span><span class="main">,</span> <span class="bound">msg0</span><span class="main">)</span><span class="main">.</span>
     <span class="main">(</span><span class="keyword1">case</span> <span class="free">msg_predicate</span> <span class="bound">msg1</span> <span class="main">∧</span> <span class="free">msg_predicate</span> <span class="bound">msg0</span> <span class="keyword1">of</span>
        True <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
         <span class="bound">c</span> <span class="main">←</span> <span class="free">encrypt</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="keyword1">then</span> <span class="bound">msg1</span> <span class="keyword1">else</span> <span class="bound">msg0</span><span class="main">)</span><span class="main">;</span>
         return_spmf <span class="main">(</span>Some <span class="bound">c</span><span class="main">,</span> <span class="main">{</span><span class="bound">c</span><span class="main">}</span> <span class="main">∪</span> <span class="free"><span class="bound"><span class="entity">L</span></span></span><span class="main">)</span>
        <span class="main">}</span>
     <span class="main">|</span> False <span class="main">⇒</span> return_spmf <span class="main">(</span>None<span class="main">,</span> <span class="free"><span class="bound"><span class="entity">L</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_oracle_encrypt <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span><span class="free">encrypt</span> <span class="free">k</span> <span class="free">m1</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span><span class="free">encrypt</span> <span class="free">k</span> <span class="free">m0</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>oracle_encrypt <span class="free">k</span> <span class="free">b</span> <span class="free">L</span> <span class="main">(</span><span class="free">m1</span><span class="main">,</span> <span class="free">m0</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle_encrypt_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> bool.split<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">oracle_decrypt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'key</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'cipher</span><span class="main">,</span> <span class="tfree">'message</span> option<span class="main">,</span> <span class="tfree">'cipher</span> set<span class="main">)</span> callee"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">oracle_decrypt</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">L</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">=</span> return_spmf <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">L</span></span></span> <span class="keyword1">then</span> None <span class="keyword1">else</span> <span class="free">decrypt</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">L</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_oracle_decrypt <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>oracle_decrypt <span class="free">k</span> <span class="free">L</span> <span class="free">c</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle_decrypt_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">game</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'message</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">)</span> adversary <span class="main">⇒</span> bool spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">game</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">key</span> <span class="main">←</span> <span class="free">key_gen</span><span class="main">;</span>
    <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
    <span class="main">(</span><span class="bound">b'</span><span class="main">,</span> <span class="bound">L'</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="main">(</span>oracle_encrypt <span class="bound">key</span> <span class="bound">b</span> <span class="keyword1">⊕<span class="hidden">⇩</span><sub>O</sub></span> oracle_decrypt <span class="bound">key</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">{}</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">b</span> <span class="main">=</span> <span class="bound">b'</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">advantage</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'message</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">)</span> adversary <span class="main">⇒</span> real"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">advantage</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> <span class="main">¦</span>spmf <span class="main">(</span>game <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span><span class="main">)</span> True <span class="main">-</span> <span class="main">1</span> <span class="main">/</span> <span class="numeral">2</span><span class="main">¦</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> advantage_nonneg<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≤</span> advantage <span class="free">𝒜</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> advantage_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="IND_CPA">
<div class="head">
<h1>Theory IND_CPA</h1>
</div>
<pre class="source"><span class="comment1">(* Title: IND_CPA.thy
  Author: Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">theory</span></span> IND_CPA <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../CryptHOL/Generative_Probabilistic_Value.html">CryptHOL.Generative_Probabilistic_Value</a>
  <a href="../CryptHOL/Computational_Model.html">CryptHOL.Computational_Model</a>
  <a href="../CryptHOL/Negligible.html">CryptHOL.Negligible</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The IND-CPA game for symmetric encryption schemes›</span></span>

<span class="keyword1"><span class="command">locale</span></span> ind_cpa <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">key_gen</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'key</span> spmf"</span></span> <span class="comment1">― ‹probabilistic›</span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">encrypt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'key</span> <span class="main">⇒</span> <span class="tfree">'plain</span> <span class="main">⇒</span> <span class="tfree">'cipher</span> spmf"</span></span>  <span class="comment1">― ‹probabilistic›</span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">decrypt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'key</span> <span class="main">⇒</span> <span class="tfree">'cipher</span> <span class="main">⇒</span> <span class="tfree">'plain</span> option"</span></span> <span class="comment1">― ‹deterministic, but not used›</span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">valid_plain</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'plain</span> <span class="main">⇒</span> bool"</span></span> <span class="comment1">― ‹checks whether a plain text is valid, i.e., has the right format›</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We cannot incorporate the predicate <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">valid_plain</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in the type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'plain</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> of plaintexts,
  because the single <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'plain</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> must contain plaintexts for all values of the security parameter,
  as HOL does not have dependent types.  Consequently, the oracle has to ensure that the received
  plaintexts are valid.
›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'plain'</span><span class="main">,</span> <span class="tfree">'cipher'</span><span class="main">,</span> <span class="tfree">'state</span><span class="main">)</span> adversary <span class="main">=</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'plain'</span> <span class="main">×</span> <span class="tfree">'plain'</span><span class="main">)</span> <span class="main">×</span> <span class="tfree">'state</span><span class="main">,</span> <span class="tfree">'plain'</span><span class="main">,</span> <span class="tfree">'cipher'</span><span class="main">)</span> gpv
   <span class="main">×</span> <span class="main">(</span><span class="tfree">'cipher'</span> <span class="main">⇒</span> <span class="tfree">'state</span> <span class="main">⇒</span> <span class="main">(</span>bool<span class="main">,</span> <span class="tfree">'plain'</span><span class="main">,</span> <span class="tfree">'cipher'</span><span class="main">)</span> gpv<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">encrypt_oracle</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'key</span> <span class="main">⇒</span> unit <span class="main">⇒</span> <span class="tfree">'plain</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'cipher</span> <span class="main">×</span> unit<span class="main">)</span> spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">encrypt_oracle</span> <span class="free"><span class="bound"><span class="entity">key</span></span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="free"><span class="bound"><span class="entity">plain</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
     <span class="bound">cipher</span> <span class="main">←</span> <span class="free">encrypt</span> <span class="free"><span class="bound"><span class="entity">key</span></span></span> <span class="free"><span class="bound"><span class="entity">plain</span></span></span><span class="main">;</span>
     return_spmf <span class="main">(</span><span class="bound">cipher</span><span class="main">,</span> <span class="main">()</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ind_cpa</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">,</span> <span class="tfree">'state</span><span class="main">)</span> adversary <span class="main">⇒</span> bool spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ind_cpa</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
     <span class="keyword1">let</span> <span class="main">(</span><span class="bound">𝒜1</span><span class="main">,</span> <span class="bound">𝒜2</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span><span class="main">;</span>
     <span class="bound">key</span> <span class="main">←</span> <span class="free">key_gen</span><span class="main">;</span>
     <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
     <span class="main">(</span><span class="bound">guess</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="main">(</span>encrypt_oracle <span class="bound">key</span><span class="main">)</span> <span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span>
         <span class="main">(</span><span class="main">(</span><span class="bound">m0</span><span class="main">,</span> <span class="bound">m1</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">←</span> <span class="bound">𝒜1</span><span class="main">;</span>
         <span class="keyword1">if</span> <span class="free">valid_plain</span> <span class="bound">m0</span> <span class="main">∧</span> <span class="free">valid_plain</span> <span class="bound">m1</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
           <span class="bound">cipher</span> <span class="main">←</span> lift_spmf <span class="main">(</span><span class="free">encrypt</span> <span class="bound">key</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">m0</span> <span class="keyword1">else</span> <span class="bound">m1</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
           <span class="bound">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span>
         <span class="main">}</span> <span class="keyword1">else</span> lift_spmf coin_spmf
       <span class="main">}</span><span class="main">)</span> <span class="main">()</span><span class="main">;</span>
     return_spmf <span class="main">(</span><span class="bound">guess</span> <span class="main">=</span> <span class="bound">b</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">advantage</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">,</span> <span class="tfree">'state</span><span class="main">)</span> adversary <span class="main">⇒</span> real"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">advantage</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> <span class="main">¦</span>spmf <span class="main">(</span>ind_cpa <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span><span class="main">)</span> True <span class="main">-</span> <span class="main">1</span><span class="main">/</span><span class="numeral">2</span><span class="main">¦</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> advantage_nonneg<span class="main">:</span> <span class="quoted"><span class="quoted">"advantage <span class="free">𝒜</span> <span class="main">≥</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> advantage_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ibounded_by</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">,</span> <span class="tfree">'state</span><span class="main">)</span> adversary <span class="main">⇒</span> enat <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">ibounded_by</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">𝒜1</span><span class="main">,</span> <span class="bound">𝒜2</span><span class="main">)</span> <span class="bound">q</span><span class="main">.</span> 
  <span class="main">(</span><span class="main">∃</span><span class="bound">q1</span> <span class="bound">q2</span><span class="main">.</span> interaction_any_bounded_by <span class="bound">𝒜1</span> <span class="bound">q1</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">cipher</span> <span class="bound">σ</span><span class="main">.</span> interaction_any_bounded_by <span class="main">(</span><span class="bound">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="bound">q2</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">q1</span> <span class="main">+</span> <span class="bound">q2</span> <span class="main">≤</span> <span class="bound">q</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ibounded_byE <span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> ibounded_by<span class="main">,</span> <span class="operator">elim</span><span class="main"><span class="main"><span class="main">?</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ibounded_by <span class="main">(</span><span class="free">𝒜1</span><span class="main">,</span> <span class="free">𝒜2</span><span class="main">)</span> <span class="free">q</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">q1</span> <span class="free">q2</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">q1</span> <span class="main">+</span> <span class="free">q2</span> <span class="main">≤</span> <span class="free">q</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"interaction_any_bounded_by <span class="free">𝒜1</span> <span class="free">q1</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">cipher</span> <span class="bound">σ</span><span class="main">.</span> interaction_any_bounded_by <span class="main">(</span><span class="free">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="free">q2</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ibounded_by_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ibounded_byI <span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main">?</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> interaction_any_bounded_by <span class="free">𝒜1</span> <span class="free">q1</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">cipher</span> <span class="bound">σ</span><span class="main">.</span> interaction_any_bounded_by <span class="main">(</span><span class="free">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="free">q2</span><span class="main">;</span> <span class="free">q1</span> <span class="main">+</span> <span class="free">q2</span> <span class="main">≤</span> <span class="free">q</span> <span class="main">⟧</span>
  <span class="main">⟹</span> ibounded_by <span class="main">(</span><span class="free">𝒜1</span><span class="main">,</span> <span class="free">𝒜2</span><span class="main">)</span> <span class="free">q</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ibounded_by_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lossless</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">,</span> <span class="tfree">'state</span><span class="main">)</span> adversary <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">lossless</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">𝒜1</span><span class="main">,</span> <span class="bound">𝒜2</span><span class="main">)</span><span class="main">.</span> lossless_gpv ℐ_full <span class="bound">𝒜1</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">cipher</span> <span class="bound">σ</span><span class="main">.</span> lossless_gpv ℐ_full <span class="main">(</span><span class="bound">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="IND_CPA_PK">
<div class="head">
<h1>Theory IND_CPA_PK</h1>
</div>
<pre class="source"><span class="comment1">(* Title: IND_CPA_PK.thy
  Author: Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">theory</span></span> IND_CPA_PK <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../CryptHOL/Computational_Model.html">CryptHOL.Computational_Model</a>
  <a href="../CryptHOL/Negligible.html">CryptHOL.Negligible</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The IND-CPA game for public-key encryption with oracle access›</span></span>

<span class="keyword1"><span class="command">locale</span></span> ind_cpa_pk <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">key_gen</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'pubkey</span> <span class="main">×</span> <span class="tfree">'privkey</span><span class="main">,</span> <span class="tfree">'call</span><span class="main">,</span> <span class="tfree">'ret</span><span class="main">)</span> gpv"</span></span> <span class="comment1">― ‹probabilistic›</span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">aencrypt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pubkey</span> <span class="main">⇒</span> <span class="tfree">'plain</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'cipher</span><span class="main">,</span> <span class="tfree">'call</span><span class="main">,</span> <span class="tfree">'ret</span><span class="main">)</span> gpv"</span></span>  <span class="comment1">― ‹probabilistic w/ access to an oracle›</span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">adecrypt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'privkey</span> <span class="main">⇒</span> <span class="tfree">'cipher</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'call</span><span class="main">,</span> <span class="tfree">'ret</span><span class="main">)</span> gpv"</span></span> <span class="comment1">― ‹not used›</span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">valid_plains</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'plain</span> <span class="main">⇒</span> <span class="tfree">'plain</span> <span class="main">⇒</span> bool"</span></span> <span class="comment1">― ‹checks whether a pair of plaintexts is valid, i.e., they have the right format›</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We cannot incorporate the predicate <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">valid_plain</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in the type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'plain</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> of plaintexts,
  because the single <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'plain</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> must contain plaintexts for all values of the security parameter,
  as HOL does not have dependent types.  Consequently, the game has to ensure that the received
  plaintexts are valid.
›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'pubkey'</span><span class="main">,</span> <span class="tfree">'plain'</span><span class="main">,</span> <span class="tfree">'cipher'</span><span class="main">,</span> <span class="tfree">'call'</span><span class="main">,</span> <span class="tfree">'ret'</span><span class="main">,</span> <span class="tfree">'state</span><span class="main">)</span> adversary <span class="main">=</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'pubkey'</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'plain'</span> <span class="main">×</span> <span class="tfree">'plain'</span><span class="main">)</span> <span class="main">×</span> <span class="tfree">'state</span><span class="main">,</span> <span class="tfree">'call'</span><span class="main">,</span> <span class="tfree">'ret'</span><span class="main">)</span> gpv<span class="main">)</span>
   <span class="main">×</span> <span class="main">(</span><span class="tfree">'cipher'</span> <span class="main">⇒</span> <span class="tfree">'state</span> <span class="main">⇒</span> <span class="main">(</span>bool<span class="main">,</span> <span class="tfree">'call'</span><span class="main">,</span> <span class="tfree">'ret'</span><span class="main">)</span> gpv<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">ind_cpa</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'pubkey</span><span class="main">,</span> <span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">,</span> <span class="tfree">'call</span><span class="main">,</span> <span class="tfree">'ret</span><span class="main">,</span> <span class="tfree">'state</span><span class="main">)</span> adversary <span class="main">⇒</span> <span class="main">(</span>bool<span class="main">,</span> <span class="tfree">'call</span><span class="main">,</span> <span class="tfree">'ret</span><span class="main">)</span> gpv"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ind_cpa</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">𝒜1</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">𝒜2</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
     <span class="main">(</span><span class="bound">pk</span><span class="main">,</span> <span class="bound">sk</span><span class="main">)</span> <span class="main">←</span> <span class="free">key_gen</span><span class="main">;</span>
     <span class="bound">b</span> <span class="main">←</span> lift_spmf coin_spmf<span class="main">;</span>
     <span class="main">(</span><span class="main">(</span><span class="bound">m0</span><span class="main">,</span> <span class="bound">m1</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">←</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">𝒜1</span></span></span> <span class="bound">pk</span><span class="main">)</span><span class="main">;</span>
     assert_gpv <span class="main">(</span><span class="free">valid_plains</span> <span class="bound">m0</span> <span class="bound">m1</span><span class="main">)</span><span class="main">;</span>
     <span class="bound">cipher</span> <span class="main">←</span> <span class="free">aencrypt</span> <span class="bound">pk</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">m0</span> <span class="keyword1">else</span> <span class="bound">m1</span><span class="main">)</span><span class="main">;</span>
     <span class="bound">guess</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">𝒜2</span></span></span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">;</span> 
     Done <span class="main">(</span><span class="bound">guess</span> <span class="main">=</span> <span class="bound">b</span><span class="main">)</span>
   <span class="main">}</span> <span class="keyword1">ELSE</span> lift_spmf coin_spmf"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">advantage</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'σ</span> <span class="main">⇒</span> <span class="tfree">'call</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'ret</span> <span class="main">×</span> <span class="tfree">'σ</span><span class="main">)</span> spmf<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'σ</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'pubkey</span><span class="main">,</span> <span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">,</span> <span class="tfree">'call</span><span class="main">,</span> <span class="tfree">'ret</span><span class="main">,</span> <span class="tfree">'state</span><span class="main">)</span> adversary <span class="main">⇒</span> real"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">advantage</span> <span class="free"><span class="bound"><span class="entity">oracle</span></span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> <span class="main">¦</span>spmf <span class="main">(</span>run_gpv <span class="free"><span class="bound"><span class="entity">oracle</span></span></span> <span class="main">(</span>ind_cpa <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">)</span> True <span class="main">-</span> <span class="main">1</span><span class="main">/</span><span class="numeral">2</span><span class="main">¦</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> advantage_nonneg<span class="main">:</span> <span class="quoted"><span class="quoted">"advantage <span class="free">oracle</span> <span class="free">σ</span> <span class="free">𝒜</span> <span class="main">≥</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> advantage_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ibounded_by</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'call</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'pubkey</span><span class="main">,</span> <span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">,</span> <span class="tfree">'call</span><span class="main">,</span> <span class="tfree">'ret</span><span class="main">,</span> <span class="tfree">'state</span><span class="main">)</span> adversary <span class="main">⇒</span> enat <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">ibounded_by</span> <span class="free"><span class="bound"><span class="entity">consider</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">𝒜1</span><span class="main">,</span> <span class="bound">𝒜2</span><span class="main">)</span> <span class="bound">q</span><span class="main">.</span> 
  <span class="main">(</span><span class="main">∃</span><span class="bound">q1</span> <span class="bound">q2</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">pk</span><span class="main">.</span> interaction_bounded_by <span class="free"><span class="bound"><span class="entity">consider</span></span></span> <span class="main">(</span><span class="bound">𝒜1</span> <span class="bound">pk</span><span class="main">)</span> <span class="bound">q1</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">cipher</span> <span class="bound">σ</span><span class="main">.</span> interaction_bounded_by <span class="free"><span class="bound"><span class="entity">consider</span></span></span> <span class="main">(</span><span class="bound">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="bound">q2</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">q1</span> <span class="main">+</span> <span class="bound">q2</span> <span class="main">≤</span> <span class="bound">q</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ibounded_by'E <span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> ibounded_by'<span class="main">,</span> <span class="operator">elim</span><span class="main"><span class="main"><span class="main">?</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ibounded_by <span class="free">consider</span> <span class="main">(</span><span class="free">𝒜1</span><span class="main">,</span> <span class="free">𝒜2</span><span class="main">)</span> <span class="free">q</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">q1</span> <span class="free">q2</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">q1</span> <span class="main">+</span> <span class="free">q2</span> <span class="main">≤</span> <span class="free">q</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">pk</span><span class="main">.</span> interaction_bounded_by <span class="free">consider</span> <span class="main">(</span><span class="free">𝒜1</span> <span class="bound">pk</span><span class="main">)</span> <span class="free">q1</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">cipher</span> <span class="bound">σ</span><span class="main">.</span> interaction_bounded_by <span class="free">consider</span> <span class="main">(</span><span class="free">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="free">q2</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ibounded_by_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ibounded_byI <span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main">?</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">⋀</span><span class="bound">pk</span><span class="main">.</span> interaction_bounded_by <span class="free">consider</span> <span class="main">(</span><span class="free">𝒜1</span> <span class="bound">pk</span><span class="main">)</span> <span class="free">q1</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">cipher</span> <span class="bound">σ</span><span class="main">.</span> interaction_bounded_by <span class="free">consider</span> <span class="main">(</span><span class="free">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="free">q2</span><span class="main">;</span> <span class="free">q1</span> <span class="main">+</span> <span class="free">q2</span> <span class="main">≤</span> <span class="free">q</span> <span class="main">⟧</span>
  <span class="main">⟹</span> ibounded_by <span class="free">consider</span> <span class="main">(</span><span class="free">𝒜1</span><span class="main">,</span> <span class="free">𝒜2</span><span class="main">)</span> <span class="free">q</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ibounded_by_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lossless</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'pubkey</span><span class="main">,</span> <span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">,</span> <span class="tfree">'call</span><span class="main">,</span> <span class="tfree">'ret</span><span class="main">,</span> <span class="tfree">'state</span><span class="main">)</span> adversary <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">lossless</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">𝒜1</span><span class="main">,</span> <span class="bound">𝒜2</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">pk</span><span class="main">.</span> lossless_gpv ℐ_full <span class="main">(</span><span class="bound">𝒜1</span> <span class="bound">pk</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">cipher</span> <span class="bound">σ</span><span class="main">.</span> lossless_gpv ℐ_full <span class="main">(</span><span class="bound">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="IND_CPA_PK_Single">
<div class="head">
<h1>Theory IND_CPA_PK_Single</h1>
</div>
<pre class="source"><span class="comment1">(* Title: IND_CPA_PK_Single.thy
  Author: Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">theory</span></span> IND_CPA_PK_Single <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../CryptHOL/Computational_Model.html">CryptHOL.Computational_Model</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The IND-CPA game (public key, single instance)›</span></span>

<span class="keyword1"><span class="command">locale</span></span> ind_cpa <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">key_gen</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'pub_key</span> <span class="main">×</span> <span class="tfree">'priv_key</span><span class="main">)</span> spmf"</span></span> <span class="comment1">― ‹probabilistic›</span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">aencrypt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub_key</span> <span class="main">⇒</span> <span class="tfree">'plain</span> <span class="main">⇒</span> <span class="tfree">'cipher</span> spmf"</span></span>  <span class="comment1">― ‹probabilistic›</span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">adecrypt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'priv_key</span> <span class="main">⇒</span> <span class="tfree">'cipher</span> <span class="main">⇒</span> <span class="tfree">'plain</span> option"</span></span> <span class="comment1">― ‹deterministic, but not used›</span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">valid_plains</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'plain</span> <span class="main">⇒</span> <span class="tfree">'plain</span> <span class="main">⇒</span> bool"</span></span> <span class="comment1">― ‹checks whether a pair of plaintexts is valid, i.e., they both have the right format›</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We cannot incorporate the predicate <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">valid_plain</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in the type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'plain</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> of plaintexts,
  because the single <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'plain</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> must contain plaintexts for all values of the security parameter,
  as HOL does not have dependent types.  Consequently, the oracle has to ensure that the received
  plaintexts are valid.
›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'pub_key'</span><span class="main">,</span> <span class="tfree">'plain'</span><span class="main">,</span> <span class="tfree">'cipher'</span><span class="main">,</span> <span class="tfree">'state</span><span class="main">)</span> adversary <span class="main">=</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'pub_key'</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'plain'</span> <span class="main">×</span> <span class="tfree">'plain'</span><span class="main">)</span> <span class="main">×</span> <span class="tfree">'state</span><span class="main">)</span> spmf<span class="main">)</span>
   <span class="main">×</span> <span class="main">(</span><span class="tfree">'cipher'</span> <span class="main">⇒</span> <span class="tfree">'state</span> <span class="main">⇒</span> bool spmf<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">ind_cpa</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'pub_key</span><span class="main">,</span> <span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">,</span> <span class="tfree">'state</span><span class="main">)</span> adversary <span class="main">⇒</span> bool spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ind_cpa</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">𝒜1</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">𝒜2</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
     <span class="main">(</span><span class="bound">pk</span><span class="main">,</span> <span class="bound">sk</span><span class="main">)</span> <span class="main">←</span> <span class="free">key_gen</span><span class="main">;</span>
     <span class="main">(</span><span class="main">(</span><span class="bound">m0</span><span class="main">,</span> <span class="bound">m1</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">𝒜1</span></span></span> <span class="bound">pk</span><span class="main">;</span>
     <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span><span class="free">valid_plains</span> <span class="bound">m0</span> <span class="bound">m1</span><span class="main">)</span><span class="main">;</span>
     <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
     <span class="bound">cipher</span> <span class="main">←</span> <span class="free">aencrypt</span> <span class="bound">pk</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">m0</span> <span class="keyword1">else</span> <span class="bound">m1</span><span class="main">)</span><span class="main">;</span>
     <span class="bound">b'</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">𝒜2</span></span></span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">;</span>
     return_spmf <span class="main">(</span><span class="bound">b</span> <span class="main">=</span> <span class="bound">b'</span><span class="main">)</span>
  <span class="main">}</span> <span class="keyword1">ELSE</span> coin_spmf"</span></span>

<span class="keyword1"><span class="command">declare</span></span> ind_cpa.simps <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">advantage</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'pub_key</span><span class="main">,</span> <span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">,</span> <span class="tfree">'state</span><span class="main">)</span> adversary <span class="main">⇒</span> real"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">advantage</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> <span class="main">¦</span>spmf <span class="main">(</span>ind_cpa <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span><span class="main">)</span> True <span class="main">-</span> <span class="main">1</span><span class="main">/</span><span class="numeral">2</span><span class="main">¦</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lossless</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'pub_key</span><span class="main">,</span> <span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">,</span> <span class="tfree">'state</span><span class="main">)</span> adversary <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lossless</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">⟷</span>
   <span class="main">(</span><span class="main">(</span><span class="main">∀</span><span class="bound">pk</span><span class="main">.</span> lossless_spmf <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="bound">pk</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
        <span class="main">(</span><span class="main">∀</span><span class="bound">cipher</span> <span class="bound">σ</span><span class="main">.</span> lossless_spmf <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_ind_cpa<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> lossless <span class="free">𝒜</span><span class="main">;</span> lossless_spmf <span class="main">(</span><span class="free">key_gen</span><span class="main">)</span> <span class="main">⟧</span> <span class="main">⟹</span> lossless_spmf <span class="main">(</span>ind_cpa <span class="free">𝒜</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lossless_def ind_cpa_def split_def Let_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="SUF_CMA">
<div class="head">
<h1>Theory SUF_CMA</h1>
</div>
<pre class="source"><span class="comment1">(* Title: SUF_CMA.thy
  Author: Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">theory</span></span> SUF_CMA <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../CryptHOL/Computational_Model.html">CryptHOL.Computational_Model</a>
  <a href="../CryptHOL/Negligible.html">CryptHOL.Negligible</a>
  <a href="../CryptHOL/Environment_Functor.html">CryptHOL.Environment_Functor</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Strongly existentially unforgeable signature scheme›</span></span>

<span class="keyword1"><span class="command">locale</span></span> sig_scheme <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">key_gen</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'vkey</span> <span class="main">×</span> <span class="tfree">'sigkey</span><span class="main">)</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">sign</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="tfree">'sigkey</span> <span class="main">⇒</span> <span class="tfree">'message</span> <span class="main">⇒</span> <span class="tfree">'signature</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">verify</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="tfree">'vkey</span> <span class="main">⇒</span> <span class="tfree">'message</span> <span class="main">⇒</span> <span class="tfree">'signature</span> <span class="main">⇒</span> bool"</span></span> <span class="comment1">― ‹verification is deterministic›</span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">valid_message</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="tfree">'message</span> <span class="main">⇒</span> bool"</span></span>

<span class="keyword1"><span class="command">locale</span></span> suf_cma <span class="main">=</span> sig_scheme <span class="main">+</span>
  <span class="keyword2"><span class="keyword">constrains</span></span> key_gen <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'vkey</span> <span class="main">×</span> <span class="tfree">'sigkey</span><span class="main">)</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> sign <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="tfree">'sigkey</span> <span class="main">⇒</span> <span class="tfree">'message</span> <span class="main">⇒</span> <span class="tfree">'signature</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> verify <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="tfree">'vkey</span> <span class="main">⇒</span> <span class="tfree">'message</span> <span class="main">⇒</span> <span class="tfree">'signature</span> <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> valid_message <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="tfree">'message</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'vkey'</span><span class="main">,</span> <span class="tfree">'sigkey'</span><span class="main">,</span> <span class="tfree">'message'</span><span class="main">,</span> <span class="tfree">'signature'</span><span class="main">)</span> state_oracle 
  <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'vkey'</span> <span class="main">×</span> <span class="tfree">'sigkey'</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'message'</span> <span class="main">×</span> <span class="tfree">'signature'</span><span class="main">)</span> list<span class="main">)</span> option"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">vkey_oracle</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'vkey</span><span class="main">,</span> <span class="tfree">'sigkey</span><span class="main">,</span> <span class="tfree">'message</span><span class="main">,</span> <span class="tfree">'signature</span><span class="main">)</span> state_oracle<span class="main">,</span> unit<span class="main">,</span> <span class="tfree">'vkey</span><span class="main">)</span> oracle'"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">vkey_oracle</span> <span class="free"><span class="bound"><span class="entity">η</span></span></span> None <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
     <span class="main">(</span><span class="bound">vkey</span><span class="main">,</span> <span class="bound">sigkey</span><span class="main">)</span> <span class="main">←</span> <span class="free">key_gen</span> <span class="free"><span class="bound"><span class="entity">η</span></span></span><span class="main">;</span>
     return_spmf <span class="main">(</span><span class="bound">vkey</span><span class="main">,</span> Some <span class="main">(</span><span class="bound">vkey</span><span class="main">,</span> <span class="bound">sigkey</span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span><span class="main">)</span>
   <span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">log</span><span class="main">.</span> <span class="free">vkey_oracle</span> <span class="free"><span class="bound"><span class="entity">η</span></span></span> <span class="main">(</span>Some <span class="main">(</span><span class="free"><span class="bound"><span class="entity">vkey</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">sigkey</span></span></span><span class="main">,</span> <span class="bound">log</span><span class="main">)</span><span class="main">)</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> return_spmf <span class="main">(</span><span class="free"><span class="bound"><span class="entity">vkey</span></span></span><span class="main">,</span> Some <span class="main">(</span><span class="free"><span class="bound"><span class="entity">vkey</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">sigkey</span></span></span><span class="main">,</span> <span class="bound">log</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">notes</span></span> bind_spmf_cong<span class="main">[</span><span class="operator">fundef_cong</span><span class="main">]</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">function</span></span> <span class="entity">sign_oracle</span>
  <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'vkey</span><span class="main">,</span> <span class="tfree">'sigkey</span><span class="main">,</span> <span class="tfree">'message</span><span class="main">,</span> <span class="tfree">'signature</span><span class="main">)</span> state_oracle<span class="main">,</span> <span class="tfree">'message</span><span class="main">,</span> <span class="tfree">'signature</span><span class="main">)</span> oracle'"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sign_oracle</span> <span class="free"><span class="bound"><span class="entity">η</span></span></span> None <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">←</span> vkey_oracle <span class="free"><span class="bound"><span class="entity">η</span></span></span> None <span class="main">()</span><span class="main">;</span> <span class="free">sign_oracle</span> <span class="free"><span class="bound"><span class="entity">η</span></span></span> <span class="bound">σ</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">log</span><span class="main">.</span> <span class="free">sign_oracle</span> <span class="free"><span class="bound"><span class="entity">η</span></span></span> <span class="main">(</span>Some <span class="main">(</span><span class="free"><span class="bound"><span class="entity">vkey</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">skey</span></span></span><span class="main">,</span> <span class="bound">log</span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">valid_message</span> <span class="free"><span class="bound"><span class="entity">η</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">sig</span> <span class="main">←</span> <span class="free">sign</span> <span class="free"><span class="bound"><span class="entity">η</span></span></span> <span class="free"><span class="bound"><span class="entity">skey</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">sig</span><span class="main">,</span> Some <span class="main">(</span><span class="free"><span class="bound"><span class="entity">vkey</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">skey</span></span></span><span class="main">,</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">,</span> <span class="bound">sig</span><span class="main">)</span> <span class="main">#</span> <span class="bound">log</span><span class="main">)</span><span class="main">)</span> 
  <span class="main">}</span> <span class="keyword1">else</span> return_pmf None<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">pat_completeness</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">termination</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">"Wellfounded.measure <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">η</span><span class="main">,</span> <span class="bound">σ</span><span class="main">,</span> <span class="bound">m</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">σ</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="main">1</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">0</span><span class="main">)</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_vkey_oracle <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>vkey_oracle <span class="free">η</span> <span class="free">σ</span> <span class="free">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">σ</span> <span class="main">=</span> None <span class="main">⟶</span> lossless_spmf <span class="main">(</span><span class="free">key_gen</span> <span class="free">η</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">η</span><span class="main">,</span> <span class="free">σ</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> vkey_oracle.cases<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_sign_oracle <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">σ</span> <span class="main">=</span> None <span class="main">⟹</span> lossless_spmf <span class="main">(</span><span class="free">key_gen</span> <span class="free">η</span><span class="main">)</span><span class="main">;</span>
    <span class="main">⋀</span><span class="bound">skey</span> <span class="bound">m</span><span class="main">.</span> <span class="free">valid_message</span> <span class="free">η</span> <span class="bound">m</span> <span class="main">⟹</span> lossless_spmf <span class="main">(</span><span class="free">sign</span> <span class="free">η</span> <span class="bound">skey</span> <span class="bound">m</span><span class="main">)</span> <span class="main">⟧</span>
  <span class="main">⟹</span> lossless_spmf <span class="main">(</span>sign_oracle <span class="free">η</span> <span class="free">σ</span> <span class="free">m</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">valid_message</span> <span class="free">η</span> <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">η</span><span class="main">,</span> <span class="free">σ</span><span class="main">,</span> <span class="free">m</span><span class="main">)</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> sign_oracle.cases<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lossless_spmfD_set_spmf_nonempty<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_sign_oracle_Some<span class="main">:</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">log</span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>sign_oracle <span class="free">η</span> <span class="main">(</span>Some <span class="main">(</span><span class="free">vkey</span><span class="main">,</span> <span class="free">skey</span><span class="main">,</span> <span class="free">log</span><span class="main">)</span><span class="main">)</span> <span class="free">m</span><span class="main">)</span> <span class="main">⟷</span> lossless_spmf <span class="main">(</span><span class="free">sign</span> <span class="free">η</span> <span class="free">skey</span> <span class="free">m</span><span class="main">)</span> <span class="main">∧</span> <span class="free">valid_message</span> <span class="free">η</span> <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Single-user setting›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'message'</span> call<span class="hidden">⇩</span><sub>1</sub> <span class="main">=</span> <span class="quoted"><span class="quoted">"unit <span class="main">+</span> <span class="tfree">'message'</span>"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'vkey'</span><span class="main">,</span> <span class="tfree">'signature'</span><span class="main">)</span> ret<span class="hidden">⇩</span><sub>1</sub> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'vkey'</span> <span class="main">+</span> <span class="tfree">'signature'</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">oracle<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"security
  <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'vkey</span><span class="main">,</span> <span class="tfree">'sigkey</span><span class="main">,</span> <span class="tfree">'message</span><span class="main">,</span> <span class="tfree">'signature</span><span class="main">)</span> state_oracle<span class="main">,</span> <span class="tfree">'message</span> call<span class="hidden">⇩</span><sub>1</sub><span class="main">,</span> <span class="main">(</span><span class="tfree">'vkey</span><span class="main">,</span> <span class="tfree">'signature</span><span class="main">)</span> ret<span class="hidden">⇩</span><sub>1</sub><span class="main">)</span> oracle'"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">oracle<span class="hidden">⇩</span><sub>1</sub></span> <span class="free"><span class="bound"><span class="entity">η</span></span></span> <span class="main">=</span> vkey_oracle <span class="free"><span class="bound"><span class="entity">η</span></span></span> <span class="keyword1">⊕<span class="hidden">⇩</span><sub>O</sub></span> sign_oracle <span class="free"><span class="bound"><span class="entity">η</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> oracle<span class="hidden">⇩</span><sub>1</sub>_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"oracle<span class="hidden">⇩</span><sub>1</sub> <span class="free">η</span> <span class="free">s</span> <span class="main">(</span>Inl <span class="free">x</span><span class="main">)</span> <span class="main">=</span> map_spmf <span class="main">(</span>apfst Inl<span class="main">)</span> <span class="main">(</span>vkey_oracle <span class="free">η</span> <span class="free">s</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"oracle<span class="hidden">⇩</span><sub>1</sub> <span class="free">η</span> <span class="free">s</span> <span class="main">(</span>Inr <span class="free">y</span><span class="main">)</span> <span class="main">=</span> map_spmf <span class="main">(</span>apfst Inr<span class="main">)</span> <span class="main">(</span>sign_oracle <span class="free">η</span> <span class="free">s</span> <span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle<span class="hidden">⇩</span><sub>1</sub>_def<span class="main">)</span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'vkey'</span><span class="main">,</span> <span class="tfree">'message'</span><span class="main">,</span> <span class="tfree">'signature'</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>1</sub>' <span class="main">=</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'message'</span> <span class="main">×</span> <span class="tfree">'signature'</span><span class="main">)</span><span class="main">,</span> <span class="tfree">'message'</span> call<span class="hidden">⇩</span><sub>1</sub><span class="main">,</span> <span class="main">(</span><span class="tfree">'vkey'</span><span class="main">,</span> <span class="tfree">'signature'</span><span class="main">)</span> ret<span class="hidden">⇩</span><sub>1</sub><span class="main">)</span> gpv"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'vkey'</span><span class="main">,</span> <span class="tfree">'message'</span><span class="main">,</span> <span class="tfree">'signature'</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>1</sub> <span class="main">=</span>
  <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'vkey'</span><span class="main">,</span> <span class="tfree">'message'</span><span class="main">,</span> <span class="tfree">'signature'</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>1</sub>'"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">suf_cma<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'vkey</span><span class="main">,</span> <span class="tfree">'message</span><span class="main">,</span> <span class="tfree">'signature</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>1</sub> <span class="main">⇒</span> security <span class="main">⇒</span> bool spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">log</span><span class="main">.</span> <span class="free">suf_cma<span class="hidden">⇩</span><sub>1</sub></span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">η</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="main">(</span><span class="bound">m</span><span class="main">,</span> <span class="bound">sig</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="main">(</span>oracle<span class="hidden">⇩</span><sub>1</sub> <span class="free"><span class="bound"><span class="entity">η</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">η</span></span></span><span class="main">)</span> None<span class="main">;</span>
    return_spmf <span class="main">(</span>
      <span class="keyword1">case</span> <span class="bound">σ</span> <span class="keyword1">of</span> None <span class="main">⇒</span> False
      <span class="main">|</span> Some <span class="main">(</span><span class="bound">vkey</span><span class="main">,</span> <span class="bound">skey</span><span class="main">,</span> log<span class="main">)</span> <span class="main">⇒</span> <span class="free">verify</span> <span class="free"><span class="bound"><span class="entity">η</span></span></span> <span class="bound">vkey</span> <span class="bound">m</span> <span class="bound">sig</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">m</span><span class="main">,</span> <span class="bound">sig</span><span class="main">)</span> <span class="main">∉</span> set <span class="bound">log</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">advantage<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'vkey</span><span class="main">,</span> <span class="tfree">'message</span><span class="main">,</span> <span class="tfree">'signature</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>1</sub> <span class="main">⇒</span> advantage"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">advantage<span class="hidden">⇩</span><sub>1</sub></span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">η</span></span></span> <span class="main">=</span> spmf <span class="main">(</span>suf_cma<span class="hidden">⇩</span><sub>1</sub> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">η</span></span></span><span class="main">)</span> True"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> advantage<span class="hidden">⇩</span><sub>1</sub>_nonneg<span class="main">:</span> <span class="quoted"><span class="quoted">"advantage<span class="hidden">⇩</span><sub>1</sub> <span class="free">𝒜</span> <span class="free">η</span> <span class="main">≥</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> advantage<span class="hidden">⇩</span><sub>1</sub>_def pmf_nonneg<span class="main">)</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">secure_for<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'vkey</span><span class="main">,</span> <span class="tfree">'message</span><span class="main">,</span> <span class="tfree">'signature</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>1</sub> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">secure_for<span class="hidden">⇩</span><sub>1</sub></span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">≡</span> negligible <span class="main">(</span>advantage<span class="hidden">⇩</span><sub>1</sub> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ibounded_by<span class="hidden">⇩</span><sub>1</sub>'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'vkey</span><span class="main">,</span> <span class="tfree">'message</span><span class="main">,</span> <span class="tfree">'signature</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>1</sub>' <span class="main">⇒</span> nat <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ibounded_by<span class="hidden">⇩</span><sub>1</sub>'</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">=</span> <span class="main">(</span>interaction_any_bounded_by <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">q</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">ibounded_by<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'vkey</span><span class="main">,</span> <span class="tfree">'message</span><span class="main">,</span> <span class="tfree">'signature</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>1</sub> <span class="main">⇒</span> <span class="main">(</span>security <span class="main">⇒</span> nat<span class="main">)</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ibounded_by<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">≡</span> rel_envir ibounded_by<span class="hidden">⇩</span><sub>1</sub>'"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lossless<span class="hidden">⇩</span><sub>1</sub>'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'vkey</span><span class="main">,</span> <span class="tfree">'message</span><span class="main">,</span> <span class="tfree">'signature</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>1</sub>' <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">lossless<span class="hidden">⇩</span><sub>1</sub>'</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> <span class="main">(</span>lossless_gpv ℐ_full <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">lossless<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'vkey</span><span class="main">,</span> <span class="tfree">'message</span><span class="main">,</span> <span class="tfree">'signature</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>1</sub> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">lossless<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">≡</span> pred_envir lossless<span class="hidden">⇩</span><sub>1</sub>'"</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Multi-user setting›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">oracle<span class="hidden">⇩</span><sub>n</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"security
  <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'i</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'vkey</span><span class="main">,</span> <span class="tfree">'sigkey</span><span class="main">,</span> <span class="tfree">'message</span><span class="main">,</span> <span class="tfree">'signature</span><span class="main">)</span> state_oracle<span class="main">,</span> <span class="tfree">'i</span> <span class="main">×</span> <span class="tfree">'message</span> call<span class="hidden">⇩</span><sub>1</sub><span class="main">,</span> <span class="main">(</span><span class="tfree">'vkey</span><span class="main">,</span> <span class="tfree">'signature</span><span class="main">)</span> ret<span class="hidden">⇩</span><sub>1</sub><span class="main">)</span> oracle'"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">oracle<span class="hidden">⇩</span><sub>n</sub></span> <span class="free"><span class="bound"><span class="entity">η</span></span></span> <span class="main">=</span> family_oracle <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> oracle<span class="hidden">⇩</span><sub>1</sub> <span class="free"><span class="bound"><span class="entity">η</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> oracle<span class="hidden">⇩</span><sub>n</sub>_apply <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"oracle<span class="hidden">⇩</span><sub>n</sub> <span class="free">η</span> <span class="free">s</span> <span class="main">(</span><span class="free">i</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> map_spmf <span class="main">(</span>apsnd <span class="main">(</span>fun_upd <span class="free">s</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>oracle<span class="hidden">⇩</span><sub>1</sub> <span class="free">η</span> <span class="main">(</span><span class="free">s</span> <span class="free">i</span><span class="main">)</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle<span class="hidden">⇩</span><sub>n</sub>_def<span class="main">)</span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'vkey'</span><span class="main">,</span> <span class="tfree">'message'</span><span class="main">,</span> <span class="tfree">'signature'</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>n</sub>' <span class="main">=</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'i</span> <span class="main">×</span> <span class="tfree">'message'</span> <span class="main">×</span> <span class="tfree">'signature'</span><span class="main">)</span><span class="main">,</span> <span class="tfree">'i</span> <span class="main">×</span> <span class="tfree">'message'</span> call<span class="hidden">⇩</span><sub>1</sub><span class="main">,</span> <span class="main">(</span><span class="tfree">'vkey'</span><span class="main">,</span> <span class="tfree">'signature'</span><span class="main">)</span> ret<span class="hidden">⇩</span><sub>1</sub><span class="main">)</span> gpv"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'vkey'</span><span class="main">,</span> <span class="tfree">'message'</span><span class="main">,</span> <span class="tfree">'signature'</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>n</sub> <span class="main">=</span>
  <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'vkey'</span><span class="main">,</span> <span class="tfree">'message'</span><span class="main">,</span> <span class="tfree">'signature'</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>n</sub>'"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">suf_cma<span class="hidden">⇩</span><sub>n</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'vkey</span><span class="main">,</span> <span class="tfree">'message</span><span class="main">,</span> <span class="tfree">'signature</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>n</sub> <span class="main">⇒</span> security <span class="main">⇒</span> bool spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">log</span><span class="main">.</span> <span class="free">suf_cma<span class="hidden">⇩</span><sub>n</sub></span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">η</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span> <span class="bound">m</span><span class="main">,</span> <span class="bound">sig</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="main">(</span>oracle<span class="hidden">⇩</span><sub>n</sub> <span class="free"><span class="bound"><span class="entity">η</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">η</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> None<span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span>
      <span class="keyword1">case</span> <span class="bound">σ</span> <span class="bound">i</span> <span class="keyword1">of</span> None <span class="main">⇒</span> False
      <span class="main">|</span> Some <span class="main">(</span><span class="bound">vkey</span><span class="main">,</span> <span class="bound">skey</span><span class="main">,</span> log<span class="main">)</span> <span class="main">⇒</span> <span class="free">verify</span> <span class="free"><span class="bound"><span class="entity">η</span></span></span> <span class="bound">vkey</span> <span class="bound">m</span> <span class="bound">sig</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">m</span><span class="main">,</span> <span class="bound">sig</span><span class="main">)</span> <span class="main">∉</span> set <span class="bound">log</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">advantage<span class="hidden">⇩</span><sub>n</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'vkey</span><span class="main">,</span> <span class="tfree">'message</span><span class="main">,</span> <span class="tfree">'signature</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>n</sub> <span class="main">⇒</span> advantage"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">advantage<span class="hidden">⇩</span><sub>n</sub></span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">η</span></span></span> <span class="main">=</span> spmf <span class="main">(</span>suf_cma<span class="hidden">⇩</span><sub>n</sub> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">η</span></span></span><span class="main">)</span> True"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> advantage<span class="hidden">⇩</span><sub>n</sub>_nonneg<span class="main">:</span> <span class="quoted"><span class="quoted">"advantage<span class="hidden">⇩</span><sub>n</sub> <span class="free">𝒜</span> <span class="free">η</span> <span class="main">≥</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> advantage<span class="hidden">⇩</span><sub>n</sub>_def pmf_nonneg<span class="main">)</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">secure_for<span class="hidden">⇩</span><sub>n</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'vkey</span><span class="main">,</span> <span class="tfree">'message</span><span class="main">,</span> <span class="tfree">'signature</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>n</sub> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">secure_for<span class="hidden">⇩</span><sub>n</sub></span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">≡</span> negligible <span class="main">(</span>advantage<span class="hidden">⇩</span><sub>n</sub> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ibounded_by<span class="hidden">⇩</span><sub>n</sub>'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'vkey</span><span class="main">,</span> <span class="tfree">'message</span><span class="main">,</span> <span class="tfree">'signature</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>n</sub>' <span class="main">⇒</span> nat <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ibounded_by<span class="hidden">⇩</span><sub>n</sub>'</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">=</span> <span class="main">(</span>interaction_any_bounded_by <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">q</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">ibounded_by<span class="hidden">⇩</span><sub>n</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'vkey</span><span class="main">,</span> <span class="tfree">'message</span><span class="main">,</span> <span class="tfree">'signature</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>n</sub> <span class="main">⇒</span> <span class="main">(</span>security <span class="main">⇒</span> nat<span class="main">)</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ibounded_by<span class="hidden">⇩</span><sub>n</sub></span> <span class="main">≡</span> rel_envir ibounded_by<span class="hidden">⇩</span><sub>n</sub>'"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lossless<span class="hidden">⇩</span><sub>n</sub>'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'vkey</span><span class="main">,</span> <span class="tfree">'message</span><span class="main">,</span> <span class="tfree">'signature</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>n</sub>' <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">lossless<span class="hidden">⇩</span><sub>n</sub>'</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> <span class="main">(</span>lossless_gpv ℐ_full <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">lossless<span class="hidden">⇩</span><sub>n</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'vkey</span><span class="main">,</span> <span class="tfree">'message</span><span class="main">,</span> <span class="tfree">'signature</span><span class="main">)</span> adversary<span class="hidden">⇩</span><sub>n</sub> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">lossless<span class="hidden">⇩</span><sub>n</sub></span> <span class="main">≡</span> pred_envir lossless<span class="hidden">⇩</span><sub>n</sub>'"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Pseudo_Random_Function">
<div class="head">
<h1>Theory Pseudo_Random_Function</h1>
</div>
<pre class="source"><span class="comment1">(* Title: Pseudo_Random_Function.thy
  Author: Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">theory</span></span> Pseudo_Random_Function <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../CryptHOL/Computational_Model.html">CryptHOL.Computational_Model</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Pseudo-random function›</span></span>

<span class="keyword1"><span class="command">locale</span></span> random_function <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> spmf"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'b</span><span class="main">,</span><span class="tfree">'a'</span><span class="main">)</span> dict <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇀</span> <span class="tfree">'a'</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">random_oracle</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> dict <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> dict<span class="main">)</span> spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">random_oracle</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">of</span> Some <span class="bound">y</span> <span class="main">⇒</span> return_spmf <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">)</span>
   <span class="main">|</span> None <span class="main">⇒</span> <span class="free">p</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> return_spmf <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">↦</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">forgetful_random_oracle</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"unit <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> unit<span class="main">)</span> spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">forgetful_random_oracle</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free">p</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> return_spmf <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="main">()</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> weight_random_oracle <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"weight_spmf <span class="free">p</span> <span class="main">=</span> <span class="main">1</span> <span class="main">⟹</span> weight_spmf <span class="main">(</span>random_oracle <span class="free">σ</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> random_oracle_def weight_bind_spmf o_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_random_oracle <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lossless_spmf <span class="free">p</span> <span class="main">⟹</span> lossless_spmf <span class="main">(</span>random_oracle <span class="free">σ</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lossless_spmf_def<span class="main">)</span>

<span class="keyword1"><span class="command">sublocale</span></span> finite<span class="main">:</span> callee_invariant_on <span class="quoted">random_oracle</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> finite <span class="main">(</span>dom <span class="bound">σ</span><span class="main">)</span>"</span></span> <span class="quoted">ℐ_full</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> random_oracle_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> card_dom_random_oracle<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"interaction_any_bounded_by <span class="free">𝒜</span> <span class="free">q</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="free">σ'</span><span class="main">)</span> <span class="main">∈</span> set_spmf <span class="main">(</span>exec_gpv random_oracle <span class="free">𝒜</span> <span class="free">σ</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>dom <span class="free">σ</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>dom <span class="free">σ'</span><span class="main">)</span> <span class="main">≤</span> <span class="free">q</span> <span class="main">+</span> card <span class="main">(</span>dom <span class="free">σ</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> finite.interaction_bounded_by'_exec_gpv_count<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1-2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> random_oracle_def fin card_insert_if <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Pseudo-random function›</span></span>

<span class="keyword1"><span class="command">locale</span></span> <span class="quoted">"prf"</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">key_gen</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'key</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">"<span class="free">prf</span>"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'key</span> <span class="main">⇒</span> <span class="tfree">'domain</span> <span class="main">⇒</span> <span class="tfree">'range</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">rand</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'range</span> spmf"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> random_function <span class="quoted"><span class="quoted">"<span class="free">rand</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">prf_oracle</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'key</span> <span class="main">⇒</span> unit <span class="main">⇒</span> <span class="tfree">'domain</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'range</span> <span class="main">×</span> unit<span class="main">)</span> spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">prf_oracle</span> <span class="free"><span class="bound"><span class="entity">key</span></span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> return_spmf <span class="main">(</span><span class="free">prf</span> <span class="free"><span class="bound"><span class="entity">key</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span> <span class="main">()</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'domain'</span><span class="main">,</span> <span class="tfree">'range'</span><span class="main">)</span> adversary <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>bool<span class="main">,</span> <span class="tfree">'domain'</span><span class="main">,</span> <span class="tfree">'range'</span><span class="main">)</span> gpv"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">game_0</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'domain</span><span class="main">,</span> <span class="tfree">'range</span><span class="main">)</span> adversary <span class="main">⇒</span> bool spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">game_0</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
     <span class="bound">key</span> <span class="main">←</span> <span class="free">key_gen</span><span class="main">;</span>
     <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="main">(</span>prf_oracle <span class="bound">key</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">()</span><span class="main">;</span>
     return_spmf <span class="bound">b</span>
   <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">game_1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'domain</span><span class="main">,</span> <span class="tfree">'range</span><span class="main">)</span> adversary <span class="main">⇒</span> bool spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">game_1</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
     <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">←</span> exec_gpv random_oracle <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> Map.empty<span class="main">;</span>
     return_spmf <span class="bound">b</span>
   <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">advantage</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'domain</span><span class="main">,</span> <span class="tfree">'range</span><span class="main">)</span> adversary <span class="main">⇒</span> real"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">advantage</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> <span class="main">¦</span>spmf <span class="main">(</span>game_0 <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span><span class="main">)</span> True <span class="main">-</span> spmf <span class="main">(</span>game_1 <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span><span class="main">)</span> True<span class="main">¦</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> advantage_nonneg<span class="main">:</span> <span class="quoted"><span class="quoted">"advantage <span class="free">𝒜</span> <span class="main">≥</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> advantage_def<span class="main">)</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">lossless</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'domain</span><span class="main">,</span> <span class="tfree">'range</span><span class="main">)</span> adversary <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">lossless</span> <span class="main">≡</span> lossless_gpv ℐ_full"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">ibounded_by</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'domain</span><span class="main">,</span> <span class="tfree">'range</span><span class="main">)</span> adversary <span class="main">⇒</span> enat <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ibounded_by</span> <span class="main">≡</span> interaction_any_bounded_by"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Pseudo_Random_Permutation">
<div class="head">
<h1>Theory Pseudo_Random_Permutation</h1>
</div>
<pre class="source"><span class="comment1">(* Title: Pseudo_Random_Permutation.thy
  Author: Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Random permutation›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Pseudo_Random_Permutation <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../CryptHOL/Computational_Model.html">CryptHOL.Computational_Model</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">locale</span></span> random_permutation <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> set"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">random_permutation</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇀</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇀</span> <span class="tfree">'b</span><span class="main">)</span><span class="main">)</span> spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">random_permutation</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">of</span> Some <span class="bound">y</span> <span class="main">⇒</span> return_spmf <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">)</span>
   <span class="main">|</span> None <span class="main">⇒</span> spmf_of_set <span class="main">(</span><span class="free">A</span> <span class="main">-</span> ran <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">)</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> return_spmf <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">↦</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> weight_random_oracle <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> finite <span class="free">A</span><span class="main">;</span> <span class="free">A</span> <span class="main">-</span> ran <span class="free">σ</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟧</span> <span class="main">⟹</span> weight_spmf <span class="main">(</span>random_permutation <span class="free">σ</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> random_permutation_def weight_bind_spmf o_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_random_oracle <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> finite <span class="free">A</span><span class="main">;</span> <span class="free">A</span> <span class="main">-</span> ran <span class="free">σ</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟧</span> <span class="main">⟹</span> lossless_spmf <span class="main">(</span>random_permutation <span class="free">σ</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lossless_spmf_def<span class="main">)</span>

<span class="keyword1"><span class="command">sublocale</span></span> finite<span class="main">:</span> callee_invariant_on <span class="quoted">random_permutation</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> finite <span class="main">(</span>dom <span class="bound">σ</span><span class="main">)</span>"</span></span> <span class="quoted">ℐ_full</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> random_permutation_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> card_dom_random_oracle<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"interaction_any_bounded_by <span class="free">𝒜</span> <span class="free">q</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="free">σ'</span><span class="main">)</span> <span class="main">∈</span> set_spmf <span class="main">(</span>exec_gpv random_permutation <span class="free">𝒜</span> <span class="free">σ</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>dom <span class="free">σ</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>dom <span class="free">σ'</span><span class="main">)</span> <span class="main">≤</span> <span class="free">q</span> <span class="main">+</span> card <span class="main">(</span>dom <span class="free">σ</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> finite.interaction_bounded_by'_exec_gpv_count<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1-2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> random_permutation_def fin card_insert_if <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Guessing_Many_One">
<div class="head">
<h1>Theory Guessing_Many_One</h1>
</div>
<pre class="source"><span class="comment1">(* Title: Guessing_Many_One.thy
  Author: Andreas Lochbihler, ETH Zurich 
  Author: S. Reza Sefidgar, ETH Zurich *)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Reducing games with many adversary guesses to games with single guesses›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Guessing_Many_One <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../CryptHOL/Computational_Model.html">CryptHOL.Computational_Model</a>
  <a href="../CryptHOL/GPV_Bisim.html">CryptHOL.GPV_Bisim</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">locale</span></span> guessing_many_one <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">init</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c_o</span> <span class="main">×</span> <span class="tfree">'c_a</span> <span class="main">×</span> <span class="tfree">'s</span><span class="main">)</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">"<span class="free">oracle</span>"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c_o</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'call</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'ret</span> <span class="main">×</span> <span class="tfree">'s</span><span class="main">)</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">"<span class="free">eval</span>"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c_o</span> <span class="main">⇒</span> <span class="tfree">'c_a</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'guess</span> <span class="main">⇒</span> bool spmf"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'c_a'</span><span class="main">,</span> <span class="tfree">'guess'</span><span class="main">,</span> <span class="tfree">'call'</span><span class="main">,</span> <span class="tfree">'ret'</span><span class="main">)</span> adversary_single <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c_a'</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'guess'</span><span class="main">,</span> <span class="tfree">'call'</span><span class="main">,</span> <span class="tfree">'ret'</span><span class="main">)</span> gpv"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">game_single</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c_a</span><span class="main">,</span> <span class="tfree">'guess</span><span class="main">,</span> <span class="tfree">'call</span><span class="main">,</span> <span class="tfree">'ret</span><span class="main">)</span> adversary_single <span class="main">⇒</span> bool spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">game_single</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">c_o</span><span class="main">,</span> <span class="bound">c_a</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="main">←</span> <span class="free">init</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">guess</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="main">(</span><span class="free">oracle</span> <span class="bound">c_o</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="bound">c_a</span><span class="main">)</span> <span class="bound">s</span><span class="main">;</span>
    <span class="free">eval</span> <span class="bound">c_o</span> <span class="bound">c_a</span> <span class="bound">s'</span> <span class="bound">guess</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">advantage_single</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c_a</span><span class="main">,</span> <span class="tfree">'guess</span><span class="main">,</span> <span class="tfree">'call</span><span class="main">,</span> <span class="tfree">'ret</span><span class="main">)</span> adversary_single <span class="main">⇒</span> real"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">advantage_single</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> spmf <span class="main">(</span>game_single <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span><span class="main">)</span> True"</span></span>


<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'c_a'</span><span class="main">,</span> <span class="tfree">'guess'</span><span class="main">,</span> <span class="tfree">'call'</span><span class="main">,</span> <span class="tfree">'ret'</span><span class="main">)</span> adversary_many <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c_a'</span> <span class="main">⇒</span> <span class="main">(</span>unit<span class="main">,</span> <span class="tfree">'call'</span> <span class="main">+</span> <span class="tfree">'guess'</span><span class="main">,</span> <span class="tfree">'ret'</span> <span class="main">+</span> unit<span class="main">)</span> gpv"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">eval_oracle</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c_o</span> <span class="main">⇒</span> <span class="tfree">'c_a</span> <span class="main">⇒</span> bool <span class="main">×</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'guess</span> <span class="main">⇒</span> <span class="main">(</span>unit <span class="main">×</span> <span class="main">(</span>bool <span class="main">×</span> <span class="tfree">'s</span><span class="main">)</span><span class="main">)</span> spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">eval_oracle</span> <span class="free"><span class="bound"><span class="entity">c_o</span></span></span> <span class="free"><span class="bound"><span class="entity">c_a</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="bound">guess</span><span class="main">.</span> map_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">b'</span><span class="main">.</span> <span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="main">(</span><span class="bound">b</span> <span class="main">∨</span> <span class="bound">b'</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">eval</span> <span class="free"><span class="bound"><span class="entity">c_o</span></span></span> <span class="free"><span class="bound"><span class="entity">c_a</span></span></span> <span class="bound">s'</span> <span class="bound">guess</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">game_multi</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c_a</span><span class="main">,</span> <span class="tfree">'guess</span><span class="main">,</span> <span class="tfree">'call</span><span class="main">,</span> <span class="tfree">'ret</span><span class="main">)</span> adversary_many <span class="main">⇒</span> bool spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">game_multi</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
     <span class="main">(</span><span class="bound">c_o</span><span class="main">,</span> <span class="bound">c_a</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="main">←</span> <span class="free">init</span><span class="main">;</span>
     <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> exec_gpv
       <span class="main">(</span><span class="main">†</span><span class="main">(</span><span class="free">oracle</span> <span class="bound">c_o</span><span class="main">)</span> <span class="keyword1">⊕<span class="hidden">⇩</span><sub>O</sub></span> eval_oracle <span class="bound">c_o</span> <span class="bound">c_a</span><span class="main">)</span>
       <span class="main">(</span><span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="bound">c_a</span><span class="main">)</span>
       <span class="main">(</span>False<span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">;</span>
     return_spmf <span class="bound">b</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">advantage_multi</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c_a</span><span class="main">,</span> <span class="tfree">'guess</span><span class="main">,</span> <span class="tfree">'call</span><span class="main">,</span> <span class="tfree">'ret</span><span class="main">)</span> adversary_many <span class="main">⇒</span> real"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">advantage_multi</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> spmf <span class="main">(</span>game_multi <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span><span class="main">)</span> True"</span></span>


<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'guess'</span> reduction_state <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'guess'</span> <span class="main">+</span> nat"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">process_call</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'guess</span> reduction_state <span class="main">⇒</span> <span class="tfree">'call</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'ret</span> option <span class="main">×</span> <span class="tfree">'guess</span> reduction_state<span class="main">,</span> <span class="tfree">'call</span><span class="main">,</span> <span class="tfree">'ret</span><span class="main">)</span> gpv"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">process_call</span> <span class="main">(</span>Inr <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">ret</span> <span class="main">←</span> Pause <span class="free"><span class="bound"><span class="entity">x</span></span></span> Done<span class="main">;</span>
    Done <span class="main">(</span>Some <span class="bound">ret</span><span class="main">,</span> Inr <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">)</span>
  <span class="main">}</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">process_call</span> <span class="main">(</span>Inl <span class="free"><span class="bound"><span class="entity">guess</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> Done <span class="main">(</span>None<span class="main">,</span> Inl <span class="free"><span class="bound"><span class="entity">guess</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">process_guess</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'guess</span> reduction_state <span class="main">⇒</span> <span class="tfree">'guess</span> <span class="main">⇒</span> <span class="main">(</span>unit option <span class="main">×</span> <span class="tfree">'guess</span> reduction_state<span class="main">,</span> <span class="tfree">'call</span><span class="main">,</span> <span class="tfree">'ret</span><span class="main">)</span> gpv"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">process_guess</span> <span class="main">(</span>Inr <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">guess</span></span></span> <span class="main">=</span> Done <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">&gt;</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">(</span>Some <span class="main">()</span><span class="main">,</span> Inr <span class="main">(</span><span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span>None<span class="main">,</span> Inl <span class="free"><span class="bound"><span class="entity">guess</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">process_guess</span> <span class="main">(</span>Inl <span class="free"><span class="bound"><span class="entity">guess</span></span></span><span class="main">)</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> Done <span class="main">(</span>None<span class="main">,</span> Inl <span class="free"><span class="bound"><span class="entity">guess</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">reduction_oracle</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'guess</span> <span class="main">+</span> nat <span class="main">⇒</span> <span class="tfree">'call</span> <span class="main">+</span> <span class="tfree">'guess</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'ret</span> <span class="main">+</span> unit<span class="main">)</span> option <span class="main">×</span> <span class="main">(</span><span class="tfree">'guess</span> <span class="main">+</span> nat<span class="main">)</span><span class="main">,</span> <span class="tfree">'call</span><span class="main">,</span> <span class="tfree">'ret</span><span class="main">)</span> gpv"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">reduction_oracle</span> <span class="main">≡</span> plus_intercept_stop process_call process_guess"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">reduction</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c_a</span><span class="main">,</span> <span class="tfree">'guess</span><span class="main">,</span> <span class="tfree">'call</span><span class="main">,</span> <span class="tfree">'ret</span><span class="main">)</span> adversary_many <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c_a</span><span class="main">,</span> <span class="tfree">'guess</span><span class="main">,</span> <span class="tfree">'call</span><span class="main">,</span> <span class="tfree">'ret</span><span class="main">)</span> adversary_single"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">reduction</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">c_a</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">j_star</span> <span class="main">←</span> lift_spmf <span class="main">(</span>spmf_of_set <span class="main">{..&lt;</span><span class="free"><span class="bound"><span class="entity">q</span></span></span><span class="main">}</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="main">←</span> inline_stop reduction_oracle <span class="main">(</span><span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">c_a</span></span></span><span class="main">)</span> <span class="main">(</span>Inr <span class="bound">j_star</span><span class="main">)</span><span class="main">;</span>
    Done <span class="main">(</span>projl <span class="bound">s</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> many_single_reduction<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> bound<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">c_a</span> <span class="bound">c_o</span> <span class="bound">s</span><span class="main">.</span> <span class="main">(</span><span class="bound">c_o</span><span class="main">,</span> <span class="bound">c_a</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="main">∈</span> set_spmf <span class="free">init</span> <span class="main">⟹</span> interaction_bounded_by <span class="main">(</span>Not <span class="main">∘</span> isl<span class="main">)</span> <span class="main">(</span><span class="free">𝒜</span> <span class="bound">c_a</span><span class="main">)</span> <span class="free">q</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> lossless_oracle<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">c_a</span> <span class="bound">c_o</span> <span class="bound">s</span> <span class="bound">s'</span> <span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="bound">c_o</span><span class="main">,</span> <span class="bound">c_a</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="main">∈</span> set_spmf <span class="free">init</span> <span class="main">⟹</span> lossless_spmf <span class="main">(</span><span class="free">oracle</span> <span class="bound">c_o</span> <span class="bound">s'</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> lossless_eval<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">c_a</span> <span class="bound">c_o</span> <span class="bound">s</span> <span class="bound">s'</span> <span class="bound">guess</span><span class="main">.</span> <span class="main">(</span><span class="bound">c_o</span><span class="main">,</span> <span class="bound">c_a</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="main">∈</span> set_spmf <span class="free">init</span> <span class="main">⟹</span> lossless_spmf <span class="main">(</span><span class="free">eval</span> <span class="bound">c_o</span> <span class="bound">c_a</span> <span class="bound">s'</span> <span class="bound">guess</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"advantage_multi <span class="free">𝒜</span> <span class="main">≤</span> advantage_single <span class="main">(</span>reduction <span class="free">q</span> <span class="free">𝒜</span><span class="main">)</span> <span class="main">*</span> <span class="free">q</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> lifting_syntax
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">eval_oracle'</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">eval_oracle'</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c_o</span> <span class="bound">c_a</span> <span class="main">(</span><span class="main">(</span><span class="bound">id</span><span class="main">,</span> <span class="bound">occ</span> <span class="main">::</span> nat option<span class="main">)</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="bound">guess</span><span class="main">.</span> 
    map_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">b'</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">occ</span> <span class="keyword1">of</span> Some <span class="bound">j<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">⇒</span> <span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="main">(</span>Suc <span class="bound">id</span><span class="main">,</span> Some <span class="bound">j<span class="hidden">⇩</span><sub>0</sub></span><span class="main">)</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span>
                                <span class="main">|</span> None <span class="main">⇒</span> <span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="main">(</span>Suc <span class="bound">id</span><span class="main">,</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b'</span> <span class="keyword1">then</span> Some <span class="bound">id</span> <span class="keyword1">else</span> None<span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span><span class="main">)</span>
      <span class="main">(</span><span class="free">eval</span> <span class="bound">c_o</span> <span class="bound">c_a</span> <span class="bound">s'</span> <span class="bound">guess</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?multi'_body</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">c_o</span> <span class="bound">c_a</span> <span class="bound">s</span><span class="main">.</span> exec_gpv <span class="main">(</span><span class="main">†</span><span class="main">(</span><span class="free">oracle</span> <span class="bound">c_o</span><span class="main">)</span> <span class="keyword1">⊕<span class="hidden">⇩</span><sub>O</sub></span> <span class="skolem">eval_oracle'</span> <span class="bound">c_o</span> <span class="bound">c_a</span><span class="main">)</span> <span class="main">(</span><span class="free">𝒜</span> <span class="bound">c_a</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="main">0</span><span class="main">,</span> None<span class="main">)</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">game_multi'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">game_multi'</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c_o</span> <span class="bound">c_a</span> <span class="bound">s</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="main">(</span><span class="main">(</span><span class="bound">id</span><span class="main">,</span> <span class="bound">j<span class="hidden">⇩</span><sub>0</sub></span><span class="main">)</span><span class="main">,</span> <span class="bound">s'</span> <span class="main">::</span> <span class="tfree">'s</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> <span class="var">?multi'_body</span> <span class="bound">c_o</span> <span class="bound">c_a</span> <span class="bound">s</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">j<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">≠</span> None<span class="main">)</span> <span class="main">}</span><span class="main">)</span>"</span></span>

  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">initialize</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c_o</span> <span class="main">⇒</span> <span class="tfree">'c_a</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> nat <span class="main">⇒</span> bool spmf<span class="main">)</span> <span class="main">⇒</span> bool spmf"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="skolem">initialize</span> <span class="skolem">body</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="main">(</span><span class="bound">c_o</span><span class="main">,</span> <span class="bound">c_a</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="main">←</span> <span class="free">init</span><span class="main">;</span>
      <span class="bound">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">←</span> spmf_of_set <span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span><span class="main">;</span>
      <span class="skolem">body</span> <span class="bound">c_o</span> <span class="bound">c_a</span> <span class="bound">s</span> <span class="bound">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">body</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">body2</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">body2</span> <span class="skolem">c_o</span> <span class="skolem">c_a</span> <span class="skolem">s</span> <span class="skolem">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="main">(</span><span class="bound">id</span><span class="main">,</span> <span class="bound">j<span class="hidden">⇩</span><sub>0</sub></span><span class="main">)</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">←</span> <span class="var">?multi'_body</span> <span class="skolem">c_o</span> <span class="skolem">c_a</span> <span class="skolem">s</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">j<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">=</span> Some <span class="skolem">j<span class="hidden">⇩</span><sub>s</sub></span><span class="main">)</span> <span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">c_o</span> <span class="skolem">c_a</span> <span class="skolem">s</span> <span class="skolem">j<span class="hidden">⇩</span><sub>s</sub></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?game2</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="skolem">initialize</span> <span class="skolem">body2</span>"</span></span>

  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">stop_oracle</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">stop_oracle</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c_o</span><span class="main">.</span> 
     <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">idgs</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">idgs</span> <span class="keyword1">of</span> Inr <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> map_spmf <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span>Some <span class="bound">y</span><span class="main">,</span> <span class="main">(</span><span class="bound">idgs</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">oracle</span> <span class="bound">c_o</span> <span class="bound">s</span> <span class="bound">x</span><span class="main">)</span> <span class="main">|</span> Inl <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> return_spmf <span class="main">(</span>None<span class="main">,</span> <span class="main">(</span><span class="bound">idgs</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
     <span class="keyword1">⊕<span class="hidden">⇩</span><sub>O</sub><span class="hidden">⇧</span><sup>S</sup></span>
     <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">idgs</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="bound">guess</span> <span class="main">::</span> <span class="tfree">'guess</span><span class="main">.</span> return_spmf <span class="main">(</span><span class="keyword1">case</span> <span class="bound">idgs</span> <span class="keyword1">of</span> Inr <span class="main">0</span> <span class="main">⇒</span> <span class="main">(</span>None<span class="main">,</span> Inl <span class="main">(</span><span class="bound">guess</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="main">|</span> Inr <span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span>Some <span class="main">()</span><span class="main">,</span> Inr <span class="bound">i</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="main">|</span> Inl <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">(</span>None<span class="main">,</span> <span class="bound">idgs</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">body3</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">body3</span> <span class="skolem">c_o</span> <span class="skolem">c_a</span> <span class="skolem">s</span> <span class="skolem">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit option<span class="main">,</span> <span class="bound">idgs</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">←</span> exec_gpv_stop <span class="main">(</span><span class="skolem">stop_oracle</span> <span class="skolem">c_o</span><span class="main">)</span> <span class="main">(</span><span class="free">𝒜</span> <span class="skolem">c_a</span><span class="main">)</span> <span class="main">(</span>Inr <span class="skolem">j<span class="hidden">⇩</span><sub>s</sub></span><span class="main">,</span> <span class="skolem">s</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">b'</span> <span class="main">::</span> bool<span class="main">)</span> <span class="main">←</span> <span class="keyword1">case</span> <span class="bound">idgs</span> <span class="keyword1">of</span> Inr <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> return_spmf False <span class="main">|</span> Inl <span class="main">(</span><span class="bound">g</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">⇒</span> <span class="free">eval</span> <span class="skolem">c_o</span> <span class="skolem">c_a</span> <span class="bound">s'</span> <span class="bound">g</span><span class="main">;</span>
    return_spmf <span class="bound">b'</span> <span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">c_o</span> <span class="skolem">c_a</span> <span class="skolem">s</span> <span class="skolem">j<span class="hidden">⇩</span><sub>s</sub></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?game3</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="skolem">initialize</span> <span class="skolem">body3</span>"</span></span>

  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">S</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"bool <span class="main">⇒</span> nat <span class="main">×</span> nat option <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">S</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">b'</span> <span class="main">(</span><span class="bound">id</span><span class="main">,</span> <span class="bound">occ</span><span class="main">)</span><span class="main">.</span> <span class="bound">b'</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">j<span class="hidden">⇩</span><sub>0</sub></span><span class="main">.</span> <span class="bound">occ</span> <span class="main">=</span> Some <span class="bound">j<span class="hidden">⇩</span><sub>0</sub></span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?S</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"rel_prod <span class="skolem">S</span> <span class="main">(=)</span>"</span></span>

    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">initial</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">×</span> nat option"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">initial</span> <span class="main">=</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span> None<span class="main">)</span>"</span></span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">result</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">×</span> nat option <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">result</span> <span class="skolem">p</span> <span class="main">=</span> <span class="main">(</span>snd <span class="skolem">p</span> <span class="main">≠</span> None<span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">S</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">b</span><span class="main">.</span> <span class="bound">b</span><span class="main">)</span> <span class="skolem">result</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def result_def S_def<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">S</span> False <span class="skolem">initial</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> S_def initial_def<span class="main">)</span>

    <span class="keyword1"><span class="command">have</span></span> eval_oracle'<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> <span class="var">?S</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> rel_spmf <span class="main">(</span>rel_prod <span class="main">(=)</span> <span class="var">?S</span><span class="main">)</span><span class="main">)</span>
       eval_oracle <span class="skolem">eval_oracle'</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> eval_oracle_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> eval_oracle'_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def S_def map_spmf_conv_bind_spmf <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_bind_reflI <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
    
    <span class="keyword1"><span class="command">have</span></span> game_multi'<span class="main">:</span> <span class="quoted"><span class="quoted">"game_multi <span class="free">𝒜</span> <span class="main">=</span> bind_spmf <span class="free">init</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">c_o</span><span class="main">,</span> <span class="bound">c_a</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">.</span> <span class="skolem">game_multi'</span> <span class="bound">c_o</span> <span class="bound">c_a</span> <span class="bound">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> game_multi_def game_multi'_def initial_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rewrite</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"case_prod <span class="main"><span class="main"><span class="main">⌑</span></span></span>"</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"bind_spmf <span class="main"><span class="main"><span class="main">_</span></span></span> <span class="main"><span class="main"><span class="main">(</span></span></span>case_prod <span class="main"><span class="main"><span class="main">⌑</span></span></span><span class="main"><span class="main"><span class="main">)</span></span></span>"</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">_</span></span></span> <span class="main"><span class="main"><span class="main">=</span></span></span> bind_spmf <span class="main"><span class="main"><span class="main">_</span></span></span> <span class="main"><span class="main"><span class="main">⌑</span></span></span>"</span></span></span></span> split_def<span class="main">)</span>
         <span class="main">(</span><span class="operator">fold</span> result_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer_prover</span><span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span><span class="skolem">game_multi'</span> <span class="skolem">c_o</span> <span class="skolem">c_a</span> <span class="skolem">s</span><span class="main">)</span> True <span class="main">=</span> spmf <span class="main">(</span>bind_spmf <span class="main">(</span>spmf_of_set <span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="skolem">body2</span> <span class="skolem">c_o</span> <span class="skolem">c_a</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> True <span class="main">*</span> <span class="free">q</span>"</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">c_o</span><span class="main">,</span> <span class="skolem">c_a</span><span class="main">,</span> <span class="skolem">s</span><span class="main">)</span> <span class="main">∈</span> set_spmf <span class="free">init</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">c_o</span> <span class="skolem">c_a</span> <span class="skolem">s</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> bnd<span class="main">:</span> <span class="quoted"><span class="quoted">"interaction_bounded_by <span class="main">(</span>Not <span class="main">∘</span> isl<span class="main">)</span> <span class="main">(</span><span class="free">𝒜</span> <span class="skolem">c_a</span><span class="main">)</span> <span class="free">q</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> bound that <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

    <span class="keyword1"><span class="command">have</span></span> bound_occ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">&lt;</span> <span class="free">q</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> that<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="main">(</span><span class="skolem">id</span><span class="main">,</span> Some <span class="skolem">j<span class="hidden">⇩</span><sub>s</sub></span><span class="main">)</span><span class="main">,</span> <span class="skolem">s'</span><span class="main">)</span> <span class="main">∈</span> set_spmf <span class="main">(</span><span class="var">?multi'_body</span> <span class="skolem">c_o</span> <span class="skolem">c_a</span> <span class="skolem">s</span><span class="main">)</span>"</span></span> 
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s'</span> <span class="skolem">id</span> <span class="skolem">j<span class="hidden">⇩</span><sub>s</sub></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">id</span> <span class="main">≤</span> <span class="free">q</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> oi_True.interaction_bounded_by'_exec_gpv_count<span class="main"><span class="main">[</span></span><span class="operator">OF</span> bnd that<span class="main"><span class="main">,</span></span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> count<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"fst <span class="main">∘</span> fst"</span></span><span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
          <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eval_oracle'_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> plus_oracle_split_asm option.split_asm<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?I</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">id</span><span class="main">,</span> <span class="bound">occ</span><span class="main">)</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">occ</span> <span class="keyword1">of</span> None <span class="main">⇒</span> True <span class="main">|</span> Some <span class="bound">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">⇒</span> <span class="bound">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">&lt;</span> <span class="bound">id</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"callee_invariant <span class="main">(</span><span class="main">†</span><span class="main">(</span><span class="free">oracle</span> <span class="skolem">c_o</span><span class="main">)</span> <span class="keyword1">⊕<span class="hidden">⇩</span><sub>O</sub></span> <span class="skolem">eval_oracle'</span> <span class="skolem">c_o</span> <span class="skolem">c_a</span><span class="main">)</span> <span class="var">?I</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> conjI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> callee_invariant_extend_state_oracle_const'<span class="main"><span class="main">]</span></span><span class="main">)</span>
          <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eval_oracle'_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> callee_invariant_on.exec_gpv_invariant<span class="main">[</span><span class="operator">OF</span> this that<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">&lt;</span> <span class="skolem">id</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>

    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?M</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"measure <span class="main">(</span>measure_spmf <span class="main">(</span><span class="var">?multi'_body</span> <span class="skolem">c_o</span> <span class="skolem">c_a</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span><span class="skolem">game_multi'</span> <span class="skolem">c_o</span> <span class="skolem">c_a</span> <span class="skolem">s</span><span class="main">)</span> True <span class="main">=</span> <span class="var">?M</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="main">(</span><span class="bound">id</span><span class="main">,</span> <span class="bound">j<span class="hidden">⇩</span><sub>0</sub></span><span class="main">)</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span><span class="main">.</span> <span class="bound">j<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">≠</span> None<span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> game_multi'_def map_spmf_conv_bind_spmf<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> split_def spmf_conv_measure_spmf measure_map_spmf vimage_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="main">(</span><span class="bound">id</span><span class="main">,</span> <span class="bound">j<span class="hidden">⇩</span><sub>0</sub></span><span class="main">)</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span><span class="main">.</span> <span class="bound">j<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">≠</span> None<span class="main">}</span> <span class="main">=</span>
      <span class="main">{</span><span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="main">(</span><span class="bound">id</span><span class="main">,</span> Some <span class="bound">j<span class="hidden">⇩</span><sub>s</sub></span><span class="main">)</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">|</span><span class="bound">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="bound">s'</span> <span class="bound">id</span><span class="main">.</span> <span class="bound">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">&lt;</span> <span class="free">q</span><span class="main">}</span> <span class="main">∪</span> <span class="main">{</span><span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="main">(</span><span class="bound">id</span><span class="main">,</span> Some <span class="bound">j<span class="hidden">⇩</span><sub>s</sub></span><span class="main">)</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">|</span><span class="bound">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="bound">s'</span> <span class="bound">id</span><span class="main">.</span> <span class="bound">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">≥</span> <span class="free">q</span><span class="main">}</span>"</span></span>
      <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> <span class="var">?A</span> <span class="main">∪</span> <span class="main">_</span>"</span></span><span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?M</span> <span class="main">…</span> <span class="main">=</span> <span class="var">?M</span> <span class="var">?A</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> measure_spmf.measure_zero_union<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> measure_spmf_zero_iff <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> bound_occ<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> measure <span class="main">(</span>measure_spmf <span class="main">(</span>pair_spmf <span class="main">(</span>spmf_of_set <span class="main">{..&lt;</span> <span class="free">q</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="var">?multi'_body</span> <span class="skolem">c_o</span> <span class="skolem">c_a</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
         <span class="main">{</span><span class="main">(</span><span class="bound">j<span class="hidden">⇩</span><sub>s</sub></span><span class="main">,</span> <span class="main">()</span><span class="main">,</span> <span class="main">(</span><span class="bound">id</span><span class="main">,</span> <span class="bound">j<span class="hidden">⇩</span><sub>0</sub></span><span class="main">)</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">|</span><span class="bound">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="bound">j<span class="hidden">⇩</span><sub>0</sub></span> <span class="bound">s'</span> <span class="bound">id</span><span class="main">.</span> <span class="bound">j<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">=</span> Some <span class="bound">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">}</span> <span class="main">*</span> <span class="free">q</span>"</span></span>
      <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> measure <span class="var">?M'</span> <span class="var">?B</span> <span class="main">*</span> <span class="main">_</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span> 
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?B</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">j<span class="hidden">⇩</span><sub>s</sub></span><span class="main">,</span> <span class="main">()</span><span class="main">,</span> <span class="main">(</span><span class="bound">id</span><span class="main">,</span> <span class="bound">j<span class="hidden">⇩</span><sub>0</sub></span><span class="main">)</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">|</span><span class="bound">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="bound">j<span class="hidden">⇩</span><sub>0</sub></span> <span class="bound">s'</span> <span class="bound">id</span><span class="main">.</span> <span class="bound">j<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">=</span> Some <span class="bound">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">∧</span> <span class="bound">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">&lt;</span> <span class="free">q</span><span class="main">}</span> <span class="main">∪</span>
        <span class="main">{</span><span class="main">(</span><span class="bound">j<span class="hidden">⇩</span><sub>s</sub></span><span class="main">,</span> <span class="main">()</span><span class="main">,</span> <span class="main">(</span><span class="bound">id</span><span class="main">,</span> <span class="bound">j<span class="hidden">⇩</span><sub>0</sub></span><span class="main">)</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">|</span><span class="bound">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="bound">j<span class="hidden">⇩</span><sub>0</sub></span> <span class="bound">s'</span> <span class="bound">id</span><span class="main">.</span> <span class="bound">j<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">=</span> Some <span class="bound">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">∧</span> <span class="bound">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">≥</span> <span class="free">q</span><span class="main">}</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> <span class="var">?Set1</span> <span class="main">∪</span> <span class="var">?Set2</span>"</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"measure <span class="var">?M'</span> <span class="var">?B</span> <span class="main">=</span> measure <span class="var">?M'</span> <span class="main">(</span><span class="var">?Set1</span> <span class="main">∪</span> <span class="var">?Set2</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> measure <span class="var">?M'</span> <span class="var">?Set1</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> measure_spmf.measure_zero_union<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> measure_spmf_zero_iff<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">j</span><span class="main">∈</span><span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">q</span><span class="main">}</span><span class="main">.</span> measure <span class="var">?M'</span> <span class="main">(</span><span class="main">{</span><span class="bound">j</span><span class="main">}</span> <span class="main">×</span> <span class="main">{</span><span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="main">(</span><span class="bound">id</span><span class="main">,</span> Some <span class="bound">j</span><span class="main">)</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span><span class="main">|</span><span class="bound">s'</span> <span class="bound">id</span><span class="main">.</span> True<span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> measure_spmf.finite_measure_finite_Union<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
          <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> arg_cong2<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">measure</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> disjoint_family_on_def<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">j</span><span class="main">∈</span><span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">q</span><span class="main">}</span><span class="main">.</span> <span class="main">1</span> <span class="main">/</span> <span class="free">q</span> <span class="main">*</span> measure <span class="main">(</span>measure_spmf <span class="main">(</span><span class="var">?multi'_body</span> <span class="skolem">c_o</span> <span class="skolem">c_a</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="main">(</span><span class="bound">id</span><span class="main">,</span> Some <span class="bound">j</span><span class="main">)</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span><span class="main">|</span><span class="bound">s'</span> <span class="bound">id</span><span class="main">.</span> True<span class="main">}</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> measure_pair_spmf_times spmf_conv_measure_spmf<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> spmf_of_set<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">1</span> <span class="main">/</span> <span class="free">q</span> <span class="main">*</span> measure <span class="main">(</span>measure_spmf <span class="main">(</span><span class="var">?multi'_body</span> <span class="skolem">c_o</span> <span class="skolem">c_a</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="main">(</span><span class="bound">id</span><span class="main">,</span> Some <span class="bound">j<span class="hidden">⇩</span><sub>s</sub></span><span class="main">)</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span><span class="main">|</span><span class="bound">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="bound">s'</span> <span class="bound">id</span><span class="main">.</span> <span class="bound">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">&lt;</span> <span class="free">q</span><span class="main">}</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> sum_distrib_left<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> measure_spmf.finite_measure_finite_Union<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
          <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> arg_cong2<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">measure</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> disjoint_family_on_def<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?B</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">j<span class="hidden">⇩</span><sub>s</sub></span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">j<span class="hidden">⇩</span><sub>0</sub></span><span class="main">)</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="bound">j<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">=</span> Some <span class="bound">j<span class="hidden">⇩</span><sub>s</sub></span><span class="main">)</span> <span class="main">-`</span> <span class="main">{</span>True<span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> vimage_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> rw2<span class="main">:</span> <span class="quoted"><span class="quoted">"measure <span class="var">?M'</span> <span class="main">…</span> <span class="main">=</span> spmf <span class="main">(</span>bind_spmf <span class="main">(</span>spmf_of_set <span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="skolem">body2</span> <span class="skolem">c_o</span> <span class="skolem">c_a</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> True"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> body2_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> measure_map_spmf<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> map_spmf_conv_bind_spmf
        split_def pair_spmf_alt_def spmf_conv_measure_spmf<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>bind_spmf <span class="free">init</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">c_a</span><span class="main">,</span> <span class="bound">c_o</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">.</span> <span class="skolem">game_multi'</span> <span class="bound">c_a</span> <span class="bound">c_o</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> True <span class="main">=</span> spmf <span class="var">?game2</span> True <span class="main">*</span> <span class="free">q</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> initialize_def spmf_bind<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> p<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">init</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> integral_cong_AE <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> integral_mult_left_zero <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> integral_mult_left_zero<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ord_spmf <span class="main">(⟶)</span> <span class="main">(</span><span class="skolem">body2</span> <span class="skolem">c_o</span> <span class="skolem">c_a</span> <span class="skolem">s</span> <span class="skolem">j<span class="hidden">⇩</span><sub>s</sub></span><span class="main">)</span> <span class="main">(</span><span class="skolem">body3</span> <span class="skolem">c_o</span> <span class="skolem">c_a</span> <span class="skolem">s</span> <span class="skolem">j<span class="hidden">⇩</span><sub>s</sub></span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> init<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">c_o</span><span class="main">,</span> <span class="skolem">c_a</span><span class="main">,</span> <span class="skolem">s</span><span class="main">)</span> <span class="main">∈</span> set_spmf <span class="free">init</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> j<span class="hidden">⇩</span><sub>s</sub><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">&lt;</span> Suc <span class="free">q</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">c_o</span> <span class="skolem">c_a</span> <span class="skolem">s</span> <span class="skolem">j<span class="hidden">⇩</span><sub>s</sub></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">oracle2'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">oracle2'</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="main">(</span><span class="bound">id</span><span class="main">,</span> <span class="bound">gs</span><span class="main">)</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="bound">guess</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">id</span> <span class="main">=</span> <span class="skolem">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">b'</span> <span class="main">::</span> bool <span class="main">←</span> <span class="free">eval</span> <span class="skolem">c_o</span> <span class="skolem">c_a</span> <span class="bound">s</span> <span class="bound">guess</span><span class="main">;</span>
        return_spmf <span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="main">(</span>Some <span class="bound">b'</span><span class="main">,</span> <span class="main">(</span>Suc <span class="bound">id</span><span class="main">,</span> Some <span class="main">(</span><span class="bound">guess</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>
      <span class="main">}</span> <span class="keyword1">else</span> return_spmf <span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="main">(</span>Suc <span class="bound">id</span><span class="main">,</span> <span class="bound">gs</span><span class="main">)</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>

    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?R</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">id1</span><span class="main">,</span> <span class="bound">j<span class="hidden">⇩</span><sub>0</sub></span><span class="main">)</span><span class="main">,</span> <span class="bound">s1</span><span class="main">)</span> <span class="main">(</span><span class="bound">b'</span><span class="main">,</span> <span class="main">(</span><span class="bound">id2</span><span class="main">,</span> <span class="bound">gs</span><span class="main">)</span><span class="main">,</span> <span class="bound">s2</span><span class="main">)</span><span class="main">.</span> <span class="bound">s1</span> <span class="main">=</span> <span class="bound">s2</span> <span class="main">∧</span> <span class="bound">id1</span> <span class="main">=</span> <span class="bound">id2</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">j<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">=</span> Some <span class="skolem">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">⟶</span> <span class="bound">b'</span> <span class="main">=</span> Some True<span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">id2</span> <span class="main">≤</span> <span class="skolem">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">⟶</span> <span class="bound">b'</span> <span class="main">=</span> None<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> init <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"rel_spmf <span class="main">(</span>rel_prod <span class="main">(=)</span> <span class="var">?R</span><span class="main">)</span>
      <span class="main">(</span>exec_gpv <span class="main">(</span>extend_state_oracle <span class="main">(</span><span class="free">oracle</span> <span class="skolem">c_o</span><span class="main">)</span> <span class="keyword1">⊕<span class="hidden">⇩</span><sub>O</sub></span> <span class="skolem">eval_oracle'</span> <span class="skolem">c_o</span> <span class="skolem">c_a</span><span class="main">)</span> <span class="main">(</span><span class="free">𝒜</span> <span class="skolem">c_a</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="main">0</span><span class="main">,</span> None<span class="main">)</span><span class="main">,</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span>
      <span class="main">(</span>exec_gpv <span class="main">(</span>extend_state_oracle <span class="main">(</span>extend_state_oracle <span class="main">(</span><span class="free">oracle</span> <span class="skolem">c_o</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">⊕<span class="hidden">⇩</span><sub>O</sub></span> <span class="skolem">oracle2'</span><span class="main">)</span> <span class="main">(</span><span class="free">𝒜</span> <span class="skolem">c_a</span><span class="main">)</span> <span class="main">(</span>None<span class="main">,</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span> None<span class="main">)</span><span class="main">,</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> exec_gpv_oracle_bisim<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> X<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="var">?R</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle2'_def eval_oracle'_def spmf_rel_map map_spmf_conv_bind_spmf<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> rel_spmf_return_spmf2 lossless_eval o_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_reflI <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm plus_oracle_split if_split_asm<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"rel_spmf <span class="main">(⟶)</span> <span class="main">(</span><span class="skolem">body2</span> <span class="skolem">c_o</span> <span class="skolem">c_a</span> <span class="skolem">s</span> <span class="skolem">j<span class="hidden">⇩</span><sub>s</sub></span><span class="main">)</span> 
      <span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span>
        <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">b'</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="main">(</span><span class="main">†</span><span class="main">†</span><span class="main">(</span><span class="free">oracle</span> <span class="skolem">c_o</span><span class="main">)</span> <span class="keyword1">⊕<span class="hidden">⇩</span><sub>O</sub></span> <span class="skolem">oracle2'</span><span class="main">)</span> <span class="main">(</span><span class="free">𝒜</span> <span class="skolem">c_a</span><span class="main">)</span> <span class="main">(</span>None<span class="main">,</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span> None<span class="main">)</span><span class="main">,</span> <span class="skolem">s</span><span class="main">)</span><span class="main">;</span>
        return_spmf <span class="main">(</span><span class="bound">b'</span> <span class="main">=</span> Some True<span class="main">)</span> <span class="main">}</span><span class="main">)</span>"</span></span>
      <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"rel_spmf <span class="main">_</span> <span class="main">_</span> <span class="var">?body2'</span>"</span></span><span class="main">)</span>
      <span class="comment1">― ‹We do not get equality here because the right hand side may return <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> True<span class="antiquote">}</span></span> even
        when the bad event has happened before the <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">j<span class="hidden">⇩</span><sub>s</sub></span><span class="antiquote">}</span></span>-th iteration.›</span>
      <span class="keyword1"><span class="command">unfolding</span></span> body2_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> rel_spmf_bindI<span class="main">)</span> <span class="operator">clarsimp</span>
    <span class="keyword1"><span class="command">also</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?guess_oracle</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">id</span><span class="main">,</span> <span class="bound">gs</span><span class="main">)</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="bound">guess</span><span class="main">.</span> return_spmf <span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="main">(</span>Suc <span class="bound">id</span><span class="main">,</span> <span class="keyword1">if</span> <span class="bound">id</span> <span class="main">=</span> <span class="skolem">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="keyword1">then</span> Some <span class="main">(</span><span class="bound">guess</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="keyword1">else</span> <span class="bound">gs</span><span class="main">)</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?I</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">idgs</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">idgs</span> <span class="keyword1">of</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> None<span class="main">)</span> <span class="main">⇒</span> False <span class="main">|</span> <span class="main">(</span><span class="bound">i</span><span class="main">,</span> Some <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">⇒</span> <span class="skolem">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">&lt;</span> <span class="bound">i</span>"</span></span>
    <span class="keyword1"><span class="command">interpret</span></span> I<span class="main">:</span> callee_invariant_on <span class="quoted"><span class="quoted">"<span class="main">†</span><span class="main">(</span><span class="free">oracle</span> <span class="skolem">c_o</span><span class="main">)</span> <span class="keyword1">⊕<span class="hidden">⇩</span><sub>O</sub></span> <span class="var">?guess_oracle</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="var">?I</span>"</span></span> <span class="quoted">ℐ_full</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?f</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="keyword1">case</span> snd <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> return_spmf False <span class="main">|</span> Some <span class="bound">a</span> <span class="main">⇒</span> <span class="free">eval</span> <span class="skolem">c_o</span> <span class="skolem">c_a</span> <span class="main">(</span>snd <span class="bound">a</span><span class="main">)</span> <span class="main">(</span>fst <span class="bound">a</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?X</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">(</span><span class="bound">b1</span><span class="main">,</span> <span class="main">(</span><span class="bound">id1</span><span class="main">,</span> <span class="bound">gs1</span><span class="main">)</span><span class="main">,</span> <span class="bound">s1</span><span class="main">)</span> <span class="main">(</span><span class="bound">b2</span><span class="main">,</span> <span class="main">(</span><span class="bound">id2</span><span class="main">,</span> <span class="bound">gs2</span><span class="main">)</span><span class="main">,</span> <span class="bound">s2</span><span class="main">)</span><span class="main">.</span> <span class="bound">b1</span> <span class="main">=</span> <span class="bound">b2</span> <span class="main">∧</span> <span class="bound">id1</span> <span class="main">=</span> <span class="bound">id2</span> <span class="main">∧</span> <span class="bound">gs1</span> <span class="main">=</span> <span class="bound">gs2</span> <span class="main">∧</span> <span class="bound">s1</span> <span class="main">=</span> <span class="bound">s2</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">b2</span> <span class="main">=</span> None <span class="main">⟷</span> <span class="bound">gs2</span> <span class="main">=</span> None<span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">id2</span> <span class="main">≤</span> <span class="bound">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">⟶</span> <span class="bound">b2</span> <span class="main">=</span> None<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?body2'</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">r</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
               <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">←</span> <span class="main">(</span><span class="main">†</span><span class="main">(</span><span class="free">oracle</span> <span class="skolem">c_o</span><span class="main">)</span> <span class="keyword1">⊕<span class="hidden">⇩</span><sub>O</sub></span> <span class="var">?guess_oracle</span><span class="main">)</span> <span class="bound">s</span> <span class="bound">x</span><span class="main">;</span>
               <span class="keyword1">if</span> <span class="var">?I</span> <span class="bound">s'</span> <span class="main">∧</span> <span class="bound">r</span> <span class="main">=</span> None <span class="keyword1">then</span> map_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> Some <span class="bound">r</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="var">?f</span> <span class="bound">s'</span><span class="main">)</span> <span class="keyword1">else</span> return_spmf <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">r</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span>
             <span class="main">}</span><span class="main">)</span>
         <span class="main">(</span><span class="free">𝒜</span> <span class="skolem">c_a</span><span class="main">)</span> <span class="main">(</span>None<span class="main">,</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span> None<span class="main">)</span><span class="main">,</span> <span class="skolem">s</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">case</span> <span class="bound">r</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="var">?f</span> <span class="bound">s</span> <span class="main">⤜</span> return_spmf <span class="main">|</span> Some <span class="bound">r'</span> <span class="main">⇒</span> return_spmf <span class="bound">r'</span> <span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> oracle2'_def spmf_rel_eq<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> rel_spmf_bindI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> exec_gpv_oracle_bisim'<span class="main"><span class="main"><span class="main">[</span></span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> X<span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span><span class="quoted"><span class="quoted">"<span class="var">?X</span> <span class="skolem">j<span class="hidden">⇩</span><sub>s</sub></span>"</span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_map_spmf o_def spmf.map_comp split_beta conj_comms map_spmf_conv_bind_spmf<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> spmf_rel_map rel_spmf_reflI <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> conj_cong <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> plus_oracle_split<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">us'</span> <span class="main">←</span> exec_gpv <span class="main">(</span><span class="main">†</span><span class="main">(</span><span class="free">oracle</span> <span class="skolem">c_o</span><span class="main">)</span> <span class="keyword1">⊕<span class="hidden">⇩</span><sub>O</sub></span> <span class="var">?guess_oracle</span><span class="main">)</span> <span class="main">(</span><span class="free">𝒜</span> <span class="skolem">c_a</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="main">0</span><span class="main">,</span> None<span class="main">)</span><span class="main">,</span> <span class="skolem">s</span><span class="main">)</span><span class="main">;</span>
        <span class="main">(</span><span class="bound">b'</span> <span class="main">::</span> bool<span class="main">)</span> <span class="main">←</span> <span class="var">?f</span> <span class="main">(</span>snd <span class="bound">us'</span><span class="main">)</span><span class="main">;</span>
        return_spmf <span class="bound">b'</span> <span class="main">}</span>"</span></span>
      <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> <span class="var">?body2''</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> I.exec_gpv_bind_materialize<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> plus_oracle_split_asm option.split_asm<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">us'</span> <span class="main">←</span> exec_gpv_stop <span class="main">(</span>lift_stop_oracle <span class="main">(</span><span class="main">†</span><span class="main">(</span><span class="free">oracle</span> <span class="skolem">c_o</span><span class="main">)</span> <span class="keyword1">⊕<span class="hidden">⇩</span><sub>O</sub></span> <span class="var">?guess_oracle</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">𝒜</span> <span class="skolem">c_a</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="main">0</span><span class="main">,</span> None<span class="main">)</span><span class="main">,</span> <span class="skolem">s</span><span class="main">)</span><span class="main">;</span>
        <span class="main">(</span><span class="bound">b'</span> <span class="main">::</span> bool<span class="main">)</span> <span class="main">←</span> <span class="var">?f</span> <span class="main">(</span>snd <span class="bound">us'</span><span class="main">)</span><span class="main">;</span>
        return_spmf <span class="bound">b'</span> <span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span> lift_stop_oracle_transfer<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span> gpv_stop_transfer<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span> exec_gpv_parametric'<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?S</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">id1</span><span class="main">,</span> <span class="bound">gs1</span><span class="main">)</span><span class="main">,</span> <span class="bound">s1</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="bound">id2</span><span class="main">,</span> <span class="bound">gs2</span><span class="main">)</span><span class="main">,</span> <span class="bound">s2</span><span class="main">)</span><span class="main">.</span> <span class="bound">gs1</span> <span class="main">=</span> <span class="bound">gs2</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">gs2</span> <span class="main">=</span> None <span class="main">⟶</span> <span class="bound">s1</span> <span class="main">=</span> <span class="bound">s2</span> <span class="main">∧</span> <span class="bound">id1</span> <span class="main">=</span> <span class="bound">id2</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">gs1</span> <span class="main">=</span> None <span class="main">⟷</span> <span class="bound">id1</span> <span class="main">≤</span> <span class="skolem">j<span class="hidden">⇩</span><sub>s</sub></span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ord_spmf <span class="main">(⟶)</span> <span class="main">…</span> <span class="main">(</span>exec_gpv_stop <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">id</span><span class="main">,</span> <span class="bound">gs</span><span class="main">)</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">gs</span> <span class="keyword1">of</span> None <span class="main">⇒</span> lift_stop_oracle <span class="main">(</span><span class="main">†</span><span class="main">(</span><span class="free">oracle</span> <span class="skolem">c_o</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="bound">id</span><span class="main">,</span> <span class="bound">gs</span><span class="main">)</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="bound">x</span> <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> return_spmf <span class="main">(</span>None<span class="main">,</span> <span class="main">(</span><span class="main">(</span><span class="bound">id</span><span class="main">,</span> <span class="bound">gs</span><span class="main">)</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">⊕<span class="hidden">⇩</span><sub>O</sub><span class="hidden">⇧</span><sup>S</sup></span>
            <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">id</span><span class="main">,</span> <span class="bound">gs</span><span class="main">)</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="bound">guess</span><span class="main">.</span> return_spmf <span class="main">(</span><span class="keyword1">if</span> <span class="bound">id</span> <span class="main">≥</span> <span class="skolem">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="keyword1">then</span> None <span class="keyword1">else</span> Some <span class="main">()</span><span class="main">,</span> <span class="main">(</span>Suc <span class="bound">id</span><span class="main">,</span> <span class="keyword1">if</span> <span class="bound">id</span> <span class="main">=</span> <span class="skolem">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="keyword1">then</span> Some <span class="main">(</span><span class="bound">guess</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="keyword1">else</span> <span class="bound">gs</span><span class="main">)</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
           <span class="main">(</span><span class="free">𝒜</span> <span class="skolem">c_a</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="main">0</span><span class="main">,</span> None<span class="main">)</span><span class="main">,</span> <span class="skolem">s</span><span class="main">)</span> <span class="main">⤜</span>
          <span class="main">(</span><span class="main">λ</span><span class="bound">us'</span><span class="main">.</span> <span class="keyword1">case</span> snd <span class="main">(</span>fst <span class="main">(</span>snd <span class="bound">us'</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> return_spmf False <span class="main">|</span> Some <span class="bound">a</span> <span class="main">⇒</span> <span class="free">eval</span> <span class="skolem">c_o</span> <span class="skolem">c_a</span> <span class="main">(</span>snd <span class="bound">a</span><span class="main">)</span> <span class="main">(</span>fst <span class="bound">a</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> body3_def stop_oracle_def
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> ord_spmf_exec_gpv_stop<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> stop <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">id</span><span class="main">,</span> <span class="bound">guess</span><span class="main">)</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="bound">guess</span> <span class="main">≠</span> None"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> S<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="var">?S</span>"</span></span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> ord_spmf_bindI<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split_asm plus_oracle_split_asm <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> plus_oracle_stop_split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> not_None_eq <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf.map_comp o_def apfst_compose ord_spmf_map_spmf1 ord_spmf_map_spmf2 split_beta ord_spmf_return_spmf2 <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ord_spmf_reflI<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?X</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">id</span><span class="main">,</span> <span class="bound">gs</span><span class="main">)</span><span class="main">,</span> <span class="bound">s1</span><span class="main">)</span> <span class="main">(</span><span class="bound">idgs</span><span class="main">,</span> <span class="bound">s2</span><span class="main">)</span><span class="main">.</span> <span class="bound">s1</span> <span class="main">=</span> <span class="bound">s2</span> <span class="main">∧</span> <span class="main">(</span><span class="keyword1">case</span> <span class="main">(</span><span class="bound">gs</span><span class="main">,</span> <span class="bound">idgs</span><span class="main">)</span> <span class="keyword1">of</span> <span class="main">(</span>None<span class="main">,</span> Inr <span class="bound">id'</span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">id'</span> <span class="main">=</span> <span class="skolem">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">-</span> <span class="bound">id</span> <span class="main">∧</span> <span class="bound">id</span> <span class="main">≤</span> <span class="skolem">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">|</span> <span class="main">(</span>Some <span class="bound">gs</span><span class="main">,</span> Inl <span class="bound">gs'</span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">gs</span> <span class="main">=</span> <span class="bound">gs'</span> <span class="main">∧</span> <span class="bound">id</span> <span class="main">&gt;</span> <span class="skolem">j<span class="hidden">⇩</span><sub>s</sub></span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> False<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="skolem">body3</span> <span class="skolem">c_o</span> <span class="skolem">c_a</span> <span class="skolem">s</span> <span class="skolem">j<span class="hidden">⇩</span><sub>s</sub></span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> body3_def spmf_rel_eq<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> stop_oracle_def
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> exec_gpv_oracle_bisim'<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> X<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="var">?X</span>"</span></span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> rel_spmf_bindI<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm plus_oracle_stop_split nat.splits <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> sum.split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf_rel_map <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_reflI<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> pmf.rel_mono_strong<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> option.rel_cases ord_option.cases<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ord_spmf <span class="main">(⟶)</span> <span class="var">?game2</span> <span class="var">?game3</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> initialize_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ord_spmf_bind_reflI<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?X</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">gsid</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="main">(</span><span class="bound">gid</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span><span class="main">.</span> <span class="bound">s</span> <span class="main">=</span> <span class="bound">s'</span> <span class="main">∧</span> rel_sum <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">g</span><span class="main">,</span> <span class="bound">s1</span><span class="main">)</span> <span class="bound">g'</span><span class="main">.</span> <span class="bound">g</span> <span class="main">=</span> <span class="bound">g'</span> <span class="main">∧</span> <span class="bound">s1</span> <span class="main">=</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">(=)</span> <span class="bound">gsid</span> <span class="bound">gid</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"rel_spmf <span class="main">(⟶)</span> <span class="var">?game3</span> <span class="main">(</span>game_single <span class="main">(</span>reduction <span class="free">q</span> <span class="free">𝒜</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> body3_def stop_oracle_def game_single_def reduction_def split_def initialize_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_map_spmf exec_gpv_bind exec_gpv_inline <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_bind_reflI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> rel_spmf_bindI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> exec_gpv_oracle_bisim'<span class="main"><span class="main"><span class="main">[</span></span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> X<span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span><span class="quoted"><span class="quoted">"<span class="var">?X</span>"</span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> plus_oracle_stop_split <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_sum.cases <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_spmf_conv_bind_spmf<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> split_def spmf_rel_map rel_spmf_reflI rel_spmf_return_spmf1 lossless_eval <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> nat.split<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ord_spmf <span class="main">(⟶)</span> <span class="var">?game2</span> <span class="main">(</span>game_single <span class="main">(</span>reduction <span class="free">q</span> <span class="free">𝒜</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> pmf.rel_mono_strong<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> option.rel_cases ord_option.cases<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">THEN</span> ord_spmf_measureD<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">{</span>True<span class="main">}</span>"</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"spmf <span class="var">?game2</span> True <span class="main">≤</span> spmf <span class="main">(</span>game_single <span class="main">(</span>reduction <span class="free">q</span> <span class="free">𝒜</span><span class="main">)</span><span class="main">)</span> True"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> spmf_conv_measure_spmf
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> ord_le_eq_trans<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> arg_cong2<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">measure</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> advantage_multi_def advantage_single_def 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mult_right_mono<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Unpredictable_Function">
<div class="head">
<h1>Theory Unpredictable_Function</h1>
</div>
<pre class="source"><span class="comment1">(* Title: Unpredictable_Function.thy
  Author: Andreas Lochbihler, ETH Zurich 
  Author: S. Reza Sefidgar, ETH Zurich *)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Unpredictable function›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Unpredictable_Function <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Guessing_Many_One.html">Guessing_Many_One</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">locale</span></span> upf <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">key_gen</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'key</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">hash</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'key</span> <span class="main">⇒</span> <span class="tfree">'x</span> <span class="main">⇒</span> <span class="tfree">'hash</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'x'</span><span class="main">,</span> <span class="tfree">'hash'</span><span class="main">)</span> adversary <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>unit<span class="main">,</span> <span class="tfree">'x'</span> <span class="main">+</span> <span class="main">(</span><span class="tfree">'x'</span> <span class="main">×</span> <span class="tfree">'hash'</span><span class="main">)</span><span class="main">,</span> <span class="tfree">'hash'</span> <span class="main">+</span> unit<span class="main">)</span> gpv"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">oracle_hash</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'key</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'x</span><span class="main">,</span> <span class="tfree">'hash</span><span class="main">,</span> <span class="tfree">'x</span> set<span class="main">)</span> callee"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">oracle_hash</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">L</span> <span class="bound">y</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">let</span> <span class="bound">t</span> <span class="main">=</span> <span class="free">hash</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="bound">y</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">L</span> <span class="main">=</span> insert <span class="bound">y</span> <span class="bound">L</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">t</span><span class="main">,</span> <span class="bound">L</span><span class="main">)</span>
  <span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">oracle_flag</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'key</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'x</span> <span class="main">×</span> <span class="tfree">'hash</span><span class="main">,</span> unit<span class="main">,</span> bool <span class="main">×</span> <span class="tfree">'x</span> set<span class="main">)</span> callee"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">oracle_flag</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">key</span> <span class="main">(</span><span class="bound">flg</span><span class="main">,</span> <span class="bound">L</span><span class="main">)</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span><span class="main">.</span>
    return_spmf <span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="main">(</span><span class="bound">flg</span> <span class="main">∨</span> <span class="main">(</span><span class="bound">t</span> <span class="main">=</span> <span class="main">(</span><span class="free">hash</span> <span class="bound">key</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">∉</span> <span class="bound">L</span><span class="main">)</span><span class="main">,</span> <span class="bound">L</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted">"<span class="entity">oracle</span>"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'key</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'x</span> <span class="main">+</span> <span class="tfree">'x</span> <span class="main">×</span> <span class="tfree">'hash</span><span class="main">,</span> <span class="tfree">'hash</span> <span class="main">+</span> unit<span class="main">,</span> bool <span class="main">×</span> <span class="tfree">'x</span> set<span class="main">)</span> callee"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">oracle</span> <span class="free"><span class="bound"><span class="entity">key</span></span></span> <span class="main">≡</span> <span class="main">†</span><span class="main">(</span>oracle_hash <span class="free"><span class="bound"><span class="entity">key</span></span></span><span class="main">)</span> <span class="keyword1">⊕<span class="hidden">⇩</span><sub>O</sub></span> oracle_flag <span class="free"><span class="bound"><span class="entity">key</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">game</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'x</span><span class="main">,</span> <span class="tfree">'hash</span><span class="main">)</span> adversary <span class="main">⇒</span> bool spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">game</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">key</span> <span class="main">←</span> <span class="free">key_gen</span><span class="main">;</span>
    <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="main">(</span><span class="bound">flag'</span><span class="main">,</span> <span class="bound">L'</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="main">(</span>oracle <span class="bound">key</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">(</span>False<span class="main">,</span> <span class="main">{}</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="bound">flag'</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">advantage</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'x</span><span class="main">,</span> <span class="tfree">'hash</span><span class="main">)</span> adversary <span class="main">⇒</span> real"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">advantage</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> spmf <span class="main">(</span>game <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span><span class="main">)</span> True"</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'x'</span><span class="main">,</span> <span class="tfree">'hash'</span><span class="main">)</span> adversary1 <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'x'</span> <span class="main">×</span> <span class="tfree">'hash'</span><span class="main">,</span> <span class="tfree">'x'</span><span class="main">,</span> <span class="tfree">'hash'</span><span class="main">)</span> gpv"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">game1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'x</span><span class="main">,</span> <span class="tfree">'hash</span><span class="main">)</span> adversary1 <span class="main">⇒</span> bool spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">game1</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">key</span> <span class="main">←</span> <span class="free">key_gen</span><span class="main">;</span>
    <span class="main">(</span><span class="main">(</span><span class="bound">m</span><span class="main">,</span> <span class="bound">h</span><span class="main">)</span><span class="main">,</span> <span class="bound">L</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="main">(</span>oracle_hash <span class="bound">key</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">{}</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">h</span> <span class="main">=</span> <span class="free">hash</span> <span class="bound">key</span> <span class="bound">m</span> <span class="main">∧</span> <span class="bound">m</span> <span class="main">∉</span> <span class="bound">L</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">advantage1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'x</span><span class="main">,</span> <span class="tfree">'hash</span><span class="main">)</span> adversary1 <span class="main">⇒</span> real"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">advantage1</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> spmf <span class="main">(</span>game1 <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span><span class="main">)</span> True"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> advantage_advantage1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> bound<span class="main">:</span> <span class="quoted"><span class="quoted">"interaction_bounded_by <span class="main">(</span>Not <span class="main">∘</span> isl<span class="main">)</span> <span class="free">𝒜</span> <span class="free">q</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"advantage <span class="free">𝒜</span> <span class="main">≤</span> advantage1 <span class="main">(</span>guessing_many_one.reduction <span class="free">q</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit<span class="main">.</span> <span class="free">𝒜</span><span class="main">)</span> <span class="main">()</span><span class="main">)</span> <span class="main">*</span> <span class="free">q</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?init</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"map_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">key</span><span class="main">.</span> <span class="main">(</span><span class="bound">key</span><span class="main">,</span> <span class="main">()</span><span class="main">,</span> <span class="main">{}</span><span class="main">)</span><span class="main">)</span> <span class="free">key_gen</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?oracle</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">key</span> <span class="main">.</span> oracle_hash <span class="bound">key</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?eval</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">key</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit<span class="main">)</span> <span class="bound">L</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">h</span><span class="main">)</span><span class="main">.</span> return_spmf <span class="main">(</span><span class="bound">h</span> <span class="main">=</span> <span class="free">hash</span> <span class="bound">key</span> <span class="bound">x</span> <span class="main">∧</span> <span class="bound">x</span> <span class="main">∉</span> <span class="bound">L</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">interpret</span></span> guessing_many_one <span class="var"><span class="quoted"><span class="var">?init</span></span></span> <span class="var"><span class="quoted"><span class="var">?oracle</span></span></span> <span class="var"><span class="quoted"><span class="var">?eval</span></span></span> <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"oracle_flag <span class="skolem">key</span> <span class="main">=</span> eval_oracle <span class="skolem">key</span> <span class="main">()</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">key</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle_flag_def eval_oracle_def fun_eq_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"game <span class="free">𝒜</span> <span class="main">=</span> game_multi <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">𝒜</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> game_multi_def game_def bind_map_spmf <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> bind_spmf_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"advantage <span class="free">𝒜</span> <span class="main">=</span> advantage_multi <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">𝒜</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> advantage_def advantage_multi_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> advantage_single <span class="main">(</span>reduction <span class="free">q</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">𝒜</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> <span class="free">q</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> bound
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> many_single_reduction<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle_hash_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"advantage_single <span class="main">(</span>reduction <span class="free">q</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="skolem">𝒜</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> advantage1 <span class="main">(</span>reduction <span class="free">q</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="skolem">𝒜</span><span class="main">)</span> <span class="main">()</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">𝒜</span>
    <span class="keyword1"><span class="command">unfolding</span></span> advantage1_def advantage_single_def
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> game1_def game_single_def bind_map_spmf o_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> bind_spmf_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span> arg_cong2<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">spmf</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Security_Spec">
<div class="head">
<h1>Theory Security_Spec</h1>
</div>
<pre class="source"><span class="comment1">(* Title: Game_Based_Crypto.thy
  Author: Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">theory</span></span> Security_Spec <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Diffie_Hellman.html">Diffie_Hellman</a>
  <a href="IND_CCA2.html">IND_CCA2</a>
  <a href="IND_CCA2_sym.html">IND_CCA2_sym</a>
  <a href="IND_CPA.html">IND_CPA</a>
  <a href="IND_CPA_PK.html">IND_CPA_PK</a>
  <a href="IND_CPA_PK_Single.html">IND_CPA_PK_Single</a>
  <a href="SUF_CMA.html">SUF_CMA</a>
  <a href="Pseudo_Random_Function.html">Pseudo_Random_Function</a>
  <a href="Pseudo_Random_Permutation.html">Pseudo_Random_Permutation</a>
  <a href="Unpredictable_Function.html">Unpredictable_Function</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Elgamal">
<div class="head">
<h1>Theory Elgamal</h1>
</div>
<pre class="source"><span class="comment1">(* Title: Elgamal.thy
  Author: Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Cryptographic constructions and their security›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Elgamal <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../CryptHOL/Cyclic_Group_SPMF.html">CryptHOL.Cyclic_Group_SPMF</a>
  <a href="../CryptHOL/Computational_Model.html">CryptHOL.Computational_Model</a>
  <a href="Diffie_Hellman.html">Diffie_Hellman</a>
  <a href="IND_CPA_PK_Single.html">IND_CPA_PK_Single</a>
  <a href="../CryptHOL/Negligible.html">CryptHOL.Negligible</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Elgamal encryption scheme›</span></span>

<span class="keyword1"><span class="command">locale</span></span> elgamal_base <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">𝒢</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> cyclic_group"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="main">)</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'grp'</span> pub_key <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp'</span>"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'grp'</span> priv_key <span class="main">=</span> <span class="quoted">nat</span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'grp'</span> plain <span class="main">=</span> <span class="tfree"><span class="quoted"><span class="tfree">'grp'</span></span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'grp'</span> cipher <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp'</span> <span class="main">×</span> <span class="tfree">'grp'</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">key_gen</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'grp</span> pub_key <span class="main">×</span> <span class="tfree">'grp</span> priv_key<span class="main">)</span> spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">key_gen</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
     <span class="bound">x</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
     return_spmf <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">x</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> key_gen_alt<span class="main">:</span>
  <span class="quoted"><span class="quoted">"key_gen <span class="main">=</span> map_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">x</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_spmf_conv_bind_spmf key_gen_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">aencrypt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> pub_key <span class="main">⇒</span> <span class="tfree">'grp</span> <span class="main">⇒</span> <span class="tfree">'grp</span> cipher spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">aencrypt</span> <span class="free"><span class="bound"><span class="entity">α</span></span></span> <span class="free"><span class="bound"><span class="entity">msg</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">y</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">y</span><span class="main">,</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">α</span></span></span> <span class="main">[^]</span> <span class="bound">y</span><span class="main">)</span> <span class="main">⊗</span> <span class="free"><span class="bound"><span class="entity">msg</span></span></span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> aencrypt_alt<span class="main">:</span>
  <span class="quoted"><span class="quoted">"aencrypt <span class="free">α</span> <span class="free">msg</span> <span class="main">=</span> map_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">y</span><span class="main">,</span> <span class="main">(</span><span class="free">α</span> <span class="main">[^]</span> <span class="bound">y</span><span class="main">)</span> <span class="main">⊗</span> <span class="free">msg</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_spmf_conv_bind_spmf aencrypt_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">adecrypt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> priv_key <span class="main">⇒</span> <span class="tfree">'grp</span> cipher <span class="main">⇒</span> <span class="tfree">'grp</span> option"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">adecrypt</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">β</span><span class="main">,</span> <span class="bound">ζ</span><span class="main">)</span><span class="main">.</span> Some <span class="main">(</span><span class="bound">ζ</span> <span class="main">⊗</span> <span class="main">(</span><span class="keyword1">inv</span> <span class="main">(</span><span class="bound">β</span> <span class="main">[^]</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">valid_plains</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> <span class="main">⇒</span> <span class="tfree">'grp</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">valid_plains</span> <span class="free"><span class="bound"><span class="entity">msg1</span></span></span> <span class="free"><span class="bound"><span class="entity">msg2</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">msg1</span></span></span> <span class="main">∈</span> carrier <span class="free">𝒢</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">msg2</span></span></span> <span class="main">∈</span> carrier <span class="free">𝒢</span>"</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> ind_cpa<span class="main">:</span> ind_cpa <span class="quoted">key_gen</span> <span class="quoted">aencrypt</span> <span class="quoted">adecrypt</span> <span class="quoted">valid_plains</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">sublocale</span></span> ddh<span class="main">:</span> ddh <span class="quoted"><span class="free">𝒢</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">elgamal_adversary</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'grp</span> pub_key<span class="main">,</span> <span class="tfree">'grp</span> plain<span class="main">,</span> <span class="tfree">'grp</span> cipher<span class="main">,</span> <span class="tfree">'state</span><span class="main">)</span> ind_cpa.adversary <span class="main">⇒</span> <span class="tfree">'grp</span> ddh.adversary"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">elgamal_adversary</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">𝒜1</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">𝒜2</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">α</span></span></span> <span class="free"><span class="bound"><span class="entity">β</span></span></span> <span class="free"><span class="bound"><span class="entity">γ</span></span></span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
    <span class="main">(</span><span class="main">(</span><span class="bound">msg1</span><span class="main">,</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">𝒜1</span></span></span> <span class="free"><span class="bound"><span class="entity">α</span></span></span><span class="main">;</span>
    <span class="comment1">― ‹have to check that the attacker actually sends two elements from the group; otherwise flip a coin›</span>
    <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span>valid_plains <span class="bound">msg1</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">guess</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">𝒜2</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">β</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">γ</span></span></span> <span class="main">⊗</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">msg1</span> <span class="keyword1">else</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">)</span> <span class="bound">σ</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">guess</span> <span class="main">=</span> <span class="bound">b</span><span class="main">)</span>
  <span class="main">}</span> <span class="keyword1">ELSE</span> coin_spmf"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> elgamal <span class="main">=</span> elgamal_base <span class="main">+</span> cyclic_group <span class="quoted"><span class="free">𝒢</span></span>
<span class="keyword2"><span class="keyword">begin</span></span> 

<span class="keyword1"><span class="command">theorem</span></span> advantage_elgamal<span class="main">:</span> <span class="quoted"><span class="quoted">"ind_cpa.advantage <span class="free">𝒜</span> <span class="main">=</span> ddh.advantage <span class="main">(</span>elgamal_adversary <span class="free">𝒜</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> monad_normalisation
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">𝒜1</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem"><span class="skolem">𝒜2</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">𝒜</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">𝒜1</span><span class="main">,</span> <span class="skolem">𝒜2</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">𝒜</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> this order_gt_0_iff_finite finite_carrier try_spmf_bind_out split_def o_def spmf_of_set bind_map_spmf weight_spmf_le_1 scale_bind_spmf bind_spmf_const
    <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">cong</span><span class="main">]</span> <span class="main">=</span> bind_spmf_cong_simp
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ddh.ddh_1 <span class="main">(</span>elgamal_adversary <span class="free">𝒜</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
       <span class="bound">x</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
       <span class="bound">y</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
       <span class="main">(</span><span class="main">(</span><span class="bound">msg1</span><span class="main">,</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">←</span> <span class="skolem">𝒜1</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">x</span><span class="main">)</span><span class="main">;</span>
       <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span>valid_plains <span class="bound">msg1</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">;</span>
       <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
       <span class="bound">z</span> <span class="main">←</span> map_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">z</span><span class="main">.</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">z</span> <span class="main">⊗</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">msg1</span> <span class="keyword1">else</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
       <span class="bound">guess</span> <span class="main">←</span> <span class="skolem">𝒜2</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">y</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="bound">σ</span><span class="main">;</span>
       return_spmf <span class="main">(</span><span class="bound">guess</span> <span class="main">⟷</span> <span class="bound">b</span><span class="main">)</span>
     <span class="main">}</span> <span class="keyword1">ELSE</span> coin_spmf"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ddh.ddh_1_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
       <span class="bound">x</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
       <span class="bound">y</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
       <span class="main">(</span><span class="main">(</span><span class="bound">msg1</span><span class="main">,</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">←</span> <span class="skolem">𝒜1</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">x</span><span class="main">)</span><span class="main">;</span>
       <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span>valid_plains <span class="bound">msg1</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">;</span>
       <span class="bound">z</span> <span class="main">←</span> map_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">z</span><span class="main">.</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">z</span><span class="main">)</span> <span class="main">(</span>sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
       <span class="bound">guess</span> <span class="main">←</span> <span class="skolem">𝒜2</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">y</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="bound">σ</span><span class="main">;</span>
       map_spmf <span class="main">(</span><span class="main">(=)</span> <span class="bound">guess</span><span class="main">)</span> coin_spmf
     <span class="main">}</span> <span class="keyword1">ELSE</span> coin_spmf"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sample_uniform_one_time_pad map_spmf_conv_bind_spmf<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> p<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">coin_spmf</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> coin_spmf"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_eq_const_coin_spmf try_bind_spmf_lossless2'<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ddh.ddh_0 <span class="main">(</span>elgamal_adversary <span class="free">𝒜</span><span class="main">)</span> <span class="main">=</span> ind_cpa.ind_cpa <span class="free">𝒜</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ddh.ddh_0_def IND_CPA_PK_Single.ind_cpa.ind_cpa_def key_gen_def aencrypt_def nat_pow_pow eq_commute<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ddh.advantage_def ind_cpa.advantage_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
  
<span class="keyword1"><span class="command">locale</span></span> elgamal_asymp <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">𝒢</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="tfree">'grp</span> cyclic_group"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> elgamal<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">η</span><span class="main">.</span> elgamal <span class="main">(</span><span class="free">𝒢</span> <span class="bound">η</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  
<span class="keyword1"><span class="command">sublocale</span></span> elgamal <span class="quoted"><span class="quoted">"<span class="free">𝒢</span> <span class="free">η</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">η</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> elgamal<span class="main">)</span>
    
<span class="keyword1"><span class="command">theorem</span></span> elgamal_secure<span class="main">:</span>
  <span class="quoted"><span class="quoted">"negligible <span class="main">(</span><span class="main">λ</span><span class="bound">η</span><span class="main">.</span> ind_cpa.advantage <span class="bound">η</span> <span class="main">(</span><span class="free">𝒜</span> <span class="bound">η</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"negligible <span class="main">(</span><span class="main">λ</span><span class="bound">η</span><span class="main">.</span> ddh.advantage <span class="bound">η</span> <span class="main">(</span>elgamal_adversary <span class="bound">η</span> <span class="main">(</span><span class="free">𝒜</span> <span class="bound">η</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> advantage_elgamal that<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> elgamal_base <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_key_gen <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>key_gen<span class="main">)</span> <span class="main">⟷</span> <span class="main">0</span> <span class="main">&lt;</span> order <span class="free">𝒢</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> key_gen_def Let_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_aencrypt <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>aencrypt <span class="free">key</span> <span class="free">plain</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">0</span> <span class="main">&lt;</span> order <span class="free">𝒢</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> aencrypt_def Let_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_elgamal_adversary<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> ind_cpa.lossless <span class="free">𝒜</span><span class="main">;</span> <span class="main">0</span> <span class="main">&lt;</span> order <span class="free">𝒢</span> <span class="main">⟧</span>
  <span class="main">⟹</span> ddh.lossless <span class="main">(</span>elgamal_adversary <span class="free">𝒜</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">𝒜</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ddh.lossless_def ind_cpa.lossless_def Let_def split_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Hashed_Elgamal">
<div class="head">
<h1>Theory Hashed_Elgamal</h1>
</div>
<pre class="source"><span class="comment1">(* Title: Hashed_Elgamal.thy
  Author: Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Hashed Elgamal in the Random Oracle Model›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Hashed_Elgamal <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../CryptHOL/GPV_Bisim.html">CryptHOL.GPV_Bisim</a>
  <a href="../CryptHOL/Cyclic_Group_SPMF.html">CryptHOL.Cyclic_Group_SPMF</a>
  <a href="../CryptHOL/List_Bits.html">CryptHOL.List_Bits</a>
  <a href="IND_CPA_PK.html">IND_CPA_PK</a>
  <a href="Diffie_Hellman.html">Diffie_Hellman</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> bitstring <span class="main">=</span> <span class="quoted"><span class="quoted">"bool list"</span></span>

<span class="keyword1"><span class="command">locale</span></span> hash_oracle <span class="main">=</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">len</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat"</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'a</span> state <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇀</span> bitstring"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted">"<span class="entity">oracle</span>"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> state <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span>bitstring <span class="main">×</span> <span class="tfree">'a</span> state<span class="main">)</span> spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">oracle</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
     <span class="bound">bs</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len</span><span class="main">)</span><span class="main">;</span>
     return_spmf <span class="main">(</span><span class="bound">bs</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">↦</span> <span class="bound">bs</span><span class="main">)</span><span class="main">)</span>
   <span class="main">}</span> <span class="main">|</span> Some <span class="bound">bs</span> <span class="main">⇒</span> return_spmf <span class="main">(</span><span class="bound">bs</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">initial</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> state"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">initial</span> <span class="main">≡</span> Map.empty"</span></span>

<span class="keyword1"><span class="command">inductive</span></span> <span class="entity">invariant</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> state <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  invariant<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> finite <span class="main">(</span>dom <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">)</span><span class="main">;</span> length <span class="main">`</span> ran <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">⊆</span> <span class="main">{</span><span class="free">len</span><span class="main">}</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">invariant</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> invariant_initial <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"invariant initial"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> invariant.intros<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> invariant_update <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> invariant <span class="free">σ</span><span class="main">;</span> length <span class="free">bs</span> <span class="main">=</span> <span class="free">len</span> <span class="main">⟧</span> <span class="main">⟹</span> invariant <span class="main">(</span><span class="free">σ</span><span class="main">(</span><span class="free">x</span> <span class="main">↦</span> <span class="free">bs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> invariant.simps ran_def<span class="main">)</span>
                           
<span class="keyword1"><span class="command">lemma</span></span> invariant <span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"callee_invariant oracle invariant"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle_def in_nlists_UNIV <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> invariant_in_dom <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"callee_invariant oracle <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="free">x</span> <span class="main">∈</span> dom <span class="bound">σ</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_oracle <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>oracle <span class="free">σ</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> card_dom_state<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> σ'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">σ'</span><span class="main">)</span> <span class="main">∈</span> set_spmf <span class="main">(</span>exec_gpv oracle <span class="free">gpv</span> <span class="free">σ</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> ibound<span class="main">:</span> <span class="quoted"><span class="quoted">"interaction_any_bounded_by <span class="free">gpv</span> <span class="free">n</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>dom <span class="free">σ'</span><span class="main">)</span> <span class="main">≤</span> <span class="free">n</span> <span class="main">+</span> card <span class="main">(</span>dom <span class="free">σ</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>dom <span class="free">σ</span><span class="main">)</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">interpret</span></span> callee_invariant_on <span class="quoted"><span class="quoted">"oracle"</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> finite <span class="main">(</span>dom <span class="bound">σ</span><span class="main">)</span>"</span></span> <span class="quoted">ℐ_full</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> ibound σ' _ _ _ True <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> interaction_bounded_by'_exec_gpv_count<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle_def card_insert_if <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> fun_upd_apply <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">interpret</span></span> callee_invariant_on <span class="quoted"><span class="quoted">"oracle"</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">σ'</span><span class="main">.</span> dom <span class="free">σ</span> <span class="main">⊆</span> dom <span class="bound">σ'</span>"</span></span> <span class="quoted">ℐ_full</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> σ' <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"dom <span class="free">σ</span> <span class="main">⊆</span> dom <span class="free">σ'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> exec_gpv_invariant<span class="main">)</span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">with</span></span> False <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"infinite <span class="main">(</span>dom <span class="free">σ'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_subset<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> False <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> elgamal_base <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">𝒢</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> cyclic_group"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">len_plain</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> hash<span class="main">:</span> hash_oracle <span class="quoted"><span class="quoted">"<span class="free">len_plain</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">hash</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> <span class="main">⇒</span> <span class="main">(</span>bitstring<span class="main">,</span> <span class="tfree">'grp</span><span class="main">,</span> bitstring<span class="main">)</span> gpv"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">hash</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> Pause <span class="free"><span class="bound"><span class="entity">x</span></span></span> Done"</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'grp'</span> pub_key <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp'</span>"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'grp'</span> priv_key <span class="main">=</span> <span class="quoted">nat</span>
<span class="keyword1"><span class="command">type_synonym</span></span> plain <span class="main">=</span> <span class="quoted">bitstring</span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'grp'</span> cipher <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp'</span> <span class="main">×</span> bitstring"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">key_gen</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'grp</span> pub_key <span class="main">×</span> <span class="tfree">'grp</span> priv_key<span class="main">)</span> spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">key_gen</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
     <span class="bound">x</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
     return_spmf <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">x</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">aencrypt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> pub_key <span class="main">⇒</span> plain <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'grp</span> cipher<span class="main">,</span> <span class="tfree">'grp</span><span class="main">,</span> bitstring<span class="main">)</span> gpv"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">aencrypt</span> <span class="free"><span class="bound"><span class="entity">α</span></span></span> <span class="free"><span class="bound"><span class="entity">msg</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">y</span> <span class="main">←</span> lift_spmf <span class="main">(</span>sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">h</span> <span class="main">←</span> hash <span class="main">(</span><span class="free"><span class="bound"><span class="entity">α</span></span></span> <span class="main">[^]</span> <span class="bound">y</span><span class="main">)</span><span class="main">;</span>
    Done <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">y</span><span class="main">,</span> <span class="bound">h</span> <span class="main">[⊕]</span> <span class="free"><span class="bound"><span class="entity">msg</span></span></span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">adecrypt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> priv_key <span class="main">⇒</span> <span class="tfree">'grp</span> cipher <span class="main">⇒</span> <span class="main">(</span>plain<span class="main">,</span> <span class="tfree">'grp</span><span class="main">,</span> bitstring<span class="main">)</span> gpv"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">adecrypt</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">β</span><span class="main">,</span> <span class="bound">ζ</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">h</span> <span class="main">←</span> hash <span class="main">(</span><span class="bound">β</span> <span class="main">[^]</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">;</span>
    Done <span class="main">(</span><span class="bound">ζ</span> <span class="main">[⊕]</span> <span class="bound">h</span><span class="main">)</span>
  <span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">valid_plains</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"plain <span class="main">⇒</span> plain <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">valid_plains</span> <span class="free"><span class="bound"><span class="entity">msg1</span></span></span> <span class="free"><span class="bound"><span class="entity">msg2</span></span></span> <span class="main">⟷</span> length <span class="free"><span class="bound"><span class="entity">msg1</span></span></span> <span class="main">=</span> <span class="free">len_plain</span> <span class="main">∧</span> length <span class="free"><span class="bound"><span class="entity">msg2</span></span></span> <span class="main">=</span> <span class="free">len_plain</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_aencrypt <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_gpv <span class="free">ℐ</span> <span class="main">(</span>aencrypt <span class="free">α</span> <span class="free">msg</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">0</span> <span class="main">&lt;</span> order <span class="free">𝒢</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> aencrypt_def Let_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> interaction_bounded_by_aencrypt <span class="main">[</span><span class="operator">interaction_bound</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"interaction_bounded_by <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="main">(</span>aencrypt <span class="free">α</span> <span class="free">msg</span><span class="main">)</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> aencrypt_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">interaction_bound</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> one_enat_def SUP_le_iff<span class="main">)</span>

<span class="keyword1"><span class="command">sublocale</span></span> ind_cpa<span class="main">:</span> ind_cpa_pk <span class="quoted"><span class="quoted">"lift_spmf key_gen"</span></span> <span class="quoted">aencrypt</span> <span class="quoted">adecrypt</span> <span class="quoted">valid_plains</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">sublocale</span></span> lcdh<span class="main">:</span> lcdh <span class="quoted"><span class="free">𝒢</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">elgamal_adversary</span>
   <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'grp</span> pub_key<span class="main">,</span> plain<span class="main">,</span> <span class="tfree">'grp</span> cipher<span class="main">,</span> <span class="tfree">'grp</span><span class="main">,</span> bitstring<span class="main">,</span> <span class="tfree">'state</span><span class="main">)</span> ind_cpa.adversary
   <span class="main">⇒</span> <span class="tfree">'grp</span> lcdh.adversary"</span></span>                     
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">elgamal_adversary</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">𝒜1</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">𝒜2</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">α</span></span></span> <span class="free"><span class="bound"><span class="entity">β</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="bound">msg1</span><span class="main">,</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="main">←</span> exec_gpv hash.oracle <span class="main">(</span><span class="free"><span class="bound"><span class="entity">𝒜1</span></span></span> <span class="free"><span class="bound"><span class="entity">α</span></span></span><span class="main">)</span> hash.initial<span class="main">;</span>
    <span class="comment1">― ‹have to check that the attacker actually sends an element from the group; otherwise stop early›</span>
    <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span>valid_plains <span class="bound">msg1</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">h'</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len_plain</span><span class="main">)</span><span class="main">;</span>
      <span class="main">(</span><span class="bound">guess</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">←</span> exec_gpv hash.oracle <span class="main">(</span><span class="free"><span class="bound"><span class="entity">𝒜2</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">β</span></span></span><span class="main">,</span> <span class="bound">h'</span><span class="main">)</span> <span class="bound">σ</span><span class="main">)</span> <span class="bound">s</span><span class="main">;</span>
      return_spmf <span class="main">(</span>dom <span class="bound">s'</span><span class="main">)</span>
    <span class="main">}</span> <span class="keyword1">ELSE</span> return_spmf <span class="main">(</span>dom <span class="bound">s</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> elgamal <span class="main">=</span> elgamal_base <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> cyclic_group<span class="main">:</span> <span class="quoted"><span class="quoted">"cyclic_group <span class="free">𝒢</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> cyclic_group <span class="quoted"><span class="free">𝒢</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> cyclic_group<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> advantage_elgamal<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
  <span class="keyword2"><span class="keyword">assumes</span></span> lossless<span class="main">:</span> <span class="quoted"><span class="quoted">"ind_cpa.lossless <span class="free">𝒜</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ind_cpa.advantage hash.oracle hash.initial <span class="free">𝒜</span> <span class="main">≤</span> lcdh.advantage <span class="main">(</span>elgamal_adversary <span class="free">𝒜</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">cong</span> <span class="quasi_keyword">del</span><span class="main">]</span> <span class="main">=</span> if_weak_cong <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">split</span> <span class="quasi_keyword">del</span><span class="main">]</span> <span class="main">=</span> if_split
    <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> map_lift_spmf gpv.map_id lossless_weight_spmfD map_spmf_bind_spmf bind_spmf_const
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">𝒜1</span></span> <span class="skolem"><span class="skolem">𝒜2</span></span> <span class="keyword2"><span class="keyword">where</span></span> 𝒜 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">𝒜</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">𝒜1</span><span class="main">,</span> <span class="skolem">𝒜2</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">𝒜</span>"</span></span><span class="main">)</span>

  <span class="keyword1"><span class="command">interpret</span></span> cyclic_group<span class="main">:</span> cyclic_group <span class="quoted"><span class="free">𝒢</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> cyclic_group<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> finite_carrier <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"order <span class="free">𝒢</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> order_gt_0_iff_finite <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

  <span class="keyword1"><span class="command">from</span></span> lossless <span class="keyword1"><span class="command">have</span></span> lossless1 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">pk</span><span class="main">.</span> lossless_gpv ℐ_full <span class="main">(</span><span class="skolem">𝒜1</span> <span class="bound">pk</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> lossless2 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">σ</span> <span class="bound">cipher</span><span class="main">.</span> lossless_gpv ℐ_full <span class="main">(</span><span class="skolem">𝒜2</span> <span class="bound">σ</span> <span class="bound">cipher</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ind_cpa.lossless_def<span class="main">)</span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We change the adversary's oracle to record the queries made by the adversary›</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">hash_oracle'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">hash_oracle'</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">h</span> <span class="main">←</span> hash <span class="bound">x</span><span class="main">;</span>
      Done <span class="main">(</span><span class="bound">h</span><span class="main">,</span> insert <span class="bound">x</span> <span class="bound">σ</span><span class="main">)</span>
    <span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_gpv ℐ_full <span class="main">(</span><span class="skolem">hash_oracle'</span> <span class="skolem">σ</span> <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">σ</span> <span class="skolem">x</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hash_oracle'_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_gpv ℐ_full <span class="main">(</span>inline <span class="skolem">hash_oracle'</span> <span class="main">(</span><span class="skolem">𝒜1</span> <span class="skolem">α</span><span class="main">)</span> <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">α</span> <span class="skolem">s</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lossless_inline<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> ℐ<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">ℐ_full</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp_all</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">game0</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">game0</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="main">(</span><span class="bound">pk</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">←</span> lift_spmf key_gen<span class="main">;</span>
      <span class="bound">b</span> <span class="main">←</span> lift_spmf coin_spmf<span class="main">;</span>
      <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="bound">msg1</span><span class="main">,</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="main">←</span> inline <span class="skolem">hash_oracle'</span> <span class="main">(</span><span class="skolem">𝒜1</span> <span class="bound">pk</span><span class="main">)</span> <span class="main">{}</span><span class="main">;</span>
      assert_gpv <span class="main">(</span>valid_plains <span class="bound">msg1</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">cipher</span> <span class="main">←</span> aencrypt <span class="bound">pk</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">msg1</span> <span class="keyword1">else</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">;</span>
      <span class="main">(</span><span class="bound">guess</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">←</span> inline <span class="skolem">hash_oracle'</span> <span class="main">(</span><span class="skolem">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="bound">s</span><span class="main">;</span>
      Done <span class="main">(</span><span class="bound">guess</span> <span class="main">=</span> <span class="bound">b</span><span class="main">)</span>
    <span class="main">}</span> <span class="keyword1">ELSE</span> lift_spmf coin_spmf"</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">cr</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">cr</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit<span class="main">.</span> <span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">.</span> True<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">cr</span> <span class="main">()</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_def<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="skolem">cr</span> <span class="main">===&gt;</span> <span class="skolem">cr</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">σ</span><span class="main">.</span> <span class="bound">σ</span><span class="main">)</span> insert"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def cr_def<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">cr</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> rel_gpv <span class="main">(</span>rel_prod <span class="main">(=)</span> <span class="skolem">cr</span><span class="main">)</span> <span class="main">(=)</span><span class="main">)</span> id_oracle <span class="skolem">hash_oracle'</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> hash_oracle'_def id_oracle_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> bind_gpv_Pause bind_rpv_Done <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ind_cpa.ind_cpa <span class="free">𝒜</span> <span class="main">=</span> <span class="skolem">game0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> game0_def 𝒜 ind_cpa_pk.ind_cpa.simps
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">𝒢</span></span> <span class="quoted"><span class="free">len_plain</span></span> <span class="quoted"><span class="skolem">𝒜1</span></span> <span class="quoted"><span class="skolem">𝒜2</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_map_gpv o_def ind_cpa_pk.ind_cpa.simps split_def<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">note</span></span> game0 <span class="main">=</span> this
  <span class="keyword1"><span class="command">have</span></span> game0_alt_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">game0</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">x</span> <span class="main">←</span> lift_spmf <span class="main">(</span>sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">b</span> <span class="main">←</span> lift_spmf coin_spmf<span class="main">;</span>
      <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="bound">msg1</span><span class="main">,</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="main">←</span> inline <span class="skolem">hash_oracle'</span> <span class="main">(</span><span class="skolem">𝒜1</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">{}</span><span class="main">;</span>
      <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_gpv <span class="main">(</span>valid_plains <span class="bound">msg1</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">cipher</span> <span class="main">←</span> aencrypt <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">msg1</span> <span class="keyword1">else</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">;</span>
        <span class="main">(</span><span class="bound">guess</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">←</span> inline <span class="skolem">hash_oracle'</span> <span class="main">(</span><span class="skolem">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="bound">s</span><span class="main">;</span>
        Done <span class="main">(</span><span class="bound">guess</span> <span class="main">=</span> <span class="bound">b</span><span class="main">)</span>
      <span class="main">}</span> <span class="keyword1">ELSE</span> lift_spmf coin_spmf
    <span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_def game0_def key_gen_def lift_spmf_bind_spmf bind_gpv_assoc try_gpv_bind_lossless<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">hash_oracle''</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">hash_oracle''</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">(</span><span class="bound">x</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="main">(</span><span class="bound">h</span><span class="main">,</span> <span class="bound">σ'</span><span class="main">)</span> <span class="main">←</span> <span class="keyword1">case</span> <span class="bound">σ</span> <span class="bound">x</span> <span class="keyword1">of</span>
          None <span class="main">⇒</span> bind_spmf <span class="main">(</span>spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len_plain</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">bs</span><span class="main">.</span> return_spmf <span class="main">(</span><span class="bound">bs</span><span class="main">,</span> <span class="bound">σ</span><span class="main">(</span><span class="bound">x</span> <span class="main">↦</span> <span class="bound">bs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
        <span class="main">|</span> Some <span class="main">(</span><span class="bound">bs</span> <span class="main">::</span> bitstring<span class="main">)</span> <span class="main">⇒</span> return_spmf <span class="main">(</span><span class="bound">bs</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">;</span>
      return_spmf <span class="main">(</span><span class="bound">h</span><span class="main">,</span> insert <span class="bound">x</span> <span class="bound">s</span><span class="main">,</span> <span class="bound">σ'</span><span class="main">)</span>
    <span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"exec_gpv hash.oracle <span class="main">(</span>inline <span class="skolem">hash_oracle'</span> <span class="skolem">𝒜</span> <span class="skolem">s</span><span class="main">)</span> <span class="skolem">σ</span> <span class="main">=</span> 
    map_spmf <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>exec_gpv <span class="skolem">hash_oracle''</span> <span class="skolem">𝒜</span> <span class="main">(</span><span class="skolem">s</span><span class="main">,</span> <span class="skolem">σ</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">𝒜</span> <span class="skolem">σ</span> <span class="skolem">s</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hash_oracle'_def hash_oracle''_def hash.oracle_def Let_def exec_gpv_inline exec_gpv_bind o_def split_def <span class="quasi_keyword">cong</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> option.case_cong_weak<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span><span class="skolem">hash_oracle''</span> <span class="skolem">s</span> <span class="skolem">plain</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span> <span class="skolem">plain</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hash_oracle''_def Let_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split option.split<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>exec_gpv <span class="skolem">hash_oracle''</span> <span class="main">(</span><span class="skolem">𝒜1</span> <span class="skolem">α</span><span class="main">)</span> <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span> <span class="skolem">α</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lossless_exec_gpv<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> ℐ<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">ℐ_full</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>exec_gpv <span class="skolem">hash_oracle''</span> <span class="main">(</span><span class="skolem">𝒜2</span> <span class="skolem">σ</span> <span class="skolem">cipher</span><span class="main">)</span> <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">σ</span> <span class="skolem">cipher</span> <span class="skolem">s</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lossless_exec_gpv<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> ℐ<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">ℐ_full</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp_all</span>

  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?sample</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">f</span><span class="main">.</span> bind_spmf <span class="main">(</span>sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> bind_spmf <span class="main">(</span>sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">game1</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">game1</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span> <span class="main">::</span> nat<span class="main">)</span> <span class="main">(</span><span class="bound">y</span> <span class="main">::</span> nat<span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
      <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="bound">msg1</span><span class="main">,</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">s_h</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">hash_oracle''</span> <span class="main">(</span><span class="skolem">𝒜1</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">{}</span><span class="main">,</span> hash.initial<span class="main">)</span><span class="main">;</span>
      <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span>valid_plains <span class="bound">msg1</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">;</span>
        <span class="main">(</span><span class="bound">h</span><span class="main">,</span> <span class="bound">s_h'</span><span class="main">)</span> <span class="main">←</span> hash.oracle <span class="bound">s_h</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="bound">x</span> <span class="main">*</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1">let</span> <span class="bound">cipher</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">y</span><span class="main">,</span> <span class="bound">h</span> <span class="main">[⊕]</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">msg1</span> <span class="keyword1">else</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
        <span class="main">(</span><span class="bound">guess</span><span class="main">,</span> <span class="main">(</span><span class="bound">s'</span><span class="main">,</span> <span class="bound">s_h''</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">hash_oracle''</span> <span class="main">(</span><span class="skolem">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">s_h'</span><span class="main">)</span><span class="main">;</span>
        return_spmf <span class="main">(</span><span class="bound">guess</span> <span class="main">=</span> <span class="bound">b</span><span class="main">,</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="bound">x</span> <span class="main">*</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="bound">s'</span><span class="main">)</span>
      <span class="main">}</span> <span class="keyword1">ELSE</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
        return_spmf <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="bound">x</span> <span class="main">*</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="bound">s</span><span class="main">)</span>
      <span class="main">}</span>
    <span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> game01<span class="main">:</span> <span class="quoted"><span class="quoted">"run_gpv hash.oracle <span class="skolem">game0</span> hash.initial <span class="main">=</span> map_spmf fst <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game1</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> exec_gpv_bind split_def bind_gpv_assoc aencrypt_def game0_alt_def game1_def o_def bind_map_spmf <span class="dynamic"><span class="dynamic">if_distribs</span></span> * try_bind_assert_gpv try_bind_assert_spmf lossless_inline<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> ℐ<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">ℐ_full</span><span class="main"><span class="main">]</span></span> bind_rpv_def nat_pow_pow <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> bind_spmf_const<span class="main">)</span>
    <span class="keyword1"><span class="command">including</span></span> monad_normalisation <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_rpv_def nat_pow_pow<span class="main">)</span>
  
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">game2</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">game2</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span> <span class="main">::</span> nat<span class="main">)</span> <span class="main">(</span><span class="bound">y</span> <span class="main">::</span> nat<span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
    <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="bound">msg1</span><span class="main">,</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">s_h</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">hash_oracle''</span> <span class="main">(</span><span class="skolem">𝒜1</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">{}</span><span class="main">,</span> hash.initial<span class="main">)</span><span class="main">;</span>
    <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span>valid_plains <span class="bound">msg1</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">h</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len_plain</span><span class="main">)</span><span class="main">;</span>
      <span class="comment1">― ‹We do not do the lookup in <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>s_h›</span></span> here, so the rest differs only if the adversary guessed <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>y›</span></span>›</span>
      <span class="keyword1">let</span> <span class="bound">cipher</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">y</span><span class="main">,</span> <span class="bound">h</span> <span class="main">[⊕]</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">msg1</span> <span class="keyword1">else</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
      <span class="main">(</span><span class="bound">guess</span><span class="main">,</span> <span class="main">(</span><span class="bound">s'</span><span class="main">,</span> <span class="bound">s_h'</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">hash_oracle''</span> <span class="main">(</span><span class="skolem">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">s_h</span><span class="main">)</span><span class="main">;</span>
      return_spmf <span class="main">(</span><span class="bound">guess</span> <span class="main">=</span> <span class="bound">b</span><span class="main">,</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="bound">x</span> <span class="main">*</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="bound">s'</span><span class="main">)</span>
    <span class="main">}</span> <span class="keyword1">ELSE</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
      return_spmf <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="bound">x</span> <span class="main">*</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="bound">s</span><span class="main">)</span>
    <span class="main">}</span>
  <span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> inv''<span class="main">:</span> callee_invariant_on <span class="quoted"><span class="quoted">"<span class="skolem">hash_oracle''</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">s_h</span><span class="main">)</span><span class="main">.</span> <span class="bound">s</span> <span class="main">=</span> dom <span class="bound">s_h</span>"</span></span> <span class="quoted">ℐ_full</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hash_oracle''_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm if_split<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> in_encrypt_oracle<span class="main">:</span> <span class="quoted"><span class="quoted">"callee_invariant <span class="skolem">hash_oracle''</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="skolem">x</span> <span class="main">∈</span> <span class="bound">s</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hash_oracle''_def<span class="main">)</span>

  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">::</span> <span class="quoted">nat</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?bad</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">s_h</span><span class="main">)</span><span class="main">.</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">*</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="bound">s</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?X</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">s_h</span><span class="main">)</span> <span class="main">(</span><span class="bound">s'</span><span class="main">,</span> <span class="bound">s_h'</span><span class="main">)</span><span class="main">.</span> <span class="bound">s</span> <span class="main">=</span> dom <span class="bound">s_h</span> <span class="main">∧</span> <span class="bound">s'</span> <span class="main">=</span> <span class="bound">s</span> <span class="main">∧</span> <span class="bound">s_h</span> <span class="main">=</span> <span class="bound">s_h'</span><span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">*</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">:=</span> None<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> bisim<span class="main">:</span>
      <span class="quoted"><span class="quoted">"rel_spmf <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">s1'</span><span class="main">)</span> <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">s2'</span><span class="main">)</span><span class="main">.</span> <span class="var">?bad</span> <span class="bound">s1'</span> <span class="main">=</span> <span class="var">?bad</span> <span class="bound">s2'</span> <span class="main">∧</span> <span class="main">(</span><span class="main">¬</span> <span class="var">?bad</span> <span class="bound">s2'</span> <span class="main">⟶</span> <span class="bound">a</span> <span class="main">=</span> <span class="bound">b</span> <span class="main">∧</span> <span class="var">?X</span> <span class="bound">s1'</span> <span class="bound">s2'</span><span class="main">)</span><span class="main">)</span>
             <span class="main">(</span><span class="skolem">hash_oracle''</span> <span class="skolem">s1</span> <span class="skolem">plain</span><span class="main">)</span> <span class="main">(</span><span class="skolem">hash_oracle''</span> <span class="skolem">s2</span> <span class="skolem">plain</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="var">?X</span> <span class="skolem">s1</span> <span class="skolem">s2</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s1</span> <span class="skolem">s2</span> <span class="skolem">plain</span> <span class="keyword1"><span class="command">using</span></span> that
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_bind_reflI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hash_oracle''_def rel_spmf_return_spmf2 fun_upd_twist <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> fun_upd_eqD<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> inv<span class="main">:</span> <span class="quoted"><span class="quoted">"callee_invariant <span class="skolem">hash_oracle''</span> <span class="var">?bad</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hash_oracle''_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"rel_spmf <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">win</span><span class="main">,</span> <span class="bound">bad</span><span class="main">)</span> <span class="main">(</span><span class="bound">win'</span><span class="main">,</span> <span class="bound">bad'</span><span class="main">)</span><span class="main">.</span> <span class="bound">bad</span> <span class="main">=</span> <span class="bound">bad'</span> <span class="main">∧</span> <span class="main">(</span><span class="main">¬</span> <span class="bound">bad'</span> <span class="main">⟶</span> <span class="bound">win</span> <span class="main">=</span> <span class="bound">win'</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="skolem">game2</span> <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">(</span><span class="skolem">game1</span> <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> game1_def game2_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_def o_def hash.oracle_def rel_spmf_bind_reflI <span class="dynamic"><span class="dynamic">if_distribs</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_bind_reflI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> bind_spmf_const<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> rel_spmf_try_spmf<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> b msg1 msg2 σ s s_h
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> rel_spmf_bind_reflI<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> inv''.exec_gpv_invariant<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">s_h</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">*</span> <span class="skolem">y</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="comment1">― ‹case <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> None<span class="antiquote">}</span></span>›</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_bind_reflI<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> rel_spmf_bindI<span class="main">)</span>
           <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> exec_gpv_oracle_bisim_bad_full<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ _ bisim inv inv<span class="main"><span class="main">,</span></span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s1</span><span class="main">)</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">s2</span><span class="main">)</span><span class="main">.</span> <span class="var">?bad</span> <span class="bound">s1</span> <span class="main">=</span> <span class="var">?bad</span> <span class="bound">s2</span> <span class="main">∧</span> <span class="main">(</span><span class="main">¬</span> <span class="var">?bad</span> <span class="bound">s2</span> <span class="main">⟶</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">y</span><span class="main">)</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_upd_idem<span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_bindI1 rel_spmf_bindI2 lossless_exec_gpv<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> ℐ<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">ℐ_full</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> callee_invariant_on.exec_gpv_invariant<span class="main"><span class="main">[</span></span><span class="operator">OF</span> in_encrypt_oracle<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> rel_spmf_reflI<span class="main">)</span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"rel_spmf <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">win</span><span class="main">,</span> <span class="bound">bad</span><span class="main">)</span> <span class="main">(</span><span class="bound">win'</span><span class="main">,</span> <span class="bound">bad'</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">bad</span> <span class="main">⟷</span> <span class="bound">bad'</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">¬</span> <span class="bound">bad'</span> <span class="main">⟶</span> <span class="bound">win</span> <span class="main">⟷</span> <span class="bound">win'</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game2</span><span class="main">)</span> <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game1</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> rel_spmf_bind_reflI<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">¦</span>measure <span class="main">(</span>measure_spmf <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game2</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span><span class="main">}</span> <span class="main">-</span> measure <span class="main">(</span>measure_spmf <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game1</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="bound">y</span><span class="main">}</span><span class="main">¦</span>
        <span class="main">≤</span> measure <span class="main">(</span>measure_spmf <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game2</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">bad</span><span class="main">)</span><span class="main">.</span> <span class="bound">bad</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> split_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> fundamental_lemma<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"measure <span class="main">(</span>measure_spmf <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game2</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span><span class="main">}</span> <span class="main">=</span> spmf <span class="main">(</span>map_spmf fst <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game2</span><span class="main">)</span><span class="main">)</span> True"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"measure <span class="main">(</span>measure_spmf <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game1</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="bound">y</span><span class="main">}</span> <span class="main">=</span> spmf <span class="main">(</span>map_spmf fst <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game1</span><span class="main">)</span><span class="main">)</span> True"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"measure <span class="main">(</span>measure_spmf <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game2</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">bad</span><span class="main">)</span><span class="main">.</span> <span class="bound">bad</span><span class="main">}</span> <span class="main">=</span> spmf <span class="main">(</span>map_spmf snd <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game2</span><span class="main">)</span><span class="main">)</span> True"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> spmf_conv_measure_spmf measure_map_spmf <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> arg_cong2<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">measure</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> hop23<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¦</span>spmf <span class="main">(</span>map_spmf fst <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game2</span><span class="main">)</span><span class="main">)</span> True <span class="main">-</span> spmf <span class="main">(</span>map_spmf fst <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game1</span><span class="main">)</span><span class="main">)</span> True<span class="main">¦</span> <span class="main">≤</span> spmf <span class="main">(</span>map_spmf snd <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game2</span><span class="main">)</span><span class="main">)</span> True"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">game3</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">game3</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">f</span> <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> bitstring spmf <span class="main">⇒</span> <span class="main">_</span> spmf<span class="main">.</span> <span class="main">λ</span><span class="main">(</span><span class="bound">x</span> <span class="main">::</span> nat<span class="main">)</span> <span class="main">(</span><span class="bound">y</span> <span class="main">::</span> nat<span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
      <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="bound">msg1</span><span class="main">,</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">s_h</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">hash_oracle''</span> <span class="main">(</span><span class="skolem">𝒜1</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">{}</span><span class="main">,</span> hash.initial<span class="main">)</span><span class="main">;</span>
      <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span>valid_plains <span class="bound">msg1</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">h'</span> <span class="main">←</span> <span class="bound">f</span> <span class="bound">b</span> <span class="bound">msg1</span> <span class="bound">msg2</span> <span class="main">(</span>spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len_plain</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1">let</span> <span class="bound">cipher</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">y</span><span class="main">,</span> <span class="bound">h'</span><span class="main">)</span><span class="main">;</span>
        <span class="main">(</span><span class="bound">guess</span><span class="main">,</span> <span class="main">(</span><span class="bound">s'</span><span class="main">,</span> <span class="bound">s_h'</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">hash_oracle''</span> <span class="main">(</span><span class="skolem">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">s_h</span><span class="main">)</span><span class="main">;</span>
        return_spmf <span class="main">(</span><span class="bound">guess</span> <span class="main">=</span> <span class="bound">b</span><span class="main">,</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="bound">x</span> <span class="main">*</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="bound">s'</span><span class="main">)</span>
      <span class="main">}</span> <span class="keyword1">ELSE</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
        return_spmf <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="bound">x</span> <span class="main">*</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="bound">s</span><span class="main">)</span>
      <span class="main">}</span>
    <span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?f</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">b</span> <span class="bound">msg1</span> <span class="bound">msg2</span><span class="main">.</span> map_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">h</span><span class="main">.</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">msg1</span> <span class="keyword1">else</span> <span class="bound">msg2</span><span class="main">)</span> <span class="main">[⊕]</span> <span class="bound">h</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">game2</span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">=</span> <span class="skolem">game3</span> <span class="var">?f</span> <span class="skolem">x</span> <span class="skolem">y</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
    <span class="keyword1"><span class="command">unfolding</span></span> game2_def game3_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def bind_map_spmf xor_list_commute o_def nat_pow_pow<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">game3</span> <span class="var">?f</span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">=</span> <span class="skolem">game3</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span> <span class="skolem">x</span> <span class="skolem">y</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="comment1">(* optimistic sampling *)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> game3_def
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> try_spmf_cong bind_spmf_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span> if_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_def one_time_pad valid_plains_def <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> map_spmf_of_set_inj_on bind_spmf_const <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> game23<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">game2</span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">=</span> <span class="skolem">game3</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span> <span class="skolem">x</span> <span class="skolem">y</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">hash_oracle'''</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">hash_oracle'''</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">σ</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span><span class="main">.</span> hash.oracle <span class="bound">σ</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">bisim</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">bisim</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span> <span class="main">(</span><span class="bound">s</span> <span class="main">::</span> <span class="tfree">'a</span> set<span class="main">,</span> <span class="bound">σ'</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">⇀</span> bitstring<span class="main">)</span><span class="main">.</span> <span class="bound">s</span> <span class="main">=</span> dom <span class="bound">σ</span> <span class="main">∧</span> <span class="bound">σ</span> <span class="main">=</span> <span class="bound">σ'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">bisim</span> Map_empty <span class="main">(</span><span class="main">{}</span><span class="main">,</span> Map_empty<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bisim_def<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">bisim</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> rel_spmf <span class="main">(</span>rel_prod <span class="main">(=)</span> <span class="skolem">bisim</span><span class="main">)</span><span class="main">)</span> <span class="skolem">hash_oracle'''</span> <span class="skolem">hash_oracle''</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hash_oracle''_def split_def hash_oracle'''_def spmf_rel_map hash.oracle_def rel_fun_def bisim_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_bind_reflI<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> * <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">bisim</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> dom fst"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bisim_def rel_fun_def<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> * <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">bisim</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span> snd"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def bisim_def<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">game3</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
        <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="bound">msg1</span><span class="main">,</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">hash_oracle'''</span> <span class="main">(</span><span class="skolem">𝒜1</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span> hash.initial<span class="main">;</span>
        <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span>valid_plains <span class="bound">msg1</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">;</span>
          <span class="bound">h'</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len_plain</span><span class="main">)</span><span class="main">;</span>
          <span class="keyword1">let</span> <span class="bound">cipher</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">y</span><span class="main">,</span> <span class="bound">h'</span><span class="main">)</span><span class="main">;</span>
          <span class="main">(</span><span class="bound">guess</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">hash_oracle'''</span> <span class="main">(</span><span class="skolem">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="bound">s</span><span class="main">;</span>
          return_spmf <span class="main">(</span><span class="bound">guess</span> <span class="main">=</span> <span class="bound">b</span><span class="main">,</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">*</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> dom <span class="bound">s'</span><span class="main">)</span>
        <span class="main">}</span> <span class="keyword1">ELSE</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
          return_spmf <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">*</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> dom <span class="bound">s</span><span class="main">)</span>
        <span class="main">}</span>
      <span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
      <span class="keyword1"><span class="command">unfolding</span></span> game3_def Map_empty_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> split_def fst_conv snd_conv prod.collapse
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">𝒜1</span></span> <span class="quoted"><span class="free">𝒢</span></span> <span class="quoted"><span class="free">len_plain</span></span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="skolem">y</span></span> <span class="quoted"><span class="skolem">𝒜2</span></span><span class="main">)</span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_spmf snd <span class="main">(</span><span class="main">…</span> <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">zs</span> <span class="main">←</span> elgamal_adversary <span class="free">𝒜</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">y</span><span class="main">)</span><span class="main">;</span>
        return_spmf <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">*</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="bound">zs</span><span class="main">)</span>
      <span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def split_def hash_oracle'''_def map_try_spmf map_scale_spmf<span class="main">)</span>
        <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def map_try_spmf map_scale_spmf map_spmf_conv_bind_spmf<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> spmf.map_comp map_const_spmf_of_set<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_spmf snd <span class="main">(</span><span class="var">?sample</span> <span class="main">(</span><span class="skolem">game3</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> lcdh.lcdh <span class="main">(</span>elgamal_adversary <span class="free">𝒜</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def lcdh.lcdh_def Let_def nat_pow_pow<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> game2_snd<span class="main">:</span> <span class="quoted"><span class="quoted">"map_spmf snd <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game2</span><span class="main">)</span> <span class="main">=</span> lcdh.lcdh <span class="main">(</span>elgamal_adversary <span class="free">𝒜</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> game23 <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def<span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_spmf fst <span class="main">(</span><span class="skolem">game3</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span> <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="bound">msg1</span><span class="main">,</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">s_h</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">hash_oracle''</span> <span class="main">(</span><span class="skolem">𝒜1</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">{}</span><span class="main">,</span> hash.initial<span class="main">)</span><span class="main">;</span>
      <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span>valid_plains <span class="bound">msg1</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">h'</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len_plain</span><span class="main">)</span><span class="main">;</span>
        <span class="main">(</span><span class="bound">guess</span><span class="main">,</span> <span class="main">(</span><span class="bound">s'</span><span class="main">,</span> <span class="bound">s_h'</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">hash_oracle''</span> <span class="main">(</span><span class="skolem">𝒜2</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">y</span><span class="main">,</span> <span class="bound">h'</span><span class="main">)</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">s_h</span><span class="main">)</span><span class="main">;</span>
        map_spmf <span class="main">(</span><span class="main">(=)</span> <span class="bound">guess</span><span class="main">)</span> coin_spmf
      <span class="main">}</span> <span class="keyword1">ELSE</span> coin_spmf
    <span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">y</span> 
    <span class="keyword1"><span class="command">including</span></span> monad_normalisation
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> game3_def o_def split_def map_spmf_conv_bind_spmf try_spmf_bind_out weight_spmf_le_1 scale_bind_spmf try_spmf_bind_out1 bind_scale_spmf<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> game3_fst<span class="main">:</span> <span class="quoted"><span class="quoted">"map_spmf fst <span class="main">(</span><span class="skolem">game3</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span> <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">=</span> coin_spmf"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def <span class="dynamic"><span class="dynamic">if_distribs</span></span> spmf.map_comp map_eq_const_coin_spmf split_def<span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ind_cpa.advantage hash.oracle hash.initial <span class="free">𝒜</span> <span class="main">=</span> <span class="main">¦</span>spmf <span class="main">(</span>map_spmf fst <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game1</span><span class="main">)</span><span class="main">)</span> True <span class="main">-</span> <span class="main">1</span> <span class="main">/</span> <span class="numeral">2</span><span class="main">¦</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> game0 <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ind_cpa_pk.advantage_def game01 o_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">¦</span><span class="main">1</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">-</span> spmf <span class="main">(</span>map_spmf fst <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game1</span><span class="main">)</span><span class="main">)</span> True<span class="main">¦</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> abs_minus_commute<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">=</span> spmf <span class="main">(</span>map_spmf fst <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game2</span><span class="main">)</span><span class="main">)</span> True"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> game23 o_def game3_fst spmf_of_set<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> hop23 <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> game2_snd
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lcdh.advantage_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> elgamal_base <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_key_gen <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf key_gen <span class="main">⟷</span> <span class="main">0</span> <span class="main">&lt;</span> order <span class="free">𝒢</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> key_gen_def Let_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_elgamal_adversary<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> ind_cpa.lossless <span class="free">𝒜</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">η</span><span class="main">.</span> <span class="main">0</span> <span class="main">&lt;</span> order <span class="free">𝒢</span> <span class="main">⟧</span>
  <span class="main">⟹</span> lcdh.lossless <span class="main">(</span>elgamal_adversary <span class="free">𝒜</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">𝒜</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lcdh.lossless_def ind_cpa.lossless_def split_def Let_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> lossless_exec_gpv<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> ℐ<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">ℐ_full</span><span class="main"><span class="main">]</span></span> lossless_inline<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="RP_RF">
<div class="head">
<h1>Theory RP_RF</h1>
</div>
<pre class="source"><span class="comment1">(* Title: RP_RF.thy
  Author: Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The random-permutation random-function switching lemma›</span></span>

<span class="keyword1"><span class="command">theory</span></span> RP_RF <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Pseudo_Random_Function.html">Pseudo_Random_Function</a>
  <a href="Pseudo_Random_Permutation.html">Pseudo_Random_Permutation</a>
  <a href="../CryptHOL/GPV_Bisim.html">CryptHOL.GPV_Bisim</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> rp_resample<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">⊆</span> <span class="free">A</span> <span class="main">∪</span> <span class="free">C</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">∩</span> <span class="free">C</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">C</span> <span class="main">⊆</span> <span class="free">B</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> finB<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"bind_spmf <span class="main">(</span>spmf_of_set <span class="free">B</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">A</span> <span class="keyword1">then</span> spmf_of_set <span class="free">C</span> <span class="keyword1">else</span> return_spmf <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> spmf_of_set <span class="free">C</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">C</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">∨</span> <span class="free">A</span> <span class="main">∩</span> <span class="free">B</span> <span class="main">=</span> <span class="main">{}</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">A'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A'</span> <span class="main">≡</span> <span class="free">A</span> <span class="main">∩</span> <span class="free">B</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> False <span class="keyword1"><span class="command">have</span></span> C<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">C</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> A'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A'</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> A'_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">=</span> <span class="skolem">A'</span> <span class="main">∪</span> <span class="free">C</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> A'_def<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> finB <span class="keyword1"><span class="command">have</span></span> finA<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="skolem">A'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> finC<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">C</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> A'C<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A'</span> <span class="main">∩</span> <span class="free">C</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> A'_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"bind_spmf <span class="main">(</span>spmf_of_set <span class="free">B</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">A</span> <span class="keyword1">then</span> spmf_of_set <span class="free">C</span> <span class="keyword1">else</span> return_spmf <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> 
        bind_spmf <span class="main">(</span>spmf_of_set <span class="free">B</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">∈</span> <span class="skolem">A'</span> <span class="keyword1">then</span> spmf_of_set <span class="free">C</span> <span class="keyword1">else</span> return_spmf <span class="bound">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> bind_spmf_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_spmf_of_set finB A'_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> spmf_of_set <span class="free">C</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> spmf_eqI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">x</span><span class="main">∈</span><span class="free">C</span><span class="main">.</span> spmf <span class="main">(</span><span class="keyword1">if</span> <span class="bound">x</span> <span class="main">∈</span> <span class="skolem">A'</span> <span class="keyword1">then</span> spmf_of_set <span class="free">C</span> <span class="keyword1">else</span> return_spmf <span class="bound">x</span><span class="main">)</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">=</span> indicator <span class="free">C</span> <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> finA finC 
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> disjoint_notin1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> A'C<span class="main"><span class="main">]</span></span> indicator_single_Some sum_mult_indicator<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">C</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">1</span> <span class="main">::</span> real"</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">_</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span>"</span></span><span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> split_indicator <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> conj_cong sum.cong<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"spmf <span class="var">?lhs</span> <span class="skolem">i</span> <span class="main">=</span> spmf <span class="var">?rhs</span> <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> B finA finC A'C C A'
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf_bind integral_spmf_of_set sum_Un spmf_of_set <span class="dynamic"><span class="dynamic">field_simps</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">field_simps</span></span> card_Un_disjoint<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">use</span> assms <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted">‹<span class="operator">auto</span> 4 3 <span class="quasi_keyword">cong</span><span class="main">:</span> bind_spmf_cong_simp <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main">:</span> subsetD bind_spmf_const spmf_of_set_empty disjoint_notin1 <span class="quasi_keyword">intro</span><span class="main">!</span><span class="main">:</span> arg_cong<span class="main">[</span><span class="operator">where</span> f<span class="main"><span class="main">=</span></span><span class="quoted">spmf_of_set</span><span class="main">]</span>›</span><span class="main">)</span>

<span class="keyword1"><span class="command">locale</span></span> rp_rf <span class="main">=</span>
  rp<span class="main">:</span> random_permutation <span class="quoted"><span class="free">A</span></span> <span class="main">+</span>
  rf<span class="main">:</span> random_function <span class="quoted"><span class="quoted">"spmf_of_set <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> finite_A<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> nonempty_A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'a'</span> adversary <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>bool<span class="main">,</span> <span class="tfree">'a'</span><span class="main">,</span> <span class="tfree">'a'</span><span class="main">)</span> gpv"</span></span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">game</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"bool <span class="main">⇒</span> <span class="tfree">'a</span> adversary <span class="main">⇒</span> bool spmf"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">game</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> run_gpv <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="keyword1">then</span> rp.random_permutation <span class="keyword1">else</span> rf.random_oracle<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> Map.empty"</span></span>
  
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">prp_game</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> adversary <span class="main">⇒</span> bool spmf"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">prp_game</span> <span class="main">≡</span> game True"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">prf_game</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> adversary <span class="main">⇒</span> bool spmf"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">prf_game</span> <span class="main">≡</span> game False"</span></span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">advantage</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> adversary <span class="main">⇒</span> real"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">advantage</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> <span class="main">¦</span>spmf <span class="main">(</span>prp_game <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span><span class="main">)</span> True <span class="main">-</span> spmf <span class="main">(</span>prf_game <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span><span class="main">)</span> True<span class="main">¦</span>"</span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> advantage_nonneg<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≤</span> advantage <span class="free">𝒜</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> advantage_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> advantage_le_1<span class="main">:</span> <span class="quoted"><span class="quoted">"advantage <span class="free">𝒜</span> <span class="main">≤</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> advantage_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> abs_leI<span class="main">)</span><span class="main">(</span><span class="operator">metis</span> diff_0_right diff_left_mono order_trans pmf_le_1 pmf_nonneg<span class="main">)</span> <span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> ℐ.lifting <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> ℐ <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> ℐ"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">A</span> <span class="keyword1">then</span> <span class="free">A</span> <span class="keyword1">else</span> <span class="main">{}</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lemma</span></span> outs_ℐ_ℐ <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"outs_ℐ ℐ <span class="main">=</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">lemma</span></span> responses_ℐ_ℐ <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"responses_ℐ ℐ <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">∈</span> <span class="free">A</span> <span class="keyword1">then</span> <span class="free">A</span> <span class="keyword1">else</span> <span class="main">{}</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lifting_update</span></span> ℐ.lifting
<span class="keyword1"><span class="command">lifting_forget</span></span> ℐ.lifting
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> rp_rf<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> bound<span class="main">:</span> <span class="quoted"><span class="quoted">"interaction_any_bounded_by <span class="free">𝒜</span> <span class="free">q</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> lossless<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_gpv ℐ <span class="free">𝒜</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> WT<span class="main">:</span> <span class="quoted"><span class="quoted">"ℐ <span class="keyword1">⊢g</span> <span class="free">𝒜</span> <span class="main">√</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"advantage <span class="free">𝒜</span> <span class="main">≤</span> <span class="free">q</span> <span class="main">*</span> <span class="free">q</span> <span class="main">/</span> card <span class="free">A</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> lifting_syntax  
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?run</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">b</span><span class="main">.</span> exec_gpv <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> rp.random_permutation <span class="keyword1">else</span> rf.random_oracle<span class="main">)</span> <span class="free">𝒜</span> Map.empty"</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">rp_bad</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"bool <span class="main">×</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇀</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="main">(</span>bool <span class="main">×</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇀</span> <span class="tfree">'a</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> spmf"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">rp_bad</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">bad</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">σ</span> <span class="bound">x</span> <span class="keyword1">of</span> Some <span class="bound">y</span> <span class="main">⇒</span> return_spmf <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="main">(</span><span class="bound">bad</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">)</span>
      <span class="main">|</span> None <span class="main">⇒</span> bind_spmf <span class="main">(</span>spmf_of_set <span class="free">A</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">y</span> <span class="main">∈</span> ran <span class="bound">σ</span> <span class="keyword1">then</span> map_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">y'</span><span class="main">.</span> <span class="main">(</span><span class="bound">y'</span><span class="main">,</span> <span class="main">(</span>True<span class="main">,</span> <span class="bound">σ</span><span class="main">(</span><span class="bound">x</span> <span class="main">↦</span> <span class="bound">y'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>spmf_of_set <span class="main">(</span><span class="free">A</span> <span class="main">-</span> ran <span class="bound">σ</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> return_spmf <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="main">(</span><span class="bound">bad</span><span class="main">,</span> <span class="main">(</span><span class="bound">σ</span><span class="main">(</span><span class="bound">x</span> <span class="main">↦</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> rp_bad_simps<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">rp_bad</span> <span class="main">(</span><span class="skolem">bad</span><span class="main">,</span> <span class="skolem">σ</span><span class="main">)</span> <span class="skolem">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="skolem">σ</span> <span class="skolem">x</span> <span class="keyword1">of</span> Some <span class="bound">y</span> <span class="main">⇒</span> return_spmf <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="main">(</span><span class="skolem">bad</span><span class="main">,</span> <span class="skolem">σ</span><span class="main">)</span><span class="main">)</span>
      <span class="main">|</span> None <span class="main">⇒</span> bind_spmf <span class="main">(</span>spmf_of_set <span class="free">A</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">y</span> <span class="main">∈</span> ran <span class="skolem">σ</span> <span class="keyword1">then</span> map_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">y'</span><span class="main">.</span> <span class="main">(</span><span class="bound">y'</span><span class="main">,</span> <span class="main">(</span>True<span class="main">,</span> <span class="skolem">σ</span><span class="main">(</span><span class="skolem">x</span> <span class="main">↦</span> <span class="bound">y'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>spmf_of_set <span class="main">(</span><span class="free">A</span> <span class="main">-</span> ran <span class="skolem">σ</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> return_spmf <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="main">(</span><span class="skolem">bad</span><span class="main">,</span> <span class="main">(</span><span class="skolem">σ</span><span class="main">(</span><span class="skolem">x</span> <span class="main">↦</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">bad</span> <span class="skolem">σ</span> <span class="skolem">x</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rp_bad_def<span class="main">)</span>

  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?S</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"rel_prod2 <span class="main">(=)</span>"</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">init</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"bool <span class="main">×</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇀</span> <span class="tfree">'a</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">init</span> <span class="main">=</span> <span class="main">(</span>False<span class="main">,</span> Map.empty<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> rp<span class="main">:</span> <span class="quoted"><span class="quoted">"rp.random_permutation <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">σ</span> <span class="bound">x</span> <span class="keyword1">of</span> Some <span class="bound">y</span> <span class="main">⇒</span> return_spmf <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> 
    <span class="main">|</span> None <span class="main">⇒</span> bind_spmf <span class="main">(</span>bind_spmf <span class="main">(</span>spmf_of_set <span class="free">A</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">y</span> <span class="main">∈</span> ran <span class="bound">σ</span> <span class="keyword1">then</span> spmf_of_set <span class="main">(</span><span class="free">A</span> <span class="main">-</span> ran <span class="bound">σ</span><span class="main">)</span> <span class="keyword1">else</span> return_spmf <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> return_spmf <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">σ</span><span class="main">(</span><span class="bound">x</span> <span class="main">↦</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> rp_resample<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_A rp.random_permutation_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?S</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> rel_spmf <span class="main">(</span>rel_prod <span class="main">(=)</span> <span class="var">?S</span><span class="main">)</span><span class="main">)</span> rp.random_permutation <span class="skolem">rp_bad</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> rp rp_bad_def
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def map_spmf_conv_bind_spmf <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_bind_reflI<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?S</span> Map.empty <span class="skolem">init</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> init_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>prp_game <span class="free">𝒜</span><span class="main">)</span> True <span class="main">=</span> spmf <span class="main">(</span>run_gpv <span class="skolem">rp_bad</span> <span class="free">𝒜</span> <span class="skolem">init</span><span class="main">)</span> True"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> vimage_def game_def if_True <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">collision</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇀</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">collision</span> <span class="skolem">m</span> <span class="main">⟷</span> <span class="main">¬</span> inj_on <span class="skolem">m</span> <span class="main">(</span>dom <span class="skolem">m</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="skolem">collision</span> Map.empty"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> collision_def<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="skolem">collision</span> <span class="skolem">m</span><span class="main">;</span> <span class="skolem">m</span> <span class="skolem">x</span> <span class="main">=</span> None <span class="main">⟧</span> <span class="main">⟹</span> <span class="skolem">collision</span> <span class="main">(</span><span class="skolem">m</span><span class="main">(</span><span class="skolem">x</span> <span class="main">:=</span> <span class="skolem">y</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="skolem">x</span> <span class="skolem">y</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> collision_def fun_upd_idem dom_minus fun_upd_image <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> inj_on_fun_updD<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> collision_map_updI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="skolem">m</span> <span class="skolem">x</span> <span class="main">=</span> None<span class="main">;</span> <span class="skolem">y</span> <span class="main">∈</span> ran <span class="skolem">m</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="skolem">collision</span> <span class="main">(</span><span class="skolem">m</span><span class="main">(</span><span class="skolem">x</span> <span class="main">↦</span> <span class="skolem">y</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="skolem">x</span> <span class="skolem">y</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> collision_def ran_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_image_eqI<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> collision_map_upd_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="skolem">collision</span> <span class="skolem">m</span> <span class="main">⟹</span> <span class="skolem">collision</span> <span class="main">(</span><span class="skolem">m</span><span class="main">(</span><span class="skolem">x</span> <span class="main">↦</span> <span class="skolem">y</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> <span class="skolem">y</span> <span class="main">∈</span> ran <span class="skolem">m</span> <span class="main">∧</span> <span class="skolem">m</span> <span class="skolem">x</span> <span class="main">≠</span> Some <span class="skolem">y</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="skolem">x</span> <span class="skolem">y</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> collision_def ran_def fun_upd_idem <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> inj_on_fun_updI rev_image_eqI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> inj_on_eq_iff<span class="main">)</span>
  
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?bad1</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="skolem">collision</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="var"><span class="quoted"><span class="var">?bad2</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"fst"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="var"><span class="quoted"><span class="var">?X</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">σ1</span> <span class="main">(</span><span class="bound">bad</span><span class="main">,</span> <span class="bound">σ2</span><span class="main">)</span><span class="main">.</span> <span class="bound">σ1</span> <span class="main">=</span> <span class="bound">σ2</span> <span class="main">∧</span> <span class="main">¬</span> <span class="skolem">collision</span> <span class="bound">σ1</span> <span class="main">∧</span> <span class="main">¬</span> <span class="bound">bad</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="var"><span class="quoted"><span class="var">?I1</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">σ1</span><span class="main">.</span> dom <span class="bound">σ1</span> <span class="main">⊆</span> <span class="free">A</span> <span class="main">∧</span> ran <span class="bound">σ1</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="var"><span class="quoted"><span class="var">?I2</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">bad</span><span class="main">,</span> <span class="bound">σ2</span><span class="main">)</span><span class="main">.</span> dom <span class="bound">σ2</span> <span class="main">⊆</span> <span class="free">A</span> <span class="main">∧</span> ran <span class="bound">σ2</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?X_bad</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">σ1</span> <span class="bound">s2</span><span class="main">.</span> <span class="var">?I1</span> <span class="bound">σ1</span> <span class="main">∧</span> <span class="var">?I2</span> <span class="bound">s2</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ℐ <span class="keyword1">⊢c</span> rf.random_oracle <span class="skolem">s1</span> <span class="main">√</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"ran <span class="skolem">s1</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s1</span> <span class="keyword1"><span class="command">using</span></span> that
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> WT_calleeI<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rf.random_oracle_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> finite_A nonempty_A ran_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"callee_invariant_on rf.random_oracle <span class="var">?I1</span> ℐ"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rf.random_oracle_def finite_A <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> rf<span class="main">:</span> callee_invariant_on <span class="quoted">rf.random_oracle</span> <span class="var"><span class="quoted"><span class="var">?I1</span></span></span> <span class="quoted">ℐ</span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ℐ <span class="keyword1">⊢c</span> <span class="skolem">rp_bad</span> <span class="skolem">s2</span> <span class="main">√</span> "</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"ran <span class="main">(</span>snd <span class="skolem">s2</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s2</span> <span class="keyword1"><span class="command">using</span></span> that
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> WT_calleeI<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rp_bad_def finite_A <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split_asm option.split_asm if_split_asm <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ranI<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"callee_invariant_on rf.random_oracle <span class="main">(</span><span class="main">λ</span><span class="bound">σ1</span><span class="main">.</span> <span class="var">?bad1</span> <span class="bound">σ1</span> <span class="main">∧</span> <span class="var">?I1</span> <span class="bound">σ1</span><span class="main">)</span> ℐ"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rf.random_oracle_def finite_A  <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"callee_invariant_on <span class="skolem">rp_bad</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s2</span><span class="main">.</span> <span class="var">?I2</span> <span class="bound">s2</span><span class="main">)</span> ℐ"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rp_bad_simps finite_A <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits if_split_asm <span class="quasi_keyword">iff</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> domIff<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"callee_invariant_on <span class="skolem">rp_bad</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s2</span><span class="main">.</span> <span class="var">?bad2</span> <span class="bound">s2</span> <span class="main">∧</span> <span class="var">?I2</span> <span class="bound">s2</span><span class="main">)</span> ℐ"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rp_bad_simps finite_A <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits if_split_asm <span class="quasi_keyword">iff</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> domIff<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ℐ <span class="keyword1">⊢c</span> <span class="skolem">rp_bad</span> <span class="main">(</span><span class="skolem">bad</span><span class="main">,</span> <span class="skolem">σ2</span><span class="main">)</span> <span class="main">√</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"ran <span class="skolem">σ2</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">bad</span> <span class="skolem">σ2</span> <span class="keyword1"><span class="command">using</span></span> that
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> WT_calleeI<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rp_bad_def finite_A nonempty_A ran_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm if_split_asm<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span><span class="skolem">rp_bad</span> <span class="main">(</span><span class="skolem">b</span><span class="main">,</span> <span class="skolem">σ2</span><span class="main">)</span> <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"dom <span class="skolem">σ2</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"ran <span class="skolem">σ2</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">b</span> <span class="skolem">σ2</span> <span class="skolem">x</span>
      <span class="keyword1"><span class="command">using</span></span> finite_A that <span class="keyword1"><span class="command">unfolding</span></span> rp_bad_def
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nonempty_A dom_subset_ran_iff eq_None_iff_not_dom <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"rel_spmf <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">b1</span><span class="main">,</span> <span class="bound">σ1</span><span class="main">)</span> <span class="main">(</span><span class="bound">b2</span><span class="main">,</span> <span class="bound">state2</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="var">?bad1</span> <span class="bound">σ1</span> <span class="main">⟷</span> <span class="var">?bad2</span> <span class="bound">state2</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="keyword1">if</span> <span class="var">?bad2</span> <span class="bound">state2</span> <span class="keyword1">then</span> <span class="var">?X_bad</span> <span class="bound">σ1</span> <span class="bound">state2</span> <span class="keyword1">else</span> <span class="bound">b1</span> <span class="main">=</span> <span class="bound">b2</span> <span class="main">∧</span> <span class="var">?X</span> <span class="bound">σ1</span> <span class="bound">state2</span><span class="main">)</span><span class="main">)</span>
            <span class="main">(</span><span class="main">(</span><span class="keyword1">if</span> False <span class="keyword1">then</span> rp.random_permutation <span class="keyword1">else</span> rf.random_oracle<span class="main">)</span> <span class="skolem">s1</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="skolem">rp_bad</span> <span class="skolem">s2</span> <span class="skolem">x</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="var">?X</span> <span class="skolem">s1</span> <span class="skolem">s2</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> outs_ℐ ℐ"</span></span> <span class="quoted"><span class="quoted">"<span class="var">?I1</span> <span class="skolem">s1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="var">?I2</span> <span class="skolem">s2</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s1</span> <span class="skolem">s2</span> <span class="skolem">x</span> <span class="keyword1"><span class="command">using</span></span> that finite_A
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rf.random_oracle_def rp_bad_def rel_spmf_return_spmf1 collision_map_updI dom_subset_ran_iff eq_None_iff_not_dom collision_map_upd_iff <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_bind_reflI<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> _ _ <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"rel_spmf
       <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">b1</span><span class="main">,</span> <span class="bound">σ1</span><span class="main">)</span> <span class="main">(</span><span class="bound">b2</span><span class="main">,</span> <span class="bound">state2</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="var">?bad1</span> <span class="bound">σ1</span> <span class="main">⟷</span> <span class="var">?bad2</span> <span class="bound">state2</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="keyword1">if</span> <span class="var">?bad2</span> <span class="bound">state2</span> <span class="keyword1">then</span> <span class="var">?X_bad</span> <span class="bound">σ1</span> <span class="bound">state2</span> <span class="keyword1">else</span> <span class="bound">b1</span> <span class="main">=</span> <span class="bound">b2</span> <span class="main">∧</span> <span class="var">?X</span> <span class="bound">σ1</span> <span class="bound">state2</span><span class="main">)</span><span class="main">)</span>
       <span class="main">(</span><span class="var">?run</span> False<span class="main">)</span> <span class="main">(</span>exec_gpv <span class="skolem">rp_bad</span> <span class="free">𝒜</span> <span class="skolem">init</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> exec_gpv_oracle_bisim_bad_invariant<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> ℐ <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted">ℐ</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> <span class="var">?I1.0</span> <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted">"<span class="var">?I1</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> <span class="var">?I2.0</span><span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="var">?I2</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> init_def WT lossless finite_A nonempty_A<span class="main">)</span>
   <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¦</span>spmf <span class="main">(</span>map_spmf fst <span class="main">(</span><span class="var">?run</span> False<span class="main">)</span><span class="main">)</span> True <span class="main">-</span> spmf <span class="main">(</span>run_gpv <span class="skolem">rp_bad</span> <span class="free">𝒜</span> <span class="skolem">init</span><span class="main">)</span> True<span class="main">¦</span> <span class="main">≤</span> spmf <span class="main">(</span>map_spmf <span class="main">(</span><span class="var">?bad1</span> <span class="main">∘</span> snd<span class="main">)</span> <span class="main">(</span><span class="var">?run</span> False<span class="main">)</span><span class="main">)</span> True"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> spmf_conv_measure_spmf measure_map_spmf vimage_def
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> fundamental_lemma<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="var">?bad2.0</span><span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">s2</span><span class="main">)</span><span class="main">.</span> <span class="var">?bad2</span> <span class="bound">s2</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rel_spmf_mono<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ennreal <span class="main">…</span> <span class="main">≤</span> ennreal <span class="main">(</span><span class="free">q</span> <span class="main">/</span> card <span class="free">A</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>enat <span class="free">q</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> if_False <span class="keyword1"><span class="command">using</span></span> bound _ _ _ _ _ _ _ WT
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> rf.interaction_bounded_by_exec_gpv_bad_count<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> count<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">s</span><span class="main">.</span> card <span class="main">(</span>dom <span class="bound">s</span><span class="main">)</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rf.random_oracle_def finite_A nonempty_A card_insert_if finite_subset<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ finite_A<span class="main"><span class="main">]</span></span> map_spmf_conv_bind_spmf<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> spmf.map_comp o_def collision_map_upd_iff map_mem_spmf_of_set card_gt_0_iff card_mono <span class="dynamic"><span class="dynamic">field_simps</span></span> Int_absorb2 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> card_ran_le_dom<span class="main"><span class="main">[</span></span><span class="operator">OF</span> finite_subset<span class="main"><span class="main">,</span></span> <span class="operator">OF</span> _ finite_A<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> order_trans<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>map_spmf <span class="main">(</span><span class="var">?bad1</span> <span class="main">∘</span> snd<span class="main">)</span> <span class="main">(</span><span class="var">?run</span> False<span class="main">)</span><span class="main">)</span> True <span class="main">≤</span> <span class="free">q</span> <span class="main">*</span> <span class="free">q</span> <span class="main">/</span> card <span class="free">A</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ennreal_of_nat_eq_real_of_nat ennreal_times_divide ennreal_mult''<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¦</span>spmf <span class="main">(</span>run_gpv <span class="skolem">rp_bad</span> <span class="free">𝒜</span> <span class="skolem">init</span><span class="main">)</span> True <span class="main">-</span> spmf <span class="main">(</span>run_gpv rf.random_oracle <span class="free">𝒜</span> Map.empty<span class="main">)</span> True<span class="main">¦</span> <span class="main">≤</span> <span class="free">q</span> <span class="main">*</span> <span class="free">q</span> <span class="main">/</span> card <span class="free">A</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> advantage_def game_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="PRF_UHF">
<div class="head">
<h1>Theory PRF_UHF</h1>
</div>
<pre class="source"><span class="comment1">(* Title: PRF_UHF.thy 
  Author: Bhargav Bhatt, ETH Zurich
  Author: Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Extending the input length of a PRF using a universal hash function›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ This example is taken from \cite[\S 4.2]{Shoup2004IACR}.›</span></span>

<span class="keyword1"><span class="command">theory</span></span> PRF_UHF <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../CryptHOL/GPV_Bisim.html">CryptHOL.GPV_Bisim</a>
  <a href="Pseudo_Random_Function.html">Pseudo_Random_Function</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">locale</span></span> <span class="quoted">"hash"</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">seed_gen</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'seed</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">"<span class="free">hash</span>"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'seed</span> <span class="main">⇒</span> <span class="tfree">'domain</span> <span class="main">⇒</span> <span class="tfree">'range</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">game_hash</span> <span class="main">::</span> <span class="quoted"><span class="quoted">" <span class="tfree">'domain</span> <span class="main">⇒</span> <span class="tfree">'domain</span> <span class="main">⇒</span> bool spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> 
 <span class="quoted"><span class="quoted">"<span class="free">game_hash</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">w'</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">seed</span> <span class="main">←</span> <span class="free">seed_gen</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="free">hash</span> <span class="bound">seed</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">=</span> <span class="free">hash</span> <span class="bound">seed</span> <span class="free"><span class="bound"><span class="entity">w'</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">≠</span> <span class="free"><span class="bound"><span class="entity">w'</span></span></span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">game_hash_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'domain</span> set <span class="main">⇒</span> bool spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">game_hash_set</span> <span class="free"><span class="bound"><span class="entity">W</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
     <span class="bound">seed</span>  <span class="main">←</span> <span class="free">seed_gen</span><span class="main">;</span>
     return_spmf <span class="main">(</span><span class="main">¬</span> inj_on <span class="main">(</span><span class="free">hash</span> <span class="bound">seed</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">W</span></span></span><span class="main">)</span>
   <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ε_uh</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"real"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ε_uh</span>  <span class="main">=</span> <span class="main">(</span><span class="keyword1">SUP</span> <span class="bound">w</span> <span class="bound">w'</span><span class="main">.</span> spmf <span class="main">(</span>game_hash <span class="bound">w</span> <span class="bound">w'</span><span class="main">)</span> True<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ε_uh_nonneg <span class="main">:</span> <span class="quoted"><span class="quoted">"ε_uh <span class="main">≥</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> cSUP_upper2 bdd_aboveI2<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> M<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="main">1</span></span><span class="main"><span class="main">]</span></span> cSUP_least pmf_le_1 pmf_nonneg <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ε_uh_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> hash_ineq_card<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">W</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>game_hash_set <span class="free">W</span><span class="main">)</span> True <span class="main">≤</span> ε_uh <span class="main">*</span> card <span class="free">W</span> <span class="main">*</span> card <span class="free">W</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?M</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"measure <span class="main">(</span>measure_spmf <span class="free">seed_gen</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> bound<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?M</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free">hash</span> <span class="bound">x</span> <span class="skolem">w</span> <span class="main">=</span> <span class="free">hash</span> <span class="bound">x</span> <span class="skolem">w'</span> <span class="main">∧</span> <span class="skolem">w</span> <span class="main">≠</span> <span class="skolem">w'</span><span class="main">}</span> <span class="main">≤</span> ε_uh"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">w</span> <span class="skolem">w'</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?M</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free">hash</span> <span class="bound">x</span> <span class="skolem">w</span> <span class="main">=</span> <span class="free">hash</span> <span class="bound">x</span> <span class="skolem">w'</span> <span class="main">∧</span> <span class="skolem">w</span> <span class="main">≠</span> <span class="skolem">w'</span><span class="main">}</span> <span class="main">=</span> spmf <span class="main">(</span>game_hash <span class="skolem">w</span> <span class="skolem">w'</span><span class="main">)</span> True"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> game_hash_def spmf_conv_measure_spmf map_spmf_conv_bind_spmf<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> measure_map_spmf vimage_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> ε_uh"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> ε_uh_def
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> cSUP_upper2 bdd_aboveI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> M<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="main">1</span></span><span class="main"><span class="main">]</span></span> cSUP_least <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pmf_le_1<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>game_hash_set <span class="free">W</span><span class="main">)</span> True <span class="main">=</span> <span class="var">?M</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="main">∃</span><span class="bound">xa</span><span class="main">∈</span><span class="free">W</span><span class="main">.</span> <span class="main">∃</span><span class="bound">y</span><span class="main">∈</span><span class="free">W</span><span class="main">.</span> <span class="free">hash</span> <span class="bound">x</span> <span class="bound">xa</span> <span class="main">=</span> <span class="free">hash</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">∧</span> <span class="bound">xa</span> <span class="main">≠</span> <span class="bound">y</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> game_hash_set_def inj_on_def map_spmf_conv_bind_spmf<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> spmf_conv_measure_spmf measure_map_spmf vimage_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="main">∃</span><span class="bound">xa</span><span class="main">∈</span><span class="free">W</span><span class="main">.</span> <span class="main">∃</span><span class="bound">y</span><span class="main">∈</span><span class="free">W</span><span class="main">.</span> <span class="free">hash</span> <span class="bound">x</span> <span class="bound">xa</span> <span class="main">=</span> <span class="free">hash</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">∧</span> <span class="bound">xa</span> <span class="main">≠</span> <span class="bound">y</span><span class="main">}</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="main">(</span><span class="bound">w</span><span class="main">,</span> <span class="bound">w'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">W</span><span class="main">×</span> <span class="free">W</span><span class="main">.</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free">hash</span> <span class="bound">x</span> <span class="bound">w</span> <span class="main">=</span> <span class="free">hash</span> <span class="bound">x</span> <span class="bound">w'</span> <span class="main">∧</span> <span class="bound">w</span> <span class="main">≠</span> <span class="bound">w'</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?M</span> <span class="main">…</span> <span class="main">≤</span> <span class="main">(</span><span class="main">∑</span><span class="main">(</span><span class="bound">w</span><span class="main">,</span> <span class="bound">w'</span><span class="main">)</span><span class="main">∈</span><span class="free">W</span> <span class="main">×</span> <span class="free">W</span><span class="main">.</span> <span class="var">?M</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free">hash</span> <span class="bound">x</span> <span class="bound">w</span> <span class="main">=</span> <span class="free">hash</span> <span class="bound">x</span> <span class="bound">w'</span> <span class="main">∧</span> <span class="bound">w</span> <span class="main">≠</span> <span class="bound">w'</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> measure_spmf.finite_measure_subadditive_finite <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_def assms<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="main">(</span><span class="main">∑</span><span class="main">(</span><span class="bound">w</span><span class="main">,</span> <span class="bound">w'</span><span class="main">)</span><span class="main">∈</span><span class="free">W</span> <span class="main">×</span> <span class="free">W</span><span class="main">.</span> ε_uh<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> sum_mono<span class="main">)</span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bound<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span>  ε_uh <span class="main">*</span> card<span class="main">(</span><span class="free">W</span><span class="main">)</span> <span class="main">*</span> card<span class="main">(</span><span class="free">W</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_cartesian_product<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span> 

<span class="keyword1"><span class="command">locale</span></span> prf_hash <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'key</span> <span class="main">⇒</span> <span class="tfree">'α</span> <span class="main">⇒</span> <span class="tfree">'γ</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">h</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'seed</span> <span class="main">⇒</span> <span class="tfree">'β</span> <span class="main">⇒</span> <span class="tfree">'α</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">key_gen</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'key</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">seed_gen</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'seed</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">range_f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'γ</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> lossless_seed_gen<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="free">seed_gen</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> range_f_finite<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">range_f</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> range_f_nonempty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">range_f</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">rand</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'γ</span> spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">rand</span> <span class="main">=</span> spmf_of_set <span class="free">range_f</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_rand <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf rand"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rand_def range_f_finite range_f_nonempty<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">key_seed_gen</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'key</span> <span class="main">*</span> <span class="tfree">'seed</span><span class="main">)</span> spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">key_seed_gen</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
     <span class="bound">k</span> <span class="main">←</span> <span class="free">key_gen</span><span class="main">;</span>
     <span class="bound">s</span> <span class="main">::</span> <span class="tfree">'seed</span> <span class="main">←</span> <span class="free">seed_gen</span><span class="main">;</span>
     return_spmf <span class="main">(</span><span class="bound">k</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span>
   <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> <span class="quoted">"prf"</span><span class="main">:</span> <span class="quoted">"prf"</span> <span class="quoted"><span class="free">key_gen</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted">rand</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">interpretation</span></span> hash<span class="main">:</span> hash <span class="quoted"><span class="quoted">"<span class="free">seed_gen</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span>"</span></span><span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">f'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'key</span> <span class="main">×</span> <span class="tfree">'seed</span> <span class="main">⇒</span> <span class="tfree">'β</span> <span class="main">⇒</span> <span class="tfree">'γ</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">f'</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">key</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">seed</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free">f</span> <span class="free"><span class="bound"><span class="entity">key</span></span></span> <span class="main">(</span><span class="free">h</span> <span class="free"><span class="bound"><span class="entity">seed</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> <span class="quoted">"prf'"</span><span class="main">:</span> <span class="quoted">"prf"</span> <span class="quoted">key_seed_gen</span> <span class="quoted">f'</span> <span class="quoted">rand</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">reduction_oracle</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'seed</span> <span class="main">⇒</span> unit <span class="main">⇒</span> <span class="tfree">'β</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'γ</span> <span class="main">×</span> unit<span class="main">,</span> <span class="tfree">'α</span><span class="main">,</span> <span class="tfree">'γ</span><span class="main">)</span> gpv"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">reduction_oracle</span> <span class="free"><span class="bound"><span class="entity">seed</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> Pause <span class="main">(</span><span class="free">h</span> <span class="free"><span class="bound"><span class="entity">seed</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> Done <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="main">()</span><span class="main">)</span><span class="main">)</span>"</span></span> 

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">prf'_reduction</span> <span class="main">::</span> <span class="quoted"><span class="quoted">" <span class="main">(</span><span class="tfree">'β</span><span class="main">,</span> <span class="tfree">'γ</span><span class="main">)</span> prf'.adversary <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'α</span><span class="main">,</span> <span class="tfree">'γ</span><span class="main">)</span> prf.adversary"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">prf'_reduction</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">seed</span>  <span class="main">←</span> lift_spmf <span class="free">seed_gen</span><span class="main">;</span>
      <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">←</span> inline <span class="main">(</span>reduction_oracle <span class="bound">seed</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">()</span><span class="main">;</span>
      Done <span class="bound">b</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">theorem</span></span> prf_prf'_advantage<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"prf'.lossless <span class="free">𝒜</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> bounded<span class="main">:</span> <span class="quoted"><span class="quoted">"prf'.ibounded_by <span class="free">𝒜</span> <span class="free">q</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"prf'.advantage <span class="free">𝒜</span>  <span class="main">≤</span> prf.advantage <span class="main">(</span>prf'_reduction <span class="free">𝒜</span><span class="main">)</span> <span class="main">+</span> hash.ε_uh <span class="main">*</span> <span class="free">q</span> <span class="main">*</span> <span class="free">q</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> lifting_syntax
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?𝒜</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"prf'_reduction <span class="free">𝒜</span>"</span></span>

  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">cr</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">cr</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">×</span> unit<span class="main">.</span> <span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit<span class="main">.</span> True<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">cr</span> <span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="main">()</span><span class="main">)</span> <span class="main">()</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_def<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"prf.game_0 <span class="var">?𝒜</span> <span class="main">=</span> prf'.game_0 <span class="free">𝒜</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> prf'.game_0_def prf.game_0_def prf'_reduction_def <span class="keyword1"><span class="command">unfolding</span></span> key_seed_gen_def
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> exec_gpv_bind split_def exec_gpv_inline reduction_oracle_def bind_map_spmf prf.prf_oracle_def prf'.prf_oracle_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">)</span> 
        <span class="main">(</span><span class="operator">transfer_prover</span><span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">note</span></span> hop1 <span class="main">=</span> this<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>

  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">semi_forgetful_RO</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">semi_forgetful_RO</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">seed</span> <span class="main">::</span> <span class="tfree">'seed</span><span class="main">.</span> <span class="main">λ</span><span class="main">(</span><span class="bound">σ</span> <span class="main">::</span> <span class="tfree">'α</span> <span class="main">⇀</span> <span class="tfree">'β</span> <span class="main">×</span> <span class="tfree">'γ</span><span class="main">,</span> <span class="bound">b</span> <span class="main">::</span> bool<span class="main">)</span><span class="main">.</span> <span class="main">λ</span><span class="bound">x</span><span class="main">.</span> 
    <span class="keyword1">case</span> <span class="bound">σ</span> <span class="main">(</span><span class="free">h</span> <span class="bound">seed</span> <span class="bound">x</span><span class="main">)</span> <span class="keyword1">of</span> Some <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">⇒</span> return_spmf <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="main">(</span><span class="bound">σ</span><span class="main">,</span> <span class="bound">a</span> <span class="main">≠</span> <span class="bound">x</span> <span class="main">∨</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span>
     <span class="main">|</span> None <span class="main">⇒</span> bind_spmf rand <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> return_spmf <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="main">(</span><span class="bound">σ</span><span class="main">(</span><span class="free">h</span> <span class="bound">seed</span> <span class="bound">x</span> <span class="main">↦</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">game_semi_forgetful</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">game_semi_forgetful</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
     <span class="bound">seed</span> <span class="main">::</span> <span class="tfree">'seed</span> <span class="main">←</span> <span class="free">seed_gen</span><span class="main">;</span>
     <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">rep</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="main">(</span><span class="skolem">semi_forgetful_RO</span> <span class="bound">seed</span><span class="main">)</span> <span class="free">𝒜</span> <span class="main">(</span>Map.empty<span class="main">,</span> False<span class="main">)</span><span class="main">;</span>
     return_spmf <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">rep</span><span class="main">)</span> 
   <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">have</span></span> bad_semi_forgetful <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"callee_invariant <span class="main">(</span><span class="skolem">semi_forgetful_RO</span> <span class="skolem">seed</span><span class="main">)</span> snd"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">seed</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> semi_forgetful_RO_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> lossless_semi_forgetful <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span><span class="skolem">semi_forgetful_RO</span> <span class="skolem">seed</span> <span class="skolem">s1</span> <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">seed</span> <span class="skolem">s1</span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> semi_forgetful_RO_def split_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">cr</span></span>
      <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">cr</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit<span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">(</span><span class="bound">σ'</span> <span class="main">::</span> <span class="tfree">'α</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'β</span> <span class="main">×</span> <span class="tfree">'γ</span><span class="main">)</span> option<span class="main">,</span> <span class="main"><span class="bound">_</span></span> <span class="main">::</span> bool<span class="main">)</span><span class="main">.</span> <span class="bound">σ</span> <span class="main">=</span> map_option snd <span class="main">∘</span> <span class="bound">σ'</span><span class="main">)</span>"</span></span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">initial</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">initial</span> <span class="main">=</span> <span class="main">(</span>Map.empty <span class="main">::</span> <span class="tfree">'α</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'β</span> <span class="main">×</span> <span class="tfree">'γ</span><span class="main">)</span> option<span class="main">,</span> False<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">cr</span> <span class="main">(</span><span class="main">()</span><span class="main">,</span> Map.empty<span class="main">)</span> <span class="skolem">initial</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_def initial_def fun_eq_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="skolem">cr</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> rel_spmf <span class="main">(</span>rel_prod <span class="main">(=)</span> <span class="skolem">cr</span><span class="main">)</span><span class="main">)</span>
        <span class="main">(</span><span class="main">λ</span><span class="bound">y</span> <span class="bound">p</span> <span class="bound">ya</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span><span class="bound">y</span> <span class="main">←</span> prf.random_oracle <span class="main">(</span>snd <span class="bound">p</span><span class="main">)</span> <span class="main">(</span><span class="free">h</span> <span class="bound">y</span> <span class="bound">ya</span><span class="main">)</span><span class="main">;</span> return_spmf <span class="main">(</span>fst <span class="bound">y</span><span class="main">,</span> <span class="main">()</span><span class="main">,</span> snd <span class="bound">y</span><span class="main">)</span> <span class="main">}</span><span class="main">)</span>
        <span class="skolem">semi_forgetful_RO</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> semi_forgetful_RO_def cr_def prf.random_oracle_def rel_fun_def fun_eq_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_bind_reflI<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"prf.game_1 <span class="var">?𝒜</span> <span class="main">=</span> map_spmf fst <span class="skolem">game_semi_forgetful</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> prf.game_1_def prf'_reduction_def game_semi_forgetful_def
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> exec_gpv_bind exec_gpv_inline split_def bind_map_spmf map_spmf_bind_spmf o_def map_spmf_conv_bind_spmf reduction_oracle_def initial_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="main">(</span><span class="operator">transfer_prover</span><span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">note</span></span> hop2 <span class="main">=</span> this

  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">game_semi_forgetful_bad</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">game_semi_forgetful_bad</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
       <span class="bound">seed</span> <span class="main">::</span> <span class="tfree">'seed</span> <span class="main">←</span> <span class="free">seed_gen</span><span class="main">;</span>
       <span class="bound">x</span> <span class="main">←</span> exec_gpv <span class="main">(</span><span class="skolem">semi_forgetful_RO</span> <span class="bound">seed</span><span class="main">)</span> <span class="free">𝒜</span> <span class="main">(</span>Map.empty<span class="main">,</span> False<span class="main">)</span><span class="main">;</span>
       return_spmf <span class="main">(</span>snd <span class="bound">x</span><span class="main">)</span> 
       <span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> game_semi_forgetful_bad <span class="main">:</span> <span class="quoted"><span class="quoted">"map_spmf snd <span class="skolem">game_semi_forgetful</span> <span class="main">=</span> <span class="skolem">game_semi_forgetful_bad</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> game_semi_forgetful_bad_def game_semi_forgetful_def
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_spmf_bind_spmf o_def<span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> bad_random_oracle_A <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"callee_invariant prf.random_oracle <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="main">¬</span> inj_on <span class="main">(</span><span class="free">h</span> <span class="skolem">seed</span><span class="main">)</span> <span class="main">(</span>dom <span class="bound">σ</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">seed</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> prf.random_oracle_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>

  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">invar</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">invar</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">seed</span> <span class="main">(</span><span class="bound">σ1</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">(</span><span class="bound">σ2</span> <span class="main">::</span> <span class="tfree">'β</span> <span class="main">⇒</span> <span class="tfree">'γ</span> option<span class="main">)</span><span class="main">.</span> <span class="main">¬</span> <span class="bound">b</span> <span class="main">∧</span> dom <span class="bound">σ1</span> <span class="main">=</span> <span class="free">h</span> <span class="bound">seed</span> <span class="main">`</span> dom <span class="bound">σ2</span> <span class="main">∧</span> 
      <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> dom <span class="bound">σ2</span><span class="main">.</span> <span class="bound">σ1</span> <span class="main">(</span><span class="free">h</span> <span class="bound">seed</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> map_option <span class="main">(</span>Pair <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="bound">σ2</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">have</span></span> rel_spmf_oracle_adv<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"rel_spmf <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s1</span><span class="main">)</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">s2</span><span class="main">)</span><span class="main">.</span> snd <span class="bound">s1</span> <span class="main">≠</span> inj_on <span class="main">(</span><span class="free">h</span> <span class="skolem">seed</span><span class="main">)</span> <span class="main">(</span>dom <span class="bound">s2</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span>inj_on <span class="main">(</span><span class="free">h</span> <span class="skolem">seed</span><span class="main">)</span> <span class="main">(</span>dom <span class="bound">s2</span><span class="main">)</span> <span class="main">⟶</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">y</span> <span class="main">∧</span> <span class="skolem">invar</span> <span class="skolem">seed</span> <span class="bound">s1</span> <span class="bound">s2</span><span class="main">)</span><span class="main">)</span>
      <span class="main">(</span>exec_gpv <span class="main">(</span><span class="skolem">semi_forgetful_RO</span> <span class="skolem">seed</span><span class="main">)</span> <span class="free">𝒜</span> <span class="main">(</span>Map.empty<span class="main">,</span> False<span class="main">)</span><span class="main">)</span>
      <span class="main">(</span>exec_gpv prf.random_oracle <span class="free">𝒜</span> Map.empty<span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> seed<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">seed</span> <span class="main">∈</span> set_spmf <span class="free">seed_gen</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">seed</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> invar_initial <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">invar</span> <span class="skolem">seed</span> <span class="main">(</span>Map.empty<span class="main">,</span> False<span class="main">)</span> Map.empty"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> invar_def<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> invarD_inj<span class="main">:</span> <span class="quoted"><span class="quoted">"inj_on <span class="main">(</span><span class="free">h</span> <span class="skolem">seed</span><span class="main">)</span> <span class="main">(</span>dom <span class="skolem">s2</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">invar</span> <span class="skolem">seed</span> <span class="skolem">bs1</span> <span class="skolem">s2</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">bs1</span> <span class="skolem">s2</span>
      <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> inj_onI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> invar_def<span class="main">)</span><span class="main">(</span><span class="operator">metis</span> domI domIff option.map_sel prod.inject<span class="main">)</span>

    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?R</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">s1</span><span class="main">)</span> <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">s2</span> <span class="main">::</span> <span class="tfree">'β</span> <span class="main">⇒</span> <span class="tfree">'γ</span> option<span class="main">)</span><span class="main">.</span>
        snd <span class="bound">s1</span> <span class="main">=</span> <span class="main">(</span><span class="main">¬</span> inj_on <span class="main">(</span><span class="free">h</span> <span class="skolem">seed</span><span class="main">)</span> <span class="main">(</span>dom <span class="bound">s2</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
        <span class="main">(</span><span class="main">¬</span> <span class="main">¬</span> inj_on <span class="main">(</span><span class="free">h</span> <span class="skolem">seed</span><span class="main">)</span> <span class="main">(</span>dom <span class="bound">s2</span><span class="main">)</span> <span class="main">⟶</span> <span class="bound">a</span> <span class="main">=</span> <span class="bound">b</span> <span class="main">∧</span> <span class="skolem">invar</span> <span class="skolem">seed</span> <span class="bound">s1</span> <span class="bound">s2</span><span class="main">)</span>"</span></span>

    <span class="keyword1"><span class="command">have</span></span> step<span class="main">:</span> <span class="quoted"><span class="quoted">"rel_spmf <span class="var">?R</span> <span class="main">(</span><span class="skolem">semi_forgetful_RO</span> <span class="skolem">seed</span> <span class="skolem">σ1b</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span>prf.random_oracle <span class="skolem">s2</span> <span class="skolem">x</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> X<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">invar</span> <span class="skolem">seed</span> <span class="skolem">σ1b</span> <span class="skolem">s2</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s2</span> <span class="skolem">σ1b</span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">σ1</span></span> <span class="skolem"><span class="skolem">b</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">σ1b</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">σ1</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">σ1b</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> X <span class="keyword1"><span class="command">have</span></span> not_b<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="skolem">b</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> dom<span class="main">:</span> <span class="quoted"><span class="quoted">"dom <span class="skolem">σ1</span> <span class="main">=</span> <span class="free">h</span> <span class="skolem">seed</span> <span class="main">`</span> dom <span class="skolem">s2</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>dom <span class="skolem">s2</span><span class="main">.</span> <span class="skolem">σ1</span> <span class="main">(</span><span class="free">h</span> <span class="skolem">seed</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> map_option <span class="main">(</span>Pair <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="skolem">s2</span> <span class="bound">x</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> invar_def<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> X <span class="keyword1"><span class="command">have</span></span> inj<span class="main">:</span> <span class="quoted"><span class="quoted">"inj_on <span class="main">(</span><span class="free">h</span> <span class="skolem">seed</span><span class="main">)</span> <span class="main">(</span>dom <span class="skolem">s2</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> invarD_inj<span class="main">)</span>
  
      <span class="keyword1"><span class="command">have</span></span> not_in_image<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="skolem">seed</span> <span class="skolem">x</span> <span class="main">∉</span> <span class="free">h</span> <span class="skolem">seed</span> <span class="main">`</span> <span class="main">(</span>dom <span class="skolem">s2</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">σ1</span> <span class="main">(</span><span class="free">h</span> <span class="skolem">seed</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> None"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> notI<span class="main">)</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="skolem">seed</span> <span class="skolem">x</span> <span class="main">∈</span> <span class="free">h</span> <span class="skolem">seed</span> <span class="main">`</span> <span class="main">(</span>dom <span class="skolem">s2</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> dom <span class="skolem">s2</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> hx_hy<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="skolem">seed</span> <span class="skolem">x</span> <span class="main">=</span> <span class="free">h</span> <span class="skolem">seed</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">σ1</span> <span class="main">(</span><span class="free">h</span> <span class="skolem">seed</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">=</span> None"</span></span> <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="skolem">seed</span> <span class="skolem">y</span> <span class="main">∉</span> <span class="free">h</span> <span class="skolem">seed</span> <span class="main">`</span> dom <span class="skolem">s2</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> dom <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∉</span> dom <span class="skolem">s2</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">∈</span> dom <span class="skolem">s2</span>›</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
  
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">σ1</span> <span class="main">(</span><span class="free">h</span> <span class="skolem">seed</span> <span class="skolem">x</span><span class="main">)</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> σ1<span class="main">:</span> None
        <span class="keyword1"><span class="command">hence</span></span> s2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">s2</span> <span class="skolem">x</span> <span class="main">=</span> None"</span></span> <span class="keyword1"><span class="command">using</span></span> dom <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"insert <span class="main">(</span><span class="free">h</span> <span class="skolem">seed</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span>dom <span class="skolem">σ1</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span><span class="free">h</span> <span class="skolem">seed</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="free">h</span> <span class="skolem">seed</span> <span class="main">`</span> dom <span class="skolem">s2</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dom<span class="main">)</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> invar_update<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">invar</span> <span class="skolem">seed</span> <span class="main">(</span><span class="skolem">σ1</span><span class="main">(</span><span class="free">h</span> <span class="skolem">seed</span> <span class="skolem">x</span> <span class="main">↦</span> <span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">bs</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> False<span class="main">)</span> <span class="main">(</span><span class="skolem">s2</span><span class="main">(</span><span class="skolem">x</span> <span class="main">↦</span> <span class="skolem">bs</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">bs</span>
          <span class="keyword1"><span class="command">using</span></span> inj not_b not_in_image σ1 dom
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> invar_def domIff eq<span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> domI domIff imageI<span class="main">)</span>
        <span class="keyword1"><span class="command">with</span></span> σ1 s2 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> inj not_b not_in_image
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> semi_forgetful_RO_def prf.random_oracle_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rel_spmf_bind_reflI<span class="main">)</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> σ1<span class="main">:</span> <span class="main">(</span>Some <span class="quoted">"<span class="skolem">by</span>"</span><span class="main">)</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">s2</span> <span class="skolem">x</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> s2<span class="main">:</span> <span class="main">(</span>Some <span class="skolem">z</span><span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> eq σ1 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">by</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> domIff<span class="main">)</span>
          <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> σ1 inj not_b s2 X
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> semi_forgetful_RO_def prf.random_oracle_def split_beta<span class="main">)</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> s2<span class="main">:</span> None
          <span class="keyword1"><span class="command">from</span></span> σ1 dom <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> dom <span class="skolem">s2</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="skolem">seed</span> <span class="skolem">x</span> <span class="main">=</span> <span class="free">h</span> <span class="skolem">seed</span> <span class="skolem">y</span>"</span></span> 
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">metis</span> domIff imageE option.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command">from</span></span> y <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> z<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">s2</span> <span class="skolem">y</span> <span class="main">=</span> Some <span class="skolem">z</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">from</span></span> eq z σ1 <span class="keyword1"><span class="command">have</span></span> <span class="quoted">"by"</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">by</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> * domIff<span class="main">)</span>
          <span class="keyword1"><span class="command">from</span></span> y s2 <span class="keyword1"><span class="command">have</span></span> xny<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≠</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">with</span></span> y * <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="skolem">seed</span> <span class="skolem">x</span> <span class="main">∈</span> <span class="free">h</span> <span class="skolem">seed</span> <span class="main">`</span> <span class="main">(</span>dom <span class="skolem">s2</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> σ1 s2 not_b <span class="quoted">"by"</span> xny inj
            <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> semi_forgetful_RO_def prf.random_oracle_def split_beta<span class="main">)</span><span class="main">(</span><span class="operator">rule</span> rel_spmf_bindI2<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">from</span></span> invar_initial _ step <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> exec_gpv_oracle_bisim_bad_full<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="var">?bad1.0</span> <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted">"snd"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> <span class="var">?bad2.0</span> <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="main">¬</span> inj_on <span class="main">(</span><span class="free">h</span> <span class="skolem">seed</span><span class="main">)</span> <span class="main">(</span>dom <span class="bound">σ</span><span class="main">)</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">game_A</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">game_A</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">seed</span> <span class="main">::</span> <span class="tfree">'seed</span> <span class="main">←</span> <span class="free">seed_gen</span><span class="main">;</span>
      <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">←</span> exec_gpv prf.random_oracle <span class="free">𝒜</span> Map.empty<span class="main">;</span>
      return_spmf <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="main">¬</span> inj_on <span class="main">(</span><span class="free">h</span> <span class="bound">seed</span><span class="main">)</span> <span class="main">(</span>dom <span class="bound">σ</span><span class="main">)</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?bad1</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> snd <span class="main">(</span>snd <span class="bound">x</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="var"><span class="quoted"><span class="var">?bad2</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"snd"</span></span>
  <span class="keyword1"><span class="command">have</span></span> hop3<span class="main">:</span> <span class="quoted"><span class="quoted">"rel_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">xa</span><span class="main">.</span> <span class="main">(</span><span class="var">?bad1</span> <span class="bound">x</span> <span class="main">⟷</span> <span class="var">?bad2</span> <span class="bound">xa</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">¬</span> <span class="var">?bad2</span> <span class="bound">xa</span> <span class="main">⟶</span> fst <span class="bound">x</span> <span class="main">⟷</span> fst <span class="bound">xa</span><span class="main">)</span><span class="main">)</span> <span class="skolem">game_semi_forgetful</span> <span class="skolem">game_A</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> game_semi_forgetful_def game_A_def 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> restrict_bind_spmf split_def map_spmf_bind_spmf restrict_return_spmf o_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_bind_reflI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> bind_return_spmf<span class="main">)</span>
      <span class="main">(</span><span class="operator">rule</span> rel_spmf_bindI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> rel_spmf_oracle_adv<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> bad1_bad2<span class="main">:</span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>map_spmf <span class="main">(</span>snd <span class="main">∘</span> snd<span class="main">)</span> <span class="skolem">game_semi_forgetful</span><span class="main">)</span> True <span class="main">=</span> spmf <span class="main">(</span>map_spmf snd <span class="skolem">game_A</span><span class="main">)</span> True"</span></span>
    <span class="keyword1"><span class="command">using</span></span> fundamental_lemma_bad<span class="main">[</span><span class="operator">OF</span> hop3<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> measure_map_spmf spmf_conv_measure_spmf vimage_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> bound_bad1_event<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¦</span>spmf <span class="main">(</span>map_spmf fst <span class="skolem">game_semi_forgetful</span><span class="main">)</span> True <span class="main">-</span> spmf <span class="main">(</span>map_spmf fst <span class="skolem">game_A</span><span class="main">)</span> True<span class="main">¦</span> <span class="main">≤</span> spmf <span class="main">(</span>map_spmf <span class="main">(</span>snd <span class="main">∘</span> snd<span class="main">)</span> <span class="skolem">game_semi_forgetful</span><span class="main">)</span> True"</span></span>
    <span class="keyword1"><span class="command">using</span></span> fundamental_lemma<span class="main">[</span><span class="operator">OF</span> hop3<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> measure_map_spmf spmf_conv_measure_spmf vimage_def<span class="main">)</span>
  
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> bound_bad2_event <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¦</span>spmf <span class="main">(</span>map_spmf fst <span class="skolem">game_semi_forgetful</span><span class="main">)</span> True <span class="main">-</span> spmf <span class="main">(</span>map_spmf fst <span class="skolem">game_A</span><span class="main">)</span> True<span class="main">¦</span> <span class="main">≤</span> spmf <span class="main">(</span>map_spmf snd <span class="skolem">game_A</span><span class="main">)</span> True"</span></span>
    <span class="keyword1"><span class="command">using</span></span> bad1_bad2 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
  
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">game_B</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">game_B</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">←</span> exec_gpv prf.random_oracle <span class="free">𝒜</span> Map.empty<span class="main">;</span>
      hash.game_hash_set <span class="main">(</span>dom <span class="bound">σ</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>
  
  <span class="keyword1"><span class="command">have</span></span> game_A_game_B<span class="main">:</span> <span class="quoted"><span class="quoted">"map_spmf snd <span class="skolem">game_A</span> <span class="main">=</span> <span class="skolem">game_B</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> game_B_def game_A_def hash.game_hash_set_def <span class="keyword1"><span class="command">including</span></span> monad_normalisation
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_spmf_bind_spmf o_def split_def<span class="main">)</span>
  
  <span class="keyword1"><span class="command">have</span></span> game_B_bound <span class="main">:</span> <span class="quoted"><span class="quoted">"spmf <span class="skolem">game_B</span> True <span class="main">≤</span> hash.ε_uh <span class="main">*</span> <span class="free">q</span> <span class="main">*</span> <span class="free">q</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> game_B_def
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> spmf_bind_leI<span class="main"><span class="keyword3">,</span></span> <span class="operator">clarify</span><span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">b</span> <span class="skolem">σ</span>
    <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">b</span><span class="main">,</span> <span class="skolem">σ</span><span class="main">)</span> <span class="main">∈</span> set_spmf <span class="main">(</span>exec_gpv prf.random_oracle <span class="free">𝒜</span> Map.empty<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>dom <span class="skolem">σ</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> prf.finite.exec_gpv_invariant<span class="main"><span class="main">[</span></span><span class="operator">OF</span> *<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>hash.game_hash_set <span class="main">(</span>dom <span class="skolem">σ</span><span class="main">)</span><span class="main">)</span> True <span class="main">≤</span> hash.ε_uh <span class="main">*</span> <span class="main">(</span>card <span class="main">(</span>dom <span class="skolem">σ</span><span class="main">)</span> <span class="main">*</span> card <span class="main">(</span>dom <span class="skolem">σ</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> hash.hash_ineq_card<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"dom <span class="skolem">σ</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> p1<span class="main">:</span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>dom <span class="skolem">σ</span><span class="main">)</span> <span class="main">≤</span> <span class="free">q</span> <span class="main">+</span> card <span class="main">(</span>dom <span class="main">(</span>Map.empty <span class="main">::</span> <span class="tfree">'β</span> <span class="main">⇒</span> <span class="tfree">'γ</span> option<span class="main">)</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> prf.card_dom_random_oracle<span class="main"><span class="main">[</span></span><span class="operator">OF</span> bounded *<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>dom <span class="skolem">σ</span><span class="main">)</span> <span class="main">*</span> card <span class="main">(</span>dom <span class="skolem">σ</span><span class="main">)</span> <span class="main">≤</span> <span class="free">q</span> <span class="main">*</span> <span class="free">q</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> mult_le_mono <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>hash.game_hash_set <span class="main">(</span>dom <span class="skolem">σ</span><span class="main">)</span><span class="main">)</span> True <span class="main">≤</span> hash.ε_uh <span class="main">*</span> <span class="free">q</span> <span class="main">*</span> <span class="free">q</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hash.ε_uh_nonneg mult_left_mono<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hash.ε_uh_nonneg<span class="main">)</span>
  
  <span class="keyword1"><span class="command">have</span></span> hop4<span class="main">:</span> <span class="quoted"><span class="quoted">"prf'.game_1 <span class="free">𝒜</span> <span class="main">=</span> map_spmf fst <span class="skolem">game_A</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> game_A_def prf'.game_1_def map_spmf_bind_spmf o_def split_def bind_spmf_const lossless_seed_gen lossless_weight_spmfD<span class="main">)</span>
  
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"prf'.advantage <span class="free">𝒜</span> <span class="main">≤</span> <span class="main">¦</span>spmf <span class="main">(</span>prf.game_0 <span class="var">?𝒜</span><span class="main">)</span> True <span class="main">-</span> spmf <span class="main">(</span>prf'.game_1 <span class="free">𝒜</span><span class="main">)</span> True<span class="main">¦</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> hop1 <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> prf'.advantage_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> prf.advantage <span class="var">?𝒜</span> <span class="main">+</span> <span class="main">¦</span>spmf <span class="main">(</span>prf.game_1 <span class="var">?𝒜</span><span class="main">)</span> True <span class="main">-</span> spmf <span class="main">(</span>prf'.game_1 <span class="free">𝒜</span><span class="main">)</span> True<span class="main">¦</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> prf.advantage_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¦</span>spmf <span class="main">(</span>prf.game_1 <span class="var">?𝒜</span><span class="main">)</span> True <span class="main">-</span> spmf <span class="main">(</span>prf'.game_1 <span class="free">𝒜</span><span class="main">)</span> True<span class="main">¦</span> <span class="main">≤</span>
    <span class="main">¦</span>spmf <span class="main">(</span>map_spmf fst <span class="skolem">game_semi_forgetful</span><span class="main">)</span> True <span class="main">-</span> spmf <span class="main">(</span>prf'.game_1 <span class="free">𝒜</span><span class="main">)</span> True<span class="main">¦</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> hop2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> hash.ε_uh <span class="main">*</span> <span class="free">q</span> <span class="main">*</span> <span class="free">q</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> game_A_game_B game_B_bound bound_bad2_event hop4 <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> add_left_mono<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="PRF_IND_CPA">
<div class="head">
<h1>Theory PRF_IND_CPA</h1>
</div>
<pre class="source"><span class="comment1">(* Title: PRF_IND_CPA.thy
  Author: Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹IND-CPA from PRF›</span></span>

<span class="keyword1"><span class="command">theory</span></span> PRF_IND_CPA <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../CryptHOL/GPV_Bisim.html">CryptHOL.GPV_Bisim</a>
  <a href="../CryptHOL/List_Bits.html">CryptHOL.List_Bits</a>
  <a href="Pseudo_Random_Function.html">Pseudo_Random_Function</a>
  <a href="IND_CPA.html">IND_CPA</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Formalises the construction from \cite{PetcherMorrisett2015POST}.
›</span></span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">simproc</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> let_simp<span class="main">]</span><span class="main">]</span>

<span class="keyword1"><span class="command">type_synonym</span></span> key <span class="main">=</span> <span class="quoted"><span class="quoted">"bool list"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> plain <span class="main">=</span> <span class="quoted"><span class="quoted">"bool list"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> cipher <span class="main">=</span> <span class="quoted"><span class="quoted">"bool list <span class="main">*</span> bool list"</span></span>

<span class="keyword1"><span class="command">locale</span></span> otp <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"key <span class="main">⇒</span> bool list <span class="main">⇒</span> bool list"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">len</span> <span class="main">::</span> <span class="quoted">nat</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> length_f<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span> <span class="bound">ys</span><span class="main">.</span> <span class="main">⟦</span> length <span class="bound">xs</span> <span class="main">=</span> <span class="free">len</span><span class="main">;</span> length <span class="bound">ys</span> <span class="main">=</span> <span class="free">len</span> <span class="main">⟧</span> <span class="main">⟹</span> length <span class="main">(</span><span class="free">f</span> <span class="bound">xs</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">=</span> <span class="free">len</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">key_gen</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"bool list spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">key_gen</span> <span class="main">=</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">valid_plain</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"plain <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">valid_plain</span> <span class="free"><span class="bound"><span class="entity">plain</span></span></span> <span class="main">⟷</span> length <span class="free"><span class="bound"><span class="entity">plain</span></span></span> <span class="main">=</span> <span class="free">len</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">encrypt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"key <span class="main">⇒</span> plain <span class="main">⇒</span> cipher spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">encrypt</span> <span class="free"><span class="bound"><span class="entity">key</span></span></span> <span class="free"><span class="bound"><span class="entity">plain</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
     <span class="bound">r</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len</span><span class="main">)</span><span class="main">;</span>
     return_spmf <span class="main">(</span><span class="bound">r</span><span class="main">,</span> xor_list <span class="free"><span class="bound"><span class="entity">plain</span></span></span> <span class="main">(</span><span class="free">f</span> <span class="free"><span class="bound"><span class="entity">key</span></span></span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>
   <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">decrypt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"key <span class="main">⇒</span> cipher <span class="main">⇒</span> plain option"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">decrypt</span> <span class="free"><span class="bound"><span class="entity">key</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span>xor_list <span class="main">(</span><span class="free">f</span> <span class="free"><span class="bound"><span class="entity">key</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> encrypt_decrypt_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> length <span class="free">key</span> <span class="main">=</span> <span class="free">len</span><span class="main">;</span> length <span class="free">plain</span> <span class="main">=</span> <span class="free">len</span> <span class="main">⟧</span>
  <span class="main">⟹</span> encrypt <span class="free">key</span> <span class="free">plain</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="bound">cipher</span><span class="main">.</span> return_spmf <span class="main">(</span>decrypt <span class="free">key</span> <span class="bound">cipher</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> return_spmf <span class="main">(</span>Some <span class="free">plain</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> encrypt_def zip_map2 o_def split_def bind_eq_return_spmf length_f in_nlists_UNIV xor_list_left_commute<span class="main">)</span>

<span class="keyword1"><span class="command">interpretation</span></span> ind_cpa<span class="main">:</span> ind_cpa <span class="quoted">key_gen</span> <span class="quoted">encrypt</span> <span class="quoted">decrypt</span> <span class="quoted">valid_plain</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">interpretation</span></span> <span class="quoted">"prf"</span><span class="main">:</span> <span class="quoted">"prf"</span> <span class="quoted">key_gen</span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="quoted">"spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">prf_encrypt_oracle</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"unit <span class="main">⇒</span> plain <span class="main">⇒</span> <span class="main">(</span>cipher <span class="main">×</span> unit<span class="main">,</span> plain<span class="main">,</span> plain<span class="main">)</span> gpv"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">prf_encrypt_oracle</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">plain</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
     <span class="bound">r</span> <span class="main">←</span> lift_spmf <span class="main">(</span>spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
     Pause <span class="bound">r</span> <span class="main">(</span><span class="main">λ</span><span class="bound">pad</span><span class="main">.</span> Done <span class="main">(</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span> xor_list <span class="free"><span class="bound"><span class="entity">plain</span></span></span> <span class="bound">pad</span><span class="main">)</span><span class="main">,</span> <span class="main">()</span><span class="main">)</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> interaction_bounded_by_prf_encrypt_oracle <span class="main">[</span><span class="operator">interaction_bound</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"interaction_any_bounded_by <span class="main">(</span>prf_encrypt_oracle <span class="free">σ</span> <span class="free">plain</span><span class="main">)</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> prf_encrypt_oracle_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_prf_encyrpt_oracle <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_gpv <span class="free">ℐ_top</span> <span class="main">(</span>prf_encrypt_oracle <span class="free">s</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> prf_encrypt_oracle_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">prf_adversary</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>plain<span class="main">,</span> cipher<span class="main">,</span> <span class="tfree">'state</span><span class="main">)</span> ind_cpa.adversary <span class="main">⇒</span> <span class="main">(</span>plain<span class="main">,</span> plain<span class="main">)</span> prf.adversary"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">prf_adversary</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
     <span class="keyword1">let</span> <span class="main">(</span><span class="bound">𝒜1</span><span class="main">,</span> <span class="bound">𝒜2</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span><span class="main">;</span>
     <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="bound">p1</span><span class="main">,</span> <span class="bound">p2</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">,</span> <span class="bound">n</span><span class="main">)</span> <span class="main">←</span> inline prf_encrypt_oracle <span class="bound">𝒜1</span> <span class="main">()</span><span class="main">;</span>
     <span class="keyword1">if</span> valid_plain <span class="bound">p1</span> <span class="main">∧</span> valid_plain <span class="bound">p2</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span> 
       <span class="bound">b</span> <span class="main">←</span> lift_spmf coin_spmf<span class="main">;</span>
       <span class="keyword1">let</span> <span class="bound">pb</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">p1</span> <span class="keyword1">else</span> <span class="bound">p2</span><span class="main">)</span><span class="main">;</span>
       <span class="bound">r</span> <span class="main">←</span> lift_spmf <span class="main">(</span>spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
       <span class="bound">pad</span> <span class="main">←</span> Pause <span class="bound">r</span> Done<span class="main">;</span>
       <span class="keyword1">let</span> <span class="bound">c</span> <span class="main">=</span> <span class="main">(</span><span class="bound">r</span><span class="main">,</span> xor_list <span class="bound">pb</span> <span class="bound">pad</span><span class="main">)</span><span class="main">;</span>
       <span class="main">(</span><span class="bound">b'</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">←</span> inline prf_encrypt_oracle <span class="main">(</span><span class="bound">𝒜2</span> <span class="bound">c</span> <span class="bound">σ</span><span class="main">)</span> <span class="bound">n</span><span class="main">;</span>
       Done <span class="main">(</span><span class="bound">b'</span> <span class="main">=</span> <span class="bound">b</span><span class="main">)</span>
     <span class="main">}</span> <span class="keyword1">else</span> lift_spmf coin_spmf
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">theorem</span></span> prf_encrypt_advantage<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ind_cpa.ibounded_by <span class="free">𝒜</span> <span class="free">q</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"lossless_gpv ℐ_full <span class="main">(</span>fst <span class="free">𝒜</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">cipher</span> <span class="bound">σ</span><span class="main">.</span> lossless_gpv ℐ_full <span class="main">(</span>snd <span class="free">𝒜</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ind_cpa.advantage <span class="free">𝒜</span> <span class="main">≤</span> prf.advantage <span class="main">(</span>prf_adversary <span class="free">𝒜</span><span class="main">)</span> <span class="main">+</span> <span class="free">q</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">^</span> <span class="free">len</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">split</span> <span class="quasi_keyword">del</span><span class="main">]</span> <span class="main">=</span> if_split
    <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">cong</span> <span class="quasi_keyword">del</span><span class="main">]</span> <span class="main">=</span> if_weak_cong
    <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span>
      bind_spmf_const map_spmf_bind_spmf bind_map_spmf 
      exec_gpv_bind exec_gpv_inline
      rel_spmf_bind_reflI rel_spmf_reflI
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">𝒜1</span></span> <span class="skolem"><span class="skolem">𝒜2</span></span> <span class="keyword2"><span class="keyword">where</span></span> 𝒜<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">𝒜</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">𝒜1</span><span class="main">,</span> <span class="skolem">𝒜2</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">𝒜</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹ind_cpa.ibounded_by <span class="main">_</span> <span class="main">_</span>›</span></span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">q1</span></span> <span class="skolem"><span class="skolem">q2</span></span> <span class="main">::</span> <span class="quoted">nat</span>
    <span class="keyword2"><span class="keyword">where</span></span> q1<span class="main">:</span> <span class="quoted"><span class="quoted">"interaction_any_bounded_by <span class="skolem">𝒜1</span> <span class="skolem">q1</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> q2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">cipher</span> <span class="bound">σ</span><span class="main">.</span> interaction_any_bounded_by <span class="main">(</span><span class="skolem">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="skolem">q2</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q1</span> <span class="main">+</span> <span class="skolem">q2</span> <span class="main">≤</span> <span class="free">q</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> 𝒜 <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> ind_cpa.ibounded_byE<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> iadd_le_enat_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> 𝒜 assms <span class="keyword1"><span class="command">have</span></span> lossless1<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_gpv ℐ_full <span class="skolem">𝒜1</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> lossless2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">cipher</span> <span class="bound">σ</span><span class="main">.</span> lossless_gpv ℐ_full <span class="main">(</span><span class="skolem">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">have</span></span> weight1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">oracle</span> <span class="bound">s</span><span class="main">.</span> <span class="main">(</span><span class="main">⋀</span><span class="bound">s</span> <span class="bound">x</span><span class="main">.</span> lossless_spmf <span class="main">(</span><span class="bound">oracle</span> <span class="bound">s</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> 
    <span class="main">⟹</span> weight_spmf <span class="main">(</span>exec_gpv <span class="bound">oracle</span> <span class="skolem">𝒜1</span> <span class="bound">s</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lossless_weight_spmfD<span class="main">)</span><span class="main">(</span><span class="operator">rule</span> lossless_exec_gpv<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lossless1<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> weight2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">oracle</span> <span class="bound">s</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">.</span> <span class="main">(</span><span class="main">⋀</span><span class="bound">s</span> <span class="bound">x</span><span class="main">.</span> lossless_spmf <span class="main">(</span><span class="bound">oracle</span> <span class="bound">s</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> 
    <span class="main">⟹</span> weight_spmf <span class="main">(</span>exec_gpv <span class="bound">oracle</span> <span class="main">(</span><span class="skolem">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="bound">s</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lossless_weight_spmfD<span class="main">)</span><span class="main">(</span><span class="operator">rule</span> lossless_exec_gpv<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lossless2<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?oracle1</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">key</span> <span class="main">(</span><span class="bound">s'</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="bound">y</span><span class="main">.</span> map_spmf <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="main">()</span><span class="main">,</span> <span class="main">()</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>exec_gpv <span class="main">(</span>prf.prf_oracle <span class="bound">key</span><span class="main">)</span> <span class="main">(</span>prf_encrypt_oracle <span class="main">()</span> <span class="bound">y</span><span class="main">)</span> <span class="main">()</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> bisim1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">key</span><span class="main">.</span> rel_spmf <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">y</span><span class="main">)</span>
          <span class="main">(</span>exec_gpv <span class="main">(</span>ind_cpa.encrypt_oracle <span class="bound">key</span><span class="main">)</span> <span class="skolem">𝒜1</span> <span class="main">()</span><span class="main">)</span>
          <span class="main">(</span>exec_gpv <span class="main">(</span><span class="var">?oracle1</span> <span class="bound">key</span><span class="main">)</span> <span class="skolem">𝒜1</span> <span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="main">()</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> TrueI
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> exec_gpv_oracle_bisim<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> encrypt_def prf_encrypt_oracle_def ind_cpa.encrypt_oracle_def prf.prf_oracle_def o_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> bisim2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">key</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">.</span> rel_spmf <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">y</span><span class="main">)</span>
             <span class="main">(</span>exec_gpv <span class="main">(</span>ind_cpa.encrypt_oracle <span class="bound">key</span><span class="main">)</span> <span class="main">(</span><span class="skolem">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">()</span><span class="main">)</span>
             <span class="main">(</span>exec_gpv <span class="main">(</span><span class="var">?oracle1</span> <span class="bound">key</span><span class="main">)</span> <span class="main">(</span><span class="skolem">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="main">()</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> TrueI
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> exec_gpv_oracle_bisim<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> encrypt_def prf_encrypt_oracle_def ind_cpa.encrypt_oracle_def prf.prf_oracle_def o_def<span class="main">)</span>
   
  <span class="keyword1"><span class="command">have</span></span> ind_cpa_0<span class="main">:</span> <span class="quoted"><span class="quoted">"rel_spmf <span class="main">(=)</span> <span class="main">(</span>ind_cpa.ind_cpa <span class="free">𝒜</span><span class="main">)</span> <span class="main">(</span>prf.game_0 <span class="main">(</span>prf_adversary <span class="free">𝒜</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> IND_CPA.ind_cpa.ind_cpa_def 𝒜 key_gen_def Let_def prf_adversary_def Pseudo_Random_Function.prf.game_0_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rewrite</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"bind_spmf <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">⌑</span></span>"</span></span></span> bind_commute_spmf<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> rel_spmf_bind_reflI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> rel_spmf_bindI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> bisim1<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">if_distribs</span></span> bind_coin_spmf_eq_const'<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rel_spmf_bindI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> bisim2<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_bind_reflI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> encrypt_def prf.prf_oracle_def <span class="quasi_keyword">cong</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> if_cong<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">rf_encrypt</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">rf_encrypt</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span> <span class="bound">plain</span><span class="main">.</span> bind_spmf <span class="main">(</span>spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span> <span class="main">::</span> bool list<span class="main">.</span> 
    bind_spmf <span class="main">(</span>prf.random_oracle <span class="bound">s</span> <span class="bound">r</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">pad</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span><span class="main">.</span> 
    return_spmf <span class="main">(</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span> xor_list <span class="bound">plain</span> <span class="bound">pad</span><span class="main">)</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
  <span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> rf_finite<span class="main">:</span> callee_invariant_on <span class="quoted"><span class="skolem">rf_encrypt</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">s</span><span class="main">.</span> finite <span class="main">(</span>dom <span class="bound">s</span><span class="main">)</span>"</span></span> <span class="quoted">ℐ_full</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rf_encrypt_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> prf.finite.callee_invariant<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> lossless_rf_encrypt <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">plain</span><span class="main">.</span> lossless_spmf <span class="main">(</span><span class="skolem">rf_encrypt</span> <span class="bound">s</span> <span class="bound">plain</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rf_encrypt_def<span class="main">)</span>

  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">game2</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">game2</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="bound">p0</span><span class="main">,</span> <span class="bound">p1</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">,</span> <span class="bound">s1</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">rf_encrypt</span> <span class="skolem">𝒜1</span> Map.empty<span class="main">;</span>
    <span class="keyword1">if</span> valid_plain <span class="bound">p0</span> <span class="main">∧</span> valid_plain <span class="bound">p1</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">pb</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">p0</span> <span class="keyword1">else</span> <span class="bound">p1</span><span class="main">)</span><span class="main">;</span>
      <span class="main">(</span><span class="bound">cipher</span><span class="main">,</span> <span class="bound">s2</span><span class="main">)</span> <span class="main">←</span> <span class="skolem">rf_encrypt</span> <span class="bound">s1</span> <span class="bound">pb</span><span class="main">;</span>
      <span class="main">(</span><span class="bound">b'</span><span class="main">,</span> <span class="bound">s3</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">rf_encrypt</span> <span class="main">(</span><span class="skolem">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="bound">s2</span><span class="main">;</span>
      return_spmf <span class="main">(</span><span class="bound">b'</span> <span class="main">=</span> <span class="bound">b</span><span class="main">)</span>
    <span class="main">}</span> <span class="keyword1">else</span> coin_spmf
  <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?oracle2</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">s'</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="bound">y</span><span class="main">.</span> map_spmf <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="main">()</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>exec_gpv prf.random_oracle <span class="main">(</span>prf_encrypt_oracle <span class="main">()</span> <span class="bound">y</span><span class="main">)</span> <span class="bound">s</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?I</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">y</span> <span class="main">∧</span> <span class="bound">s</span> <span class="main">=</span> <span class="bound">s'</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> bisim1<span class="main">:</span> <span class="quoted"><span class="quoted">"rel_spmf <span class="var">?I</span> <span class="main">(</span>exec_gpv <span class="var">?oracle2</span> <span class="skolem">𝒜1</span> <span class="main">(</span><span class="main">()</span><span class="main">,</span> Map.empty<span class="main">)</span><span class="main">)</span> <span class="main">(</span>exec_gpv <span class="skolem">rf_encrypt</span> <span class="skolem">𝒜1</span> Map.empty<span class="main">)</span>"</span></span>
     <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> exec_gpv_oracle_bisim<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> X<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="bound">s'</span><span class="main">.</span> <span class="bound">s</span> <span class="main">=</span> <span class="bound">s'</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
       <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rf_encrypt_def prf_encrypt_oracle_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_bind_reflI<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> bisim2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">cipher</span> <span class="bound">σ</span> <span class="bound">s</span><span class="main">.</span> rel_spmf <span class="var">?I</span> <span class="main">(</span>exec_gpv <span class="var">?oracle2</span> <span class="main">(</span><span class="skolem">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>exec_gpv <span class="skolem">rf_encrypt</span> <span class="main">(</span><span class="skolem">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="bound">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> exec_gpv_oracle_bisim<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> X<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="bound">s'</span><span class="main">.</span> <span class="bound">s</span> <span class="main">=</span> <span class="bound">s'</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> prf_encrypt_oracle_def rf_encrypt_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_bind_reflI<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> game1_2 <span class="main">[</span><span class="operator">unfolded</span> spmf_rel_eq<span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rel_spmf <span class="main">(=)</span> <span class="main">(</span>prf.game_1 <span class="main">(</span>prf_adversary <span class="free">𝒜</span><span class="main">)</span><span class="main">)</span> <span class="skolem">game2</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> prf.game_1_def game2_def prf_adversary_def
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rewrite</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1"><span class="keyword1">if</span></span></span> <span class="main"><span class="main"><span class="main">_</span></span></span> <span class="keyword1"><span class="keyword1"><span class="keyword1">then</span></span></span> <span class="main"><span class="main"><span class="main">⌑</span></span></span> <span class="keyword1"><span class="keyword1"><span class="keyword1">else</span></span></span> <span class="main"><span class="main"><span class="main">_</span></span></span>"</span></span></span></span> rf_encrypt_def<span class="main">)</span>
      <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def 𝒜 <span class="dynamic"><span class="dynamic">if_distribs</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_bindI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> bisim2<span class="main"><span class="main">]</span></span> rel_spmf_bind_reflI rel_spmf_bindI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> bisim1<span class="main"><span class="main">]</span></span><span class="main">)</span>

  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">game2_a</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">game2_a</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">r</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="bound">p0</span><span class="main">,</span> <span class="bound">p1</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">,</span> <span class="bound">s1</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">rf_encrypt</span> <span class="skolem">𝒜1</span> Map.empty<span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">bad</span> <span class="main">=</span> <span class="bound">r</span> <span class="main">∈</span> dom <span class="bound">s1</span><span class="main">;</span>
    <span class="keyword1">if</span> valid_plain <span class="bound">p0</span> <span class="main">∧</span> valid_plain <span class="bound">p1</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">pb</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">p0</span> <span class="keyword1">else</span> <span class="bound">p1</span><span class="main">)</span><span class="main">;</span>
      <span class="main">(</span><span class="bound">pad</span><span class="main">,</span> <span class="bound">s2</span><span class="main">)</span> <span class="main">←</span> prf.random_oracle <span class="bound">s1</span> <span class="bound">r</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">cipher</span> <span class="main">=</span> <span class="main">(</span><span class="bound">r</span><span class="main">,</span> xor_list <span class="bound">pb</span> <span class="bound">pad</span><span class="main">)</span><span class="main">;</span>
      <span class="main">(</span><span class="bound">b'</span><span class="main">,</span> <span class="bound">s3</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">rf_encrypt</span> <span class="main">(</span><span class="skolem">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="bound">s2</span><span class="main">;</span>
      return_spmf <span class="main">(</span><span class="bound">b'</span> <span class="main">=</span> <span class="bound">b</span><span class="main">,</span> <span class="bound">bad</span><span class="main">)</span>
    <span class="main">}</span> <span class="keyword1">else</span> coin_spmf <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="bound">b</span><span class="main">.</span> return_spmf <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">bad</span><span class="main">)</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">game2_b</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">game2_b</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">r</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="bound">p0</span><span class="main">,</span> <span class="bound">p1</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">,</span> <span class="bound">s1</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">rf_encrypt</span> <span class="skolem">𝒜1</span> Map.empty<span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">bad</span> <span class="main">=</span> <span class="bound">r</span> <span class="main">∈</span> dom <span class="bound">s1</span><span class="main">;</span>
    <span class="keyword1">if</span> valid_plain <span class="bound">p0</span> <span class="main">∧</span> valid_plain <span class="bound">p1</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">pb</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">p0</span> <span class="keyword1">else</span> <span class="bound">p1</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">pad</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">cipher</span> <span class="main">=</span> <span class="main">(</span><span class="bound">r</span><span class="main">,</span> xor_list <span class="bound">pb</span> <span class="bound">pad</span><span class="main">)</span><span class="main">;</span>
      <span class="main">(</span><span class="bound">b'</span><span class="main">,</span> <span class="bound">s3</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">rf_encrypt</span> <span class="main">(</span><span class="skolem">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">(</span><span class="bound">s1</span><span class="main">(</span><span class="bound">r</span> <span class="main">↦</span> <span class="bound">pad</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
      return_spmf <span class="main">(</span><span class="bound">b'</span> <span class="main">=</span> <span class="bound">b</span><span class="main">,</span> <span class="bound">bad</span><span class="main">)</span>
    <span class="main">}</span> <span class="keyword1">else</span> coin_spmf <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="bound">b</span><span class="main">.</span> return_spmf <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">bad</span><span class="main">)</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>
  
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">game2</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">r</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len</span><span class="main">)</span><span class="main">;</span>
      <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="bound">p0</span><span class="main">,</span> <span class="bound">p1</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">,</span> <span class="bound">s1</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">rf_encrypt</span> <span class="skolem">𝒜1</span> Map.empty<span class="main">;</span>
      <span class="keyword1">if</span> valid_plain <span class="bound">p0</span> <span class="main">∧</span> valid_plain <span class="bound">p1</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
        <span class="keyword1">let</span> <span class="bound">pb</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">p0</span> <span class="keyword1">else</span> <span class="bound">p1</span><span class="main">)</span><span class="main">;</span>
        <span class="main">(</span><span class="bound">pad</span><span class="main">,</span> <span class="bound">s2</span><span class="main">)</span> <span class="main">←</span> prf.random_oracle <span class="bound">s1</span> <span class="bound">r</span><span class="main">;</span>
        <span class="keyword1">let</span> <span class="bound">cipher</span> <span class="main">=</span> <span class="main">(</span><span class="bound">r</span><span class="main">,</span> xor_list <span class="bound">pb</span> <span class="bound">pad</span><span class="main">)</span><span class="main">;</span>
        <span class="main">(</span><span class="bound">b'</span><span class="main">,</span> <span class="bound">s3</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">rf_encrypt</span> <span class="main">(</span><span class="skolem">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="bound">s2</span><span class="main">;</span>
        return_spmf <span class="main">(</span><span class="bound">b'</span> <span class="main">=</span> <span class="bound">b</span><span class="main">)</span>
      <span class="main">}</span> <span class="keyword1">else</span> coin_spmf
    <span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">including</span></span> monad_normalisation <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> game2_def split_def rf_encrypt_def Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> map_spmf fst <span class="skolem">game2_a</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> game2_a_def
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_spmf_conv_bind_spmf Let_def if_distribR if_distrib split_def <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> if_cong<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> game2_2a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">game2</span> <span class="main">=</span> <span class="main">…</span>"</span></span>  <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_spmf snd <span class="skolem">game2_a</span> <span class="main">=</span> map_spmf snd <span class="skolem">game2_b</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> game2_a_def game2_b_def
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def Let_def split_def <span class="dynamic"><span class="dynamic">if_distribs</span></span> weight2 <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> bind_spmf_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"rel_spmf <span class="main">(=)</span> <span class="main">(</span>map_spmf fst <span class="main">(</span><span class="skolem">game2_a</span> <span class="main">↿</span> <span class="main">(</span>snd <span class="main">-`</span> <span class="main">{</span>False<span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>map_spmf fst <span class="main">(</span><span class="skolem">game2_b</span> <span class="main">↿</span> <span class="main">(</span>snd <span class="main">-`</span> <span class="main">{</span>False<span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> game2_a_def game2_b_def
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> restrict_bind_spmf o_def Let_def <span class="dynamic"><span class="dynamic">if_distribs</span></span> split_def restrict_return_spmf prf.random_oracle_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_bind_reflI <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"spmf <span class="skolem">game2_a</span> <span class="main">(</span>True<span class="main">,</span> False<span class="main">)</span> <span class="main">=</span> spmf <span class="skolem">game2_b</span> <span class="main">(</span>True<span class="main">,</span> False<span class="main">)</span>"</span></span> 
     <span class="keyword1"><span class="command">unfolding</span></span> spmf_rel_eq <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> spmf_map_restrict<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">ultimately</span></span>
  <span class="keyword1"><span class="command">have</span></span> game2a_2b<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¦</span>spmf <span class="main">(</span>map_spmf fst <span class="skolem">game2_a</span><span class="main">)</span> True <span class="main">-</span> spmf <span class="main">(</span>map_spmf fst <span class="skolem">game2_b</span><span class="main">)</span> True<span class="main">¦</span> <span class="main">≤</span> spmf <span class="main">(</span>map_spmf snd <span class="skolem">game2_a</span><span class="main">)</span> True"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> spmf_conv_measure_spmf<span class="main">)</span><span class="main">(</span><span class="operator">rule</span> identical_until_bad<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf.map_id<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> id_def<span class="main"><span class="main">]</span></span> spmf_conv_measure_spmf<span class="main">)</span>

  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">game2_a_bad</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">game2_a_bad</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">r</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len</span><span class="main">)</span><span class="main">;</span>
      <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="bound">p0</span><span class="main">,</span> <span class="bound">p1</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">,</span> <span class="bound">s1</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">rf_encrypt</span> <span class="skolem">𝒜1</span> Map.empty<span class="main">;</span>
      return_spmf <span class="main">(</span><span class="bound">r</span> <span class="main">∈</span> dom <span class="bound">s1</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> game2a_bad<span class="main">:</span> <span class="quoted"><span class="quoted">"map_spmf snd <span class="skolem">game2_a</span> <span class="main">=</span> <span class="skolem">game2_a_bad</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> game2_a_def game2_a_bad_def
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> bind_spmf_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def weight2 Let_def split_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> card<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">B</span> <span class="main">::</span> bool list set<span class="main">.</span> card <span class="main">(</span><span class="bound">B</span> <span class="main">∩</span> nlists UNIV <span class="free">len</span><span class="main">)</span> <span class="main">≤</span> card <span class="main">(</span>nlists UNIV <span class="free">len</span> <span class="main">::</span> bool list set<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> card_mono<span class="main">)</span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"spmf <span class="skolem">game2_a_bad</span> True <span class="main">=</span> <span class="main">∫<span class="hidden">⇧</span><sup>+</sup></span> <span class="bound">x</span><span class="main">.</span> card <span class="main">(</span>dom <span class="main">(</span>snd <span class="bound">x</span><span class="main">)</span> <span class="main">∩</span> nlists UNIV <span class="free">len</span><span class="main">)</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">^</span> <span class="free">len</span> <span class="main">∂</span>measure_spmf <span class="main">(</span>exec_gpv <span class="skolem">rf_encrypt</span> <span class="skolem">𝒜1</span> Map.empty<span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> game2_a_bad_def
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rewrite</span> bind_commute_spmf<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ennreal_spmf_bind split_def map_mem_spmf_of_set<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> map_spmf_conv_bind_spmf<span class="main"><span class="main">]</span></span> card_nlists<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">s</span>
    <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">s</span><span class="main">)</span> <span class="main">∈</span> set_spmf <span class="main">(</span>exec_gpv <span class="skolem">rf_encrypt</span> <span class="skolem">𝒜1</span> Map.empty<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>dom <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> rf_finite.exec_gpv_invariant<span class="main">)</span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command">hence</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>dom <span class="skolem">s</span> <span class="main">∩</span> nlists UNIV <span class="free">len</span><span class="main">)</span> <span class="main">≤</span> card <span class="main">(</span>dom <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> card_mono<span class="main">)</span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> q1 *
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>dom <span class="skolem">s</span><span class="main">)</span> <span class="main">≤</span> <span class="skolem">q1</span> <span class="main">+</span> card <span class="main">(</span>dom <span class="main">(</span>Map.empty <span class="main">::</span> <span class="main">(</span>plain<span class="main">,</span> plain<span class="main">)</span> prf.dict<span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> rf_finite.interaction_bounded_by'_exec_gpv_count<span class="main">)</span>
        <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rf_encrypt_def eSuc_enat prf.random_oracle_def card_insert_if <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm if_split<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>dom <span class="skolem">s</span> <span class="main">∩</span> nlists UNIV <span class="free">len</span><span class="main">)</span> <span class="main">≤</span> <span class="skolem">q1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span>  <span class="main">∫<span class="hidden">⇧</span><sup>+</sup></span> <span class="bound">x</span><span class="main">.</span> <span class="skolem">q1</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">^</span> <span class="free">len</span> <span class="main">∂</span>measure_spmf <span class="main">(</span>exec_gpv <span class="skolem">rf_encrypt</span> <span class="skolem">𝒜1</span> Map.empty<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> nn_integral_mono_AE<span class="main">)</span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">field_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="skolem">q1</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">^</span> <span class="free">len</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> measure_spmf.emeasure_eq_measure <span class="dynamic"><span class="dynamic">field_simps</span></span> mult_left_le weight1<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> game2a_bad_bound<span class="main">:</span> <span class="quoted"><span class="quoted">"spmf <span class="skolem">game2_a_bad</span> True <span class="main">≤</span> <span class="skolem">q1</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">^</span> <span class="free">len</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">rf_encrypt_bad</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">rf_encrypt_bad</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">secret</span> <span class="main">(</span><span class="bound">s</span> <span class="main">::</span> <span class="main">(</span>plain<span class="main">,</span> plain<span class="main">)</span> prf.dict<span class="main">,</span> <span class="bound">bad</span><span class="main">)</span> <span class="bound">plain</span><span class="main">.</span> bind_spmf
     <span class="main">(</span>spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span>
     bind_spmf <span class="main">(</span>prf.random_oracle <span class="bound">s</span> <span class="bound">r</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">pad</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span><span class="main">.</span>
     return_spmf <span class="main">(</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span> xor_list <span class="bound">plain</span> <span class="bound">pad</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">s'</span><span class="main">,</span> <span class="bound">bad</span> <span class="main">∨</span> <span class="bound">r</span> <span class="main">=</span> <span class="bound">secret</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> rf_encrypt_bad_sticky <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> callee_invariant <span class="main">(</span><span class="skolem">rf_encrypt_bad</span> <span class="bound">s</span><span class="main">)</span> snd"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rf_encrypt_bad_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> lossless_rf_encrypt <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">challenge</span> <span class="bound">s</span> <span class="bound">plain</span><span class="main">.</span> lossless_spmf <span class="main">(</span><span class="skolem">rf_encrypt_bad</span> <span class="bound">challenge</span> <span class="bound">s</span> <span class="bound">plain</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rf_encrypt_bad_def prf.random_oracle_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">game2_c</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">game2_c</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">r</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="bound">p0</span><span class="main">,</span> <span class="bound">p1</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">,</span> <span class="bound">s1</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">rf_encrypt</span> <span class="skolem">𝒜1</span> Map.empty<span class="main">;</span>
    <span class="keyword1">if</span> valid_plain <span class="bound">p0</span> <span class="main">∧</span> valid_plain <span class="bound">p1</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">pb</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">p0</span> <span class="keyword1">else</span> <span class="bound">p1</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">pad</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">cipher</span> <span class="main">=</span> <span class="main">(</span><span class="bound">r</span><span class="main">,</span> xor_list <span class="bound">pb</span> <span class="bound">pad</span><span class="main">)</span><span class="main">;</span>
      <span class="main">(</span><span class="bound">b'</span><span class="main">,</span> <span class="main">(</span><span class="bound">s2</span><span class="main">,</span> <span class="bound">bad</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="main">(</span><span class="skolem">rf_encrypt_bad</span> <span class="bound">r</span><span class="main">)</span> <span class="main">(</span><span class="skolem">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">(</span><span class="bound">s1</span><span class="main">(</span><span class="bound">r</span> <span class="main">↦</span> <span class="bound">pad</span><span class="main">)</span><span class="main">,</span> False<span class="main">)</span><span class="main">;</span>
      return_spmf <span class="main">(</span><span class="bound">b'</span> <span class="main">=</span> <span class="bound">b</span><span class="main">,</span> <span class="bound">bad</span><span class="main">)</span>
    <span class="main">}</span> <span class="keyword1">else</span> coin_spmf <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="bound">b</span><span class="main">.</span> return_spmf <span class="main">(</span><span class="bound">b</span><span class="main">,</span> False<span class="main">)</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">have</span></span> bisim2c_bad<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">cipher</span> <span class="bound">σ</span> <span class="bound">s</span> <span class="bound">x</span> <span class="bound">r</span><span class="main">.</span> rel_spmf <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">y</span><span class="main">)</span>
    <span class="main">(</span>exec_gpv <span class="skolem">rf_encrypt</span> <span class="main">(</span><span class="skolem">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">(</span><span class="bound">s</span><span class="main">(</span><span class="bound">x</span> <span class="main">↦</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="main">(</span>exec_gpv <span class="main">(</span><span class="skolem">rf_encrypt_bad</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="skolem">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">(</span><span class="bound">s</span><span class="main">(</span><span class="bound">x</span> <span class="main">↦</span> <span class="bound">r</span><span class="main">)</span><span class="main">,</span> False<span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> exec_gpv_oracle_bisim<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> X<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">s</span> <span class="main">(</span><span class="bound">s'</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="bound">s</span> <span class="main">=</span> <span class="bound">s'</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rf_encrypt_bad_def rf_encrypt_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_bind_reflI<span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> game2b_c <span class="main">[</span><span class="operator">unfolded</span> spmf_rel_eq<span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rel_spmf <span class="main">(=)</span> <span class="main">(</span>map_spmf fst <span class="skolem">game2_b</span><span class="main">)</span> <span class="main">(</span>map_spmf fst <span class="skolem">game2_c</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> game2_b_def game2_c_def o_def split_def Let_def <span class="dynamic"><span class="dynamic">if_distribs</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_bind_reflI rel_spmf_bindI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> bisim2c_bad<span class="main"><span class="main">]</span></span><span class="main">)</span>

  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">game2_d</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">game2_d</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">r</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="bound">p0</span><span class="main">,</span> <span class="bound">p1</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">,</span> <span class="bound">s1</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">rf_encrypt</span> <span class="skolem">𝒜1</span> Map.empty<span class="main">;</span>
    <span class="keyword1">if</span> valid_plain <span class="bound">p0</span> <span class="main">∧</span> valid_plain <span class="bound">p1</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">pb</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">p0</span> <span class="keyword1">else</span> <span class="bound">p1</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">pad</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">cipher</span> <span class="main">=</span> <span class="main">(</span><span class="bound">r</span><span class="main">,</span> xor_list <span class="bound">pb</span> <span class="bound">pad</span><span class="main">)</span><span class="main">;</span>
      <span class="main">(</span><span class="bound">b'</span><span class="main">,</span> <span class="main">(</span><span class="bound">s2</span><span class="main">,</span> <span class="bound">bad</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="main">(</span><span class="skolem">rf_encrypt_bad</span> <span class="bound">r</span><span class="main">)</span> <span class="main">(</span><span class="skolem">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">(</span><span class="bound">s1</span><span class="main">,</span> False<span class="main">)</span><span class="main">;</span>
      return_spmf <span class="main">(</span><span class="bound">b'</span> <span class="main">=</span> <span class="bound">b</span><span class="main">,</span> <span class="bound">bad</span><span class="main">)</span>
    <span class="main">}</span> <span class="keyword1">else</span> coin_spmf <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="bound">b</span><span class="main">.</span> return_spmf <span class="main">(</span><span class="bound">b</span><span class="main">,</span> False<span class="main">)</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>


  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">cipher</span> <span class="skolem">σ</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted">plain</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">s</span> <span class="skolem">r</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?I</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s</span><span class="main">,</span> <span class="bound">bad</span><span class="main">)</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">s'</span><span class="main">,</span> <span class="bound">bad'</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">bad</span> <span class="main">⟷</span> <span class="bound">bad'</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">¬</span> <span class="bound">bad'</span> <span class="main">⟶</span> <span class="bound">x</span> <span class="main">⟷</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?X</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">bad</span><span class="main">)</span> <span class="main">(</span><span class="bound">s'</span><span class="main">,</span> <span class="bound">bad'</span><span class="main">)</span><span class="main">.</span> <span class="bound">bad</span> <span class="main">=</span> <span class="bound">bad'</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">z</span><span class="main">.</span> <span class="bound">z</span> <span class="main">≠</span> <span class="skolem">x</span> <span class="main">⟶</span> <span class="bound">s</span> <span class="bound">z</span> <span class="main">=</span> <span class="bound">s'</span> <span class="bound">z</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s1</span> <span class="bound">s2</span> <span class="bound">x'</span><span class="main">.</span> <span class="var">?X</span> <span class="bound">s1</span> <span class="bound">s2</span> <span class="main">⟹</span> rel_spmf <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">s1'</span><span class="main">)</span> <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">s2'</span><span class="main">)</span><span class="main">.</span> snd <span class="bound">s1'</span> <span class="main">=</span> snd <span class="bound">s2'</span> <span class="main">∧</span> <span class="main">(</span><span class="main">¬</span> snd <span class="bound">s2'</span> <span class="main">⟶</span> <span class="bound">a</span> <span class="main">=</span> <span class="bound">b</span> <span class="main">∧</span> <span class="var">?X</span> <span class="bound">s1'</span> <span class="bound">s2'</span><span class="main">)</span><span class="main">)</span>
       <span class="main">(</span><span class="skolem">rf_encrypt_bad</span> <span class="skolem">x</span> <span class="bound">s1</span> <span class="bound">x'</span><span class="main">)</span> <span class="main">(</span><span class="skolem">rf_encrypt_bad</span> <span class="skolem">x</span> <span class="bound">s2</span> <span class="bound">x'</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="improper">x'</span>"</span></span><span class="main">)</span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rf_encrypt_bad_def prf.random_oracle_def rel_spmf_return_spmf1 rel_spmf_return_spmf2 Let_def split_def bind_UNION <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_bind_reflI <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">with</span></span> _ _ <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"rel_spmf <span class="var">?I</span>
             <span class="main">(</span>exec_gpv <span class="main">(</span><span class="skolem">rf_encrypt_bad</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="skolem">𝒜2</span> <span class="skolem">cipher</span> <span class="skolem">σ</span><span class="main">)</span> <span class="main">(</span><span class="skolem">s</span><span class="main">(</span><span class="skolem">x</span> <span class="main">↦</span> <span class="skolem">r</span><span class="main">)</span><span class="main">,</span> False<span class="main">)</span><span class="main">)</span>
             <span class="main">(</span>exec_gpv <span class="main">(</span><span class="skolem">rf_encrypt_bad</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="skolem">𝒜2</span> <span class="skolem">cipher</span> <span class="skolem">σ</span><span class="main">)</span> <span class="main">(</span><span class="skolem">s</span><span class="main">,</span> False<span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> exec_gpv_oracle_bisim_bad_full<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lossless2<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">note</span></span> bisim_bad <span class="main">=</span> this
  <span class="keyword1"><span class="command">have</span></span> game2c_2d_bad <span class="main">[</span><span class="operator">unfolded</span> spmf_rel_eq<span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rel_spmf <span class="main">(=)</span> <span class="main">(</span>map_spmf snd <span class="skolem">game2_c</span><span class="main">)</span> <span class="main">(</span>map_spmf snd <span class="skolem">game2_d</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> game2_c_def game2_d_def o_def Let_def split_def <span class="dynamic"><span class="dynamic">if_distribs</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_bind_reflI rel_spmf_bindI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> bisim_bad<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"rel_spmf <span class="main">(=)</span> <span class="main">(</span>map_spmf fst <span class="main">(</span><span class="skolem">game2_c</span> <span class="main">↿</span> <span class="main">(</span>snd <span class="main">-`</span> <span class="main">{</span>False<span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>map_spmf fst <span class="main">(</span><span class="skolem">game2_d</span> <span class="main">↿</span> <span class="main">(</span>snd <span class="main">-`</span> <span class="main">{</span>False<span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> game2_c_def game2_d_def
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> restrict_bind_spmf o_def Let_def <span class="dynamic"><span class="dynamic">if_distribs</span></span> split_def restrict_return_spmf <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_bind_reflI rel_spmf_bindI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> bisim_bad<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"spmf <span class="skolem">game2_c</span> <span class="main">(</span>True<span class="main">,</span> False<span class="main">)</span> <span class="main">=</span> spmf <span class="skolem">game2_d</span> <span class="main">(</span>True<span class="main">,</span> False<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> spmf_rel_eq <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> spmf_map_restrict<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> game2c_2d<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¦</span>spmf <span class="main">(</span>map_spmf fst <span class="skolem">game2_c</span><span class="main">)</span> True <span class="main">-</span> spmf <span class="main">(</span>map_spmf fst <span class="skolem">game2_d</span><span class="main">)</span> True<span class="main">¦</span> <span class="main">≤</span> spmf <span class="main">(</span>map_spmf snd <span class="skolem">game2_c</span><span class="main">)</span> True"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> spmf_conv_measure_spmf<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">intro</span> identical_until_bad<span class="main">)</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf.map_id<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> id_def<span class="main"><span class="main">]</span></span> spmf_conv_measure_spmf<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">cipher</span> <span class="skolem">σ</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">challenge</span> <span class="main">::</span> <span class="quoted">plain</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">s</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>nlists UNIV <span class="free">len</span> <span class="main">∩</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">=</span> <span class="skolem">challenge</span><span class="main">)</span> <span class="main">-`</span> <span class="main">{</span>True<span class="main">}</span><span class="main">)</span> <span class="main">≤</span> card <span class="main">{</span><span class="skolem">challenge</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> card_mono<span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>map_spmf <span class="main">(</span>snd <span class="main">∘</span> snd<span class="main">)</span> <span class="main">(</span>exec_gpv <span class="main">(</span><span class="skolem">rf_encrypt_bad</span> <span class="skolem">challenge</span><span class="main">)</span> <span class="main">(</span><span class="skolem">𝒜2</span> <span class="skolem">cipher</span> <span class="skolem">σ</span><span class="main">)</span> <span class="main">(</span><span class="skolem">s</span><span class="main">,</span> False<span class="main">)</span><span class="main">)</span><span class="main">)</span> True <span class="main">≤</span> <span class="main">(</span><span class="main">1</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">^</span> <span class="free">len</span><span class="main">)</span> <span class="main">*</span> <span class="skolem">q2</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> oi_True.interaction_bounded_by_exec_gpv_bad<span class="main"><span class="main">[</span></span><span class="operator">OF</span> q2<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rf_encrypt_bad_def o_def split_beta map_spmf_conv_bind_spmf<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> spmf_map measure_spmf_of_set <span class="dynamic"><span class="dynamic">field_simps</span></span> card_nlists<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∫<span class="hidden">⇧</span><sup>+</sup></span> <span class="bound">x</span><span class="main">.</span> ennreal <span class="main">(</span>indicator <span class="main">{</span>True<span class="main">}</span> <span class="bound">x</span><span class="main">)</span> <span class="main">∂</span>measure_spmf <span class="main">(</span>map_spmf <span class="main">(</span>snd <span class="main">∘</span> snd<span class="main">)</span> <span class="main">(</span>exec_gpv <span class="main">(</span><span class="skolem">rf_encrypt_bad</span> <span class="skolem">challenge</span><span class="main">)</span> <span class="main">(</span><span class="skolem">𝒜2</span> <span class="skolem">cipher</span> <span class="skolem">σ</span><span class="main">)</span> <span class="main">(</span><span class="skolem">s</span><span class="main">,</span> False<span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> <span class="main">(</span><span class="main">1</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">^</span> <span class="free">len</span><span class="main">)</span> <span class="main">*</span> <span class="skolem">q2</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> ennreal_indicator nn_integral_indicator sets_measure_spmf sets_count_space Pow_UNIV UNIV_I emeasure_spmf_single<span class="main">)</span> <span class="operator">simp</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>map_spmf snd <span class="skolem">game2_d</span><span class="main">)</span> True <span class="main">≤</span>
        <span class="main">∫<span class="hidden">⇧</span><sup>+</sup></span> <span class="main">(</span><span class="bound">r</span> <span class="main">::</span> plain<span class="main">)</span><span class="main">.</span> <span class="main">∫<span class="hidden">⇧</span><sup>+</sup></span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="bound">p0</span><span class="main">,</span> <span class="bound">p1</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="keyword1">if</span> valid_plain <span class="bound">p0</span> <span class="main">∧</span> valid_plain <span class="bound">p1</span> <span class="keyword1">then</span>
             <span class="main">∫<span class="hidden">⇧</span><sup>+</sup></span> <span class="bound">b</span> <span class="main">.</span> <span class="main">∫<span class="hidden">⇧</span><sup>+</sup></span> <span class="main">(</span><span class="bound">pad</span> <span class="main">::</span> plain<span class="main">)</span><span class="main">.</span> <span class="skolem">q2</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">^</span> <span class="free">len</span> <span class="main">∂</span>measure_spmf <span class="main">(</span>spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len</span><span class="main">)</span><span class="main">)</span> <span class="main">∂</span>measure_spmf coin_spmf
              <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>
           <span class="main">∂</span>measure_spmf <span class="main">(</span>exec_gpv <span class="skolem">rf_encrypt</span> <span class="skolem">𝒜1</span> Map.empty<span class="main">)</span> <span class="main">∂</span>measure_spmf <span class="main">(</span>spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> game2_d_def
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ennreal_spmf_bind o_def split_def Let_def <span class="dynamic"><span class="dynamic">if_distribs</span></span> if_distrib<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> ennreal <span class="main">(</span>spmf <span class="bound">x</span> <span class="main">_</span><span class="main">)</span>"</span></span><span class="main"><span class="main">]</span></span> indicator_single_Some nn_integral_mono if_mono_cong <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> nn_integral_const <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> if_cong<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="main">∫<span class="hidden">⇧</span><sup>+</sup></span> <span class="main">(</span><span class="bound">r</span> <span class="main">::</span> plain<span class="main">)</span><span class="main">.</span> <span class="main">∫<span class="hidden">⇧</span><sup>+</sup></span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="bound">p0</span><span class="main">,</span> <span class="bound">p1</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="keyword1">if</span> valid_plain <span class="bound">p0</span> <span class="main">∧</span> valid_plain <span class="bound">p1</span> <span class="keyword1">then</span> ennreal <span class="main">(</span><span class="skolem">q2</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">^</span> <span class="free">len</span><span class="main">)</span> <span class="keyword1">else</span> <span class="skolem">q2</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">^</span> <span class="free">len</span><span class="main">)</span>
                   <span class="main">∂</span>measure_spmf <span class="main">(</span>exec_gpv <span class="skolem">rf_encrypt</span> <span class="skolem">𝒜1</span> Map.empty<span class="main">)</span> <span class="main">∂</span>measure_spmf <span class="main">(</span>spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> split_def
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> nn_integral_mono if_mono_cong<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> measure_spmf.emeasure_eq_measure<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="skolem">q2</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">^</span> <span class="free">len</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_def weight1 measure_spmf.emeasure_eq_measure<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> game2_d_bad<span class="main">:</span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>map_spmf snd <span class="skolem">game2_d</span><span class="main">)</span> True <span class="main">≤</span> <span class="skolem">q2</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">^</span> <span class="free">len</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">game3</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">game3</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="bound">p0</span><span class="main">,</span> <span class="bound">p1</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">,</span> <span class="bound">s1</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">rf_encrypt</span> <span class="skolem">𝒜1</span> Map.empty<span class="main">;</span>
      <span class="keyword1">if</span> valid_plain <span class="bound">p0</span> <span class="main">∧</span> valid_plain <span class="bound">p1</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
        <span class="keyword1">let</span> <span class="bound">pb</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">p0</span> <span class="keyword1">else</span> <span class="bound">p1</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">r</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">pad</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1">let</span> <span class="bound">cipher</span> <span class="main">=</span> <span class="main">(</span><span class="bound">r</span><span class="main">,</span> xor_list <span class="bound">pb</span> <span class="bound">pad</span><span class="main">)</span><span class="main">;</span>
        <span class="main">(</span><span class="bound">b'</span><span class="main">,</span> <span class="bound">s2</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">rf_encrypt</span> <span class="main">(</span><span class="skolem">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="bound">s1</span><span class="main">;</span>
        return_spmf <span class="main">(</span><span class="bound">b'</span> <span class="main">=</span> <span class="bound">b</span><span class="main">)</span>
      <span class="main">}</span> <span class="keyword1">else</span> coin_spmf
    <span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> bisim2d_3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">cipher</span> <span class="bound">σ</span> <span class="bound">s</span> <span class="bound">r</span><span class="main">.</span> rel_spmf <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">y</span><span class="main">)</span>
             <span class="main">(</span>exec_gpv <span class="main">(</span><span class="skolem">rf_encrypt_bad</span> <span class="bound">r</span><span class="main">)</span> <span class="main">(</span><span class="skolem">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span> False<span class="main">)</span><span class="main">)</span>
             <span class="main">(</span>exec_gpv <span class="skolem">rf_encrypt</span> <span class="main">(</span><span class="skolem">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="bound">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> exec_gpv_oracle_bisim<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> X<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">s1</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="bound">s2</span><span class="main">.</span> <span class="bound">s1</span> <span class="main">=</span> <span class="bound">s2</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rf_encrypt_bad_def rf_encrypt_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_bind_reflI<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> game2d_3<span class="main">:</span> <span class="quoted"><span class="quoted">"rel_spmf <span class="main">(=)</span> <span class="main">(</span>map_spmf fst <span class="skolem">game2_d</span><span class="main">)</span> <span class="skolem">game3</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> game2_d_def game3_def Let_def <span class="keyword1"><span class="command">including</span></span> monad_normalisation
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def split_def <span class="dynamic"><span class="dynamic">if_distribs</span></span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> if_cong <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_bind_reflI rel_spmf_bindI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> bisim2d_3<span class="main"><span class="main">]</span></span><span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¦</span>spmf <span class="skolem">game2</span> True <span class="main">-</span> <span class="main">1</span> <span class="main">/</span> <span class="numeral">2</span><span class="main">¦</span> <span class="main">≤</span>
    <span class="main">¦</span>spmf <span class="main">(</span>map_spmf fst <span class="skolem">game2_a</span><span class="main">)</span> True <span class="main">-</span> spmf <span class="main">(</span>map_spmf fst <span class="skolem">game2_b</span><span class="main">)</span> True<span class="main">¦</span> <span class="main">+</span> <span class="main">¦</span>spmf <span class="main">(</span>map_spmf fst <span class="skolem">game2_b</span><span class="main">)</span> True <span class="main">-</span> <span class="main">1</span> <span class="main">/</span> <span class="numeral">2</span><span class="main">¦</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> game2_2a <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> abs_diff_triangle_ineq2<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="skolem">q1</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">^</span> <span class="free">len</span> <span class="main">+</span> <span class="main">¦</span>spmf <span class="main">(</span>map_spmf fst <span class="skolem">game2_b</span><span class="main">)</span> True <span class="main">-</span> <span class="main">1</span> <span class="main">/</span> <span class="numeral">2</span><span class="main">¦</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> game2a_2b game2a_bad_bound <span class="keyword1"><span class="command">unfolding</span></span> game2a_bad <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> add_right_mono<span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¦</span>spmf <span class="main">(</span>map_spmf fst <span class="skolem">game2_b</span><span class="main">)</span> True <span class="main">-</span> <span class="main">1</span> <span class="main">/</span> <span class="numeral">2</span><span class="main">¦</span> <span class="main">≤</span>
    <span class="main">¦</span>spmf <span class="main">(</span>map_spmf fst <span class="skolem">game2_c</span><span class="main">)</span> True <span class="main">-</span> spmf <span class="main">(</span>map_spmf fst <span class="skolem">game2_d</span><span class="main">)</span> True<span class="main">¦</span> <span class="main">+</span> <span class="main">¦</span>spmf <span class="main">(</span>map_spmf fst <span class="skolem">game2_d</span><span class="main">)</span> True <span class="main">-</span> <span class="main">1</span> <span class="main">/</span> <span class="numeral">2</span><span class="main">¦</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> game2b_c <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> abs_diff_triangle_ineq2<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="main">(</span>add_left_mono_trans<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="skolem">q2</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">^</span> <span class="free">len</span> <span class="main">+</span> <span class="main">¦</span>spmf <span class="main">(</span>map_spmf fst <span class="skolem">game2_d</span><span class="main">)</span> True <span class="main">-</span> <span class="main">1</span> <span class="main">/</span> <span class="numeral">2</span><span class="main">¦</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> game2c_2d game2_d_bad <span class="keyword1"><span class="command">unfolding</span></span> game2c_2d_bad <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> add_right_mono<span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="main">(</span>add_left_mono_trans<span class="main">)</span> 
  <span class="keyword1"><span class="command">have</span></span> game2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¦</span>spmf <span class="skolem">game2</span> True <span class="main">-</span> <span class="main">1</span> <span class="main">/</span> <span class="numeral">2</span><span class="main">¦</span> <span class="main">≤</span> <span class="skolem">q1</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">^</span> <span class="free">len</span> <span class="main">+</span> <span class="skolem">q2</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">^</span> <span class="free">len</span> <span class="main">+</span>  <span class="main">¦</span>spmf <span class="skolem">game3</span> True <span class="main">-</span> <span class="main">1</span> <span class="main">/</span> <span class="numeral">2</span><span class="main">¦</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> game2d_3 <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">field_simps</span></span> spmf_rel_eq<span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">game3</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="bound">p0</span><span class="main">,</span> <span class="bound">p1</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">,</span> <span class="bound">s1</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">rf_encrypt</span> <span class="skolem">𝒜1</span> Map.empty<span class="main">;</span>
      <span class="keyword1">if</span> valid_plain <span class="bound">p0</span> <span class="main">∧</span> valid_plain <span class="bound">p1</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
        <span class="keyword1">let</span> <span class="bound">pb</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">p0</span> <span class="keyword1">else</span> <span class="bound">p1</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">r</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">pad</span> <span class="main">←</span> map_spmf <span class="main">(</span>xor_list <span class="bound">pb</span><span class="main">)</span> <span class="main">(</span>spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1">let</span> <span class="bound">cipher</span> <span class="main">=</span> <span class="main">(</span><span class="bound">r</span><span class="main">,</span> xor_list <span class="bound">pb</span> <span class="bound">pad</span><span class="main">)</span><span class="main">;</span>
        <span class="main">(</span><span class="bound">b'</span><span class="main">,</span> <span class="bound">s2</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">rf_encrypt</span> <span class="main">(</span><span class="skolem">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="bound">s1</span><span class="main">;</span>
        return_spmf <span class="main">(</span><span class="bound">b'</span> <span class="main">=</span> <span class="bound">b</span><span class="main">)</span>
      <span class="main">}</span> <span class="keyword1">else</span> coin_spmf
    <span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> valid_plain_def game3_def Let_def one_time_pad <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> bind_map_spmf map_spmf_of_set_inj_on <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> bind_spmf_cong_simp if_cong <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
       <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="bound">p0</span><span class="main">,</span> <span class="bound">p1</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">,</span> <span class="bound">s1</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">rf_encrypt</span> <span class="skolem">𝒜1</span> Map.empty<span class="main">;</span>
       <span class="keyword1">if</span> valid_plain <span class="bound">p0</span> <span class="main">∧</span> valid_plain <span class="bound">p1</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
         <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
         <span class="keyword1">let</span> <span class="bound">pb</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">p0</span> <span class="keyword1">else</span> <span class="bound">p1</span><span class="main">)</span><span class="main">;</span>
         <span class="bound">r</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len</span><span class="main">)</span><span class="main">;</span>
         <span class="bound">pad</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len</span><span class="main">)</span><span class="main">;</span>
         <span class="keyword1">let</span> <span class="bound">cipher</span> <span class="main">=</span> <span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">pad</span><span class="main">)</span><span class="main">;</span>
         <span class="main">(</span><span class="bound">b'</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">rf_encrypt</span> <span class="main">(</span><span class="skolem">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="bound">s1</span><span class="main">;</span>
         return_spmf <span class="main">(</span><span class="bound">b'</span> <span class="main">=</span> <span class="bound">b</span><span class="main">)</span>
       <span class="main">}</span> <span class="keyword1">else</span> coin_spmf
     <span class="main">}</span>"</span></span>
     <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> game3_def Let_def valid_plain_def in_nlists_UNIV <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> bind_spmf_cong_simp if_cong <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="bound">p0</span><span class="main">,</span> <span class="bound">p1</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">,</span> <span class="bound">s1</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">rf_encrypt</span> <span class="skolem">𝒜1</span> Map.empty<span class="main">;</span>
      <span class="keyword1">if</span> valid_plain <span class="bound">p0</span> <span class="main">∧</span> valid_plain <span class="bound">p1</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">r</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">pad</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1">let</span> <span class="bound">cipher</span> <span class="main">=</span> <span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">pad</span><span class="main">)</span><span class="main">;</span>
        <span class="main">(</span><span class="bound">b'</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">rf_encrypt</span> <span class="main">(</span><span class="skolem">𝒜2</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="bound">s1</span><span class="main">;</span>
        map_spmf <span class="main">(</span><span class="main">(=)</span> <span class="bound">b'</span><span class="main">)</span> coin_spmf
      <span class="main">}</span> <span class="keyword1">else</span> coin_spmf
    <span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">including</span></span> monad_normalisation <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_spmf_conv_bind_spmf split_def Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> coin_spmf"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_eq_const_coin_spmf Let_def split_def weight2 weight1<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> game3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">game3</span> <span class="main">=</span> coin_spmf"</span></span> <span class="keyword1"><span class="command">.</span></span>
  
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ind_cpa.advantage <span class="free">𝒜</span> <span class="main">≤</span> prf.advantage <span class="main">(</span>prf_adversary <span class="free">𝒜</span><span class="main">)</span> <span class="main">+</span> <span class="main">¦</span>spmf <span class="main">(</span>prf.game_1 <span class="main">(</span>prf_adversary <span class="free">𝒜</span><span class="main">)</span><span class="main">)</span> True <span class="main">-</span> <span class="main">1</span> <span class="main">/</span> <span class="numeral">2</span><span class="main">¦</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> ind_cpa.advantage_def prf.advantage_def ind_cpa_0<span class="main">[</span><span class="operator">unfolded</span> spmf_rel_eq<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> abs_diff_triangle_ineq2<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¦</span>spmf <span class="main">(</span>prf.game_1 <span class="main">(</span>prf_adversary <span class="free">𝒜</span><span class="main">)</span><span class="main">)</span> True <span class="main">-</span> <span class="main">1</span> <span class="main">/</span> <span class="numeral">2</span><span class="main">¦</span> <span class="main">≤</span> <span class="skolem">q1</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">^</span> <span class="free">len</span> <span class="main">+</span> <span class="skolem">q2</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">^</span> <span class="free">len</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> game1_2 game2 game3 <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf_of_set<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">q1</span> <span class="main">+</span> <span class="skolem">q2</span><span class="main">)</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">^</span> <span class="free">len</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">field_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="free">q</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">^</span> <span class="free">len</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">q1</span> <span class="main">+</span> <span class="skolem">q2</span> <span class="main">≤</span> <span class="free">q</span>›</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> divide_right_mono<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">field_simps</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> interaction_bounded_prf_adversary<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">q</span> <span class="main">::</span> <span class="quoted">nat</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ind_cpa.ibounded_by <span class="free">𝒜</span> <span class="free">q</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"prf.ibounded_by <span class="main">(</span>prf_adversary <span class="free">𝒜</span><span class="main">)</span> <span class="main">(</span><span class="main">1</span> <span class="main">+</span> <span class="free">q</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">η</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ind_cpa.ibounded_by <span class="free">𝒜</span> <span class="free">q</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">q1</span></span> <span class="skolem"><span class="skolem">q2</span></span> <span class="keyword2"><span class="keyword">where</span></span> q<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">q1</span> <span class="main">+</span> <span class="skolem">q2</span> <span class="main">≤</span> <span class="free">q</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">interaction_bound</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"interaction_any_bounded_by <span class="main">(</span>fst <span class="free">𝒜</span><span class="main">)</span> <span class="skolem">q1</span>"</span></span>
       <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">σ</span><span class="main">.</span> interaction_any_bounded_by <span class="main">(</span>snd <span class="free">𝒜</span> <span class="bound">x</span> <span class="bound">σ</span><span class="main">)</span> <span class="skolem">q2</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> ind_cpa.ibounded_by_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_beta iadd_le_enat_iff<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"prf.ibounded_by <span class="main">(</span>prf_adversary <span class="free">𝒜</span><span class="main">)</span> <span class="main">(</span><span class="main">1</span> <span class="main">+</span> <span class="free">q</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> q
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> prf_adversary_def Let_def split_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">interaction_bound</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> iadd_SUP_le_iff SUP_le_iff add.assoc <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> one_enat_def <span class="quasi_keyword">cong</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> image_cong_simp <span class="quasi_keyword">cong</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> SUP_cong_simp<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span> 
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_prf_adversary<span class="main">:</span> <span class="quoted"><span class="quoted">"ind_cpa.lossless <span class="free">𝒜</span> <span class="main">⟹</span> prf.lossless <span class="main">(</span>prf_adversary <span class="free">𝒜</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> prf_adversary_def Let_def split_def ind_cpa.lossless_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lossless_inline<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> otp_η <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> key <span class="main">⇒</span> bool list <span class="main">⇒</span> bool list"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">len</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> nat"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> length_f<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">η</span> <span class="bound">xs</span> <span class="bound">ys</span><span class="main">.</span> <span class="main">⟦</span> length <span class="bound">xs</span> <span class="main">=</span> <span class="free">len</span> <span class="bound">η</span><span class="main">;</span> length <span class="bound">ys</span> <span class="main">=</span> <span class="free">len</span> <span class="bound">η</span> <span class="main">⟧</span> <span class="main">⟹</span> length <span class="main">(</span><span class="free">f</span> <span class="bound">η</span> <span class="bound">xs</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">=</span> <span class="free">len</span> <span class="bound">η</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> negligible_len <span class="main">[</span><span class="operator">negligible_intros</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"negligible <span class="main">(</span><span class="main">λ</span><span class="bound">η</span><span class="main">.</span> <span class="main">1</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">^</span> <span class="main">(</span><span class="free">len</span> <span class="bound">η</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> otp <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">η</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">len</span> <span class="free">η</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">η</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span><span class="main">(</span><span class="operator">rule</span> length_f<span class="main">)</span>
<span class="keyword1"><span class="command">interpretation</span></span> ind_cpa<span class="main">:</span> ind_cpa <span class="quoted"><span class="quoted">"key_gen <span class="free">η</span>"</span></span> <span class="quoted"><span class="quoted">"encrypt <span class="free">η</span>"</span></span> <span class="quoted"><span class="quoted">"decrypt <span class="free">η</span>"</span></span> <span class="quoted"><span class="quoted">"valid_plain <span class="free">η</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">η</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">interpretation</span></span> <span class="quoted">"prf"</span><span class="main">:</span> <span class="quoted">"prf"</span> <span class="quoted"><span class="quoted">"key_gen <span class="free">η</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">η</span>"</span></span> <span class="quoted"><span class="quoted">"spmf_of_set <span class="main">(</span>nlists UNIV <span class="main">(</span><span class="free">len</span> <span class="free">η</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">η</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lemma</span></span> prf_encrypt_secure_for<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">negligible_intros</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"negligible <span class="main">(</span><span class="main">λ</span><span class="bound">η</span><span class="main">.</span> prf.advantage <span class="bound">η</span> <span class="main">(</span>prf_adversary <span class="bound">η</span> <span class="main">(</span><span class="free">𝒜</span> <span class="bound">η</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> q<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">η</span><span class="main">.</span> ind_cpa.ibounded_by <span class="main">(</span><span class="free">𝒜</span> <span class="bound">η</span><span class="main">)</span> <span class="main">(</span><span class="free">q</span> <span class="bound">η</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">negligible_intros</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"polynomial <span class="free">q</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> lossless<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">η</span><span class="main">.</span> ind_cpa.lossless <span class="main">(</span><span class="free">𝒜</span> <span class="bound">η</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"negligible <span class="main">(</span><span class="main">λ</span><span class="bound">η</span><span class="main">.</span> ind_cpa.advantage <span class="bound">η</span> <span class="main">(</span><span class="free">𝒜</span> <span class="bound">η</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> negligible_mono<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"negligible <span class="main">(</span><span class="main">λ</span><span class="bound">η</span><span class="main">.</span> prf.advantage <span class="bound">η</span> <span class="main">(</span>prf_adversary <span class="bound">η</span> <span class="main">(</span><span class="free">𝒜</span> <span class="bound">η</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> <span class="free">q</span> <span class="bound">η</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">^</span> <span class="free">len</span> <span class="bound">η</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> <span class="dynamic"><span class="dynamic">negligible_intros</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">η</span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹ind_cpa.ibounded_by <span class="main">_</span> <span class="main">_</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ind_cpa.ibounded_by <span class="main">(</span><span class="free">𝒜</span> <span class="skolem">η</span><span class="main">)</span> <span class="main">(</span><span class="free">q</span> <span class="skolem">η</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> lossless <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ind_cpa.lossless <span class="main">(</span><span class="free">𝒜</span> <span class="skolem">η</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lossless_gpv ℐ_full <span class="main">(</span>fst <span class="main">(</span><span class="free">𝒜</span> <span class="skolem">η</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">cipher</span> <span class="bound">σ</span><span class="main">.</span> lossless_gpv ℐ_full <span class="main">(</span>snd <span class="main">(</span><span class="free">𝒜</span> <span class="skolem">η</span><span class="main">)</span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ind_cpa.lossless_def<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ind_cpa.advantage <span class="skolem">η</span> <span class="main">(</span><span class="free">𝒜</span> <span class="skolem">η</span><span class="main">)</span> <span class="main">≤</span> prf.advantage <span class="skolem">η</span> <span class="main">(</span>prf_adversary <span class="skolem">η</span> <span class="main">(</span><span class="free">𝒜</span> <span class="skolem">η</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> <span class="free">q</span> <span class="skolem">η</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">^</span> <span class="free">len</span> <span class="skolem">η</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> prf_encrypt_advantage<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"eventually <span class="main">(</span><span class="main">λ</span><span class="bound">η</span><span class="main">.</span> <span class="main">¦</span>ind_cpa.advantage <span class="bound">η</span> <span class="main">(</span><span class="free">𝒜</span> <span class="bound">η</span><span class="main">)</span><span class="main">¦</span> <span class="main">≤</span> <span class="main">1</span> <span class="main">*</span> <span class="main">¦</span>prf.advantage <span class="bound">η</span> <span class="main">(</span>prf_adversary <span class="bound">η</span> <span class="main">(</span><span class="free">𝒜</span> <span class="bound">η</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> <span class="free">q</span> <span class="bound">η</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">^</span> <span class="free">len</span> <span class="bound">η</span><span class="main">¦</span><span class="main">)</span> at_top"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> always_eventually ind_cpa.advantage_nonneg prf.advantage_nonneg<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">η</span><span class="main">.</span> ind_cpa.advantage <span class="bound">η</span> <span class="main">(</span><span class="free">𝒜</span> <span class="bound">η</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> <span class="keyword1">O(</span><span class="main">λ</span><span class="bound">η</span><span class="main">.</span> prf.advantage <span class="bound">η</span> <span class="main">(</span>prf_adversary <span class="bound">η</span> <span class="main">(</span><span class="free">𝒜</span> <span class="bound">η</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> <span class="free">q</span> <span class="bound">η</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">^</span> <span class="free">len</span> <span class="bound">η</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> bigoI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> c<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="main">1</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="PRF_UPF_IND_CCA">
<div class="head">
<h1>Theory PRF_UPF_IND_CCA</h1>
</div>
<pre class="source"><span class="comment1">(* Title: PRF_UPF_IND_CCA.thy
  Author: Andreas Lochbihler, ETH Zurich 
  Author: S. Reza Sefidgar, ETH Zurich *)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹IND-CCA from a PRF and an unpredictable function›</span></span>

<span class="keyword1"><span class="command">theory</span></span> PRF_UPF_IND_CCA
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Pseudo_Random_Function.html">Pseudo_Random_Function</a>
  <a href="../CryptHOL/List_Bits.html">CryptHOL.List_Bits</a>
  <a href="Unpredictable_Function.html">Unpredictable_Function</a>
  <a href="IND_CCA2_sym.html">IND_CCA2_sym</a>
  <a href="../CryptHOL/Negligible.html">CryptHOL.Negligible</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Formalisation of Shoup's construction of an IND-CCA secure cipher from a PRF and an unpredictable function \cite[\S 7]{Shoup2004IACR}.›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> bitstring <span class="main">=</span> <span class="quoted"><span class="quoted">"bool list"</span></span>

<span class="keyword1"><span class="command">locale</span></span> simple_cipher <span class="main">=</span> 
  PRF<span class="main">:</span> <span class="quoted">"prf"</span> <span class="quoted"><span class="free">prf_key_gen</span></span> <span class="quoted"><span class="free">prf_fun</span></span> <span class="quoted"><span class="quoted">"spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">prf_clen</span><span class="main">)</span>"</span></span> <span class="main">+</span>
  UPF<span class="main">:</span> upf <span class="quoted"><span class="free">upf_key_gen</span></span> <span class="quoted"><span class="free">upf_fun</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">prf_key_gen</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'prf_key</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">prf_fun</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'prf_key</span> <span class="main">⇒</span> bitstring <span class="main">⇒</span> bitstring"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">prf_domain</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"bitstring set"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">prf_range</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"bitstring set"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">prf_dlen</span> <span class="main">::</span> <span class="quoted">nat</span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">prf_clen</span> <span class="main">::</span> <span class="quoted">nat</span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">upf_key_gen</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'upf_key</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">upf_fun</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'upf_key</span> <span class="main">⇒</span> bitstring <span class="main">⇒</span> <span class="tfree">'hash</span>"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> prf_domain_finite<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">prf_domain</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> prf_domain_nonempty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">prf_domain</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> prf_domain_length<span class="main">:</span>  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">prf_domain</span> <span class="main">⟹</span> length <span class="free">x</span> <span class="main">=</span> <span class="free">prf_dlen</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> prf_codomain_length<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">key_prf</span> <span class="main">∈</span> set_spmf <span class="free">prf_key_gen</span><span class="main">;</span> <span class="free">m</span> <span class="main">∈</span> <span class="free">prf_domain</span> <span class="main">⟧</span> <span class="main">⟹</span> length <span class="main">(</span><span class="free">prf_fun</span> <span class="free">key_prf</span> <span class="free">m</span><span class="main">)</span> <span class="main">=</span> <span class="free">prf_clen</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> prf_key_gen_lossless<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="free">prf_key_gen</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> upf_key_gen_lossless<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="free">upf_key_gen</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'hash'</span> cipher_text <span class="main">=</span> <span class="quoted"><span class="quoted">"bitstring <span class="main">×</span> bitstring <span class="main">×</span> <span class="tfree">'hash'</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">key_gen</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'prf_key</span> <span class="main">×</span> <span class="tfree">'upf_key</span><span class="main">)</span> spmf"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
 <span class="quoted"><span class="quoted">"<span class="free">key_gen</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
   <span class="bound">k_prf</span> <span class="main">←</span> <span class="free">prf_key_gen</span><span class="main">;</span>
   <span class="bound">k_upf</span> <span class="main">::</span> <span class="tfree">'upf_key</span> <span class="main">←</span> <span class="free">upf_key_gen</span><span class="main">;</span>
   return_spmf <span class="main">(</span><span class="bound">k_prf</span><span class="main">,</span> <span class="bound">k_upf</span><span class="main">)</span>
 <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_key_gen <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf key_gen"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> key_gen_def prf_key_gen_lossless upf_key_gen_lossless<span class="main">)</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">encrypt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'prf_key</span> <span class="main">×</span> <span class="tfree">'upf_key</span><span class="main">)</span> <span class="main">⇒</span> bitstring <span class="main">⇒</span> <span class="tfree">'hash</span> cipher_text spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">encrypt</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">k_prf</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">k_upf</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">x</span> <span class="main">←</span> spmf_of_set <span class="free">prf_domain</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">c</span> <span class="main">=</span> <span class="free">prf_fun</span> <span class="free"><span class="bound"><span class="entity">k_prf</span></span></span> <span class="bound">x</span> <span class="main">[⊕]</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">t</span> <span class="main">=</span> <span class="free">upf_fun</span> <span class="free"><span class="bound"><span class="entity">k_upf</span></span></span> <span class="main">(</span><span class="bound">x</span> <span class="main">@</span> <span class="bound">c</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">c</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_encrypt <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>encrypt <span class="free">k</span> <span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">k</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def prf_domain_nonempty prf_domain_finite <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> bool.split<span class="main">)</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">decrypt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'prf_key</span> <span class="main">×</span> <span class="tfree">'upf_key</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'hash</span> cipher_text <span class="main">⇒</span> bitstring option"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">decrypt</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">k_prf</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">k_upf</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
    <span class="keyword1">if</span> <span class="free">upf_fun</span> <span class="free"><span class="bound"><span class="entity">k_upf</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">@</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">∧</span> length <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free">prf_dlen</span> <span class="keyword1">then</span>
      Some <span class="main">(</span><span class="free">prf_fun</span> <span class="free"><span class="bound"><span class="entity">k_prf</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">[⊕]</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span>
    <span class="keyword1">else</span>
      None
  <span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cipher_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">k</span> <span class="main">∈</span> set_spmf key_gen<span class="main">;</span> length <span class="free">m</span> <span class="main">=</span> <span class="free">prf_clen</span> <span class="main">⟧</span>
  <span class="main">⟹</span> encrypt <span class="free">k</span> <span class="free">m</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> return_spmf <span class="main">(</span>decrypt <span class="free">k</span> <span class="bound">c</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> return_spmf <span class="main">(</span>Some <span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">k</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> prf_domain_nonempty prf_domain_finite prf_domain_length
  prf_codomain_length key_gen_def bind_eq_return_spmf Let_def<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> encrypt.simps<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>

<span class="keyword1"><span class="command">sublocale</span></span> ind_cca<span class="main">:</span> ind_cca <span class="quoted">key_gen</span> <span class="quoted">encrypt</span> <span class="quoted">decrypt</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">m</span><span class="main">.</span> length <span class="bound">m</span> <span class="main">=</span> <span class="free">prf_clen</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">interpretation</span></span> ind_cca'<span class="main">:</span> ind_cca <span class="quoted">key_gen</span> <span class="quoted">encrypt</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> None"</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">m</span><span class="main">.</span> length <span class="bound">m</span> <span class="main">=</span> <span class="free">prf_clen</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">intercept_upf_enc</span>
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'prf_key</span> <span class="main">⇒</span> bool <span class="main">⇒</span> <span class="tfree">'hash</span> cipher_text set <span class="main">×</span> <span class="tfree">'hash</span> cipher_text set <span class="main">⇒</span> bitstring <span class="main">×</span> bitstring
  <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'hash</span> cipher_text option <span class="main">×</span> <span class="main">(</span><span class="tfree">'hash</span> cipher_text set <span class="main">×</span> <span class="tfree">'hash</span> cipher_text set<span class="main">)</span><span class="main">,</span>
     bitstring <span class="main">+</span> <span class="main">(</span>bitstring <span class="main">×</span> <span class="tfree">'hash</span><span class="main">)</span><span class="main">,</span> <span class="tfree">'hash</span> <span class="main">+</span> unit<span class="main">)</span> gpv"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">intercept_upf_enc</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">L</span><span class="main">,</span> <span class="bound">D</span><span class="main">)</span> <span class="main">(</span><span class="bound">m1</span><span class="main">,</span> <span class="bound">m0</span><span class="main">)</span><span class="main">.</span>
    <span class="main">(</span><span class="keyword1">case</span> <span class="main">(</span>length <span class="bound">m1</span> <span class="main">=</span> <span class="free">prf_clen</span> <span class="main">∧</span> length <span class="bound">m0</span> <span class="main">=</span> <span class="free">prf_clen</span><span class="main">)</span> <span class="keyword1">of</span>
      False <span class="main">⇒</span> Done <span class="main">(</span>None<span class="main">,</span> <span class="bound">L</span><span class="main">,</span> <span class="bound">D</span><span class="main">)</span>
    <span class="main">|</span> True <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">x</span> <span class="main">←</span> lift_spmf <span class="main">(</span>spmf_of_set <span class="free">prf_domain</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1">let</span> <span class="bound">c</span> <span class="main">=</span> <span class="free">prf_fun</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="bound">x</span> <span class="main">[⊕]</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="keyword1">then</span> <span class="bound">m1</span> <span class="keyword1">else</span> <span class="bound">m0</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">t</span> <span class="main">←</span> Pause <span class="main">(</span>Inl <span class="main">(</span><span class="bound">x</span> <span class="main">@</span> <span class="bound">c</span><span class="main">)</span><span class="main">)</span> Done<span class="main">;</span>
        Done <span class="main">(</span><span class="main">(</span>Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">c</span><span class="main">,</span> projl <span class="bound">t</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>insert <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">c</span><span class="main">,</span> projl <span class="bound">t</span><span class="main">)</span> <span class="bound">L</span><span class="main">,</span> <span class="bound">D</span><span class="main">)</span><span class="main">)</span>
      <span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">intercept_upf_dec</span>
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'hash</span> cipher_text set <span class="main">×</span> <span class="tfree">'hash</span> cipher_text set <span class="main">⇒</span> <span class="tfree">'hash</span> cipher_text
  <span class="main">⇒</span> <span class="main">(</span>bitstring option <span class="main">×</span> <span class="main">(</span><span class="tfree">'hash</span> cipher_text set <span class="main">×</span> <span class="tfree">'hash</span> cipher_text set<span class="main">)</span><span class="main">,</span>
     bitstring <span class="main">+</span> <span class="main">(</span>bitstring <span class="main">×</span> <span class="tfree">'hash</span><span class="main">)</span><span class="main">,</span> <span class="tfree">'hash</span> <span class="main">+</span> unit<span class="main">)</span> gpv"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">intercept_upf_dec</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">L</span><span class="main">,</span> <span class="bound">D</span><span class="main">)</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">c</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span><span class="main">.</span>
    <span class="keyword1">if</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">c</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span> <span class="main">∈</span> <span class="bound">L</span> <span class="main">∨</span> length <span class="bound">x</span> <span class="main">≠</span> <span class="free">prf_dlen</span> <span class="keyword1">then</span> Done <span class="main">(</span>None<span class="main">,</span> <span class="main">(</span><span class="bound">L</span><span class="main">,</span> <span class="bound">D</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
      Pause <span class="main">(</span>Inr <span class="main">(</span><span class="bound">x</span> <span class="main">@</span> <span class="bound">c</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span><span class="main">)</span> Done<span class="main">;</span>
      Done <span class="main">(</span>None<span class="main">,</span> <span class="main">(</span><span class="bound">L</span><span class="main">,</span> insert <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">c</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span> <span class="bound">D</span><span class="main">)</span><span class="main">)</span>
    <span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">intercept_upf</span> <span class="main">::</span> 
  <span class="quoted"><span class="quoted">"<span class="tfree">'prf_key</span> <span class="main">⇒</span> bool <span class="main">⇒</span> <span class="tfree">'hash</span> cipher_text set <span class="main">×</span> <span class="tfree">'hash</span> cipher_text set <span class="main">⇒</span> bitstring <span class="main">×</span> bitstring <span class="main">+</span> <span class="tfree">'hash</span> cipher_text
  <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'hash</span> cipher_text option <span class="main">+</span> bitstring option<span class="main">)</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'hash</span> cipher_text set <span class="main">×</span> <span class="tfree">'hash</span> cipher_text set<span class="main">)</span><span class="main">,</span>
     bitstring <span class="main">+</span> <span class="main">(</span>bitstring <span class="main">×</span> <span class="tfree">'hash</span><span class="main">)</span><span class="main">,</span> <span class="tfree">'hash</span> <span class="main">+</span> unit<span class="main">)</span> gpv"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">intercept_upf</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> plus_intercept <span class="main">(</span>intercept_upf_enc <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span> intercept_upf_dec"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> intercept_upf_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"intercept_upf <span class="free">k</span> <span class="free">b</span> <span class="main">(</span><span class="free">L</span><span class="main">,</span> <span class="free">D</span><span class="main">)</span> <span class="main">(</span>Inr <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">c</span><span class="main">,</span> <span class="free">t</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">c</span><span class="main">,</span> <span class="free">t</span><span class="main">)</span> <span class="main">∈</span> <span class="free">L</span> <span class="main">∨</span> length <span class="free">x</span> <span class="main">≠</span> <span class="free">prf_dlen</span> <span class="keyword1">then</span> Done <span class="main">(</span>Inr None<span class="main">,</span> <span class="main">(</span><span class="free">L</span><span class="main">,</span> <span class="free">D</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
      Pause <span class="main">(</span>Inr <span class="main">(</span><span class="free">x</span> <span class="main">@</span> <span class="free">c</span><span class="main">,</span> <span class="free">t</span><span class="main">)</span><span class="main">)</span> Done<span class="main">;</span>
      Done <span class="main">(</span>Inr None<span class="main">,</span> <span class="main">(</span><span class="free">L</span><span class="main">,</span> insert <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">c</span><span class="main">,</span> <span class="free">t</span><span class="main">)</span> <span class="free">D</span><span class="main">)</span><span class="main">)</span>
    <span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"intercept_upf <span class="free">k</span> <span class="free">b</span> <span class="main">(</span><span class="free">L</span><span class="main">,</span> <span class="free">D</span><span class="main">)</span> <span class="main">(</span>Inl <span class="main">(</span><span class="free">m1</span><span class="main">,</span> <span class="free">m0</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
    <span class="main">(</span><span class="keyword1">case</span> <span class="main">(</span>length <span class="free">m1</span> <span class="main">=</span> <span class="free">prf_clen</span> <span class="main">∧</span> length <span class="free">m0</span> <span class="main">=</span> <span class="free">prf_clen</span><span class="main">)</span> <span class="keyword1">of</span>
      False <span class="main">⇒</span> Done <span class="main">(</span>Inl None<span class="main">,</span> <span class="free">L</span><span class="main">,</span> <span class="free">D</span><span class="main">)</span>
    <span class="main">|</span> True <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">x</span> <span class="main">←</span> lift_spmf <span class="main">(</span>spmf_of_set <span class="free">prf_domain</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1">let</span> <span class="bound">c</span> <span class="main">=</span> <span class="free">prf_fun</span> <span class="free">k</span> <span class="bound">x</span> <span class="main">[⊕]</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">m1</span> <span class="keyword1">else</span> <span class="free">m0</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">t</span> <span class="main">←</span> Pause <span class="main">(</span>Inl <span class="main">(</span><span class="bound">x</span> <span class="main">@</span> <span class="bound">c</span><span class="main">)</span><span class="main">)</span> Done<span class="main">;</span>
        Done <span class="main">(</span>Inl <span class="main">(</span>Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">c</span><span class="main">,</span> projl <span class="bound">t</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>insert <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">c</span><span class="main">,</span> projl <span class="bound">t</span><span class="main">)</span> <span class="free">L</span><span class="main">,</span> <span class="free">D</span><span class="main">)</span><span class="main">)</span>
      <span class="main">}</span><span class="main">)</span>"</span></span>
   <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> intercept_upf_def intercept_upf_dec_def intercept_upf_enc_def o_def map_gpv_bind_gpv gpv.map_id Let_def <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> bool.split<span class="main">)</span>


<span class="keyword1"><span class="command">lemma</span></span> interaction_bounded_by_upf_enc_Inr <span class="main">[</span><span class="operator">interaction_bound</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"interaction_bounded_by <span class="main">(</span>Not <span class="main">∘</span> isl<span class="main">)</span> <span class="main">(</span>intercept_upf_enc <span class="free">k</span> <span class="free">b</span> <span class="free">LD</span> <span class="free">mm</span><span class="main">)</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> intercept_upf_enc_def case_prod_app
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">interaction_bound</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> SUP_constant bot_enat_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> interaction_bounded_by_upf_dec_Inr <span class="main">[</span><span class="operator">interaction_bound</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"interaction_bounded_by <span class="main">(</span>Not <span class="main">∘</span> isl<span class="main">)</span> <span class="main">(</span>intercept_upf_dec <span class="free">LD</span> <span class="free">c</span><span class="main">)</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> intercept_upf_dec_def case_prod_app
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">interaction_bound</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> SUP_constant <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> interaction_bounded_by_intercept_upf_Inr <span class="main">[</span><span class="operator">interaction_bound</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"interaction_bounded_by <span class="main">(</span>Not <span class="main">∘</span> isl<span class="main">)</span> <span class="main">(</span>intercept_upf <span class="free">k</span> <span class="free">b</span> <span class="free">LD</span> <span class="free">x</span><span class="main">)</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> intercept_upf_def 
<span class="keyword1"><span class="command">by</span></span> <span class="operator">interaction_bound</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_def one_enat_def SUP_le_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> interaction_bounded_by_intercept_upf_Inl <span class="main">[</span><span class="operator">interaction_bound</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"isl <span class="free">x</span> <span class="main">⟹</span> interaction_bounded_by <span class="main">(</span>Not <span class="main">∘</span> isl<span class="main">)</span> <span class="main">(</span>intercept_upf <span class="free">k</span> <span class="free">b</span> <span class="free">LD</span> <span class="free">x</span><span class="main">)</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> intercept_upf_def case_prod_app
<span class="keyword1"><span class="command">by</span></span> <span class="operator">interaction_bound</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_intercept_upf_enc <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_gpv <span class="main">(</span>ℐ_full <span class="keyword1">⊕<span class="hidden">⇩</span><sub>ℐ</sub></span> ℐ_full<span class="main">)</span> <span class="main">(</span>intercept_upf_enc <span class="free">k</span> <span class="free">b</span> <span class="free">LD</span> <span class="free">mm</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> intercept_upf_enc_def split_beta prf_domain_finite prf_domain_nonempty Let_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> bool.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_intercept_upf_dec <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_gpv <span class="main">(</span>ℐ_full <span class="keyword1">⊕<span class="hidden">⇩</span><sub>ℐ</sub></span> ℐ_full<span class="main">)</span> <span class="main">(</span>intercept_upf_dec <span class="free">LD</span> <span class="free">mm</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> intercept_upf_dec_def split_beta<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_intercept_upf <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_gpv <span class="main">(</span>ℐ_full <span class="keyword1">⊕<span class="hidden">⇩</span><sub>ℐ</sub></span> ℐ_full<span class="main">)</span> <span class="main">(</span>intercept_upf <span class="free">k</span> <span class="free">b</span> <span class="free">LD</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> intercept_upf_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> results_gpv_intercept_upf <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"results_gpv <span class="main">(</span>ℐ_full <span class="keyword1">⊕<span class="hidden">⇩</span><sub>ℐ</sub></span> ℐ_full<span class="main">)</span> <span class="main">(</span>intercept_upf <span class="free">k</span> <span class="free">b</span> <span class="free">LD</span> <span class="free">x</span><span class="main">)</span> <span class="main">⊆</span> responses_ℐ <span class="main">(</span>ℐ_full <span class="keyword1">⊕<span class="hidden">⇩</span><sub>ℐ</sub></span> ℐ_full<span class="main">)</span> <span class="free">x</span> <span class="main">×</span> UNIV"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> intercept_upf_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">reduction_upf</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>bitstring<span class="main">,</span> <span class="tfree">'hash</span> cipher_text<span class="main">)</span> ind_cca.adversary
  <span class="main">⇒</span> <span class="main">(</span>bitstring<span class="main">,</span> <span class="tfree">'hash</span><span class="main">)</span> UPF.adversary"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">reduction_upf</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">k</span> <span class="main">←</span> lift_spmf <span class="free">prf_key_gen</span><span class="main">;</span>
    <span class="bound">b</span> <span class="main">←</span> lift_spmf coin_spmf<span class="main">;</span>
    <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="main">(</span><span class="bound">L</span><span class="main">,</span> <span class="bound">D</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> inline <span class="main">(</span>intercept_upf <span class="bound">k</span> <span class="bound">b</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">(</span><span class="main">{}</span><span class="main">,</span> <span class="main">{}</span><span class="main">)</span><span class="main">;</span>
    Done <span class="main">()</span> <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_reduction_upf <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"lossless_gpv <span class="main">(</span>ℐ_full <span class="keyword1">⊕<span class="hidden">⇩</span><sub>ℐ</sub></span> ℐ_full<span class="main">)</span> <span class="free">𝒜</span> <span class="main">⟹</span> lossless_gpv <span class="main">(</span>ℐ_full <span class="keyword1">⊕<span class="hidden">⇩</span><sub>ℐ</sub></span> ℐ_full<span class="main">)</span> <span class="main">(</span>reduction_upf <span class="free">𝒜</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> reduction_upf_def prf_key_gen_lossless <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lossless_inline <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> subsetI<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> round_1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lossless_gpv <span class="main">(</span>ℐ_full <span class="keyword1">⊕<span class="hidden">⇩</span><sub>ℐ</sub></span> ℐ_full<span class="main">)</span> <span class="free">𝒜</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">¦</span>spmf <span class="main">(</span>ind_cca.game <span class="free">𝒜</span><span class="main">)</span> True <span class="main">-</span> spmf <span class="main">(</span>ind_cca'.game <span class="free">𝒜</span><span class="main">)</span> True<span class="main">¦</span> <span class="main">≤</span> UPF.advantage <span class="main">(</span>reduction_upf <span class="free">𝒜</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">oracle_decrypt0'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">oracle_decrypt0'</span> <span class="main">≡</span> <span class="main">(</span><span class="main">λ</span><span class="bound">key</span> <span class="main">(</span><span class="bound">bad</span><span class="main">,</span> <span class="bound">L</span><span class="main">)</span> <span class="main">(</span><span class="bound">x'</span><span class="main">,</span> <span class="bound">c'</span><span class="main">,</span> <span class="bound">t'</span><span class="main">)</span><span class="main">.</span> return_spmf <span class="main">(</span>
      <span class="keyword1">if</span> <span class="main">(</span><span class="bound">x'</span><span class="main">,</span> <span class="bound">c'</span><span class="main">,</span> <span class="bound">t'</span><span class="main">)</span> <span class="main">∈</span> <span class="bound">L</span> <span class="main">∨</span> length <span class="bound">x'</span> <span class="main">≠</span> <span class="free">prf_dlen</span> <span class="keyword1">then</span> <span class="main">(</span>None<span class="main">,</span> <span class="main">(</span><span class="bound">bad</span><span class="main">,</span> <span class="bound">L</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword1">else</span> <span class="main">(</span>decrypt <span class="bound">key</span> <span class="main">(</span><span class="bound">x'</span><span class="main">,</span> <span class="bound">c'</span><span class="main">,</span> <span class="bound">t'</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">bad</span> <span class="main">∨</span> <span class="free">upf_fun</span> <span class="main">(</span>snd <span class="bound">key</span><span class="main">)</span> <span class="main">(</span><span class="bound">x'</span> <span class="main">@</span> <span class="bound">c'</span><span class="main">)</span> <span class="main">=</span> <span class="bound">t'</span><span class="main">,</span> <span class="bound">L</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> oracle_decrypt0'_simps<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="skolem">oracle_decrypt0'</span> <span class="skolem">key</span> <span class="main">(</span><span class="skolem">bad</span><span class="main">,</span> <span class="skolem">L</span><span class="main">)</span> <span class="main">(</span><span class="skolem">x'</span><span class="main">,</span> <span class="skolem">c'</span><span class="main">,</span> <span class="skolem">t'</span><span class="main">)</span> <span class="main">=</span> return_spmf <span class="main">(</span>
       <span class="keyword1">if</span> <span class="main">(</span><span class="skolem">x'</span><span class="main">,</span> <span class="skolem">c'</span><span class="main">,</span> <span class="skolem">t'</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">L</span> <span class="main">∨</span> length <span class="skolem">x'</span> <span class="main">≠</span> <span class="free">prf_dlen</span> <span class="keyword1">then</span> <span class="main">(</span>None<span class="main">,</span> <span class="main">(</span><span class="skolem">bad</span><span class="main">,</span> <span class="skolem">L</span><span class="main">)</span><span class="main">)</span>
       <span class="keyword1">else</span> <span class="main">(</span>decrypt <span class="skolem">key</span> <span class="main">(</span><span class="skolem">x'</span><span class="main">,</span> <span class="skolem">c'</span><span class="main">,</span> <span class="skolem">t'</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="skolem">bad</span> <span class="main">∨</span> <span class="free">upf_fun</span> <span class="main">(</span>snd <span class="skolem">key</span><span class="main">)</span> <span class="main">(</span><span class="skolem">x'</span> <span class="main">@</span> <span class="skolem">c'</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">t'</span><span class="main">,</span> <span class="skolem">L</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">key</span> <span class="skolem">L</span> <span class="skolem">bad</span> <span class="skolem">x'</span> <span class="skolem">c'</span> <span class="skolem">t'</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle_decrypt0'_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> lossless_oracle_decrypt0' <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span><span class="skolem">oracle_decrypt0'</span> <span class="skolem">k</span> <span class="skolem">Lbad</span> <span class="skolem">c</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">k</span> <span class="skolem">Lbad</span> <span class="skolem">c</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle_decrypt0'_def split_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> callee_invariant_oracle_decrypt0' <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"callee_invariant <span class="main">(</span><span class="skolem">oracle_decrypt0'</span> <span class="skolem">k</span><span class="main">)</span> fst"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">k</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle_decrypt0'_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>

  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">oracle_decrypt1'</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">oracle_decrypt1'</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">key</span> <span class="main">::</span> <span class="tfree">'prf_key</span> <span class="main">×</span> <span class="tfree">'upf_key</span><span class="main">)</span> <span class="main">(</span><span class="bound">bad</span><span class="main">,</span> <span class="bound">L</span><span class="main">)</span> <span class="main">(</span><span class="bound">x'</span><span class="main">,</span> <span class="bound">c'</span><span class="main">,</span> <span class="bound">t'</span><span class="main">)</span><span class="main">.</span> 
      return_spmf <span class="main">(</span>None <span class="main">::</span> bitstring option<span class="main">,</span>
        <span class="main">(</span><span class="bound">bad</span> <span class="main">∨</span> <span class="free">upf_fun</span> <span class="main">(</span>snd <span class="bound">key</span><span class="main">)</span> <span class="main">(</span><span class="bound">x'</span> <span class="main">@</span> <span class="bound">c'</span><span class="main">)</span> <span class="main">=</span> <span class="bound">t'</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">x'</span><span class="main">,</span> <span class="bound">c'</span><span class="main">,</span> <span class="bound">t'</span><span class="main">)</span> <span class="main">∉</span> <span class="bound">L</span> <span class="main">∧</span> length <span class="bound">x'</span> <span class="main">=</span> <span class="free">prf_dlen</span><span class="main">)</span><span class="main">,</span> <span class="bound">L</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> oracle_decrypt1'_simps<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="skolem">oracle_decrypt1'</span> <span class="skolem">key</span> <span class="main">(</span><span class="skolem">bad</span><span class="main">,</span> <span class="skolem">L</span><span class="main">)</span> <span class="main">(</span><span class="skolem">x'</span><span class="main">,</span> <span class="skolem">c'</span><span class="main">,</span> <span class="skolem">t'</span><span class="main">)</span> <span class="main">=</span> 
    return_spmf <span class="main">(</span>None<span class="main">,</span> 
      <span class="main">(</span><span class="skolem">bad</span> <span class="main">∨</span> <span class="free">upf_fun</span> <span class="main">(</span>snd <span class="skolem">key</span><span class="main">)</span> <span class="main">(</span><span class="skolem">x'</span> <span class="main">@</span> <span class="skolem">c'</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">t'</span> <span class="main">∧</span> <span class="main">(</span><span class="skolem">x'</span><span class="main">,</span> <span class="skolem">c'</span><span class="main">,</span> <span class="skolem">t'</span><span class="main">)</span> <span class="main">∉</span> <span class="skolem">L</span> <span class="main">∧</span> length <span class="skolem">x'</span> <span class="main">=</span> <span class="free">prf_dlen</span><span class="main">,</span> <span class="skolem">L</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">key</span> <span class="skolem">L</span> <span class="skolem">bad</span> <span class="skolem">x'</span> <span class="skolem">c'</span> <span class="skolem">t'</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle_decrypt1'_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> lossless_oracle_decrypt1' <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span><span class="skolem">oracle_decrypt1'</span> <span class="skolem">k</span> <span class="skolem">Lbad</span> <span class="skolem">c</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">k</span> <span class="skolem">Lbad</span> <span class="skolem">c</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle_decrypt1'_def split_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> callee_invariant_oracle_decrypt1' <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"callee_invariant <span class="main">(</span><span class="skolem">oracle_decrypt1'</span> <span class="skolem">k</span><span class="main">)</span> fst"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">k</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle_decrypt1'_def<span class="main">)</span>

  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">game01'</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">game01'</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">decrypt</span> <span class="main">::</span> <span class="tfree">'prf_key</span> <span class="main">×</span> <span class="tfree">'upf_key</span> <span class="main">⇒</span> <span class="main">(</span>bitstring <span class="main">×</span> bitstring <span class="main">×</span> <span class="tfree">'hash</span><span class="main">,</span> bitstring option<span class="main">,</span> bool <span class="main">×</span> <span class="main">(</span>bitstring <span class="main">×</span> bitstring <span class="main">×</span> <span class="tfree">'hash</span><span class="main">)</span> set<span class="main">)</span> callee<span class="main">)</span> <span class="bound">𝒜</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">key</span> <span class="main">←</span> key_gen<span class="main">;</span>
    <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
    <span class="main">(</span><span class="bound">b'</span><span class="main">,</span> <span class="main">(</span><span class="bound">bad'</span><span class="main">,</span> <span class="bound">L'</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="main">(</span><span class="main">†</span><span class="main">(</span>ind_cca.oracle_encrypt <span class="bound">key</span> <span class="bound">b</span><span class="main">)</span> <span class="keyword1">⊕<span class="hidden">⇩</span><sub>O</sub></span> <span class="bound">decrypt</span> <span class="bound">key</span><span class="main">)</span> <span class="bound">𝒜</span> <span class="main">(</span>False<span class="main">,</span> <span class="main">{}</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">b</span> <span class="main">=</span> <span class="bound">b'</span><span class="main">,</span> <span class="bound">bad'</span><span class="main">)</span> <span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?game0'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="skolem">game01'</span> <span class="skolem">oracle_decrypt0'</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?game1'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="skolem">game01'</span> <span class="skolem">oracle_decrypt1'</span>"</span></span>

  <span class="keyword1"><span class="command">have</span></span> game0'_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"ind_cca.game <span class="free">𝒜</span> <span class="main">=</span> map_spmf fst <span class="main">(</span><span class="var">?game0'</span> <span class="free">𝒜</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?game0</span></span></span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">and</span></span> game1'_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"ind_cca'.game <span class="free">𝒜</span> <span class="main">=</span> map_spmf fst <span class="main">(</span><span class="var">?game1'</span> <span class="free">𝒜</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?game1</span></span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?S</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"rel_prod2 <span class="main">(=)</span>"</span></span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">initial</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">initial</span> <span class="main">=</span> <span class="main">(</span>False<span class="main">,</span> <span class="main">{}</span> <span class="main">::</span> <span class="tfree">'hash</span> cipher_text set<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?S</span> <span class="main">{}</span> <span class="skolem">initial</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> initial_def<span class="main">)</span>

    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="var">?S</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> rel_spmf <span class="main">(</span>rel_prod <span class="main">(=)</span> <span class="var">?S</span><span class="main">)</span><span class="main">)</span>
       ind_cca.oracle_decrypt <span class="skolem">oracle_decrypt0'</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> ind_cca.oracle_decrypt_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> oracle_decrypt0'_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_spmf_return_spmf1 rel_fun_def<span class="main">)</span>

    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="var">?S</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> rel_spmf <span class="main">(</span>rel_prod <span class="main">(=)</span> <span class="var">?S</span><span class="main">)</span><span class="main">)</span>
       ind_cca'.oracle_decrypt <span class="skolem">oracle_decrypt1'</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> ind_cca'.oracle_decrypt_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> oracle_decrypt1'_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_spmf_return_spmf1 rel_fun_def<span class="main">)</span>

    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span> <span class="main">=</span> extend_state_oracle_transfer
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?game0</span></span></span> <span class="var"><span class="quoted"><span class="var">?game1</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> game01'_def ind_cca.game_def ind_cca'.game_def initial_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_spmf_bind_spmf o_def split_def<span class="main">)</span> <span class="operator">transfer_prover</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"rel_spmf <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">b'1</span><span class="main">,</span> <span class="main">(</span><span class="bound">bad1</span><span class="main">,</span> <span class="bound">L1</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="bound">b'2</span><span class="main">,</span> <span class="main">(</span><span class="bound">bad2</span><span class="main">,</span> <span class="bound">L2</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="bound">bad1</span> <span class="main">=</span> <span class="bound">bad2</span> <span class="main">∧</span> <span class="main">(</span><span class="main">¬</span> <span class="bound">bad2</span> <span class="main">⟶</span> <span class="bound">b'1</span> <span class="main">=</span> <span class="bound">b'2</span><span class="main">)</span><span class="main">)</span>
         <span class="main">(</span>exec_gpv <span class="main">(</span><span class="main">†</span><span class="main">(</span>ind_cca.oracle_encrypt <span class="skolem">k</span> <span class="skolem">b</span><span class="main">)</span> <span class="keyword1">⊕<span class="hidden">⇩</span><sub>O</sub></span> <span class="skolem">oracle_decrypt1'</span> <span class="skolem">k</span><span class="main">)</span> <span class="free">𝒜</span> <span class="main">(</span>False<span class="main">,</span> <span class="main">{}</span><span class="main">)</span><span class="main">)</span>
         <span class="main">(</span>exec_gpv <span class="main">(</span><span class="main">†</span><span class="main">(</span>ind_cca.oracle_encrypt <span class="skolem">k</span> <span class="skolem">b</span><span class="main">)</span> <span class="keyword1">⊕<span class="hidden">⇩</span><sub>O</sub></span> <span class="skolem">oracle_decrypt0'</span> <span class="skolem">k</span><span class="main">)</span> <span class="free">𝒜</span> <span class="main">(</span>False<span class="main">,</span> <span class="main">{}</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">k</span> <span class="skolem">b</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">k</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">rule</span> exec_gpv_oracle_bisim_bad<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> X<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">(=)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> <span class="var">?bad1.0</span><span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">fst</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> <span class="var">?bad2.0</span><span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">fst</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> ℐ <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted">"ℐ_full <span class="keyword1">⊕<span class="hidden">⇩</span><sub>ℐ</sub></span> ℐ_full"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
       <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rel_spmf_reflI callee_invariant_extend_state_oracle_const' <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf_rel_map1 spmf_rel_map2 oracle_decrypt0'_simps oracle_decrypt1'_simps assms <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> plus_oracle_split<span class="main">)</span>
    <span class="comment1">― ‹We cannot get rid of the losslessness assumption on <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted"><span class="free">𝒜</span></span><span class="antiquote">}</span></span> in this step, because if it 
      were not, then the bad event might still occur, but the adversary does not terminate in
      the case of <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="var">?game1'</span>"</span><span class="antiquote">}</span></span>. Thus, the reduction does not terminate either, but it cannot
      detect whether the bad event has happened. So the advantage in the UPF game could be lower than
      the probability of the bad event, if the adversary is not lossless.›</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¦</span>measure <span class="main">(</span>measure_spmf <span class="main">(</span><span class="var">?game1'</span> <span class="free">𝒜</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">bad</span><span class="main">)</span><span class="main">.</span> <span class="bound">b</span><span class="main">}</span> <span class="main">-</span> measure <span class="main">(</span>measure_spmf <span class="main">(</span><span class="var">?game0'</span> <span class="free">𝒜</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">bad</span><span class="main">)</span><span class="main">.</span> <span class="bound">b</span><span class="main">}</span><span class="main">¦</span> 
     <span class="main">≤</span> measure <span class="main">(</span>measure_spmf <span class="main">(</span><span class="var">?game1'</span> <span class="free">𝒜</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">bad</span><span class="main">)</span><span class="main">.</span> <span class="bound">bad</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> fundamental_lemma<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="var">?bad2.0</span><span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">snd</span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_bind_reflI rel_spmf_bindI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> *<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> game01'_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> spmf <span class="main">(</span>map_spmf snd <span class="main">(</span><span class="var">?game1'</span> <span class="free">𝒜</span><span class="main">)</span><span class="main">)</span> True"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf_conv_measure_spmf measure_map_spmf split_def vimage_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_spmf snd <span class="main">(</span><span class="var">?game1'</span> <span class="free">𝒜</span><span class="main">)</span> <span class="main">=</span> UPF.game <span class="main">(</span>reduction_upf <span class="free">𝒜</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">split</span> <span class="quasi_keyword">del</span><span class="main">]</span> <span class="main">=</span> if_split
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> fst <span class="main">(</span>snd <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>exec_gpv <span class="main">(</span><span class="main">†</span><span class="main">(</span>ind_cca.oracle_encrypt <span class="main">(</span><span class="skolem">k_prf</span><span class="main">,</span> <span class="skolem">k_upf</span><span class="main">)</span> <span class="skolem">b</span><span class="main">)</span> <span class="keyword1">⊕<span class="hidden">⇩</span><sub>O</sub></span> <span class="skolem">oracle_decrypt1'</span> <span class="main">(</span><span class="skolem">k_prf</span><span class="main">,</span> <span class="skolem">k_upf</span><span class="main">)</span><span class="main">)</span> <span class="free">𝒜</span> <span class="main">(</span>False<span class="main">,</span> <span class="main">{}</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
        map_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> fst <span class="main">(</span>snd <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>exec_gpv <span class="main">(</span>UPF.oracle <span class="skolem">k_upf</span><span class="main">)</span> <span class="main">(</span>inline <span class="main">(</span>intercept_upf <span class="skolem">k_prf</span> <span class="skolem">b</span><span class="main">)</span> <span class="free">𝒜</span> <span class="main">(</span><span class="main">{}</span><span class="main">,</span> <span class="main">{}</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>False<span class="main">,</span> <span class="main">{}</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"map_spmf <span class="var">?fl</span> <span class="var">?lhs</span> <span class="main">=</span> map_spmf <span class="var">?fr</span> <span class="var">?rhs</span>"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"map_spmf <span class="main">_</span> <span class="main">(</span>exec_gpv <span class="var">?oracle_normal</span> <span class="main">_</span> <span class="var">?init_normal</span><span class="main">)</span> <span class="main">=</span> <span class="main">_</span>"</span></span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">k_prf</span> <span class="skolem">k_upf</span> <span class="skolem">b</span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> map_spmf_eq_map_spmfI<span class="main">)</span>
      <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">oracle_intercept</span></span>
        <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">oracle_intercept</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">s'</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="bound">y</span><span class="main">.</span> map_spmf <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s'</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>
         <span class="main">(</span>exec_gpv <span class="main">(</span>UPF.oracle <span class="skolem">k_upf</span><span class="main">)</span> <span class="main">(</span>intercept_upf <span class="skolem">k_prf</span> <span class="skolem">b</span> <span class="bound">s'</span> <span class="bound">y</span><span class="main">)</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?I</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">L</span><span class="main">,</span> <span class="bound">D</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">flg</span><span class="main">,</span> <span class="bound">Li</span><span class="main">)</span><span class="main">)</span><span class="main">.</span>
          <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">c</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span> <span class="main">∈</span> <span class="bound">L</span><span class="main">.</span> <span class="free">upf_fun</span> <span class="skolem">k_upf</span> <span class="main">(</span><span class="bound">x</span> <span class="main">@</span> <span class="bound">c</span><span class="main">)</span> <span class="main">=</span> <span class="bound">t</span> <span class="main">∧</span> length <span class="bound">x</span> <span class="main">=</span> <span class="free">prf_dlen</span><span class="main">)</span> <span class="main">∧</span>
          <span class="main">(</span><span class="main">∀</span><span class="bound">e</span><span class="main">∈</span><span class="bound">Li</span><span class="main">.</span> <span class="main">∃</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">c</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">∈</span> <span class="bound">L</span><span class="main">.</span> <span class="bound">e</span> <span class="main">=</span> <span class="bound">x</span> <span class="main">@</span> <span class="bound">c</span><span class="main">)</span> <span class="main">∧</span>
          <span class="main">(</span><span class="main">(</span><span class="main">∃</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">c</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span> <span class="main">∈</span> <span class="bound">D</span><span class="main">.</span> <span class="free">upf_fun</span> <span class="skolem">k_upf</span> <span class="main">(</span><span class="bound">x</span> <span class="main">@</span> <span class="bound">c</span><span class="main">)</span> <span class="main">=</span> <span class="bound">t</span><span class="main">)</span> <span class="main">⟷</span> <span class="bound">flg</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">interpret</span></span> callee_invariant_on <span class="quoted"><span class="skolem">oracle_intercept</span></span> <span class="quoted"><span class="quoted">"<span class="var">?I</span>"</span></span> <span class="quoted">ℐ_full</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> s x y s'
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">s</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">s'</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span>
           <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_spmf_of_set_finite<span class="main"><span class="main">[</span></span><span class="operator">OF</span> prf_domain_finite<span class="main"><span class="main">]</span></span>
                UPF.oracle_hash_def prf_domain_length exec_gpv_bind Let_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> bool.splits<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> exec_gpv_bind UPF.oracle_flag_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      
      <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">S</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"bool <span class="main">×</span> <span class="tfree">'hash</span> cipher_text set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'hash</span> cipher_text set <span class="main">×</span> <span class="tfree">'hash</span> cipher_text set<span class="main">)</span> <span class="main">×</span>  bool <span class="main">×</span> bitstring set <span class="main">⇒</span> bool"</span></span>
        <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">S</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">bad</span><span class="main">,</span> <span class="bound">L1</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="bound">L2</span><span class="main">,</span> <span class="bound">D</span><span class="main">)</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="bound">bad</span> <span class="main">=</span> <span class="main">(</span><span class="main">∃</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">c</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span><span class="main">∈</span><span class="bound">D</span><span class="main">.</span> <span class="free">upf_fun</span> <span class="skolem">k_upf</span> <span class="main">(</span><span class="bound">x</span> <span class="main">@</span> <span class="bound">c</span><span class="main">)</span> <span class="main">=</span> <span class="bound">t</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">L1</span> <span class="main">=</span> <span class="bound">L2</span><span class="main">)</span> <span class="main">↿</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="main">⊗</span> <span class="var">?I</span>"</span></span>
      <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">initial</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'hash</span> cipher_text set <span class="main">×</span> <span class="tfree">'hash</span> cipher_text set<span class="main">)</span> <span class="main">×</span>  bool <span class="main">×</span> bitstring set"</span></span>
        <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">initial</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="main">{}</span><span class="main">,</span> <span class="main">{}</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>False<span class="main">,</span> <span class="main">{}</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">S</span> <span class="var">?init_normal</span> <span class="skolem">initial</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> S_def initial_def<span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">S</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> rel_spmf <span class="main">(</span>rel_prod <span class="main">(=)</span> <span class="skolem">S</span><span class="main">)</span><span class="main">)</span> <span class="var">?oracle_normal</span> <span class="skolem">oracle_intercept</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> S_def
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> callee_invariant_restrict_relp<span class="main"><span class="keyword3">,</span></span> <span class="operator">unfold_locales</span><span class="main">)</span>
          <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def bind_spmf_of_set prf_domain_finite prf_domain_nonempty bind_spmf_pmf_assoc bind_assoc_pmf bind_return_pmf spmf_rel_map exec_gpv_bind Let_def ind_cca.oracle_encrypt_def oracle_decrypt1'_def encrypt.simps UPF.oracle_hash_def UPF.oracle_flag_def bind_map_spmf o_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> plus_oracle_split bool.split if_split <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_bind_reflI rel_pmf_bind_reflI<span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"rel_spmf <span class="main">(</span>rel_prod <span class="main">(=)</span> <span class="skolem">S</span><span class="main">)</span> <span class="var">?lhs</span> <span class="main">(</span>exec_gpv <span class="skolem">oracle_intercept</span> <span class="free">𝒜</span> <span class="skolem">initial</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer_prover</span><span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"rel_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="var">?fl</span> <span class="bound">x</span> <span class="main">=</span> <span class="var">?fr</span> <span class="bound">y</span><span class="main">)</span> <span class="var">?lhs</span> <span class="var">?rhs</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> S_def exec_gpv_inline spmf_rel_map initial_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rel_spmf_mono<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">including</span></span> monad_normalisation
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> reduction_upf_def UPF.game_def game01'_def key_gen_def map_spmf_conv_bind_spmf split_def exec_gpv_bind <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> bind_spmf_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> game0'_eq game1'_eq 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf_conv_measure_spmf measure_map_spmf vimage_def fst_def UPF.advantage_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">oracle_encrypt2</span> <span class="main">::</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'prf_key</span> <span class="main">×</span> <span class="tfree">'upf_key</span><span class="main">)</span> <span class="main">⇒</span> bool <span class="main">⇒</span> <span class="main">(</span>bitstring<span class="main">,</span> bitstring<span class="main">)</span> PRF.dict <span class="main">⇒</span> bitstring <span class="main">×</span> bitstring 
    <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'hash</span> cipher_text option <span class="main">×</span> <span class="main">(</span>bitstring<span class="main">,</span> bitstring<span class="main">)</span> PRF.dict<span class="main">)</span> spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">oracle_encrypt2</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">k_prf</span><span class="main">,</span> <span class="bound">k_upf</span><span class="main">)</span> <span class="bound">b</span> <span class="bound">D</span> <span class="main">(</span><span class="bound">msg1</span><span class="main">,</span> <span class="bound">msg0</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="keyword1">case</span> <span class="main">(</span>length <span class="bound">msg1</span> <span class="main">=</span> <span class="free">prf_clen</span> <span class="main">∧</span> length <span class="bound">msg0</span> <span class="main">=</span> <span class="free">prf_clen</span><span class="main">)</span> <span class="keyword1">of</span>
      False <span class="main">⇒</span> return_spmf <span class="main">(</span>None<span class="main">,</span> <span class="bound">D</span><span class="main">)</span>
    <span class="main">|</span> True <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">x</span> <span class="main">←</span> spmf_of_set <span class="free">prf_domain</span><span class="main">;</span>
        <span class="bound">P</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">prf_clen</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1">let</span> <span class="bound">p</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="bound">D</span> <span class="bound">x</span> <span class="keyword1">of</span> Some <span class="bound">r</span> <span class="main">⇒</span> <span class="bound">r</span> <span class="main">|</span> None <span class="main">⇒</span> <span class="bound">P</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1">let</span> <span class="bound">c</span> <span class="main">=</span> <span class="bound">p</span> <span class="main">[⊕]</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">msg1</span> <span class="keyword1">else</span> <span class="bound">msg0</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1">let</span> <span class="bound">t</span> <span class="main">=</span> <span class="free">upf_fun</span> <span class="bound">k_upf</span> <span class="main">(</span><span class="bound">x</span> <span class="main">@</span> <span class="bound">c</span><span class="main">)</span><span class="main">;</span>
        return_spmf <span class="main">(</span>Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">c</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span><span class="main">,</span> <span class="bound">D</span><span class="main">(</span><span class="bound">x</span> <span class="main">↦</span> <span class="bound">p</span><span class="main">)</span><span class="main">)</span> 
      <span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">oracle_decrypt2</span><span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'prf_key</span> <span class="main">×</span> <span class="tfree">'upf_key</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'hash</span> cipher_text<span class="main">,</span> bitstring option<span class="main">,</span> <span class="tfree">'state</span><span class="main">)</span> callee"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">oracle_decrypt2</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">key</span> <span class="bound">D</span> <span class="bound">cipher</span><span class="main">.</span> return_spmf <span class="main">(</span>None<span class="main">,</span> <span class="bound">D</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_oracle_decrypt2 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>oracle_decrypt2 <span class="free">k</span> <span class="free">Dbad</span> <span class="free">c</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle_decrypt2_def split_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> callee_invariant_oracle_decrypt2 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"callee_invariant <span class="main">(</span>oracle_decrypt2 <span class="free">key</span><span class="main">)</span> fst"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle_decrypt2_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> oracle_decrypt2_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_prod <span class="free">P</span> <span class="free">U</span> <span class="main">===&gt;</span> <span class="free">S</span> <span class="main">===&gt;</span> rel_prod <span class="main">(=)</span> <span class="main">(</span>rel_prod <span class="main">(=)</span> <span class="free">H</span><span class="main">)</span> <span class="main">===&gt;</span> rel_spmf <span class="main">(</span>rel_prod <span class="main">(=)</span> <span class="free">S</span><span class="main">)</span><span class="main">)</span>
   oracle_decrypt2 oracle_decrypt2"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> oracle_decrypt2_def split_def <span class="dynamic"><span class="dynamic">relator_eq</span></span><span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">game2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>bitstring<span class="main">,</span> <span class="tfree">'hash</span> cipher_text<span class="main">)</span> ind_cca.adversary <span class="main">⇒</span> bool spmf"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">game2</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">key</span> <span class="main">←</span> key_gen<span class="main">;</span>
    <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
    <span class="main">(</span><span class="bound">b'</span><span class="main">,</span> <span class="bound">D</span><span class="main">)</span> <span class="main">←</span> exec_gpv 
      <span class="main">(</span>oracle_encrypt2 <span class="bound">key</span> <span class="bound">b</span> <span class="keyword1">⊕<span class="hidden">⇩</span><sub>O</sub></span> oracle_decrypt2 <span class="bound">key</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> Map_empty<span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">b</span> <span class="main">=</span> <span class="bound">b'</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">intercept_prf</span> <span class="main">::</span> 
  <span class="quoted"><span class="quoted">"<span class="tfree">'upf_key</span> <span class="main">⇒</span> bool <span class="main">⇒</span> unit <span class="main">⇒</span> <span class="main">(</span>bitstring <span class="main">×</span> bitstring<span class="main">)</span> <span class="main">+</span> <span class="tfree">'hash</span> cipher_text
  <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'hash</span> cipher_text option <span class="main">+</span> bitstring option<span class="main">)</span> <span class="main">×</span> unit<span class="main">,</span> bitstring<span class="main">,</span> bitstring<span class="main">)</span> gpv"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">intercept_prf</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">(</span>Inr <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> Done <span class="main">(</span>Inr None<span class="main">,</span> <span class="main">()</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">intercept_prf</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">(</span>Inl <span class="main">(</span><span class="free"><span class="bound"><span class="entity">m1</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">m0</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="main">(</span>length <span class="free"><span class="bound"><span class="entity">m1</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">prf_clen</span> <span class="main">∧</span> <span class="main">(</span>length <span class="free"><span class="bound"><span class="entity">m0</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">prf_clen</span> <span class="keyword1">of</span>
      False <span class="main">⇒</span> Done <span class="main">(</span>Inl None<span class="main">,</span> <span class="main">()</span><span class="main">)</span>
    <span class="main">|</span> True <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">x</span> <span class="main">←</span> lift_spmf <span class="main">(</span>spmf_of_set <span class="free">prf_domain</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">p</span> <span class="main">←</span> Pause <span class="bound">x</span> Done<span class="main">;</span>
        <span class="keyword1">let</span> <span class="bound">c</span> <span class="main">=</span> <span class="bound">p</span> <span class="main">[⊕]</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">m1</span></span></span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">m0</span></span></span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1">let</span> <span class="bound">t</span> <span class="main">=</span> <span class="free">upf_fun</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">(</span><span class="bound">x</span> <span class="main">@</span> <span class="bound">c</span><span class="main">)</span><span class="main">;</span>
        Done <span class="main">(</span>Inl <span class="main">(</span>Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">c</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">()</span><span class="main">)</span>
      <span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">reduction_prf</span>
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>bitstring<span class="main">,</span> <span class="tfree">'hash</span> cipher_text<span class="main">)</span> ind_cca.adversary <span class="main">⇒</span> <span class="main">(</span>bitstring<span class="main">,</span> bitstring<span class="main">)</span> PRF.adversary"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> 
 <span class="quoted"><span class="quoted">"<span class="free">reduction_prf</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
   <span class="bound">k</span> <span class="main">←</span> lift_spmf <span class="free">upf_key_gen</span><span class="main">;</span>
   <span class="bound">b</span> <span class="main">←</span> lift_spmf coin_spmf<span class="main">;</span>
   <span class="main">(</span><span class="bound">b'</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">←</span> inline <span class="main">(</span>intercept_prf <span class="bound">k</span> <span class="bound">b</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">()</span><span class="main">;</span>
   Done <span class="main">(</span><span class="bound">b'</span> <span class="main">=</span> <span class="bound">b</span><span class="main">)</span>
 <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> round_2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¦</span>spmf <span class="main">(</span>ind_cca'.game <span class="free">𝒜</span><span class="main">)</span> True <span class="main">-</span> spmf <span class="main">(</span>game2 <span class="free">𝒜</span><span class="main">)</span> True<span class="main">¦</span> <span class="main">=</span> PRF.advantage <span class="main">(</span>reduction_prf <span class="free">𝒜</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">oracle_encrypt1''</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">oracle_encrypt1''</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">k_prf</span><span class="main">,</span> <span class="bound">k_upf</span><span class="main">)</span> <span class="bound">b</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit<span class="main">)</span> <span class="main">(</span><span class="bound">msg1</span><span class="main">,</span> <span class="bound">msg0</span><span class="main">)</span><span class="main">.</span> 
      <span class="keyword1">case</span> length <span class="bound">msg1</span> <span class="main">=</span> <span class="free">prf_clen</span> <span class="main">∧</span> length <span class="bound">msg0</span> <span class="main">=</span> <span class="free">prf_clen</span> <span class="keyword1">of</span>
        False <span class="main">⇒</span> return_spmf <span class="main">(</span>None<span class="main">,</span> <span class="main">()</span><span class="main">)</span>
      <span class="main">|</span> True <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="bound">x</span> <span class="main">←</span> spmf_of_set <span class="free">prf_domain</span><span class="main">;</span>
          <span class="keyword1">let</span> <span class="bound">p</span> <span class="main">=</span> <span class="free">prf_fun</span> <span class="bound">k_prf</span> <span class="bound">x</span><span class="main">;</span>
          <span class="keyword1">let</span> <span class="bound">c</span> <span class="main">=</span> <span class="bound">p</span> <span class="main">[⊕]</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">msg1</span> <span class="keyword1">else</span> <span class="bound">msg0</span><span class="main">)</span><span class="main">;</span>
          <span class="keyword1">let</span> <span class="bound">t</span> <span class="main">=</span> <span class="free">upf_fun</span> <span class="bound">k_upf</span> <span class="main">(</span><span class="bound">x</span> <span class="main">@</span> <span class="bound">c</span><span class="main">)</span><span class="main">;</span>
          return_spmf <span class="main">(</span>Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">c</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span><span class="main">,</span> <span class="main">()</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">game1''</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">game1''</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">key</span> <span class="main">←</span> key_gen<span class="main">;</span>
    <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
    <span class="main">(</span><span class="bound">b'</span><span class="main">,</span> <span class="bound">D</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="main">(</span><span class="skolem">oracle_encrypt1''</span> <span class="bound">key</span> <span class="bound">b</span> <span class="keyword1">⊕<span class="hidden">⇩</span><sub>O</sub></span> oracle_decrypt2 <span class="bound">key</span><span class="main">)</span> <span class="free">𝒜</span> <span class="main">()</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">b</span> <span class="main">=</span> <span class="bound">b'</span><span class="main">)</span><span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ind_cca'.game <span class="free">𝒜</span> <span class="main">=</span> <span class="skolem">game1''</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">S</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">S</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">L</span> <span class="main">::</span> <span class="tfree">'hash</span> cipher_text set<span class="main">)</span> <span class="main">(</span><span class="bound">D</span> <span class="main">::</span> unit<span class="main">)</span><span class="main">.</span> True<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">S</span> <span class="main">{}</span> <span class="main">()</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> S_def<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> <span class="skolem">S</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> rel_spmf <span class="main">(</span>rel_prod <span class="main">(=)</span> <span class="skolem">S</span><span class="main">)</span><span class="main">)</span>
       ind_cca'.oracle_encrypt <span class="skolem">oracle_encrypt1''</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> ind_cca'.oracle_encrypt_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> oracle_encrypt1''_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def Let_def S_def encrypt.simps prf_domain_finite prf_domain_nonempty <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rel_spmf_bind_reflI rel_pmf_bind_reflI <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> bool.split<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="skolem">S</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> rel_spmf <span class="main">(</span>rel_prod <span class="main">(=)</span> <span class="skolem">S</span><span class="main">)</span><span class="main">)</span> 
       ind_cca'.oracle_decrypt oracle_decrypt2"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> ind_cca'.oracle_decrypt_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> oracle_decrypt2_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> ind_cca'.game_def game1''_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> PRF.game_0 <span class="main">(</span>reduction_prf <span class="free">𝒜</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">k_prf</span> <span class="skolem">k_upf</span> <span class="skolem">b</span>
      <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">oracle_normal</span></span>
        <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">oracle_normal</span> <span class="main">=</span> <span class="skolem">oracle_encrypt1''</span> <span class="main">(</span><span class="skolem">k_prf</span><span class="main">,</span> <span class="skolem">k_upf</span><span class="main">)</span> <span class="skolem">b</span> <span class="keyword1">⊕<span class="hidden">⇩</span><sub>O</sub></span> oracle_decrypt2 <span class="main">(</span><span class="skolem">k_prf</span><span class="main">,</span> <span class="skolem">k_upf</span><span class="main">)</span>"</span></span>
      <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">oracle_intercept</span></span>
        <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">oracle_intercept</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">s'</span><span class="main">,</span> <span class="bound">s</span> <span class="main">::</span> unit<span class="main">)</span> <span class="bound">y</span><span class="main">.</span> map_spmf <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s'</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>exec_gpv <span class="main">(</span>PRF.prf_oracle <span class="skolem">k_prf</span><span class="main">)</span> <span class="main">(</span>intercept_prf <span class="skolem">k_upf</span> <span class="skolem">b</span> <span class="bound">s'</span> <span class="bound">y</span><span class="main">)</span> <span class="main">()</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">initial</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">initial</span> <span class="main">=</span> <span class="main">()</span>"</span></span>
      <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">S</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">S</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">s2</span> <span class="main">::</span> unit<span class="main">,</span> <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit<span class="main">)</span> <span class="main">(</span><span class="bound">s1</span> <span class="main">::</span> unit<span class="main">)</span><span class="main">.</span> True<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">S</span> <span class="main">(</span><span class="main">()</span><span class="main">,</span> <span class="main">()</span><span class="main">)</span> <span class="skolem">initial</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> S_def initial_def<span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">S</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> rel_spmf <span class="main">(</span>rel_prod <span class="main">(=)</span> <span class="skolem">S</span><span class="main">)</span><span class="main">)</span> <span class="skolem">oracle_intercept</span> <span class="skolem">oracle_normal</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> oracle_normal_def oracle_intercept_def
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> bool.split plus_oracle_split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> S_def rel_fun_def exec_gpv_bind PRF.prf_oracle_def oracle_encrypt1''_def Let_def map_spmf_conv_bind_spmf oracle_decrypt2_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_bind_reflI rel_spmf_reflI<span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">b</span> <span class="main">=</span> fst <span class="bound">x</span><span class="main">)</span> <span class="main">(</span>exec_gpv <span class="skolem">oracle_normal</span> <span class="free">𝒜</span> <span class="skolem">initial</span><span class="main">)</span> <span class="main">=</span>
        map_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">b</span> <span class="main">=</span> fst <span class="main">(</span>fst <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>exec_gpv <span class="main">(</span>PRF.prf_oracle <span class="skolem">k_prf</span><span class="main">)</span> <span class="main">(</span>inline <span class="main">(</span>intercept_prf <span class="skolem">k_upf</span> <span class="skolem">b</span><span class="main">)</span> <span class="free">𝒜</span> <span class="main">()</span><span class="main">)</span> <span class="main">()</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">b</span></span> <span class="quoted"><span class="free">𝒜</span></span> <span class="quoted"><span class="free">prf_fun</span></span> <span class="quoted"><span class="skolem">k_prf</span></span> <span class="quoted"><span class="free">prf_domain</span></span> <span class="quoted"><span class="free">prf_clen</span></span> <span class="quoted"><span class="free">upf_fun</span></span> <span class="quoted"><span class="skolem">k_upf</span></span><span class="main">)</span>
          <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_spmf_eq_map_spmf_iff exec_gpv_inline spmf_rel_map oracle_intercept_def split_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rel_spmf_reflI<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> game1''_def PRF.game_0_def key_gen_def reduction_prf_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> exec_gpv_bind_lift_spmf exec_gpv_bind map_spmf_conv_bind_spmf split_def eq_commute <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> bind_spmf_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"game2 <span class="free">𝒜</span> <span class="main">=</span> PRF.game_1 <span class="main">(</span>reduction_prf <span class="free">𝒜</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">split</span> <span class="quasi_keyword">del</span><span class="main">]</span> <span class="main">=</span> if_split
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">k_upf</span> <span class="skolem">b</span> <span class="skolem">k_prf</span>
      <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">oracle2</span></span>
        <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">oracle2</span> <span class="main">=</span> oracle_encrypt2 <span class="main">(</span><span class="skolem">k_prf</span><span class="main">,</span> <span class="skolem">k_upf</span><span class="main">)</span> <span class="skolem">b</span> <span class="keyword1">⊕<span class="hidden">⇩</span><sub>O</sub></span> oracle_decrypt2 <span class="main">(</span><span class="skolem">k_prf</span><span class="main">,</span> <span class="skolem">k_upf</span><span class="main">)</span>"</span></span>
      <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">oracle_intercept</span></span>
        <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">oracle_intercept</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">s'</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="bound">y</span><span class="main">.</span> map_spmf <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s'</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>exec_gpv PRF.random_oracle <span class="main">(</span>intercept_prf <span class="skolem">k_upf</span> <span class="skolem">b</span> <span class="bound">s'</span> <span class="bound">y</span><span class="main">)</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">S</span></span>
        <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">S</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">s2</span> <span class="main">::</span> unit<span class="main">,</span> <span class="bound">s2'</span><span class="main">)</span> <span class="main">(</span><span class="bound">s1</span> <span class="main">::</span> <span class="main">(</span>bitstring<span class="main">,</span> bitstring<span class="main">)</span> PRF.dict<span class="main">)</span><span class="main">.</span> <span class="bound">s2'</span> <span class="main">=</span> <span class="bound">s1</span><span class="main">)</span>"</span></span>

      <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">S</span> <span class="main">(</span><span class="main">()</span><span class="main">,</span> Map_empty<span class="main">)</span> Map_empty"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> S_def<span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">S</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> rel_spmf <span class="main">(</span>rel_prod <span class="main">(=)</span> <span class="skolem">S</span><span class="main">)</span><span class="main">)</span> <span class="skolem">oracle_intercept</span> <span class="skolem">oracle2</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> oracle2_def oracle_intercept_def
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> bool.split plus_oracle_split option.split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> S_def rel_fun_def exec_gpv_bind PRF.random_oracle_def oracle_encrypt2_def Let_def map_spmf_conv_bind_spmf oracle_decrypt2_def rel_spmf_return_spmf1 fun_upd_idem <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_bind_reflI rel_spmf_reflI<span class="main">)</span>

      <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"map_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">b</span> <span class="main">=</span> fst <span class="main">(</span>fst <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>exec_gpv <span class="main">(</span>PRF.random_oracle<span class="main">)</span> <span class="main">(</span>inline <span class="main">(</span>intercept_prf <span class="skolem">k_upf</span> <span class="skolem">b</span><span class="main">)</span> <span class="free">𝒜</span> <span class="main">()</span><span class="main">)</span> Map.empty<span class="main">)</span> <span class="main">=</span> 
        map_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">b</span> <span class="main">=</span> fst <span class="bound">x</span><span class="main">)</span> <span class="main">(</span>exec_gpv <span class="skolem">oracle2</span> <span class="free">𝒜</span> Map_empty<span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">b</span></span> <span class="quoted"><span class="free">prf_clen</span></span> <span class="quoted"><span class="free">prf_domain</span></span> <span class="quoted"><span class="free">upf_fun</span></span> <span class="quoted"><span class="skolem">k_upf</span></span> <span class="quoted"><span class="free">𝒜</span></span> <span class="quoted"><span class="skolem">k_prf</span></span><span class="main">)</span>
          <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> exec_gpv_inline map_spmf_conv_bind_spmf<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> spmf.map_comp o_def split_def oracle_intercept_def<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> game2_def PRF.game_1_def key_gen_def reduction_prf_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> exec_gpv_bind_lift_spmf exec_gpv_bind map_spmf_conv_bind_spmf split_def bind_spmf_const prf_key_gen_lossless lossless_weight_spmfD eq_commute<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> PRF.advantage_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">oracle_encrypt3</span> <span class="main">::</span> 
   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'prf_key</span> <span class="main">×</span> <span class="tfree">'upf_key</span><span class="main">)</span> <span class="main">⇒</span> bool <span class="main">⇒</span> <span class="main">(</span>bool <span class="main">×</span> <span class="main">(</span>bitstring<span class="main">,</span> bitstring<span class="main">)</span> PRF.dict<span class="main">)</span> <span class="main">⇒</span>
    bitstring <span class="main">×</span> bitstring <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'hash</span> cipher_text option <span class="main">×</span> <span class="main">(</span>bool <span class="main">×</span> <span class="main">(</span>bitstring<span class="main">,</span> bitstring<span class="main">)</span> PRF.dict<span class="main">)</span><span class="main">)</span> spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">oracle_encrypt3</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">k_prf</span><span class="main">,</span> <span class="bound">k_upf</span><span class="main">)</span> <span class="bound">b</span> <span class="main">(</span><span class="bound">bad</span><span class="main">,</span> <span class="bound">D</span><span class="main">)</span> <span class="main">(</span><span class="bound">msg1</span><span class="main">,</span> <span class="bound">msg0</span><span class="main">)</span><span class="main">.</span> 
    <span class="main">(</span><span class="keyword1">case</span> <span class="main">(</span>length <span class="bound">msg1</span> <span class="main">=</span> <span class="free">prf_clen</span> <span class="main">∧</span> length <span class="bound">msg0</span> <span class="main">=</span> <span class="free">prf_clen</span><span class="main">)</span> <span class="keyword1">of</span>
      False <span class="main">⇒</span> return_spmf <span class="main">(</span>None<span class="main">,</span> <span class="main">(</span><span class="bound">bad</span><span class="main">,</span> <span class="bound">D</span><span class="main">)</span><span class="main">)</span>
    <span class="main">|</span> True <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">x</span> <span class="main">←</span> spmf_of_set <span class="free">prf_domain</span><span class="main">;</span>
        <span class="bound">P</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">prf_clen</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1">let</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span> <span class="bound">F</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="bound">D</span> <span class="bound">x</span> <span class="keyword1">of</span> Some <span class="bound">r</span> <span class="main">⇒</span> <span class="main">(</span><span class="bound">P</span><span class="main">,</span> True<span class="main">)</span> <span class="main">|</span> None <span class="main">⇒</span> <span class="main">(</span><span class="bound">P</span><span class="main">,</span> False<span class="main">)</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1">let</span> <span class="bound">c</span> <span class="main">=</span> <span class="bound">p</span> <span class="main">[⊕]</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">msg1</span> <span class="keyword1">else</span> <span class="bound">msg0</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1">let</span> <span class="bound">t</span> <span class="main">=</span> <span class="free">upf_fun</span> <span class="bound">k_upf</span> <span class="main">(</span><span class="bound">x</span> <span class="main">@</span> <span class="bound">c</span><span class="main">)</span><span class="main">;</span>
        return_spmf <span class="main">(</span>Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">c</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">bad</span> <span class="main">∨</span> <span class="bound">F</span><span class="main">,</span> <span class="bound">D</span><span class="main">(</span><span class="bound">x</span> <span class="main">↦</span> <span class="bound">p</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
      <span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_oracle_encrypt3 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>oracle_encrypt3 <span class="free">k</span> <span class="free">b</span> <span class="free">D</span> <span class="free">m10</span><span class="main">)</span> "</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">m10</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle_encrypt3_def prf_domain_nonempty prf_domain_finite
    split_def Let_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> bool.splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> callee_invariant_oracle_encrypt3 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"callee_invariant <span class="main">(</span>oracle_encrypt3 <span class="free">key</span> <span class="free">b</span><span class="main">)</span> fst"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle_encrypt3_def split_def Let_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> bool.splits<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">game3</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>bitstring<span class="main">,</span> <span class="tfree">'hash</span> cipher_text<span class="main">)</span> ind_cca.adversary <span class="main">⇒</span> <span class="main">(</span>bool <span class="main">×</span> bool<span class="main">)</span> spmf"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">game3</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">key</span> <span class="main">←</span> key_gen<span class="main">;</span>
    <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
    <span class="main">(</span><span class="bound">b'</span><span class="main">,</span> <span class="main">(</span><span class="bound">bad</span><span class="main">,</span> <span class="bound">D</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="main">(</span>oracle_encrypt3 <span class="bound">key</span> <span class="bound">b</span> <span class="keyword1">⊕<span class="hidden">⇩</span><sub>O</sub></span> oracle_decrypt2 <span class="bound">key</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">(</span>False<span class="main">,</span> Map_empty<span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">b</span> <span class="main">=</span> <span class="bound">b'</span><span class="main">,</span> <span class="bound">bad</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> round_3<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lossless_gpv <span class="main">(</span>ℐ_full <span class="keyword1">⊕<span class="hidden">⇩</span><sub>ℐ</sub></span> ℐ_full<span class="main">)</span> <span class="free">𝒜</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">¦</span>measure <span class="main">(</span>measure_spmf <span class="main">(</span>game3 <span class="free">𝒜</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">bad</span><span class="main">)</span><span class="main">.</span> <span class="bound">b</span><span class="main">}</span> <span class="main">-</span> spmf <span class="main">(</span>game2 <span class="free">𝒜</span><span class="main">)</span> True<span class="main">¦</span> 
          <span class="main">≤</span> measure <span class="main">(</span>measure_spmf <span class="main">(</span>game3 <span class="free">𝒜</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">bad</span><span class="main">)</span><span class="main">.</span> <span class="bound">bad</span><span class="main">}</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">oracle_encrypt2'</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">oracle_encrypt2'</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">k_prf</span> <span class="main">::</span> <span class="tfree">'prf_key</span><span class="main">,</span> <span class="bound">k_upf</span><span class="main">)</span> <span class="bound">b</span> <span class="main">(</span><span class="bound">bad</span><span class="main">,</span> <span class="bound">D</span><span class="main">)</span> <span class="main">(</span><span class="bound">msg1</span><span class="main">,</span> <span class="bound">msg0</span><span class="main">)</span><span class="main">.</span> 
      <span class="keyword1">case</span> length <span class="bound">msg1</span> <span class="main">=</span> <span class="free">prf_clen</span> <span class="main">∧</span> length <span class="bound">msg0</span> <span class="main">=</span> <span class="free">prf_clen</span> <span class="keyword1">of</span>
        False <span class="main">⇒</span> return_spmf <span class="main">(</span>None<span class="main">,</span> <span class="main">(</span><span class="bound">bad</span><span class="main">,</span> <span class="bound">D</span><span class="main">)</span><span class="main">)</span>
      <span class="main">|</span> True <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="bound">x</span> <span class="main">←</span> spmf_of_set <span class="free">prf_domain</span><span class="main">;</span>
          <span class="bound">P</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">prf_clen</span><span class="main">)</span><span class="main">;</span>
          <span class="keyword1">let</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span> <span class="bound">F</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="bound">D</span> <span class="bound">x</span> <span class="keyword1">of</span> Some <span class="bound">r</span> <span class="main">⇒</span> <span class="main">(</span><span class="bound">r</span><span class="main">,</span> True<span class="main">)</span> <span class="main">|</span> None <span class="main">⇒</span> <span class="main">(</span><span class="bound">P</span><span class="main">,</span> False<span class="main">)</span><span class="main">)</span><span class="main">;</span>
          <span class="keyword1">let</span> <span class="bound">c</span> <span class="main">=</span> <span class="bound">p</span> <span class="main">[⊕]</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">msg1</span> <span class="keyword1">else</span> <span class="bound">msg0</span><span class="main">)</span><span class="main">;</span>
          <span class="keyword1">let</span> <span class="bound">t</span> <span class="main">=</span> <span class="free">upf_fun</span> <span class="bound">k_upf</span> <span class="main">(</span><span class="bound">x</span> <span class="main">@</span> <span class="bound">c</span><span class="main">)</span><span class="main">;</span>
          return_spmf <span class="main">(</span>Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">c</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">bad</span> <span class="main">∨</span> <span class="bound">F</span><span class="main">,</span> <span class="bound">D</span><span class="main">(</span><span class="bound">x</span> <span class="main">↦</span> <span class="bound">p</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
        <span class="main">}</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span><span class="skolem">oracle_encrypt2'</span> <span class="skolem">key</span> <span class="skolem">b</span> <span class="skolem">D</span> <span class="skolem">msg10</span><span class="main">)</span> "</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">key</span> <span class="skolem">b</span> <span class="skolem">D</span> <span class="skolem">msg10</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">msg10</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle_encrypt2'_def prf_domain_nonempty prf_domain_finite
      split_def Let_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> bool.split<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"callee_invariant <span class="main">(</span><span class="skolem">oracle_encrypt2'</span> <span class="skolem">key</span> <span class="skolem">b</span><span class="main">)</span> fst"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">key</span> <span class="skolem">b</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle_encrypt2'_def split_def Let_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> bool.splits<span class="main">)</span>

  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">game2'</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">game2'</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">𝒜</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">key</span> <span class="main">←</span> key_gen<span class="main">;</span>
      <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
      <span class="main">(</span><span class="bound">b'</span><span class="main">,</span> <span class="main">(</span><span class="bound">bad</span><span class="main">,</span> <span class="bound">D</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="main">(</span><span class="skolem">oracle_encrypt2'</span> <span class="bound">key</span> <span class="bound">b</span> <span class="keyword1">⊕<span class="hidden">⇩</span><sub>O</sub></span> oracle_decrypt2 <span class="bound">key</span><span class="main">)</span> <span class="bound">𝒜</span> <span class="main">(</span>False<span class="main">,</span> Map_empty<span class="main">)</span><span class="main">;</span>
      return_spmf <span class="main">(</span><span class="bound">b</span> <span class="main">=</span> <span class="bound">b'</span><span class="main">,</span> <span class="bound">bad</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">have</span></span> game2'_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"game2 <span class="free">𝒜</span> <span class="main">=</span> map_spmf fst <span class="main">(</span><span class="skolem">game2'</span> <span class="free">𝒜</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">S</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">S</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">D1</span> <span class="main">::</span> <span class="main">(</span>bitstring<span class="main">,</span> bitstring<span class="main">)</span> PRF.dict<span class="main">)</span> <span class="main">(</span><span class="bound">bad</span> <span class="main">::</span> bool<span class="main">,</span> <span class="bound">D2</span><span class="main">)</span><span class="main">.</span> <span class="bound">D1</span> <span class="main">=</span> <span class="bound">D2</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">S</span> Map_empty <span class="main">(</span><span class="skolem">b</span><span class="main">,</span> Map_empty<span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">b</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> S_def<span class="main">)</span>
  
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> <span class="skolem">S</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> rel_spmf <span class="main">(</span>rel_prod <span class="main">(=)</span> <span class="skolem">S</span><span class="main">)</span><span class="main">)</span>
      oracle_encrypt2 <span class="skolem">oracle_encrypt2'</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> oracle_encrypt2_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> oracle_encrypt2'_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def Let_def split_def S_def
           <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_bind_reflI <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> bool.split option.split<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="skolem">S</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> rel_spmf <span class="main">(</span>rel_prod <span class="main">(=)</span> <span class="skolem">S</span><span class="main">)</span><span class="main">)</span> 
      oracle_decrypt2 oracle_decrypt2"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def oracle_decrypt2_def<span class="main">)</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> game2_def game2'_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_spmf_bind_spmf o_def split_def Map_empty_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> Map_empty_def<span class="main">)</span>
         <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"rel_spmf <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">b'1</span><span class="main">,</span> <span class="bound">bad1</span><span class="main">,</span> <span class="bound">L1</span><span class="main">)</span> <span class="main">(</span><span class="bound">b'2</span><span class="main">,</span> <span class="bound">bad2</span><span class="main">,</span> <span class="bound">L2</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">bad1</span> <span class="main">⟷</span> <span class="bound">bad2</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">¬</span> <span class="bound">bad2</span> <span class="main">⟶</span> <span class="bound">b'1</span> <span class="main">⟷</span> <span class="bound">b'2</span><span class="main">)</span><span class="main">)</span>
    <span class="main">(</span>exec_gpv <span class="main">(</span>oracle_encrypt3 <span class="skolem">key</span> <span class="skolem">b</span> <span class="keyword1">⊕<span class="hidden">⇩</span><sub>O</sub></span> oracle_decrypt2 <span class="skolem">key</span><span class="main">)</span> <span class="free">𝒜</span> <span class="main">(</span>False<span class="main">,</span> Map_empty<span class="main">)</span><span class="main">)</span>
    <span class="main">(</span>exec_gpv <span class="main">(</span><span class="skolem">oracle_encrypt2'</span> <span class="skolem">key</span> <span class="skolem">b</span> <span class="keyword1">⊕<span class="hidden">⇩</span><sub>O</sub></span> oracle_decrypt2 <span class="skolem">key</span><span class="main">)</span> <span class="free">𝒜</span> <span class="main">(</span>False<span class="main">,</span> Map_empty<span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">key</span> <span class="skolem">b</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> exec_gpv_oracle_bisim_bad<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> X<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">(=)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> X_bad <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> True"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> <span class="var">?bad1.0</span><span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">fst</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> <span class="var">?bad2.0</span><span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">fst</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> ℐ<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"ℐ_full <span class="keyword1">⊕<span class="hidden">⇩</span><sub>ℐ</sub></span> ℐ_full"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms spmf_rel_map Let_def oracle_encrypt2'_def oracle_encrypt3_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> plus_oracle_split prod.split bool.split option.split <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_bind_reflI rel_spmf_reflI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¦</span>measure <span class="main">(</span>measure_spmf <span class="main">(</span>game3 <span class="free">𝒜</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">bad</span><span class="main">)</span><span class="main">.</span> <span class="bound">b</span><span class="main">}</span> <span class="main">-</span> measure <span class="main">(</span>measure_spmf <span class="main">(</span><span class="skolem">game2'</span> <span class="free">𝒜</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">bad</span><span class="main">)</span><span class="main">.</span> <span class="bound">b</span><span class="main">}</span><span class="main">¦</span> <span class="main">≤</span>
    measure <span class="main">(</span>measure_spmf <span class="main">(</span>game3 <span class="free">𝒜</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">bad</span><span class="main">)</span><span class="main">.</span> <span class="bound">bad</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> game2'_def game3_def
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> fundamental_lemma<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="var">?bad2.0</span><span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">snd</span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">intro</span> rel_spmf_bind_reflI rel_spmf_bindI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> *<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf_conv_measure_spmf measure_map_spmf vimage_def fst_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> round_4<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lossless_gpv <span class="main">(</span>ℐ_full <span class="keyword1">⊕<span class="hidden">⇩</span><sub>ℐ</sub></span> ℐ_full<span class="main">)</span> <span class="free">𝒜</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_spmf fst <span class="main">(</span>game3 <span class="free">𝒜</span><span class="main">)</span> <span class="main">=</span> coin_spmf"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">oracle_encrypt4</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">oracle_encrypt4</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">k_prf</span> <span class="main">::</span> <span class="tfree">'prf_key</span><span class="main">,</span> <span class="bound">k_upf</span><span class="main">)</span> <span class="main">(</span><span class="bound">s</span> <span class="main">::</span> unit<span class="main">)</span> <span class="main">(</span><span class="bound">msg1</span> <span class="main">::</span> bitstring<span class="main">,</span> <span class="bound">msg0</span> <span class="main">::</span> bitstring<span class="main">)</span><span class="main">.</span>
      <span class="keyword1">case</span> length <span class="bound">msg1</span> <span class="main">=</span> <span class="free">prf_clen</span> <span class="main">∧</span> length <span class="bound">msg0</span> <span class="main">=</span> <span class="free">prf_clen</span> <span class="keyword1">of</span>
        False <span class="main">⇒</span> return_spmf <span class="main">(</span>None<span class="main">,</span> <span class="bound">s</span><span class="main">)</span>
      <span class="main">|</span> True <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="bound">x</span> <span class="main">←</span> spmf_of_set <span class="free">prf_domain</span><span class="main">;</span>
          <span class="bound">P</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">prf_clen</span><span class="main">)</span><span class="main">;</span>
          <span class="keyword1">let</span> <span class="bound">c</span> <span class="main">=</span> <span class="bound">P</span><span class="main">;</span>
          <span class="keyword1">let</span> <span class="bound">t</span> <span class="main">=</span> <span class="free">upf_fun</span> <span class="bound">k_upf</span> <span class="main">(</span><span class="bound">x</span> <span class="main">@</span> <span class="bound">c</span><span class="main">)</span><span class="main">;</span>
          return_spmf <span class="main">(</span>Some <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">c</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="main">}</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span><span class="skolem">oracle_encrypt4</span> <span class="skolem">k</span> <span class="skolem">s</span> <span class="skolem">msg10</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">k</span> <span class="skolem">s</span> <span class="skolem">msg10</span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">msg10</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle_encrypt4_def prf_domain_finite prf_domain_nonempty
      split_def Let_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> bool.splits<span class="main">)</span>

  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">game4</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">game4</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">𝒜</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">key</span> <span class="main">←</span> key_gen<span class="main">;</span>
    <span class="main">(</span><span class="bound">b'</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="main">(</span><span class="skolem">oracle_encrypt4</span> <span class="bound">key</span> <span class="keyword1">⊕<span class="hidden">⇩</span><sub>O</sub></span> oracle_decrypt2 <span class="bound">key</span><span class="main">)</span> <span class="bound">𝒜</span> <span class="main">()</span><span class="main">;</span>
    map_spmf <span class="main">(</span><span class="main">(=)</span> <span class="bound">b'</span><span class="main">)</span> coin_spmf<span class="main">}</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_spmf fst <span class="main">(</span>game3 <span class="free">𝒜</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">game4</span> <span class="free">𝒜</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">split</span> <span class="quasi_keyword">del</span><span class="main">]</span> <span class="main">=</span> if_split
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">S</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">S</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit<span class="main">)</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span> <span class="main">::</span> bool <span class="main">×</span> <span class="main">(</span>bitstring<span class="main">,</span> bitstring<span class="main">)</span> PRF.dict<span class="main">)</span><span class="main">.</span> True<span class="main">)</span>"</span></span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">initial3</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">initial3</span> <span class="main">=</span> <span class="main">(</span>False<span class="main">,</span> Map.empty <span class="main">::</span> <span class="main">(</span>bitstring<span class="main">,</span> bitstring<span class="main">)</span> PRF.dict<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">S</span> <span class="main">()</span> <span class="skolem">initial3</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> S_def<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> <span class="skolem">S</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> rel_spmf <span class="main">(</span>rel_prod <span class="main">(=)</span> <span class="skolem">S</span><span class="main">)</span><span class="main">)</span>
       <span class="main">(</span><span class="main">λ</span><span class="bound">key</span> <span class="bound">b</span><span class="main">.</span> <span class="skolem">oracle_encrypt4</span> <span class="bound">key</span><span class="main">)</span> oracle_encrypt3"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> rel_funI<span class="main"><span class="keyword3">;</span></span> <span class="operator">hypsubst</span><span class="main">)</span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">key</span> <span class="skolem">unit</span> <span class="skolem">msg10</span> <span class="skolem">b</span> <span class="skolem">Dbad</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_spmf fst <span class="main">(</span><span class="skolem">oracle_encrypt4</span> <span class="skolem">key</span> <span class="main">()</span> <span class="skolem">msg10</span><span class="main">)</span> <span class="main">=</span> map_spmf fst <span class="main">(</span>oracle_encrypt3 <span class="skolem">key</span> <span class="skolem">b</span> <span class="skolem">Dbad</span> <span class="skolem">msg10</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> oracle_encrypt3_def oracle_encrypt4_def
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_spmf_conv_bind_spmf Let_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> bool.split prod.split<span class="main"><span class="keyword3">;</span></span> <span class="operator">rule</span> conjI<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rewrite</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">⌑</span></span> <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">_</span></span>"</span></span></span> one_time_pad<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">,</span></span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> xs<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="keyword1">if</span> <span class="skolem">b</span> <span class="keyword1">then</span> fst <span class="skolem">msg10</span> <span class="keyword1">else</span> snd <span class="skolem">msg10</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_map_spmf o_def option.case_distrib case_option_collapse xor_list_commute split_def <span class="quasi_keyword">cong</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> option.case_cong_weak if_weak_cong<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"rel_spmf <span class="main">(</span>rel_prod <span class="main">(=)</span> <span class="skolem">S</span><span class="main">)</span> <span class="main">(</span><span class="skolem">oracle_encrypt4</span> <span class="skolem">key</span> <span class="skolem">unit</span> <span class="skolem">msg10</span><span class="main">)</span> <span class="main">(</span>oracle_encrypt3 <span class="skolem">key</span> <span class="skolem">b</span> <span class="skolem">Dbad</span> <span class="skolem">msg10</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf_rel_eq<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> spmf_rel_map S_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rel_spmf_mono<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> game3_def game4_def <span class="keyword1"><span class="command">including</span></span> monad_normalisation
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_spmf_bind_spmf o_def split_def map_spmf_conv_bind_spmf initial3_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> eq_commute<span class="main">)</span>
         <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> coin_spmf"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_eq_const_coin_spmf game4_def bind_spmf_const split_def lossless_exec_gpv<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span> lossless_weight_spmfD<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span>  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> game3_bad<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"interaction_bounded_by isl <span class="free">𝒜</span> <span class="free">q</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"measure <span class="main">(</span>measure_spmf <span class="main">(</span>game3 <span class="free">𝒜</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">bad</span><span class="main">)</span><span class="main">.</span> <span class="bound">bad</span><span class="main">}</span> <span class="main">≤</span> <span class="free">q</span> <span class="main">/</span> card <span class="free">prf_domain</span> <span class="main">*</span> <span class="free">q</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"measure <span class="main">(</span>measure_spmf <span class="main">(</span>game3 <span class="free">𝒜</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">bad</span><span class="main">)</span><span class="main">.</span> <span class="bound">bad</span><span class="main">}</span> <span class="main">=</span> spmf <span class="main">(</span>map_spmf snd <span class="main">(</span>game3 <span class="free">𝒜</span><span class="main">)</span><span class="main">)</span> True"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf_conv_measure_spmf measure_map_spmf vimage_def snd_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>map_spmf <span class="main">(</span>fst <span class="main">∘</span> snd<span class="main">)</span> <span class="main">(</span>exec_gpv <span class="main">(</span>oracle_encrypt3 <span class="skolem">k</span> <span class="skolem">b</span> <span class="keyword1">⊕<span class="hidden">⇩</span><sub>O</sub></span> oracle_decrypt2 <span class="skolem">k</span><span class="main">)</span> <span class="free">𝒜</span> <span class="main">(</span>False<span class="main">,</span> Map.empty<span class="main">)</span><span class="main">)</span><span class="main">)</span> True <span class="main">≤</span> <span class="free">q</span> <span class="main">/</span> card <span class="free">prf_domain</span> <span class="main">*</span> <span class="free">q</span>"</span></span>
    <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>map_spmf <span class="main">_</span> <span class="main">(</span>exec_gpv <span class="var">?oracle</span> <span class="main">_</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">_</span> <span class="main">≤</span>  <span class="main">_</span>"</span></span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">if</span></span> k<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">∈</span> set_spmf key_gen"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">k</span> <span class="skolem">b</span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> callee_invariant_on.interaction_bounded_by'_exec_gpv_bad_count<span class="main">)</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">k_prf</span></span> <span class="skolem"><span class="skolem">k_upf</span></span> <span class="keyword2"><span class="keyword">where</span></span> k<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">k_prf</span><span class="main">,</span> <span class="skolem">k_upf</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">k</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?I</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">bad</span><span class="main">,</span> <span class="bound">D</span><span class="main">)</span><span class="main">.</span> finite <span class="main">(</span>dom <span class="bound">D</span><span class="main">)</span> <span class="main">∧</span> dom <span class="bound">D</span> <span class="main">⊆</span> <span class="free">prf_domain</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"callee_invariant <span class="main">(</span>oracle_encrypt3 <span class="skolem">k</span> <span class="skolem">b</span><span class="main">)</span> <span class="var">?I</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> prf_domain_finite oracle_encrypt3_def Let_def split_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> bool.splits<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"callee_invariant <span class="main">(</span>oracle_decrypt2 <span class="skolem">k</span><span class="main">)</span> <span class="var">?I</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> prf_domain_finite oracle_decrypt2_def<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"callee_invariant <span class="var">?oracle</span> <span class="var">?I</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?count</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">bad</span><span class="main">,</span> <span class="bound">D</span><span class="main">)</span><span class="main">.</span> card <span class="main">(</span>dom <span class="bound">D</span><span class="main">)</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">x</span> <span class="bound">y</span> <span class="bound">s'</span><span class="main">.</span> <span class="main">⟦</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">∈</span> set_spmf <span class="main">(</span><span class="var">?oracle</span> <span class="bound">s</span> <span class="bound">x</span><span class="main">)</span><span class="main">;</span> <span class="var">?I</span> <span class="bound">s</span><span class="main">;</span> isl <span class="bound">x</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="var">?count</span> <span class="bound">s'</span> <span class="main">≤</span> Suc <span class="main">(</span><span class="var">?count</span> <span class="bound">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> isl_def oracle_encrypt3_def split_def Let_def card_insert_if <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> bool.splits<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">s'</span><span class="main">)</span> <span class="main">∈</span> set_spmf <span class="main">(</span><span class="var">?oracle</span> <span class="skolem">s</span> <span class="skolem">x</span><span class="main">)</span><span class="main">;</span> <span class="var">?I</span> <span class="skolem">s</span><span class="main">;</span> <span class="main">¬</span> isl <span class="skolem">x</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="var">?count</span> <span class="skolem">s'</span> <span class="main">≤</span> <span class="var">?count</span> <span class="skolem">s</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">s'</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle_decrypt2_def<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>map_spmf <span class="main">(</span>fst <span class="main">∘</span> snd<span class="main">)</span> <span class="main">(</span><span class="var">?oracle</span> <span class="skolem">s'</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span> True <span class="main">≤</span> <span class="free">q</span> <span class="main">/</span> card <span class="free">prf_domain</span>"</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?I</span> <span class="skolem">s'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> bad<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> fst <span class="skolem">s'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> count<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?count</span> <span class="skolem">s'</span> <span class="main">&lt;</span> <span class="free">q</span> <span class="main">+</span> <span class="var">?count</span> <span class="main">(</span>False<span class="main">,</span> Map.empty<span class="main">)</span>"</span></span> 
      <span class="keyword2"><span class="keyword">and</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"isl <span class="skolem">x</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s'</span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">bad</span></span> <span class="skolem"><span class="skolem">D</span></span> <span class="keyword2"><span class="keyword">where</span></span> s' <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">s'</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">bad</span><span class="main">,</span> <span class="skolem">D</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">s'</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> x <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">m1</span></span> <span class="skolem"><span class="skolem">m0</span></span> <span class="keyword2"><span class="keyword">where</span></span> x <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> Inl <span class="main">(</span><span class="skolem">m1</span><span class="main">,</span> <span class="skolem">m0</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> islE<span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">case</span> <span class="skolem">D</span> <span class="skolem">x</span> <span class="keyword1">of</span> None <span class="main">⇒</span> False <span class="main">|</span> Some <span class="bound">x</span> <span class="main">⇒</span> True<span class="main">)</span> <span class="main">⟷</span> <span class="skolem">x</span> <span class="main">∈</span> dom <span class="skolem">D</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"length <span class="skolem">m1</span> <span class="main">=</span> <span class="free">prf_clen</span> <span class="main">∧</span> length <span class="skolem">m0</span> <span class="main">=</span> <span class="free">prf_clen</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True
        <span class="keyword1"><span class="command">with</span></span> bad
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>map_spmf <span class="main">(</span>fst <span class="main">∘</span> snd<span class="main">)</span> <span class="main">(</span><span class="var">?oracle</span> <span class="skolem">s'</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span> True <span class="main">=</span> pmf <span class="main">(</span>bernoulli_pmf <span class="main">(</span>card <span class="main">(</span>dom <span class="skolem">D</span> <span class="main">∩</span> <span class="free">prf_domain</span><span class="main">)</span> <span class="main">/</span> card <span class="free">prf_domain</span><span class="main">)</span><span class="main">)</span> True"</span></span>
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf.map_comp o_def oracle_encrypt3_def k * bool.case_distrib<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> h<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">p</span><span class="main">.</span> spmf <span class="main">(</span>map_spmf <span class="main">_</span> <span class="bound">p</span><span class="main">)</span> <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span> option.case_distrib<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> h<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">snd</span><span class="main"><span class="main">]</span></span> map_spmf_bind_spmf Let_def split_beta bind_spmf_const <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> bool.case_cong option.case_cong <span class="quasi_keyword">split</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> if_split <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> bool.split<span class="main">)</span>
            <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_spmf_conv_bind_spmf<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> map_mem_spmf_of_set prf_domain_finite prf_domain_nonempty<span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> card <span class="main">(</span>dom <span class="skolem">D</span> <span class="main">∩</span> <span class="free">prf_domain</span><span class="main">)</span> <span class="main">/</span> card <span class="free">prf_domain</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> pmf_bernoulli_True<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">field_simps</span></span> prf_domain_finite prf_domain_nonempty card_gt_0_iff card_mono<span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"dom <span class="skolem">D</span> <span class="main">∩</span> <span class="free">prf_domain</span> <span class="main">=</span> dom <span class="skolem">D</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> I <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>dom <span class="skolem">D</span><span class="main">)</span> <span class="main">≤</span> <span class="free">q</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> count <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> divide_right_mono o_def<span class="main">)</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> bad 
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf.map_comp o_def oracle_encrypt3_def k <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> bool.split<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> plus_oracle_split_asm <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle_decrypt2_def assms<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>map_spmf snd <span class="main">(</span>game3 <span class="free">𝒜</span><span class="main">)</span><span class="main">)</span> True <span class="main">≤</span> <span class="free">q</span> <span class="main">/</span> card <span class="free">prf_domain</span> <span class="main">*</span> <span class="free">q</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> game3_def map_spmf_bind_spmf o_def split_def map_spmf_conv_bind_spmf <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> spmf_bind_leI<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">theorem</span></span> security<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> lossless<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_gpv <span class="main">(</span>ℐ_full <span class="keyword1">⊕<span class="hidden">⇩</span><sub>ℐ</sub></span> ℐ_full<span class="main">)</span> <span class="free">𝒜</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> bound<span class="main">:</span> <span class="quoted"><span class="quoted">"interaction_bounded_by isl <span class="free">𝒜</span> <span class="free">q</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ind_cca.advantage <span class="free">𝒜</span> <span class="main">≤</span> 
    PRF.advantage <span class="main">(</span>reduction_prf <span class="free">𝒜</span><span class="main">)</span> <span class="main">+</span> UPF.advantage <span class="main">(</span>reduction_upf <span class="free">𝒜</span><span class="main">)</span> <span class="main">+</span>
    real <span class="free">q</span> <span class="main">/</span> real <span class="main">(</span>card <span class="free">prf_domain</span><span class="main">)</span> <span class="main">*</span> real <span class="free">q</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?LHS</span> <span class="main">≤</span> <span class="main">_</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?LHS</span> <span class="main">≤</span> <span class="main">¦</span>spmf <span class="main">(</span>ind_cca.game <span class="free">𝒜</span><span class="main">)</span> True <span class="main">-</span> spmf <span class="main">(</span>ind_cca'.game <span class="free">𝒜</span><span class="main">)</span> True<span class="main">¦</span> <span class="main">+</span> <span class="main">¦</span>spmf <span class="main">(</span>ind_cca'.game <span class="free">𝒜</span><span class="main">)</span> True <span class="main">-</span> <span class="main">1</span> <span class="main">/</span> <span class="numeral">2</span><span class="main">¦</span>"</span></span>
    <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">≤</span> <span class="var">?round1</span> <span class="main">+</span> <span class="var">?rest</span>"</span></span><span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> abs_triangle_ineq <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ind_cca.advantage_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?round1</span> <span class="main">≤</span> UPF.advantage <span class="main">(</span>reduction_upf <span class="free">𝒜</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> lossless <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> round_1<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rest</span> <span class="main">≤</span> <span class="main">¦</span>spmf <span class="main">(</span>ind_cca'.game <span class="free">𝒜</span><span class="main">)</span> True <span class="main">-</span> spmf <span class="main">(</span>game2 <span class="free">𝒜</span><span class="main">)</span> True<span class="main">¦</span> <span class="main">+</span> <span class="main">¦</span>spmf <span class="main">(</span>game2 <span class="free">𝒜</span><span class="main">)</span> True <span class="main">-</span> <span class="main">1</span> <span class="main">/</span> <span class="numeral">2</span><span class="main">¦</span>"</span></span>
    <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">≤</span> <span class="var">?round2</span> <span class="main">+</span> <span class="var">?rest</span>"</span></span><span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> abs_triangle_ineq <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?round2</span> <span class="main">=</span> PRF.advantage <span class="main">(</span>reduction_prf <span class="free">𝒜</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> round_2<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rest</span> <span class="main">≤</span> <span class="main">¦</span>measure <span class="main">(</span>measure_spmf <span class="main">(</span>game3 <span class="free">𝒜</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">bad</span><span class="main">)</span><span class="main">.</span> <span class="bound">b</span><span class="main">}</span> <span class="main">-</span> spmf <span class="main">(</span>game2 <span class="free">𝒜</span><span class="main">)</span> True<span class="main">¦</span> <span class="main">+</span>
       <span class="main">¦</span>measure <span class="main">(</span>measure_spmf <span class="main">(</span>game3 <span class="free">𝒜</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">bad</span><span class="main">)</span><span class="main">.</span> <span class="bound">b</span><span class="main">}</span> <span class="main">-</span> <span class="main">1</span> <span class="main">/</span> <span class="numeral">2</span><span class="main">¦</span>"</span></span> 
    <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">≤</span> <span class="var">?round3</span> <span class="main">+</span> <span class="main">_</span>"</span></span><span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> abs_triangle_ineq <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?round3</span> <span class="main">≤</span> measure <span class="main">(</span>measure_spmf <span class="main">(</span>game3 <span class="free">𝒜</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">bad</span><span class="main">)</span><span class="main">.</span> <span class="bound">bad</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> round_3<span class="main">[</span><span class="operator">OF</span> lossless<span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="free">q</span> <span class="main">/</span> card <span class="free">prf_domain</span> <span class="main">*</span> <span class="free">q</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> bound <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> game3_bad<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"measure <span class="main">(</span>measure_spmf <span class="main">(</span>game3 <span class="free">𝒜</span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">bad</span><span class="main">)</span><span class="main">.</span> <span class="bound">b</span><span class="main">}</span> <span class="main">=</span> spmf coin_spmf True"</span></span>
    <span class="keyword1"><span class="command">using</span></span> round_4<span class="main">[</span><span class="operator">OF</span> lossless<span class="main">,</span> <span class="operator">symmetric</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf_conv_measure_spmf measure_map_spmf vimage_def fst_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¦</span><span class="main">…</span> <span class="main">-</span> <span class="main">1</span> <span class="main">/</span> <span class="numeral">2</span><span class="main">¦</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf_of_set<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> security1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> lossless<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_gpv <span class="main">(</span>ℐ_full <span class="keyword1">⊕<span class="hidden">⇩</span><sub>ℐ</sub></span> ℐ_full<span class="main">)</span> <span class="free">𝒜</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> q<span class="main">:</span> <span class="quoted"><span class="quoted">"interaction_bounded_by isl <span class="free">𝒜</span> <span class="free">q</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> q'<span class="main">:</span> <span class="quoted"><span class="quoted">"interaction_bounded_by <span class="main">(</span>Not <span class="main">∘</span> isl<span class="main">)</span> <span class="free">𝒜</span> <span class="free">q'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ind_cca.advantage <span class="free">𝒜</span> <span class="main">≤</span> 
    PRF.advantage <span class="main">(</span>reduction_prf <span class="free">𝒜</span><span class="main">)</span> <span class="main">+</span>
    UPF.advantage1 <span class="main">(</span>guessing_many_one.reduction <span class="free">q'</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> reduction_upf <span class="free">𝒜</span><span class="main">)</span> <span class="main">()</span><span class="main">)</span> <span class="main">*</span> <span class="free">q'</span> <span class="main">+</span>
    real <span class="free">q</span> <span class="main">*</span> real <span class="free">q</span> <span class="main">/</span> real <span class="main">(</span>card <span class="free">prf_domain</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ind_cca.advantage <span class="free">𝒜</span> <span class="main">≤</span> 
    PRF.advantage <span class="main">(</span>reduction_prf <span class="free">𝒜</span><span class="main">)</span> <span class="main">+</span> UPF.advantage <span class="main">(</span>reduction_upf <span class="free">𝒜</span><span class="main">)</span> <span class="main">+</span>
    real <span class="free">q</span> <span class="main">/</span> real <span class="main">(</span>card <span class="free">prf_domain</span><span class="main">)</span> <span class="main">*</span> real <span class="free">q</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> lossless q <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> security<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> q'<span class="main">[</span><span class="operator">interaction_bound</span><span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"interaction_bounded_by <span class="main">(</span>Not <span class="main">∘</span> isl<span class="main">)</span> <span class="main">(</span>reduction_upf <span class="free">𝒜</span><span class="main">)</span> <span class="free">q'</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> reduction_upf_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">interaction_bound</span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> SUP_le_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"UPF.advantage <span class="main">(</span>reduction_upf <span class="free">𝒜</span><span class="main">)</span> <span class="main">≤</span> UPF.advantage1 <span class="main">(</span>guessing_many_one.reduction <span class="free">q'</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> reduction_upf <span class="free">𝒜</span><span class="main">)</span> <span class="main">()</span><span class="main">)</span> <span class="main">*</span> <span class="free">q'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> UPF.advantage_advantage1<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> simple_cipher' <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">prf_key_gen</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="tfree">'prf_key</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">prf_fun</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="tfree">'prf_key</span> <span class="main">⇒</span> bitstring <span class="main">⇒</span> bitstring"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">prf_domain</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> bitstring set"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">prf_range</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> bitstring set"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">prf_dlen</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> nat"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">prf_clen</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> nat"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">upf_key_gen</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="tfree">'upf_key</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">upf_fun</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="tfree">'upf_key</span> <span class="main">⇒</span> bitstring <span class="main">⇒</span> <span class="tfree">'hash</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> simple_cipher<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">η</span><span class="main">.</span> simple_cipher <span class="main">(</span><span class="free">prf_key_gen</span> <span class="bound">η</span><span class="main">)</span> <span class="main">(</span><span class="free">prf_fun</span> <span class="bound">η</span><span class="main">)</span> <span class="main">(</span><span class="free">prf_domain</span> <span class="bound">η</span><span class="main">)</span> <span class="main">(</span><span class="free">prf_dlen</span> <span class="bound">η</span><span class="main">)</span> <span class="main">(</span><span class="free">prf_clen</span> <span class="bound">η</span><span class="main">)</span> <span class="main">(</span><span class="free">upf_key_gen</span> <span class="bound">η</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> simple_cipher 
  <span class="quoted"><span class="quoted">"<span class="free">prf_key_gen</span> <span class="free">η</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">prf_fun</span> <span class="free">η</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">prf_domain</span> <span class="free">η</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">prf_range</span> <span class="free">η</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">prf_dlen</span> <span class="free">η</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">prf_clen</span> <span class="free">η</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">upf_key_gen</span> <span class="free">η</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">upf_fun</span> <span class="free">η</span>"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">η</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> simple_cipher<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> security_asymptotic<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">q</span> <span class="free">q'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> nat"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> lossless<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">η</span><span class="main">.</span> lossless_gpv <span class="main">(</span>ℐ_full <span class="keyword1">⊕<span class="hidden">⇩</span><sub>ℐ</sub></span> ℐ_full<span class="main">)</span> <span class="main">(</span><span class="free">𝒜</span> <span class="bound">η</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> bound<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">η</span><span class="main">.</span> interaction_bounded_by isl <span class="main">(</span><span class="free">𝒜</span> <span class="bound">η</span><span class="main">)</span> <span class="main">(</span><span class="free">q</span> <span class="bound">η</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> bound'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">η</span><span class="main">.</span> interaction_bounded_by <span class="main">(</span>Not <span class="main">∘</span> isl<span class="main">)</span> <span class="main">(</span><span class="free">𝒜</span> <span class="bound">η</span><span class="main">)</span> <span class="main">(</span><span class="free">q'</span> <span class="bound">η</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">negligible_intros</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"polynomial <span class="free">q'</span>"</span></span> <span class="quoted"><span class="quoted">"polynomial <span class="free">q</span>"</span></span>
    <span class="quoted"><span class="quoted">"negligible <span class="main">(</span><span class="main">λ</span><span class="bound">η</span><span class="main">.</span> PRF.advantage <span class="bound">η</span> <span class="main">(</span>reduction_prf <span class="bound">η</span> <span class="main">(</span><span class="free">𝒜</span> <span class="bound">η</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"negligible <span class="main">(</span><span class="main">λ</span><span class="bound">η</span><span class="main">.</span> UPF.advantage1 <span class="bound">η</span> <span class="main">(</span>guessing_many_one.reduction <span class="main">(</span><span class="free">q'</span> <span class="bound">η</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> reduction_upf <span class="bound">η</span> <span class="main">(</span><span class="free">𝒜</span> <span class="bound">η</span><span class="main">)</span><span class="main">)</span> <span class="main">()</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"negligible <span class="main">(</span><span class="main">λ</span><span class="bound">η</span><span class="main">.</span> <span class="main">1</span> <span class="main">/</span> card <span class="main">(</span><span class="free">prf_domain</span> <span class="bound">η</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"negligible <span class="main">(</span><span class="main">λ</span><span class="bound">η</span><span class="main">.</span> ind_cca.advantage <span class="bound">η</span> <span class="main">(</span><span class="free">𝒜</span> <span class="bound">η</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"negligible <span class="main">(</span><span class="main">λ</span><span class="bound">η</span><span class="main">.</span> PRF.advantage <span class="bound">η</span> <span class="main">(</span>reduction_prf <span class="bound">η</span> <span class="main">(</span><span class="free">𝒜</span> <span class="bound">η</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span>
    UPF.advantage1 <span class="bound">η</span> <span class="main">(</span>guessing_many_one.reduction <span class="main">(</span><span class="free">q'</span> <span class="bound">η</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> reduction_upf <span class="bound">η</span> <span class="main">(</span><span class="free">𝒜</span> <span class="bound">η</span><span class="main">)</span><span class="main">)</span> <span class="main">()</span><span class="main">)</span> <span class="main">*</span> <span class="free">q'</span> <span class="bound">η</span> <span class="main">+</span>
    real <span class="main">(</span><span class="free">q</span> <span class="bound">η</span><span class="main">)</span> <span class="main">/</span> real <span class="main">(</span>card <span class="main">(</span><span class="free">prf_domain</span> <span class="bound">η</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> real <span class="main">(</span><span class="free">q</span> <span class="bound">η</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> <span class="dynamic"><span class="dynamic">negligible_intros</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> negligible_le<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> security1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lossless bound bound'<span class="main"><span class="main">]</span></span> ind_cca.advantage_nonneg<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Cryptographic_Constructions">
<div class="head">
<h1>Theory Cryptographic_Constructions</h1>
</div>
<pre class="source"><span class="comment1">(* Title: Cryptographic_Constructions.thy
  Author: Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">theory</span></span> Cryptographic_Constructions <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Elgamal.html">Elgamal</a>
  <a href="Hashed_Elgamal.html">Hashed_Elgamal</a>
  <a href="RP_RF.html">RP_RF</a>
  <a href="PRF_UHF.html">PRF_UHF</a>
  <a href="PRF_IND_CPA.html">PRF_IND_CPA</a>
  <a href="PRF_UPF_IND_CCA.html">PRF_UPF_IND_CCA</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Game_Based_Crypto">
<div class="head">
<h1>Theory Game_Based_Crypto</h1>
</div>
<pre class="source"><span class="comment1">(* Title: Game_Based_Crypto.thy
  Author: Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">theory</span></span> Game_Based_Crypto <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Security_Spec.html">Security_Spec</a>
  <a href="Cryptographic_Constructions.html">Cryptographic_Constructions</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="CryptHOL_Tutorial">
<div class="head">
<h1>Theory CryptHOL_Tutorial</h1>
</div>
<pre class="source"><span class="comment1">(* Author: Andreas Lochbihler, Digital Asset 
   Author: S. Reza Sefidgar, ETH Zurich      *)</span>

<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹%
\clearpage
\addcontentsline{toc}{section}{A Tutorial Introduction to \CryptHOL{}}%
\begin{center}
  \normalfont
  {\huge A Tutorial Introduction to \CryptHOL{}}
  \\[1em]
  \large
  Andreas Lochbihler
  \\
  Digital Asset (Switzerland) GmbH, Zurich, Switzerland,
  \texttt{mail@andreas-lochbihler.de}
  \\[1ex]
  S. Reza Sefidgar
  \\
  Institute of Information Security, 
  Department of Computer Science, ETH Zurich, Zurich, Switzerland, \\
  \texttt{reza.sefidgar@inf.ethz.ch}
\end{center}
%
\begin{abstract}
  \noindent
  This tutorial demonstrates how cryptographic security notions, constructions, and game-based security proofs
  can be formalized using the \CryptHOL{} framework.
  As a running example, we formalize a variant of the hash-based ElGamal encryption scheme and its IND-CPA security in the random oracle model.
  This tutorial assumes basic familiarity with Isabelle/HOL and standard cryptographic terminology.
\end{abstract}
›</span></span>
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Introduction›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
\CryptHOL{}~\cite{Basin2017, Lochbihler2016} is a framework for constructing rigorous game-based
proofs using the proof assistant Isabelle/HOL~\cite{Nipkow2002}.
Games are expressed as probabilistic functional programs that are shallowly embedded in higher-order logic (HOL) using \CryptHOL{}'s combinators.
The security statements, both concrete and asymptotic, are expressed as Isabelle/HOL theorem statements, and their proofs are written declaratively in Isabelle's proof language Isar~\cite{Wenzel1999}.
This way, Isabelle mechanically checks that all definitions and statements are type-correct and each proof step is a valid logical inference in HOL.
This ensures that the resulting theorems are valid in higher-order logic.

This tutorial explains the \CryptHOL{} essentials using a simple security proof.
Our running example is a variant of the hashed ElGamal encryption scheme~\cite{Elgamal1985}.
We formalize the scheme, the indistinguishability under chosen plaintext (IND-CPA) security property, the computational Diffie-Hellman (CDH) hardness assumption~\cite{Diffie1976}, and the security proof in the random oracle model.
This illustrates how the following aspects of a cryptographic security proof are formalized using \CryptHOL{}:

\begin{itemize}
\item Game-based security definitions (CDH in \S\ref{section:lcdh} and IND-CPA in \S\ref{section:ind-cpa})
\item Oracles (a random oracle in \S\ref{section:random-oracle})
\item Cryptographic schemes, both generic (the concept of an encryption scheme) and a particular instance (the hashed Elgamal scheme in \S\ref{section:hashed-elgamal-scheme})
\item Security statements (concrete and asymptotic, \S\ref{section:security:concrete} and \S\ref{section:security:asymptotic})
\item Reductions (from IND-CPA to CDH for hashed Elgamal in \S\ref{section:reduction})
\item Different kinds of proof steps (\S\ref{section:ghop-first}--\ref{section:combining:hops}):
  \begin{itemize}
  \item Using intermediate games
  \item Defining failure events and applying indistinguishability-up-to lemmas
  \item Equivalence transformations on games
  \end{itemize}
\end{itemize}

This tutorial assumes that the reader knows the basics of Isabelle/HOL and game-based cryptography and wants to get hands-on experience with \CryptHOL{}.
The semantics behind CryptHOL's embedding in higher-order logic and its soundness are not discussed;
we refer the reader to the scientific articles for that~\cite{Basin2017, Lochbihler2016}.
Shoup's tutorial~\cite{Shoup2004IACR} provides a good introduction to game-based proofs.
The following Isabelle features are frequently used in \CryptHOL{} formalizations; the tutorials are available from the Documentation panel in Isabelle/jEdit.
\begin{itemize}
\item Function definitions (tutorials <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">doc</span></span> "prog-prove"<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">doc</span></span> "functions"<span class="antiquote"><span class="antiquote">}</span></span></span></span>,~\cite{Krauss2009}) for games and reductions
\item Locales (tutorial <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">doc</span></span> locales<span class="antiquote"><span class="antiquote">}</span></span></span></span>,~\cite{Ballarin2014}) to modularize the formalization
\item The Transfer package~\cite{Huffman2013} for automating parametricity and representation independence proofs
\end{itemize}

This document is generated from a corresponding Isabelle theory file available online~\cite{Lochbihler2017b}.%
\footnote{%
  The tutorial has been added to the Archive of Formal Proofs after the release of Isabelle2018.
  Until the subsequent Isabelle release, the tutorial is only available in the development version at
  \url{https://devel.isa-afp.org/entries/Game_Based_Crypto.html}.
  The version for Isabelle2018 is available at \url{http://www.andreas-lochbihler.de/pub/crypthol_tutorial.zip}.
}
It contains this text and all examples, including the security definitions and proofs.
We encourage all readers to download the latest version of the tutorial 
and follow the proofs and examples interactively in Isabelle/HOL.
In particular, a Ctrl-click on a formal entity (function, constant, theorem name, ...) jumps to the definition of the entity.

We split the tutorial into a series of recipes for common formalization tasks. In each section, we cover
a familiar cryptography concept and show how it is formalized in \CryptHOL{}. Simultaneously, we explain
the Isabelle/HOL and functional programming topics that are essential for formalizing game-based proofs. 
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Getting started›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
\CryptHOL{} is available as part of the Archive of Formal Proofs~\cite{Lochbihler2017a}.
Cryptography formalizations based on \CryptHOL{} are arranged in Isabelle theory files that import the relevant libraries.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Getting started›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
\CryptHOL{} is available as part of the Archive of Formal Proofs~\cite{Lochbihler2017a}.
Cryptography formalizations based on \CryptHOL{} are arranged in Isabelle theory files that import the relevant libraries.
›</span></span>

<span class="keyword1"><span class="command">theory</span></span> CryptHOL_Tutorial <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../CryptHOL/CryptHOL.html">CryptHOL.CryptHOL</a>
<span class="comment1">(*&lt;*)</span><span class="quoted">"<a href="../../HOL/HOL-Library/LaTeXsugar.html">HOL-Library.LaTeXsugar</a>"</span><span class="comment1">(*&gt;*)</span>

<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">unbundle</span></span> <span class="main">%</span>invisible lifting_syntax
<span class="keyword1"><span class="command">no_adhoc_overloading</span></span> <span class="main">%</span>invisible Monad_Syntax.bind <span class="quoted">bind_pmf</span>
<span class="keyword1"><span class="command">declare</span></span> <span class="main">%</span>invisible <span class="main">[</span><span class="main">[</span><span class="operator">names_short</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The file <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> <a href="../CryptHOL/CryptHOL.html"></a><a href="../CryptHOL/CryptHOL.html">CryptHOL.CryptHOL</a><span class="antiquote"><span class="antiquote">}</span></span></span></span> is the canonical entry point into \CryptHOL{}.
For the hashed Elgamal example in this tutorial, the \CryptHOL{} library contains everything that is needed.
Additional Isabelle libraries can be imported if necessary.
›</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Modelling cryptography using \CryptHOL{}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
This section demonstrates how the following cryptographic concepts are modelled in \CryptHOL{}.
\begin{itemize}
\item A security property without oracles (\S\ref{section:lcdh})
\item An oracle (\S\ref{section:random-oracle})
\item A cryptographic concept (\S\ref{section:pk-enc})
\item A security property with an oracle (\S\ref{section:ind-cpa})
\item A concrete cryptographic scheme (\S\ref{section:hashed-elgamal-scheme})
\end{itemize}
›</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Security notions without oracles: the CDH assumption \label{section:lcdh}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
In game-based cryptography, a security property is specified using a game between a benign challenger and an adversary.
The probability of an adversary to win the game against the challenger is called its advantage.
A cryptographic construction satisfies a security property if the advantage for any ``feasible'' adversary is ``negligible''.
A typical security proof reduces the security of a construction to the assumed security of its building blocks.
In a concrete security proof, where the security parameter is implicit, it is therefore not necessary to formally define ``feasibility'' and ''negligibility'', 
as the security statement establishes a concrete relation between the advantages of specific adversaries.%
\footnote{%
  The cryptographic literature sometimes abstracts over the adversary and 
  defines the advantage to be the advantage of the best "feasible" adversary against a game.
  Such abstraction would require a formalization of feasibility, for which \CryptHOL{} currently does not offer any support.
  We therefore always consider the advantage of a specific adversary.
}
We return to asymptotic security statements in \S\ref{section:asymptotic}.

A formalization of a security property must therefore specify all of the following:
\begin{itemize}
\item The operations of the scheme (e.g., an algebraic group, an encryption scheme)
\item The type of adversary
\item The game with the challenger
\item The advantage of the adversary as a function of the winning probability
\end{itemize}

For hashed Elgamal, the cyclic group must satisfy the computational Diffie-Hellman assumption.
To keep the proof simple, we formalize the equivalent list version of CDH.

\begin{definition}[The list computational Diffie-Hellman game]
Let <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>𝒢›</span></span></span></span> be a group of order <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>q›</span></span></span></span> with generator <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span><span class="hidden">❙</span><b>g</b>›</span></span></span></span>.
The List Computational Diffie-Hellman (LCDH)
assumption holds for <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>𝒢›</span></span></span></span> if any ``feasible'' adversary has ``negligible'' probability in winning 
the following \textbf{LCDH game} against a challenger:
  \begin{enumerate}
  \item The challenger picks <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>y›</span></span></span></span> randomly (and independently) from
    $\{0, \dots, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>q›</span></span></span></span> - 1\}$.
  \item It passes $<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span><span class="hidden">❙</span><b>g</b>›</span></span></span></span>^x$ and $<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span><span class="hidden">❙</span><b>g</b>›</span></span></span></span>^y$ to the adversary.
    The adversary generates a set <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>L›</span></span></span></span> of guesses about the value of $<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span><span class="hidden">❙</span><b>g</b>›</span></span></span></span>^{<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x›</span></span></span></span><span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>y›</span></span></span></span>}$.
  \item The adversary wins the game if $<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span><span class="hidden">❙</span><b>g</b>›</span></span></span></span>^{<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x›</span></span></span></span><span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>y›</span></span></span></span>} \in <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>L›</span></span></span></span>$.
  \end{enumerate}
\end{definition}

The scheme for LCDH uses only a cyclic group.
To make the LCDH formalisation reusable, we formalize the LCDH game for an arbitrary cyclic group <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">𝒢</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> using Isabelle's module system based on locales.
The locale <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>list_cdh›</span></span></span></span> fixes <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">𝒢</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to be a finite cyclic group that has elements of type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'grp</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and comes with a generator <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1"><span class="hidden">❙</span><b>g</b></span></span><span class="hidden">⇘</span><sub><span class="free"><span class="free">𝒢</span></span></sub><span class="hidden">⇙</span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
Basic facts about finite groups are formalized in the \CryptHOL{} theory <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> <a href="../CryptHOL/Cyclic_Group.html"></a><a href="../CryptHOL/Cyclic_Group.html">CryptHOL.Cyclic_Group</a><span class="antiquote"><span class="antiquote">}</span></span></span></span>.%
\footnote{%
  The syntax directive <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory_text</span></span> <span class="raw_text"><span class="raw_text">"<span class="keyword2"><span class="keyword"><span class="keyword2"><span class="keyword">structure</span></span></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> tells Isabelle that all group operations in the context of the locale refer to the group <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">𝒢</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> unless stated otherwise.
  For example, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1"><span class="hidden">❙</span><b>g</b></span></span><span class="hidden">⇘</span><sub><span class="free"><span class="free">𝒢</span></span></sub><span class="hidden">⇙</span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> can be written as <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span><span class="hidden">❙</span><b>g</b>›</span></span></span></span> inside the locale.

  Isabelle automatically adds the locale parameters and the assumptions on them to all definitions and lemmas inside that locale.
  Of course, we could have made the group <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">𝒢</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> an explicit argument of all functions ourselves, 
  but then we would not benefit from Isabelle's module system, in particular locale instantiation.
}
›</span></span>

<span class="keyword1"><span class="command">locale</span></span> list_cdh <span class="main">=</span> cyclic_group <span class="quoted"><span class="free">𝒢</span></span> 
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">𝒢</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> cyclic_group"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="main">)</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The LCDH game does not need oracles.
The adversary is therefore just a probabilistic function from two group elements to a set of guesses, which are again group elements.
In \CryptHOL{}, the probabilistic nature is expressed by the adversary returning a discrete subprobability distribution over sets of guesses, as expressed by the type constructor <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>spmf›</span></span></span></span>.
(Subprobability distributions are like probability distributions except that the whole probability mass may be less than 1, i.e., some probability may be ``lost''.
A subprobability distribution is called lossless, written <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">lossless_spmf</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, if its probability mass is 1.)
We define the following abbreviation as a shorthand for the type of LCDH adversaries.%
\footnote{%
  Actually, the type of group elements has already been fixed in the locale <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">locale</span></span> list_cdh<span class="antiquote"><span class="antiquote">}</span></span></span></span> to the type variable <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'grp</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  Unfortunately, such fixed type variables cannot be used in type declarations inside a locale in Isabelle2018.
  The <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> type_synonym<span class="antiquote"><span class="antiquote">}</span></span></span></span> <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>adversary›</span></span></span></span> is therefore parametrized by a different type variable <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="tfree"><span class="quoted"><span class="tfree">'grp'</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, but it will be used below only with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="tfree"><span class="quoted"><span class="tfree">'grp</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
}
›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'grp'</span> adversary <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp'</span> <span class="main">⇒</span> <span class="tfree">'grp'</span> <span class="main">⇒</span> <span class="tfree">'grp'</span> set spmf"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The LCDH game itself is expressed as a function from the adversary <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">𝒜</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to the subprobability distribution of the adversary winning.
\CryptHOL{} provides operators to express these distributions as probabilistic programs and reason about them using program logics:
\begin{itemize}
\item The <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>do›</span></span></span></span> notation desugars to monadic sequencing in the monad of subprobabilities~\cite{Wadler1989}.
  Intuitively, every line <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x ← p;›</span></span></span></span> samples an element <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">x</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> from the distribution <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">p</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  The sampling is independent, unless the distribution <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">p</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> depends on previously sampled variables.
  At the end of the block, the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"return_spmf DUMMY"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> returns whether the adversary has won the game.
\item <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"sample_uniform <span class="free"><span class="free">n</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> denotes the uniform distribution over the set <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>{0, ..., n - 1}›</span></span></span></span>.
\item <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"order <span class="free"><span class="free">𝒢</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> denotes the order of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">𝒢</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">"<span class="main"><span class="main">([^]</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">::</span></span> <span class="tfree"><span class="tfree">'grp</span></span> <span class="main"><span class="main">⇒</span></span> nat <span class="main"><span class="main">⇒</span></span> <span class="tfree"><span class="tfree">'grp</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is the group exponentiation operator.
\end{itemize}

The LCDH game formalizes the challenger's behavior against an adversary <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">𝒜</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. 
In the following definition, the challenger randomly (and independently) picks two natural numbers 
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">x</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">y</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> that are  between 0 and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">𝒢</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>'s order and passes them to the adversary.
The adversary then returns a set <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">zs</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> of guesses for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">g</span></span> <span class="main"><span class="main">^</span></span> <span class="main"><span class="main">(</span></span><span class="free"><span class="free">x</span></span> <span class="main"><span class="main">*</span></span> <span class="free"><span class="free">y</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, where <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">g</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is the 
generator of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">𝒢</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. The game finally returns a <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">bool</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>ean that indicates whether the 
adversary produced a right guess. Formally, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">game</span></span> <span class="free"><span class="free">𝒜</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is a <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">bool</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>ean random variable.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">game</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> adversary <span class="main">⇒</span> bool spmf"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">game</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span> 
    <span class="bound">x</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">y</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">zs</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">y</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="bound">x</span> <span class="main">*</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="bound">zs</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹

The advantage of the adversary is equivalent to its probability of winning the LCDH game.
The function <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">"spmf <span class="main"><span class="main">::</span></span> <span class="tfree"><span class="tfree">'a</span></span> spmf <span class="main"><span class="main">⇒</span></span> <span class="tfree"><span class="tfree">'a</span></span> <span class="main"><span class="main">⇒</span></span> real"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> returns the probability of an elementary event under a given subprobability distribution.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">advantage</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> adversary <span class="main">⇒</span> real"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">advantage</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> spmf <span class="main">(</span>game <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span><span class="main">)</span> True"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
This completes the formalisation of the LCDH game and we close the locale <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">locale</span></span> list_cdh<span class="antiquote"><span class="antiquote">}</span></span></span></span> with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> end<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
The above definitions are now accessible under the names <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"list_cdh.game"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"list_cdh.advantage"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
Furthermore, when we later instantiate the locale <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">locale</span></span> list_cdh<span class="antiquote"><span class="antiquote">}</span></span></span></span>, they will be specialized to the given pararameters.
We will return to this topic in \S\ref{section:hashed-elgamal-scheme}.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹A Random Oracle \label{section:random-oracle}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
A cryptographic oracle grants an adversary black-box access to a certain information or functionality.
In this section, we formalize a random oracle, i.e., an oracle that models a random function with a finite codomain.
In the Elgamal security proof, the random oracle represents the hash function:
the adversary can query the oracle for a value and the oracle responds with the corresponding ``hash''.

Like for the LCDH formalization, we wrap the random oracle in the locale <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>random_oracle›</span></span></span></span> for modularity.
The random oracle will return a <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>bitstring›</span></span></span></span>, i.e. a list of booleans, of length <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>len›</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> bitstring <span class="main">=</span> <span class="quoted"><span class="quoted">"bool list"</span></span>

<span class="keyword1"><span class="command">locale</span></span> random_oracle <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">len</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat"</span></span> 
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
In \CryptHOL{}, oracles are modeled as probabilistic transition systems that given an initial state
and an input, return a subprobability distribution over the output and the successor state.
The type synonym <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> [source] <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'s</span></span><span class="main"><span class="main">,</span></span> <span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">,</span></span> <span class="tfree"><span class="tfree">'b</span></span><span class="main"><span class="main">)</span></span> oracle'"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> abbreviates <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'s</span></span> <span class="main"><span class="main">⇒</span></span> <span class="tfree"><span class="tfree">'a</span></span> <span class="main"><span class="main">⇒</span></span> <span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'b</span></span> <span class="main"><span class="main">×</span></span> <span class="tfree"><span class="tfree">'s</span></span><span class="main"><span class="main">)</span></span> spmf"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.


A random oracle accepts queries of type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and generates a random bitstring of length <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">len</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
The state of the random oracle remembers its previous responses in a mapping of type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> [source] <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> <span class="main"><span class="main">⇀</span></span> bitstring"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
Upon a query <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">x</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, the oracle first checks whether this query was received before.
If so, the oracle returns the same answer again.
Otherwise, the oracle randomly samples a bitstring of length <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">len</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, stores it 
in its state, and returns it alongside with the new state.
›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'a</span> state <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇀</span> bitstring"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted">"<span class="entity">oracle</span>"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> state <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span>bitstring <span class="main">×</span> <span class="tfree">'a</span> state<span class="main">)</span> spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">oracle</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">of</span> 
    None <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">bs</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len</span><span class="main">)</span><span class="main">;</span>
      return_spmf <span class="main">(</span><span class="bound">bs</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">↦</span> <span class="bound">bs</span><span class="main">)</span><span class="main">)</span> <span class="main">}</span> 
  <span class="main">|</span> Some <span class="bound">bs</span> <span class="main">⇒</span> return_spmf <span class="main">(</span><span class="bound">bs</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Initially, the state of a random oracle is the empty map <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Map.empty</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, as no queries have been asked.
For readability, we introduce an abbreviation:›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">initial</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> state"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">initial</span> <span class="main">≡</span> Map.empty"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
This actually completes the formalization of the random oracle.
Before we close the locale, we prove two technical lemmas:
\begin{enumerate}
\item The lemma <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>lossless_oracle›</span></span></span></span> states that the distribution over answers and successor states is \emph{lossless}, i.e., a full probability distribution.
  Many reasoning steps in game-based proofs are only valid for lossless distributions, so it is generally recommended to prove losslessness of all definitions if possible.
\item The lemma <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>fresh›</span></span></span></span> describes random oracle's behavior when the query is fresh.
  This lemma makes it possible to automatically unfold the random oracle only when it is known that the query is fresh.
\end{enumerate}
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_oracle <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>oracle <span class="free">σ</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> fresh<span class="main">:</span>
  <span class="quoted"><span class="quoted">"oracle <span class="free">σ</span> <span class="free">x</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span> <span class="bound">bs</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len</span><span class="main">)</span><span class="main">;</span>
      return_spmf <span class="main">(</span><span class="bound">bs</span><span class="main">,</span> <span class="free">σ</span><span class="main">(</span><span class="free">x</span> <span class="main">↦</span> <span class="bound">bs</span><span class="main">)</span><span class="main">)</span> <span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">σ</span> <span class="free">x</span> <span class="main">=</span> None"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
\paragraph{Remark: Independence is the default.}
Note that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">_</span></span> spmf"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> represents a discrete probability distribution rather than a random variable.
The difference is that every spmf is independent of all other spmfs.
There is no implicit space of elementary events via which information may be passed from one random variable to the other.
If such information passing is necessary, this must be made explicit in the program.
That is why the random oracle explicitly takes a state of previous responses and returns the updated states.
Later, whenever the random oracle is used, the user must pass the state around as needed.
This also applies to adversaries that may want to store some information.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Cryptographic concepts: public-key encryption \label{section:pk-enc}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
A cryptographic concept consists of a set of operations and their functional behaviour.
We have already seen two simple examples:
the cyclic group in \S\ref{section:lcdh} and the random oracle in \S\ref{section:random-oracle}.
We have formalized both of them as locales; we have not modelled their functional behavior as this is not needed for the proof.
In this section, we now present a more realistic example: public-key encryption with oracle access.

A public-key encryption scheme consists of three algorithms: key generation, encryption, and decryption.
They are all probabilistic and, in the most general case, they may access an oracle jointly with the adversary, e.g., a random oracle modelling a hash function.
As before, the operations are modelled as parameters of a locale, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>ind_cpa_pk›</span></span></span></span>.

\begin{itemize}
\item The key generation algorithm <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>key_gen›</span></span></span></span> outputs a public-private key pair.
\item The encryption operation <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>encrypt›</span></span></span></span> takes a public key and a plaintext of type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'plain</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and outputs a ciphertext of type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="tfree"><span class="quoted"><span class="tfree">'cipher</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
\item The decryption operation <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>decrypt›</span></span></span></span> takes a private key and a ciphertext and outputs a plaintext.
\item Additionally, the predicate <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>valid_plains›</span></span></span></span> tests whether the adversary has chosen a valid pair of plaintexts.
  This operation is needed only in the IND-CPA game definition in the next section, but we include it already here for convenience.
\end{itemize}
›</span></span>

<span class="keyword1"><span class="command">locale</span></span> ind_cpa_pk <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">key_gen</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'pubkey</span> <span class="main">×</span> <span class="tfree">'privkey</span><span class="main">,</span> <span class="tfree">'query</span><span class="main">,</span> <span class="tfree">'response</span><span class="main">)</span> gpv"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">encrypt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pubkey</span> <span class="main">⇒</span> <span class="tfree">'plain</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'cipher</span><span class="main">,</span> <span class="tfree">'query</span><span class="main">,</span> <span class="tfree">'response</span><span class="main">)</span> gpv"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">decrypt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'privkey</span> <span class="main">⇒</span> <span class="tfree">'cipher</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'query</span><span class="main">,</span> <span class="tfree">'response</span><span class="main">)</span> gpv"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">valid_plains</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'plain</span> <span class="main">⇒</span> <span class="tfree">'plain</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The three actual operations are generative probabilistic values (GPV) of type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> [source] <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="main"><span class="main">_</span></span><span class="main"><span class="main">,</span></span> <span class="tfree"><span class="tfree">'query</span></span><span class="main"><span class="main">,</span></span> <span class="tfree"><span class="tfree">'response</span></span><span class="main"><span class="main">)</span></span> gpv"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
A GPV is a probabilistic algorithm that has not yet been connected to its oracles; see the theoretical paper <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> Basin2017<span class="antiquote"><span class="antiquote">}</span></span></span></span> for details.
The interface to the oracle is abstracted in the two type parameters <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="tfree"><span class="quoted"><span class="tfree">'query</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> for queries and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="tfree"><span class="quoted"><span class="tfree">'response</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> for responses.
As before, we omit the specification of the functional behavior, namely that decrypting an encryption with a key pair returns the plaintext.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Security notions with oracles: IND-CPA security \label{section:ind-cpa}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
In general, there are several security notions for the same cryptographic concept.
For encryption schemes, an indistinguishability notion of security~\cite{Goldwasser1982} is often used.
We now formalize the notion indistinguishability under chosen plaintext attacks (IND-CPA) for public-key encryption schemes.
Goldwasser et al.~\cite{Goldwasser1984} showed that IND-CPA is equivalent to semantic security.

\begin{definition}[IND-CPA <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> Shoup2004IACR<span class="antiquote"><span class="antiquote">}</span></span></span></span>]
Let <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">key_gen</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">encrypt</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">decrypt</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> denote a public-key encryption scheme.
The IND-CPA game is a two-stage game between the \emph{adversary} and a \emph{challenger}:
\begin{description}
\item[Stage 1 (find):]
  \strut
  \begin{enumerate}
  \item The challenger generates a public key <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">pk</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> using <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">key_gen</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and gives the public key to the adversary.
  \item The adversary returns two messages <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">m<span class="hidden">⇩</span><sub>0</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">m<span class="hidden">⇩</span><sub>1</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  \item The challenger checks that the two messages are a valid pair of plaintexts.
    (For example, both messages must have the same length.)
  \end{enumerate}
\item[Stage 2 (guess):]
  \strut
  \begin{enumerate}
  \item The challenger flips a coin <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">b</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> (either 0 or 1) and gives <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">encrypt</span></span> <span class="free"><span class="free">pk</span></span> <span class="free"><span class="free">m<span class="hidden">⇩</span><sub>b</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to the adversary.
  \item The adversary returns a bit <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">b'</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  \end{enumerate}
\end{description}
The adversary wins the game if his guess <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">b'</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is the value of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">b</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
Let <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">P<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>n</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> denote the winning probability.
His advantage is <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">¦</span></span><span class="free"><span class="free">P<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>n</sub></span></span> <span class="main"><span class="main">-</span></span> <span class="main"><span class="main">1</span></span><span class="main"><span class="main">/</span></span><span class="numeral"><span class="numeral">2</span></span><span class="main"><span class="main">¦</span></span> <span class="main"><span class="main">::</span></span> real"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
\end{definition}

Like with the encryption scheme, we will define the game such that the challenger and the adversary have access to a shared oracle, but the oracle is still unspecified.
Consequently, the corresponding \CryptHOL{} game is a GPV, like the operations of the abstract encryption scheme.
When we specialize the definitions in the next section to the hashed Elgamal scheme, the GPV will be connected to the random oracle.

The type of adversary is now more complicated: It is a pair of probabilistic functions with oracle access, one for each stage of the game.
The first computes the pair of plaintext messages and the second guesses the challenge bit.
The additional <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="tfree"><span class="quoted"><span class="tfree">'state</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> parameter allows the adversary to maintain state between the two stages.
›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'pubkey'</span><span class="main">,</span> <span class="tfree">'plain'</span><span class="main">,</span> <span class="tfree">'cipher'</span><span class="main">,</span> <span class="tfree">'query'</span><span class="main">,</span> <span class="tfree">'response'</span><span class="main">,</span> <span class="tfree">'state</span><span class="main">)</span> adversary <span class="main">=</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'pubkey'</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'plain'</span> <span class="main">×</span> <span class="tfree">'plain'</span><span class="main">)</span> <span class="main">×</span> <span class="tfree">'state</span><span class="main">,</span> <span class="tfree">'query'</span><span class="main">,</span> <span class="tfree">'response'</span><span class="main">)</span> gpv<span class="main">)</span>
   <span class="main">×</span> <span class="main">(</span><span class="tfree">'cipher'</span> <span class="main">⇒</span> <span class="tfree">'state</span> <span class="main">⇒</span> <span class="main">(</span>bool<span class="main">,</span> <span class="tfree">'query'</span><span class="main">,</span> <span class="tfree">'response'</span><span class="main">)</span> gpv<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The IND-CPA game formalization below follows the above informal definition.
There are three points that need some explanation.
First, this game differs from the simpler LCDH game in that it works with GPVs instead of SPMFs.
Therefore, probability distributions like coin flips <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">coin_spmf</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> must be lifted from SPMFs to GPVs using the coercion <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">lift_spmf</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
Second, the assertion <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"assert_gpv <span class="main"><span class="main">(</span></span><span class="free"><span class="free">valid_plains</span></span> <span class="free"><span class="free">m<span class="hidden">⇩</span><sub>0</sub></span></span> <span class="free"><span class="free">m<span class="hidden">⇩</span><sub>1</sub></span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> ensures that the pair of messages is valid.
Third, the construct <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">TRY</span></span> DUMMY <span class="keyword1"><span class="keyword1">ELSE</span></span> DUMMY <span class="main"><span class="main">::</span></span> <span class="main"><span class="main">(</span></span><span class="main"><span class="main">_</span></span><span class="main"><span class="main">,</span></span> <span class="main"><span class="main">_</span></span><span class="main"><span class="main">,</span></span> <span class="main"><span class="main">_</span></span><span class="main"><span class="main">)</span></span> gpv"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> catches a violated assertion.
In that case, the adversary's advantage drops to 0 because the result of the game is a coin flip, as we are in the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>ELSE›</span></span></span></span> branch.
›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">game</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'pubkey</span><span class="main">,</span> <span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">,</span> <span class="tfree">'query</span><span class="main">,</span> <span class="tfree">'response</span><span class="main">,</span> <span class="tfree">'state</span><span class="main">)</span> adversary
  <span class="main">⇒</span> <span class="main">(</span>bool<span class="main">,</span> <span class="tfree">'query</span><span class="main">,</span> <span class="tfree">'response</span><span class="main">)</span> gpv"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">game</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">𝒜<span class="hidden">⇩</span><sub>1</sub></span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">𝒜<span class="hidden">⇩</span><sub>2</sub></span></span></span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">pk</span><span class="main">,</span> <span class="bound">sk</span><span class="main">)</span> <span class="main">←</span> <span class="free">key_gen</span><span class="main">;</span>
    <span class="main">(</span><span class="main">(</span><span class="bound">m<span class="hidden">⇩</span><sub>0</sub></span><span class="main">,</span> <span class="bound">m<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">𝒜<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="bound">pk</span><span class="main">;</span>
    assert_gpv <span class="main">(</span><span class="free">valid_plains</span> <span class="bound">m<span class="hidden">⇩</span><sub>0</sub></span> <span class="bound">m<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span><span class="main">;</span>
    <span class="bound">b</span> <span class="main">←</span> lift_spmf coin_spmf<span class="main">;</span>
    <span class="bound">cipher</span> <span class="main">←</span> <span class="free">encrypt</span> <span class="bound">pk</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">m<span class="hidden">⇩</span><sub>0</sub></span> <span class="keyword1">else</span> <span class="bound">m<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span><span class="main">;</span>
    <span class="bound">b'</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">𝒜<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">;</span> 
    Done <span class="main">(</span><span class="bound">b'</span> <span class="main">=</span> <span class="bound">b</span><span class="main">)</span>
  <span class="main">}</span> <span class="keyword1">ELSE</span> lift_spmf coin_spmf"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
\input{fig-1}

Figure~\ref{fig:1} visualizes this game as a grey box.
The dashed boxes represent parameters of the game or the locale, i.e., parts that have not yet been instantiated.
The actual probabilistic program is shown on the left half, which uses the dashed boxes as sub-programs.
Arrows in the grey box from the left to the right pass the contents of the variables to the sub-program.
Those in the other direction bind the result of the sub-program to new variables.
The arrows leaving box indicate the query-response interaction with an oracle.
The thick arrows emphasize that the adversary's state is passed around explicitly.
The double arrow represents the return value of the game.
We will use this to define the adversary's advantage.

As the oracle is not specified in the game, the advantage, too, is parametrized by the oracle,
given by the transition function <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">"<span class="free"><span class="free">oracle</span></span> <span class="main"><span class="main">::</span></span> <span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'s</span></span><span class="main"><span class="main">,</span></span> <span class="tfree"><span class="tfree">'query</span></span><span class="main"><span class="main">,</span></span> <span class="tfree"><span class="tfree">'response</span></span><span class="main"><span class="main">)</span></span> oracle'"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
and the initial state <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">"<span class="free"><span class="free">σ</span></span> <span class="main"><span class="main">::</span></span> <span class="tfree"><span class="tfree">'s</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> its initial state.
The operator <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"run_gpv"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> connects the game with the oracle, whereby the GPV becomes an SPMF.
›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">advantage</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'σ</span><span class="main">,</span> <span class="tfree">'query</span><span class="main">,</span> <span class="tfree">'response</span><span class="main">)</span> oracle' <span class="main">×</span> <span class="tfree">'σ</span>
  <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'pubkey</span><span class="main">,</span> <span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">,</span> <span class="tfree">'query</span><span class="main">,</span> <span class="tfree">'response</span><span class="main">,</span> <span class="tfree">'state</span><span class="main">)</span> adversary <span class="main">⇒</span> real"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">advantage</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">oracle</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> <span class="main">¦</span>spmf <span class="main">(</span>run_gpv <span class="free"><span class="bound"><span class="entity">oracle</span></span></span> <span class="main">(</span>game <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">)</span> True <span class="main">-</span> <span class="main">1</span><span class="main">/</span><span class="numeral">2</span><span class="main">¦</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Concrete cryptographic constructions: the hashed ElGamal encryption scheme \label{section:hashed-elgamal-scheme}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
With all the above modelling definitions in place,
we are now ready to explain how concrete cryptographic constructions are expressed in \CryptHOL.
In general, a cryptographic construction builds a cryptographic concept from possibly several simpler cryptographic concepts.
In the running example, the hashed ElGamal cipher~\cite{Elgamal1985} constructs a public-key encryption scheme from a finite cyclic group and a hash function.
Accordingly, the formalisation consists of three steps:

\begin{enumerate}
\item Import the cryptographic concepts on which the construction builds.
\item Define the concrete construction.
\item Instantiate the abstract concepts with the construction.
\end{enumerate}

First, we declare a new locale that imports the two building blocks: 
the cyclic group from the LCDH game with namespace <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>lcdh›</span></span></span></span> and the random oracle for the hash function with namespace <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>ro›</span></span></span></span>.
This ensures that the construction can be used for arbitrary cyclic groups. 
For the message space, it suffices to fix the length <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>len_plain›</span></span></span></span> of the plaintexts.
›</span></span>

<span class="keyword1"><span class="command">locale</span></span> hashed_elgamal <span class="main">=</span>
  lcdh<span class="main">:</span> list_cdh <span class="quoted"><span class="free">𝒢</span></span> <span class="main">+</span> 
  ro<span class="main">:</span> random_oracle <span class="quoted"><span class="free">len_plain</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">𝒢</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> cyclic_group"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">len_plain</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Second, we formalize the hashed ElGamal encryption scheme.
Here is the well-known informal definition.

\begin{definition}[Hashed Elgamal encryption scheme]
Let $G$ be a cyclic group of order $q$ that has a generator $g$. Furthermore, let $h$ be a hash
function that maps the elements of $G$ to bitstrings, and $\oplus$ be the xor operator on
bitstrings. The Hashed-ElGamal encryption scheme is given by the following algorithms:
\begin{description}
\item[Key generation]
  Pick an element $x$ randomly from the set $\{0, \dots, q-1\}$
  and output the pair $(g^x, x)$, where $g^x$ is the public key and $x$ is the private key.
\item[Encryption]
  Given the public key $pk$ and the message $m$,
  pick $y$ randomly from the set $\{0, \dots, q-1\}$
  and output the pair $(g^y, h(pk^y) \oplus m)$.
  Here $\oplus$ denotes the bitwise exclusive-or of two bitstrings.
\item[Decryption]
  Given the private key $sk$ and the ciphertext $(\alpha, \beta)$,
  output $h(\alpha^{sk}) \oplus \beta$.
\end{description}
\end{definition}

As we can see, the public key is a group element, the private key a natural number, a plaintext a bitstring, and a ciphertext a pair of a group element and a bitstring.%
\footnote{%
  More precisely, the private key ranges between 0 and $q - 1$ and the bitstrings are of length <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>len_plain›</span></span></span></span>.
  However, Isabelle/HOL's type system cannot express such properties that depend on locale parameters.
}
For readability, we introduce meaningful abbreviations for these concepts.
›</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'grp'</span> pub_key <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp'</span>"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'grp'</span> priv_key <span class="main">=</span> <span class="quoted">nat</span>
<span class="keyword1"><span class="command">type_synonym</span></span> plain <span class="main">=</span> <span class="quoted">bitstring</span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'grp'</span> cipher <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp'</span> <span class="main">×</span> bitstring"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
We next translate the three algorithms into \CryptHOL{} definitions.
The definitions are straightforward except for the hashing.
Since we analyze the security in the random oracle model, 
an application of the hash function $H$ is modelled as a query to the random oracle using the GPV <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">hash</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
Here, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"Pause <span class="free"><span class="free">x</span></span> Done"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> calls the oracle with query <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">x</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and returns the oracle's response.
Furthermore, we define the plaintext validity predicate to check the length of the adversary's messages produced by the adversary.
›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">hash</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> <span class="main">⇒</span> <span class="main">(</span>bitstring<span class="main">,</span> <span class="tfree">'grp</span><span class="main">,</span> bitstring<span class="main">)</span> gpv"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">hash</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> Pause <span class="free"><span class="bound"><span class="entity">x</span></span></span> Done"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">key_gen</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'grp</span> pub_key <span class="main">×</span> <span class="tfree">'grp</span> priv_key<span class="main">)</span> spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">key_gen</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">x</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">x</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">encrypt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> pub_key <span class="main">⇒</span> plain <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'grp</span> cipher<span class="main">,</span> <span class="tfree">'grp</span><span class="main">,</span> bitstring<span class="main">)</span> gpv"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">encrypt</span> <span class="free"><span class="bound"><span class="entity">α</span></span></span> <span class="free"><span class="bound"><span class="entity">msg</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">y</span> <span class="main">←</span> lift_spmf <span class="main">(</span>sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">h</span> <span class="main">←</span> hash <span class="main">(</span><span class="free"><span class="bound"><span class="entity">α</span></span></span> <span class="main">[^]</span> <span class="bound">y</span><span class="main">)</span><span class="main">;</span>
    Done <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">y</span><span class="main">,</span> <span class="bound">h</span> <span class="main">[⊕]</span> <span class="free"><span class="bound"><span class="entity">msg</span></span></span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">decrypt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> priv_key <span class="main">⇒</span> <span class="tfree">'grp</span> cipher <span class="main">⇒</span> <span class="main">(</span>plain<span class="main">,</span> <span class="tfree">'grp</span><span class="main">,</span> bitstring<span class="main">)</span> gpv"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">decrypt</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">β</span><span class="main">,</span> <span class="bound">ζ</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">h</span> <span class="main">←</span> hash <span class="main">(</span><span class="bound">β</span> <span class="main">[^]</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">;</span>
    Done <span class="main">(</span><span class="bound">ζ</span> <span class="main">[⊕]</span> <span class="bound">h</span><span class="main">)</span>
  <span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">valid_plains</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"plain <span class="main">⇒</span> plain <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">valid_plains</span> <span class="free"><span class="bound"><span class="entity">msg1</span></span></span> <span class="free"><span class="bound"><span class="entity">msg2</span></span></span> <span class="main">⟷</span> length <span class="free"><span class="bound"><span class="entity">msg1</span></span></span> <span class="main">=</span> <span class="free">len_plain</span> <span class="main">∧</span> length <span class="free"><span class="bound"><span class="entity">msg2</span></span></span> <span class="main">=</span> <span class="free">len_plain</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
The third and last step instantiates the interface of the encryption scheme with the hashed Elgamal scheme.
This specializes all definition and theorems in the locale <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">locale</span></span> ind_cpa_pk<span class="antiquote"><span class="antiquote">}</span></span></span></span> to our scheme.
›</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> ind_cpa<span class="main">:</span> ind_cpa_pk <span class="quoted"><span class="quoted">"<span class="main">(</span>lift_spmf key_gen<span class="main">)</span>"</span></span> <span class="quoted">encrypt</span> <span class="quoted">decrypt</span> <span class="quoted">valid_plains</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Figure~\ref{fig:2} illustrates the instantiation.
In comparison to Fig.~\ref{fig:1}, the boxes for the key generation and the encryption algorithm have been instantiated with the hashed Elgamal definitions from this section.
We nevertheless draw the boxes to indicate that the definitions of these algorithms has not yet been inlined in the game definition.
The thick grey border around the key generation algorithm denotes the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">lift_spmf</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> operator, which embeds the probabilistic <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">key_gen</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> without oracle access into the type of GPVs with oracle access.
The oracle has also been instantiated with the random oracle <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">ro.oracle</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> imported from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">locale</span></span> "hashed_elgamal"<span class="antiquote"><span class="antiquote">}</span></span></span></span>'s parent locale <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">locale</span></span> random_oracle<span class="antiquote"><span class="antiquote">}</span></span></span></span> with prefix <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>ro›</span></span></span></span>.

\input{fig-2}
›</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Cryptographic proofs in \CryptHOL{}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
This section explains how cryptographic proofs are expressed in \CryptHOL{}.
We will continue our running example by stating and proving the IND-CPA security of the hashed Elgamal encryption scheme
under the computational Diffie-Hellman assumption in the random oracle model, using the definitions from the previous section.
More precisely, we will formalize a reduction argument (\S\ref{section:reduction}) and bound the IND-CPA advantage using the CDH advantage.
We will \emph{not} formally state the result that CDH hardness in the cyclic group implies IND-CPA security, 
which quantifies over all feasible adversaries--%
to that end, we would have to formally define feasibility, for which \CryptHOL{} currently does not offer any support.

The actual proof of the bound consists of several game transformations.
We will focus on those steps that illustrate common steps in cryptographic proofs (\S\ref{section:ghop-first}--\S\ref{section:combining:hops}) .
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹The reduction \label{section:reduction}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The security proof involves a reduction argument:
We will derive a bound on the advantage of an arbitrary adversary in the IND-CPA game <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"ind_cpa.game"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> for hashed Elgamal
that depends on another adversary's advantage in the LCDH game <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"lcdh.game"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> of the underlying group.
The reduction transforms every IND-CPA adversary <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">𝒜</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> into a LCDH adversary <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">elgamal_reduction</span></span> <span class="free"><span class="free">𝒜</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
using <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">𝒜</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> as a black box.
In more detail, it simulates an execution of the IND-CPA game including the random oracle.
At the end of the game, the reduction outputs the set of queries that the adversary has sent to the random oracle.
The reduction works as follows given a two part IND-CPA adversary <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">𝒜</span></span> <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">(</span></span><span class="free"><span class="free">𝒜<span class="hidden">⇩</span><sub>1</sub></span></span><span class="main"><span class="main">,</span></span> <span class="free"><span class="free">𝒜<span class="hidden">⇩</span><sub>2</sub></span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
(Figure~\ref{fig:3} visualizes the reduction as the dotted box):
\begin{enumerate}
\item It receives two group elements <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">α</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">β</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> from the LCDH challenger.
\item The reduction passes <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">α</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to the adversary as the public key and runs <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">𝒜<span class="hidden">⇩</span><sub>1</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to get messages <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">m<span class="hidden">⇩</span><sub>1</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">m<span class="hidden">⇩</span><sub>2</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  The adversary is given access to the random oracle with the initial state <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">ro.initial</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
\item The assertion checks that the adversary returns two valid plaintexts, i.e., <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">m<span class="hidden">⇩</span><sub>1</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">m<span class="hidden">⇩</span><sub>2</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> are strings of length <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">len_plain</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
\item Instead of actually performing an encryption, the reduction generates a random bitstring <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">h</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> of length <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">len_plain</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> 
(<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"nlists UNIV <span class="free"><span class="free">len_plain</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> denotes the set of all bitstrings of length <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">len_plain</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">spmf_of_set</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> converts the set into a uniform distribution over the set.)
\item The reduction passes <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="free"><span class="free">β</span></span><span class="main"><span class="main">,</span></span> <span class="free"><span class="free">h</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> as the challenge ciphertext to the adversary in the second phase of the IND-CPA game.
\item The actual guess <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">b'</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> of the adversary is ignored; 
  instead the reduction returns the set <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"dom <span class="free"><span class="free">s'</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> of all queries that the adversary made to the random oracle as its guess for the CDH game.
\item If any of the steps after the first phase fails, the reduction's guess is the set <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"dom <span class="free"><span class="free">s</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> of oracle queries made during the first phase.
\end{enumerate}

\input{fig-3}
›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">elgamal_reduction</span>
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'grp</span> pub_key<span class="main">,</span> plain<span class="main">,</span> <span class="tfree">'grp</span> cipher<span class="main">,</span> <span class="tfree">'grp</span><span class="main">,</span> bitstring<span class="main">,</span> <span class="tfree">'state</span><span class="main">)</span> ind_cpa.adversary
  <span class="main">⇒</span> <span class="tfree">'grp</span> lcdh.adversary"</span></span>                     
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">elgamal_reduction</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">𝒜<span class="hidden">⇩</span><sub>1</sub></span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">𝒜<span class="hidden">⇩</span><sub>2</sub></span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">α</span></span></span> <span class="free"><span class="bound"><span class="entity">β</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="bound">m<span class="hidden">⇩</span><sub>1</sub></span><span class="main">,</span> <span class="bound">m<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="main">←</span> exec_gpv ro.oracle <span class="main">(</span><span class="free"><span class="bound"><span class="entity">𝒜<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">α</span></span></span><span class="main">)</span> ro.initial<span class="main">;</span>
    <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span>valid_plains <span class="bound">m<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">m<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">;</span>
      <span class="bound">h</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len_plain</span><span class="main">)</span><span class="main">;</span>
      <span class="main">(</span><span class="bound">b'</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">←</span> exec_gpv ro.oracle <span class="main">(</span><span class="free"><span class="bound"><span class="entity">𝒜<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">β</span></span></span><span class="main">,</span> <span class="bound">h</span><span class="main">)</span> <span class="bound">σ</span><span class="main">)</span> <span class="bound">s</span><span class="main">;</span>
      return_spmf <span class="main">(</span>dom <span class="bound">s'</span><span class="main">)</span>
    <span class="main">}</span> <span class="keyword1">ELSE</span> return_spmf <span class="main">(</span>dom <span class="bound">s</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Concrete security statement \label{section:security:concrete}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
A concrete security statement in \CryptHOL{} has the form:
Subject to some side conditions for the adversary <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">𝒜</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, the advantage in one game is bounded
by a function of the transformed adversary's advantage in a different game.%
\footnote{%
  A security proof often involves several reductions.
  The bound then depends on several advantages, one for each reduction.
}
›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> concrete_security<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">side</span> <span class="free">conditions</span> <span class="free">for</span> <span class="free">𝒜</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">advantage<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">𝒜</span> <span class="main">≤</span> <span class="free">f</span> <span class="main">(</span><span class="free">advantage<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">(</span><span class="free">reduction</span> <span class="free">𝒜</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">oops</span></span> <span class="main">%</span>invisible
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
For the hashed Elgamal scheme, the theorem looks as follows, i.e., the function <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">f</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is the identity function.
›</span></span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="main">%</span>invisible <span class="comment1">― ‹These six lines allow us to show the concrete theorem statement before we define the side condition on 𝒜. They should not occur in a normal formalisation.›</span>
<span class="keyword1"><span class="command">context</span></span> <span class="main">%</span>invisible <span class="keyword2"><span class="keyword">begin</span></span> 
<span class="keyword1"><span class="command">local_setup</span></span> <span class="main">%</span>invisible <span class="quoted">‹Local_Theory.map_background_naming <span class="main">(</span>Name_Space.mandatory_path <span class="inner_quoted">"ind_cpa"</span><span class="main">)</span>›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">%</span>invisible <span class="entity">lossless</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">lossless</span> <span class="main">=</span> undefined"</span></span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="main">%</span>invisible
<span class="keyword1"><span class="command">context</span></span> <span class="main">%</span>invisible hashed_elgamal <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">theorem</span></span> concrete_security_elgamal<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> lossless<span class="main">:</span> <span class="quoted"><span class="quoted">"ind_cpa.lossless <span class="free">𝒜</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ind_cpa.advantage <span class="main">(</span>ro.oracle<span class="main">,</span> ro.initial<span class="main">)</span> <span class="free">𝒜</span> <span class="main">≤</span> lcdh.advantage <span class="main">(</span>elgamal_reduction <span class="free">𝒜</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">oops</span></span><span class="main">%</span>invisible <span class="comment1">― ‹This aborts the proof as we have not yet defined <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">ind_cpa.lossless</span><span class="antiquote">}</span></span> properly. We restate the theorem below properly.›</span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Such a statement captures the essence of a concrete security proof.
For if there was a feasible adversary <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">𝒜</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> with non-negligible advantage against the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">ind_cpa.game</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
then <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"elgamal_reduction <span class="free"><span class="free">𝒜</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> would be an adversary against the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">lcdh.game</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> with at least the same advantage.
This implies the existence of an adversary with non-negligible advantage against the cryptographic primitive that was assumed to be secure.
What we cannot state formally is that the transformed adversary <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"elgamal_reduction <span class="free"><span class="free">𝒜</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is feasible
as we have not formalized the notion of feasibility.
The readers of the formalization must convince themselves that the reduction preserves feasibility.

In the case of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">elgamal_reduction</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, this should be obvious from the definition (given the theorem's side condition)
as the reduction does nothing more than sampling and redirecting data.

Our proof for the concrete security theorem needs the side condition that the adversary is lossless.
Losslessness for adversaries is similar to losslessness for subprobability distributions.
It ensures that the adversary always terminates and returns an answer to the challenger.
For the IND-CPA game, we define losslessness as follows:
›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> ind_cpa_pk<span class="main">)</span> <span class="entity">lossless</span>
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'pubkey</span><span class="main">,</span> <span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'cipher</span><span class="main">,</span> <span class="tfree">'query</span><span class="main">,</span> <span class="tfree">'response</span><span class="main">,</span> <span class="tfree">'state</span><span class="main">)</span> adversary <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lossless</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">𝒜<span class="hidden">⇩</span><sub>1</sub></span><span class="main">,</span> <span class="bound">𝒜<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">pk</span><span class="main">.</span> lossless_gpv ℐ_full <span class="main">(</span><span class="bound">𝒜<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">pk</span><span class="main">)</span><span class="main">)</span> 
               <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">cipher</span> <span class="bound">σ</span><span class="main">.</span> lossless_gpv ℐ_full <span class="main">(</span><span class="bound">𝒜<span class="hidden">⇩</span><sub>2</sub></span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">theorem</span></span> <span class="main">%</span>invisible concrete_security_elgamal<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> lossless<span class="main">:</span> <span class="quoted"><span class="quoted">"ind_cpa.lossless <span class="free">𝒜</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> 
  <span class="quoted"><span class="quoted">"ind_cpa.advantage <span class="main">(</span>ro.oracle<span class="main">,</span> ro.initial<span class="main">)</span> <span class="free">𝒜</span> <span class="main">≤</span> lcdh.advantage <span class="main">(</span>elgamal_reduction <span class="free">𝒜</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="main">%</span>visible <span class="quoted"><span class="plain_text">‹
So now let's start with the proof.
›</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>visible <span class="operator">-</span>
  <span class="keyword1"><span class="command">text</span></span> <span class="main">%</span>invisible <span class="quoted"><span class="plain_text">‹
    For this proof, we configure Isabelle's simplifier such that the proofs become reasonably short.
    Initially, when writing the proof, we had added those lemmas manually to to invocation
    of the simplifier and then collected the useful rules in a polishing step.
  ›</span></span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">%</span>invisible <span class="main">[</span><span class="operator">cong</span> <span class="quasi_keyword">del</span><span class="main">]</span> <span class="main">=</span> if_weak_cong 
   <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">split</span> <span class="quasi_keyword">del</span><span class="main">]</span> <span class="main">=</span> if_split
   <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> map_lift_spmf gpv.map_id lossless_weight_spmfD map_spmf_bind_spmf bind_spmf_const lcdh.order_gt_0
   <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">if_distribs</span><span class="main">]</span> <span class="main">=</span> if_distrib<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> try_spmf <span class="bound">x</span> <span class="main">_</span>"</span></span><span class="main">]</span> if_distrib<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"weight_spmf"</span></span><span class="main">]</span> if_distrib<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">r</span><span class="main">.</span> scale_spmf <span class="bound">r</span> <span class="main">_</span>"</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">text</span></span> <span class="main">%</span>visible <span class="quoted"><span class="plain_text">‹
As a preparatory step, we split the adversary <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">𝒜</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> into its two phases <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">𝒜<span class="hidden">⇩</span><sub>1</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">𝒜<span class="hidden">⇩</span><sub>2</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
We could have made the two phases explicit in the theorem statement, but our form is easier to read and use.
We also immediately decompose the losslessness assumption on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">𝒜</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.%
\footnote{%
  Later in the proof, we will often prove losslessness of the definitions in the proof.
  We will not show them in this document, but they are in the Isabelle sources from which this document is generated.
}
›</span></span>
<span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">𝒜<span class="hidden">⇩</span><sub>1</sub></span></span> <span class="skolem"><span class="skolem">𝒜<span class="hidden">⇩</span><sub>2</sub></span></span> <span class="keyword2"><span class="keyword">where</span></span> 𝒜 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">𝒜</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">𝒜<span class="hidden">⇩</span><sub>1</sub></span><span class="main">,</span> <span class="skolem">𝒜<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">𝒜</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">from</span></span> lossless <span class="keyword1"><span class="command">have</span></span> lossless1 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">pk</span><span class="main">.</span> lossless_gpv ℐ_full <span class="main">(</span><span class="skolem">𝒜<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">pk</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> lossless2 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">σ</span> <span class="bound">cipher</span><span class="main">.</span> lossless_gpv ℐ_full <span class="main">(</span><span class="skolem">𝒜<span class="hidden">⇩</span><sub>2</sub></span> <span class="bound">σ</span> <span class="bound">cipher</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ind_cpa.lossless_def<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Recording adversary queries \label{section:ghop-first}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  As can be seen in Fig.~\ref{fig:2}, both the adversary and the encryption of the challenge ciphertext use the random oracle.
  The reduction, however, returns only the queries that the adversary makes to the oracle (in Fig.~\ref{fig:3}, $h$ is generated independently of the random oracle).
  To bridge this gap, we introduce an <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">interceptor</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> between the adversary and the oracle that records all adversary's queries.
›</span></span>
<span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">interceptor</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> set <span class="main">⇒</span> <span class="tfree">'grp</span> <span class="main">⇒</span> <span class="main">(</span>bitstring <span class="main">×</span> <span class="tfree">'grp</span> set<span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> gpv"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="skolem">interceptor</span> <span class="skolem">σ</span> <span class="skolem">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">h</span> <span class="main">←</span> hash <span class="skolem">x</span><span class="main">;</span>
    Done <span class="main">(</span><span class="bound">h</span><span class="main">,</span> insert <span class="skolem">x</span> <span class="skolem">σ</span><span class="main">)</span>
  <span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">σ</span> <span class="skolem">x</span>
<span class="keyword1"><span class="command">have</span></span> <span class="main">%</span>invisible <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_gpv ℐ_full <span class="main">(</span><span class="skolem">interceptor</span> <span class="skolem">σ</span> <span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">σ</span> <span class="skolem">x</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> interceptor_def<span class="main">)</span>
<span class="keyword1"><span class="command">have</span></span> <span class="main">%</span>invisible <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_gpv ℐ_full <span class="main">(</span>inline <span class="skolem">interceptor</span> <span class="main">(</span><span class="skolem">𝒜<span class="hidden">⇩</span><sub>1</sub></span> <span class="skolem">α</span><span class="main">)</span> <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">α</span> <span class="skolem">s</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lossless_inline<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> ℐ<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">ℐ_full</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">have</span></span> <span class="main">%</span>invisible <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_gpv ℐ_full <span class="main">(</span>inline <span class="skolem">interceptor</span> <span class="main">(</span><span class="skolem">𝒜<span class="hidden">⇩</span><sub>2</sub></span> <span class="skolem">σ</span> <span class="skolem">c</span><span class="main">)</span> <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">σ</span> <span class="skolem">c</span> <span class="skolem">s</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lossless_inline<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> ℐ<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">ℐ_full</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We integrate this interceptor into the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"ind_cpa.game"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> using the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"inline"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> function as illustrated in Fig.~\ref{fig:4}
  and name the result <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">game<span class="hidden">⇩</span><sub>0</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

\input{fig-4}
›</span></span>

<span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">game<span class="hidden">⇩</span><sub>0</sub></span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="skolem">game<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="main">(</span><span class="bound">pk</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">←</span> lift_spmf key_gen<span class="main">;</span>
  <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="bound">m<span class="hidden">⇩</span><sub>1</sub></span><span class="main">,</span> <span class="bound">m<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="main">←</span> inline <span class="skolem">interceptor</span> <span class="main">(</span><span class="skolem">𝒜<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">pk</span><span class="main">)</span> <span class="main">{}</span><span class="main">;</span>
  assert_gpv <span class="main">(</span>valid_plains <span class="bound">m<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">m<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">;</span>
  <span class="bound">b</span> <span class="main">←</span> lift_spmf coin_spmf<span class="main">;</span>
  <span class="bound">c</span> <span class="main">←</span> encrypt <span class="bound">pk</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">m<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword1">else</span> <span class="bound">m<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">;</span>
  <span class="main">(</span><span class="bound">b'</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">←</span> inline <span class="skolem">interceptor</span> <span class="main">(</span><span class="skolem">𝒜<span class="hidden">⇩</span><sub>2</sub></span> <span class="bound">c</span> <span class="bound">σ</span><span class="main">)</span> <span class="bound">s</span><span class="main">;</span>
  Done <span class="main">(</span><span class="bound">b'</span> <span class="main">=</span> <span class="bound">b</span><span class="main">)</span>
<span class="main">}</span> <span class="keyword1">ELSE</span> lift_spmf coin_spmf"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
We claim that the above modifications do not affect the output of the IND-CPA game at all.
This might seem obvious since we are only logging the adversary's queries without modifying them.
However, in a formal proof, this needs to be precisely justified.

More precisely, we have been very careful that the two games <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"ind_cpa.game <span class="free"><span class="free">𝒜</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and 
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">game<span class="hidden">⇩</span><sub>0</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> have identical structure. They differ only in that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">game<span class="hidden">⇩</span><sub>0</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> uses the adversary
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">pk</span></span><span class="main"><span class="main">.</span></span> inline <span class="skolem"><span class="skolem">interceptor</span></span> <span class="main"><span class="main">(</span></span><span class="skolem"><span class="skolem">𝒜<span class="hidden">⇩</span><sub>1</sub></span></span> <span class="bound"><span class="bound">pk</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">{}</span></span><span class="main"><span class="main">,</span></span> <span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">cipher</span></span> <span class="bound"><span class="bound">σ</span></span><span class="main"><span class="main">.</span></span> inline <span class="skolem"><span class="skolem">interceptor</span></span> <span class="main"><span class="main">(</span></span><span class="skolem"><span class="skolem">𝒜<span class="hidden">⇩</span><sub>2</sub></span></span> <span class="bound"><span class="bound">cipher</span></span> <span class="bound"><span class="bound">σ</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
instead of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">𝒜</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. The formal justification for this replacement happens in two steps:
\begin{enumerate}
\item We replace the oracle transformer <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">interceptor</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">id_oracle</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, which merely passes queries and results to the oracle.
\item Inlining the identity oracle transformer <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">id_oracle</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> does not change an adversary and can therefore be dropped.
\end{enumerate}

The first step is automated using Isabelle's Transfer package~\cite{Huffman2013},
which is based on Mitchell's representation independence~\cite{Mitchell1986}.
The replacement is controlled by so-called transfer rules of the form <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">R</span></span> <span class="free"><span class="free">x</span></span> <span class="free"><span class="free">y</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> which
indicates that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">x</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> shall replace <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">y</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>; the correspondence relation <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">R</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> captures the 
kind of replacement.
The <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">method</span></span> transfer<span class="antiquote"><span class="antiquote">}</span></span></span></span> proof method then constructs a constraint system with one constraint
for each atom in the proof goal where the correspondence relation and the replacement are unknown.
It then tries to solve the constraint system using the rules that have been declared with 
the attribute <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>[transfer_rule]›</span></span></span></span>.
Atoms that do not have a suitable transfer rule are not changed and their correspondence relation is
instantiated with the identity relation <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(=)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

The second step is automated using Isabelle's simplifier.  

In the example, the crucial change happens in the state of the oracle transformer:
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">interceptor</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> records all queries in a set whereas <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">id_oracle</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> has no state, which 
is modelled with the singleton type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">unit</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
To capture the change, we define the correspondence relation <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">cr</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> on the states of the oracle transformers.
(As we are in the process of adding this state, this state is irrelevant and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">cr</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is therefore always true.
We nevertheless have to make an explicit definition such that Isabelle does not automatically beta-reduce terms, which would confuse <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">method</span></span> transfer<span class="antiquote"><span class="antiquote">}</span></span></span></span>.) 
We then prove that it relates the initial states and that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">cr</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is a bisimulation relation
for the two oracle transformers; see <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> Basin2017<span class="antiquote"><span class="antiquote">}</span></span></span></span> for details.
The bisimulation proof itself is automated, too: A bit of term rewriting (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> "unfolding"<span class="antiquote"><span class="antiquote">}</span></span></span></span>) 
makes the two oracle transformers structurally identical except for the state update function.
Having proved that the state update function <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="main"><span class="bound"><span class="main"><span class="bound">_</span></span></span></span> <span class="bound"><span class="bound">σ</span></span><span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">σ</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is a correct replacement for
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"insert"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> w.r.t. <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">cr</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">method</span></span> transfer_prover<span class="antiquote"><span class="antiquote">}</span></span></span></span> then lifts this replacement
to the bisimulation rule.
Here, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">method</span></span> transfer_prover<span class="antiquote"><span class="antiquote">}</span></span></span></span> is similar to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">method</span></span> transfer<span class="antiquote"><span class="antiquote">}</span></span></span></span> except that it works only for
transfer rules and builds the constraint system only for the term to be replaced.

The theory source of this tutorial contains a step-by-step proof to illustrate how transfer works.
›</span></span>
<span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">cr</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"unit <span class="main">⇒</span> <span class="tfree">'grp</span> set <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">cr</span> <span class="skolem">σ</span> <span class="skolem">σ'</span> <span class="main">=</span> True"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">σ</span> <span class="skolem">σ'</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">cr</span> <span class="main">()</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_def<span class="main">)</span> <span class="comment1">― ‹initial states›</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="skolem">cr</span> <span class="main">===&gt;</span> <span class="skolem">cr</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">σ</span><span class="main">.</span> <span class="bound">σ</span><span class="main">)</span> insert"</span></span> <span class="comment1">― ‹state update›</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def cr_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="comment1">― ‹<span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted"><span class="skolem">cr</span></span><span class="antiquote">}</span></span> is a bisimulation for the oracle transformers›</span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">cr</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> rel_gpv <span class="main">(</span>rel_prod <span class="main">(=)</span> <span class="skolem">cr</span><span class="main">)</span> <span class="main">(=)</span><span class="main">)</span> id_oracle <span class="skolem">interceptor</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> interceptor_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> id_oracle_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> bind_gpv_Pause bind_rpv_Done
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ind_cpa.game <span class="free">𝒜</span> <span class="main">=</span> <span class="skolem">game<span class="hidden">⇩</span><sub>0</sub></span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> game<span class="hidden">⇩</span><sub>0</sub>_def 𝒜 ind_cpa.game.simps
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_map_gpv o_def ind_cpa.game.simps split_def<span class="main">)</span> 
<span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> <span class="main">%</span>invisible ind_cpa_game_eq_game<span class="hidden">⇩</span><sub>0</sub> <span class="main">=</span> this

<span class="keyword1"><span class="command">{</span></span> <span class="main">%</span> invisible <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹And now the same proof again, but step by step.›</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">cr</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"unit <span class="main">⇒</span> <span class="tfree">'grp</span> set <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">cr</span> <span class="skolem">σ</span> <span class="skolem">σ'</span> <span class="main">=</span> True"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">σ</span> <span class="skolem">σ'</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">cr</span> <span class="main">()</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_def<span class="main">)</span> <span class="comment1">― ‹initial states›</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="skolem">cr</span> <span class="main">===&gt;</span> <span class="skolem">cr</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">σ</span><span class="main">.</span> <span class="bound">σ</span><span class="main">)</span> insert"</span></span> <span class="comment1">― ‹state update›</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def cr_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="comment1">― ‹<span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted"><span class="skolem">cr</span></span><span class="antiquote">}</span></span> is a bisimulation for the oracle transformers›</span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">cr</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> rel_gpv <span class="main">(</span>rel_prod <span class="main">(=)</span> <span class="skolem">cr</span><span class="main">)</span> <span class="main">(=)</span><span class="main">)</span> id_oracle <span class="skolem">interceptor</span>"</span></span>
    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹1. Unfold the definitions of the oracle transformers and massage them to have the same structure.›</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> interceptor_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> id_oracle_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> bind_gpv_Pause bind_rpv_Done
    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹2. Build the constraint system for the second argument of the correspondence relation, namely <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">interceptor</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> with the rewrite rules applied.›</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer_prover_start</span>
    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹3. Solve the constraint system prolog-style by resolving with the rules from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] <span class="dynamic"><span class="dynamic"><span class="dynamic"><span class="dynamic">transfer_raw</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer_step</span> <span class="comment1">― ‹This step uses the state update transfer rule proven in the previous <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">command</span> have<span class="antiquote">}</span></span>.›</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer_step</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer_step</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer_step</span>
    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹4. Check that the found solution is the expected one, namely the first argument of the correspondence relation, here <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">id_oracle</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> with the rewrite rules applied.›</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer_prover_end</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ind_cpa.game <span class="free">𝒜</span> <span class="main">=</span> <span class="skolem">game<span class="hidden">⇩</span><sub>0</sub></span>"</span></span>
    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹1. Unfold the definitions›</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> game<span class="hidden">⇩</span><sub>0</sub>_def 𝒜 ind_cpa.game.simps
    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹2. Build the constraint system for the whole subgoal. The <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>fixing›</span></span></span></span> tells transfer
      that it must not replace the variables <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">𝒢</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">len_plain</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="skolem"><span class="skolem">𝒜<span class="hidden">⇩</span><sub>1</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="skolem"><span class="skolem">𝒜<span class="hidden">⇩</span><sub>2</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer_start</span> 
    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹3. Solve all constraints with the transfer rules›</span></span>
                        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer_step</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer_end</span>
    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹4. Get rid of the identity oracle transformer <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">id_oracle</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> by rewriting. Really curious readers may dare to look at the simplifer trace.›</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span> <span class="main">[</span><span class="main">[</span><span class="operator">simp_trace_new</span> <span class="quasi_keyword">mode</span><span class="main"><span class="main">=</span></span><span class="quasi_keyword">full</span><span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_map_gpv o_def ind_cpa.game.simps split_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">}</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="main">%</span>visible <span class="quoted"><span class="plain_text">‹Equational program transformations›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Before we move on, we need to simplify <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">game<span class="hidden">⇩</span><sub>0</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and inline a few of the definitions.
All these simplifications are equational program transformations, so the Isabelle simplifier can justify them.
We combine the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">interceptor</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> with the random oracle <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">ro.oracle</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> into a new oracle <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">oracle'</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> 
with which the adversary interacts.
›</span></span>
<span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">oracle'</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> set <span class="main">×</span> <span class="main">(</span><span class="tfree">'grp</span> <span class="main">⇀</span> bitstring<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'grp</span> <span class="main">⇒</span> <span class="main">_</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">oracle'</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="main">(</span><span class="bound">h</span><span class="main">,</span> <span class="bound">σ'</span><span class="main">)</span> <span class="main">←</span> <span class="keyword1">case</span> <span class="bound">σ</span> <span class="bound">x</span> <span class="keyword1">of</span>
      None <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="bound">bs</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len_plain</span><span class="main">)</span><span class="main">;</span>
          return_spmf <span class="main">(</span><span class="bound">bs</span><span class="main">,</span> <span class="bound">σ</span><span class="main">(</span><span class="bound">x</span> <span class="main">↦</span> <span class="bound">bs</span><span class="main">)</span><span class="main">)</span> <span class="main">}</span>
    <span class="main">|</span> Some <span class="bound">bs</span> <span class="main">⇒</span> return_spmf <span class="main">(</span><span class="bound">bs</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">;</span>
  return_spmf <span class="main">(</span><span class="bound">h</span><span class="main">,</span> insert <span class="bound">x</span> <span class="bound">s</span><span class="main">,</span> <span class="bound">σ'</span><span class="main">)</span>
<span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">have</span></span> <span class="main">%</span>invisible <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span><span class="skolem">oracle'</span> <span class="skolem">s</span> <span class="skolem">plain</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span> <span class="skolem">plain</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle'_def Let_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split option.split<span class="main">)</span>
<span class="keyword1"><span class="command">have</span></span> <span class="main">%</span>invisible <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>exec_gpv <span class="skolem">oracle'</span> <span class="main">(</span><span class="skolem">𝒜<span class="hidden">⇩</span><sub>1</sub></span> <span class="skolem">α</span><span class="main">)</span> <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span> <span class="skolem">α</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lossless_exec_gpv<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> ℐ<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">ℐ_full</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">have</span></span> <span class="main">%</span>invisible <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>exec_gpv <span class="skolem">oracle'</span> <span class="main">(</span><span class="skolem">𝒜<span class="hidden">⇩</span><sub>2</sub></span> <span class="skolem">σ</span> <span class="skolem">cipher</span><span class="main">)</span> <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">σ</span> <span class="skolem">cipher</span> <span class="skolem">s</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lossless_exec_gpv<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> ℐ<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">ℐ_full</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"exec_gpv ro.oracle <span class="main">(</span>inline <span class="skolem">interceptor</span> <span class="skolem">𝒜</span> <span class="skolem">s</span><span class="main">)</span> <span class="skolem">σ</span> <span class="main">=</span> 
  map_spmf <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>exec_gpv <span class="skolem">oracle'</span> <span class="skolem">𝒜</span> <span class="main">(</span><span class="skolem">s</span><span class="main">,</span> <span class="skolem">σ</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">𝒜</span> <span class="skolem">σ</span> <span class="skolem">s</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> interceptor_def oracle'_def ro.oracle_def Let_def 
     exec_gpv_inline exec_gpv_bind o_def split_def <span class="quasi_keyword">cong</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> option.case_cong_weak<span class="main">)</span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
We also want to inline the key generation and encryption algorithms,
push the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">TRY</span></span> DUMMY <span class="keyword1"><span class="keyword1">ELSE</span></span> DUMMY <span class="main"><span class="main">::</span></span> <span class="main"><span class="main">(</span></span><span class="main"><span class="main">_</span></span><span class="main"><span class="main">,</span></span> <span class="main"><span class="main">_</span></span><span class="main"><span class="main">,</span></span> <span class="main"><span class="main">_</span></span><span class="main"><span class="main">)</span></span> gpv"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> towards the assertion (which is possible because the adversary is lossless by assumption),
and rearrange the samplings a bit.
The latter is automated using <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>monad_normalisation›</span></span></span></span>~\cite{Schneider2017}.%
\footnote{%
  The tool <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>monad_normalisation›</span></span></span></span> augments Isabelle's simplifier with a normalization procedure for commutative monads based on higher-order ordered rewriting.
  It can also commute across control structures like <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>if›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>case›</span></span></span></span>.
  Although it is not complete as a decision procedure (as the normal forms are not unique), it usually works in practice.
}
›</span></span>
<span class="keyword1"><span class="command">have</span></span> game<span class="hidden">⇩</span><sub>0</sub><span class="main">:</span> <span class="quoted"><span class="quoted">"run_gpv ro.oracle <span class="skolem">game<span class="hidden">⇩</span><sub>0</sub></span> ro.initial <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">x</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
  <span class="bound">y</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
  <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
  <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="bound">msg1</span><span class="main">,</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">s_h</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span>
    exec_gpv <span class="skolem">oracle'</span> <span class="main">(</span><span class="skolem">𝒜<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">{}</span><span class="main">,</span> ro.initial<span class="main">)</span><span class="main">;</span>
  <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span>valid_plains <span class="bound">msg1</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">h</span><span class="main">,</span> <span class="bound">s_h'</span><span class="main">)</span> <span class="main">←</span> ro.oracle <span class="bound">s_h</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="bound">x</span> <span class="main">*</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">cipher</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">y</span><span class="main">,</span> <span class="bound">h</span> <span class="main">[⊕]</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">msg1</span> <span class="keyword1">else</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">b'</span><span class="main">,</span> <span class="main">(</span><span class="bound">s'</span><span class="main">,</span> <span class="bound">s_h''</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">oracle'</span> <span class="main">(</span><span class="skolem">𝒜<span class="hidden">⇩</span><sub>2</sub></span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">s_h'</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">b'</span> <span class="main">=</span> <span class="bound">b</span><span class="main">)</span>
  <span class="main">}</span> <span class="keyword1">ELSE</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
    return_spmf <span class="bound">b</span>
  <span class="main">}</span>
<span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> monad_normalisation
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> game<span class="hidden">⇩</span><sub>0</sub>_def key_gen_def encrypt_def * exec_gpv_bind bind_map_spmf assert_spmf_def
    try_bind_assert_gpv try_gpv_bind_lossless split_def o_def <span class="dynamic"><span class="dynamic">if_distribs</span></span> lcdh.nat_pow_pow<span class="main">)</span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
This call to Isabelle's simplifier may look complicated at first, but it can be constructed incrementally 
by adding a few theorems and looking at the resulting goal state and searching for suitable theorems using <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> find_theorems<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
As always in Isabelle, some intuition and knowledge about the library of lemmas is crucial. 
\begin{itemize}
\item We knew that the definitions <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] game<span class="hidden">⇩</span><sub>0</sub>_def<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] key_gen_def<span class="antiquote"><span class="antiquote">}</span></span></span></span>, and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] encrypt_def<span class="antiquote"><span class="antiquote">}</span></span></span></span> should be unfolded,
  so they are added first to the simplifier's set of rewrite rules.
\item The equations <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] exec_gpv_bind<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] try_bind_assert_gpv<span class="antiquote"><span class="antiquote">}</span></span></span></span>, and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] try_gpv_bind_lossless<span class="antiquote"><span class="antiquote">}</span></span></span></span>
  ensure that the operator <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">exec_gpv</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, which connects the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">game<span class="hidden">⇩</span><sub>0</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> with the random oracle, is distributed over the sequencing.
  Together with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] * <span class="antiquote"><span class="antiquote">}</span></span></span></span>, this gives the adversary access to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">oracle'</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> instead of the interceptor and the random oracle, 
  and makes the call to the random oracle in the encryption of the chosen message explicit.
\item The theorem <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] lcdh.nat_pow_pow<span class="antiquote"><span class="antiquote">}</span></span></span></span> rewrites the iterated exponentiation <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="keyword1"><span class="keyword1"><span class="hidden">❙</span><b>g</b></span></span> <span class="main"><span class="main">[^]</span></span> <span class="free"><span class="free">x</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">[^]</span></span> <span class="free"><span class="free">y</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1"><span class="hidden">❙</span><b>g</b></span></span> <span class="main"><span class="main">[^]</span></span> <span class="main"><span class="main">(</span></span><span class="free"><span class="free">x</span></span> <span class="main"><span class="main">*</span></span> <span class="free"><span class="free">y</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
\item The other theorems <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] bind_map_spmf<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] assert_spmf_def<span class="antiquote"><span class="antiquote">}</span></span></span></span>,
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] split_def<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] o_def<span class="antiquote"><span class="antiquote">}</span></span></span></span>, and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] <span class="dynamic"><span class="dynamic"><span class="dynamic"><span class="dynamic">if_distribs</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  take care of all the boilerplate code that makes all these transformations type-correct.
  These theorems often have to be used together.
\end{itemize}

Note that the state of the oracle <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">oracle'</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is changed between <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="skolem"><span class="skolem">𝒜<span class="hidden">⇩</span><sub>1</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="skolem"><span class="skolem">𝒜<span class="hidden">⇩</span><sub>2</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
Namely, the random oracle's part <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">s_h</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> may change when the chosen message is encrypted,
but the state that records the adversary's queries <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">s</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is passed on unchanged.
›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹\input{fig-5}›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Capturing a failure event›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Suppose that two games behave the same except when a so-called failure event occurs <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> Shoup2004IACR<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
Then the chance of an adversary distinguishing the two games is bounded by the probability of the failure event.
In other words, the simulation of the reduction is allowed to break if the failure event occurs.
In the running example, such an argument is a key step to derive the bound on the adversary's advantage.
But to reason about failure events, we must first introduce them into the games we consider.
This is because in \CryptHOL{}, the probabilistic programs describe probability distributions over what they return (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">return_spmf</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>).
The variables that are used internally in the program are not accessible from the outside,
i.e., there is no memory to which these are written.
This has the advantage that we never have to worry about the names of the variables, e.g., to avoid clashes.
The drawback is that we must explicitly introduce all the events that we are interested in.

Introducing a failure event into a game is straightforward.
So far, the games <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">ind_cpa.game</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">game<span class="hidden">⇩</span><sub>0</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> simply denoted the probability distribution of whether the adversary has guessed right.
For hashed Elgamal, the simulation breaks if the adversary queries the random oracle with the same query <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1"><span class="hidden">❙</span><b>g</b></span></span> <span class="main"><span class="main">[^]</span></span> <span class="main"><span class="main">(</span></span><span class="free"><span class="free">x</span></span> <span class="main"><span class="main">*</span></span> <span class="free"><span class="free">y</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> that is used for encrypting the chosen message <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>m<span class="hidden">⇩</span><sub>b</sub>›</span></span></span></span>.
So we simply change the return type of the game to return whether the adversary guessed right \emph{and} whether the failure event has occurred.
The next definition <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">game<span class="hidden">⇩</span><sub>1</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> does so.
(Recall that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">oracle'</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> stores in its first state component <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">s</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> the queries by the adversary.)
In preparation of the next reasoning step, we also split off the first two samplings, namely of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">x</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">y</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, and make them parameters of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">game<span class="hidden">⇩</span><sub>1</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>
<span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">game<span class="hidden">⇩</span><sub>1</sub></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="main">(</span>bool <span class="main">×</span> bool<span class="main">)</span> spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">game<span class="hidden">⇩</span><sub>1</sub></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
  <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="bound">m<span class="hidden">⇩</span><sub>1</sub></span><span class="main">,</span> <span class="bound">m<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">s_h</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">oracle'</span> <span class="main">(</span><span class="skolem">𝒜<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">{}</span><span class="main">,</span> ro.initial<span class="main">)</span><span class="main">;</span>
  <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span>valid_plains <span class="bound">m<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">m<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">h</span><span class="main">,</span> <span class="bound">s_h'</span><span class="main">)</span> <span class="main">←</span> ro.oracle <span class="bound">s_h</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">*</span> <span class="skolem">y</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">c</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">y</span><span class="main">,</span> <span class="bound">h</span> <span class="main">[⊕]</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">m<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword1">else</span> <span class="bound">m<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">b'</span><span class="main">,</span> <span class="main">(</span><span class="bound">s'</span><span class="main">,</span> <span class="bound">s_h''</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">oracle'</span> <span class="main">(</span><span class="skolem">𝒜<span class="hidden">⇩</span><sub>2</sub></span> <span class="bound">c</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">s_h'</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">b'</span> <span class="main">=</span> <span class="bound">b</span><span class="main">,</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">*</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="bound">s'</span><span class="main">)</span>
  <span class="main">}</span> <span class="keyword1">ELSE</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">*</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="bound">s</span><span class="main">)</span>
  <span class="main">}</span>
<span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">y</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
It is easy to prove that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">game<span class="hidden">⇩</span><sub>0</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> combined with the random oracle is a projection of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">game<span class="hidden">⇩</span><sub>1</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> with the sampling added, as formalized in <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>game<span class="hidden">⇩</span><sub>0</sub>_game<span class="hidden">⇩</span><sub>1</sub>›</span></span></span></span>.
›</span></span>
<span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?sample</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">f</span> <span class="main">::</span> nat <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="main">_</span> spmf<span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
   <span class="bound">x</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
   <span class="bound">y</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
   <span class="bound">f</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">have</span></span> game<span class="hidden">⇩</span><sub>0</sub>_game<span class="hidden">⇩</span><sub>1</sub><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"run_gpv ro.oracle <span class="skolem">game<span class="hidden">⇩</span><sub>0</sub></span> ro.initial <span class="main">=</span> map_spmf fst <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> game<span class="hidden">⇩</span><sub>0</sub> game<span class="hidden">⇩</span><sub>1</sub>_def o_def split_def map_try_spmf map_scale_spmf<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Game hop based on a failure event›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
A game hop based on a failure event changes one game into another such that they behave identically unless the failure event occurs.
The <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] "fundamental_lemma"<span class="antiquote"><span class="antiquote">}</span></span></span></span> bounds the absolute difference between the two games by the probability of the failure event.
In the running example, we would like to avoid querying the random oracle when encrypting the chosen message.
The next game <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">game<span class="hidden">⇩</span><sub>2</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is identical except that the call to the random oracle <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">ro.oracle</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is replaced with sampling a random bitstring.%
\footnote{%
  In Shoup's terminology <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> Shoup2004IACR<span class="antiquote"><span class="antiquote">}</span></span></span></span>, such a step makes (a gnome sitting inside) the random oracle forgetting the query.
}
›</span></span>
<span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">game<span class="hidden">⇩</span><sub>2</sub></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="main">(</span>bool <span class="main">×</span> bool<span class="main">)</span> spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">game<span class="hidden">⇩</span><sub>2</sub></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
  <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="bound">m<span class="hidden">⇩</span><sub>1</sub></span><span class="main">,</span> <span class="bound">m<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">s_h</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">oracle'</span> <span class="main">(</span><span class="skolem">𝒜<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">{}</span><span class="main">,</span> ro.initial<span class="main">)</span><span class="main">;</span>
  <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span>valid_plains <span class="bound">m<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">m<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">;</span>
    <span class="bound">h</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len_plain</span><span class="main">)</span><span class="main">;</span>
    <span class="comment1">― ‹We do not query the random oracle for <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">‹<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">x</span> <span class="main">*</span> <span class="free">y</span><span class="main">)</span>›</span><span class="antiquote">}</span></span>, but instead sample a random bitstring <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted"><span class="free">h</span></span><span class="antiquote">}</span></span> directly.
        So the rest differs from <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted"><span class="skolem">game<span class="hidden">⇩</span><sub>1</sub></span></span><span class="antiquote">}</span></span> only if the adversary queries <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">‹<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">x</span> <span class="main">*</span> <span class="free">y</span><span class="main">)</span>›</span><span class="antiquote">}</span></span>.›</span>
    <span class="keyword1">let</span> <span class="bound">cipher</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">y</span><span class="main">,</span> <span class="bound">h</span> <span class="main">[⊕]</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">m<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword1">else</span> <span class="bound">m<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">b'</span><span class="main">,</span> <span class="main">(</span><span class="bound">s'</span><span class="main">,</span> <span class="bound">s_h'</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">oracle'</span> <span class="main">(</span><span class="skolem">𝒜<span class="hidden">⇩</span><sub>2</sub></span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">s_h</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">b'</span> <span class="main">=</span> <span class="bound">b</span><span class="main">,</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">*</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="bound">s'</span><span class="main">)</span>
  <span class="main">}</span> <span class="keyword1">ELSE</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">*</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="bound">s</span><span class="main">)</span>
  <span class="main">}</span>
<span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
To apply the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] fundamental_lemma<span class="antiquote"><span class="antiquote">}</span></span></span></span>, we first have to prove that the two games are indeed the same
except when the failure event occurs.
›</span></span>
<span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"rel_spmf <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">win</span><span class="main">,</span> <span class="bound">bad</span><span class="main">)</span> <span class="main">(</span><span class="bound">win'</span><span class="main">,</span> <span class="bound">bad'</span><span class="main">)</span><span class="main">.</span> <span class="bound">bad</span> <span class="main">=</span> <span class="bound">bad'</span> <span class="main">∧</span> <span class="main">(</span><span class="main">¬</span> <span class="bound">bad'</span> <span class="main">⟶</span> <span class="bound">win</span> <span class="main">=</span> <span class="bound">win'</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="skolem">game<span class="hidden">⇩</span><sub>2</sub></span> <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">(</span><span class="skolem">game<span class="hidden">⇩</span><sub>1</sub></span> <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This proof requires two invariants on the state of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">oracle'</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  First, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">s</span></span> <span class="main"><span class="main">=</span></span> dom <span class="free"><span class="free">s_h</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  Second, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">s</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> only becomes larger.
  The next two statements capture the two invariants:
›</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> inv_oracle'<span class="main">:</span> callee_invariant_on <span class="quoted"><span class="quoted">"<span class="skolem">oracle'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">s_h</span><span class="main">)</span><span class="main">.</span> <span class="bound">s</span> <span class="main">=</span> dom <span class="bound">s_h</span><span class="main">)</span>"</span></span> <span class="quoted">ℐ_full</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle'_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm if_split<span class="main">)</span>
  <span class="keyword1"><span class="command">interpret</span></span> bad<span class="main">:</span> callee_invariant_on <span class="quoted"><span class="quoted">"<span class="skolem">oracle'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="skolem">z</span> <span class="main">∈</span> <span class="bound">s</span><span class="main">)</span>"</span></span> <span class="quoted">ℐ_full</span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">z</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle'_def<span class="main">)</span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  First, we identify a bisimulation relation <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>?X›</span></span></span></span> between the different states of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">oracle'</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> for the second phase of the game.
  Namely, the invariant <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">s</span></span> <span class="main"><span class="main">=</span></span> dom <span class="free"><span class="free">s_h</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> holds, the set of queries are the same, 
  and the random oracle's state (a map from queries to responses) differs only at the point <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1"><span class="hidden">❙</span><b>g</b></span></span> <span class="main"><span class="main">[^]</span></span> <span class="main"><span class="main">(</span></span><span class="skolem"><span class="skolem">x</span></span> <span class="main"><span class="main">*</span></span> <span class="skolem"><span class="skolem">y</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  ›</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?X</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">s_h</span><span class="main">)</span> <span class="main">(</span><span class="bound">s'</span><span class="main">,</span> <span class="bound">s_h'</span><span class="main">)</span><span class="main">.</span> <span class="bound">s</span> <span class="main">=</span> dom <span class="bound">s_h</span> <span class="main">∧</span> <span class="bound">s'</span> <span class="main">=</span> <span class="bound">s</span> <span class="main">∧</span> <span class="bound">s_h</span> <span class="main">=</span> <span class="bound">s_h'</span><span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">*</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">:=</span> None<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Then, we can prove that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">"<span class="var"><span class="var">?X</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> really is a bisimulation for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">oracle'</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> except when the failure event occurs.
  The next statement expresses this.
  ›</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?bad</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">s_h</span><span class="main">)</span><span class="main">.</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">*</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="bound">s</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?R</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">s1'</span><span class="main">)</span> <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">s2'</span><span class="main">)</span><span class="main">.</span> <span class="var">?bad</span> <span class="bound">s1'</span> <span class="main">=</span> <span class="var">?bad</span> <span class="bound">s2'</span> <span class="main">∧</span> <span class="main">(</span><span class="main">¬</span> <span class="var">?bad</span> <span class="bound">s2'</span> <span class="main">⟶</span> <span class="bound">a</span> <span class="main">=</span> <span class="bound">b</span> <span class="main">∧</span> <span class="var">?X</span> <span class="bound">s1'</span> <span class="bound">s2'</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> bisim<span class="main">:</span> <span class="quoted"><span class="quoted">"rel_spmf <span class="var">?R</span> <span class="main">(</span><span class="skolem">oracle'</span> <span class="skolem">s1</span> <span class="skolem">plain</span><span class="main">)</span> <span class="main">(</span><span class="skolem">oracle'</span> <span class="skolem">s2</span> <span class="skolem">plain</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="var">?X</span> <span class="skolem">s1</span> <span class="skolem">s2</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s1</span> <span class="skolem">s2</span> <span class="skolem">plain</span> <span class="keyword1"><span class="command">using</span></span> that
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_bind_reflI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle'_def rel_spmf_return_spmf2 fun_upd_twist <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> fun_upd_eqD<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> inv<span class="main">:</span> <span class="quoted"><span class="quoted">"callee_invariant <span class="skolem">oracle'</span> <span class="var">?bad</span>"</span></span>
    <span class="comment1">― ‹Once the failure event has happened, it will not be forgotten any more.›</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle'_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Now we are ready to prove that the two games <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">game<span class="hidden">⇩</span><sub>1</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">game<span class="hidden">⇩</span><sub>2</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> are sufficiently similar.
  The Isar proof now switches into an <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> apply<span class="antiquote"><span class="antiquote">}</span></span></span></span> script that manipulates the goal state directly.
  This is sometimes convenient when it would be too cumbersome to spell out every intermediate goal state.
›</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> game<span class="hidden">⇩</span><sub>1</sub>_def game<span class="hidden">⇩</span><sub>2</sub>_def
    <span class="comment1">― ‹Peel off the first phase of the game using the structural decomposition rules <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">thm</span> [source] rel_spmf_bind_reflI<span class="antiquote">}</span></span> and <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">thm</span> [source] rel_spmf_try_spmf<span class="antiquote">}</span></span>.›</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_bind_reflI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> bind_spmf_const<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> rel_spmf_try_spmf<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> TRY <span class="keyword2"><span class="keyword">for</span></span> b m<span class="hidden">⇩</span><sub>1</sub> m<span class="hidden">⇩</span><sub>2</sub> σ s s_h
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> rel_spmf_bind_reflI<span class="main">)</span>
      <span class="comment1">― ‹Exploit that in the first phase of the game, the set <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted"><span class="skolem">s</span></span><span class="antiquote">}</span></span> of queried strings and the map of the random oracle <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted"><span class="skolem">s_h</span></span><span class="antiquote">}</span></span> are updated in lock step, i.e., <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="skolem">s</span> <span class="main">=</span> dom <span class="skolem">s_h</span>"</span><span class="antiquote">}</span></span>.›</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> inv_oracle'.exec_gpv_invariant<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
      <span class="comment1">― ‹Has the adversary queried the random oracle with <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">*</span> <span class="skolem">y</span><span class="main">)</span>"</span><span class="antiquote">}</span></span> during the first phase?›</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">*</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">s</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> True <span class="comment1">― ‹Then the failure event has already happened and there is nothing more to do. 
        We just have to prove that the two games on both sides terminate with the same probability.›</span> 
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_bindI1 rel_spmf_bindI2 lossless_exec_gpv<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> ℐ<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">ℐ_full</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> bad.exec_gpv_invariant<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> False <span class="comment1">― ‹Then let's see whether the adversary queries <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">*</span> <span class="skolem">y</span><span class="main">)</span>"</span><span class="antiquote">}</span></span> in the second phase.
        Thanks to <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">thm</span> [source] ro.fresh<span class="antiquote">}</span></span>, the call to the random oracle simplifies to sampling a random bitstring.›</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">iff</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> domIff <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> domIff ro.fresh <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_bind_reflI<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> rel_spmf_bindI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="var">?R</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
         <span class="comment1">― ‹The lemma <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">thm</span> [source] exec_gpv_oracle_bisim_bad_full<span class="antiquote">}</span></span> lifts the bisimulation for <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted"><span class="skolem">oracle'</span></span><span class="antiquote">}</span></span>
             to the adversary <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted"><span class="skolem">𝒜<span class="hidden">⇩</span><sub>2</sub></span></span><span class="antiquote">}</span></span> interacting with <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted"><span class="skolem">oracle'</span></span><span class="antiquote">}</span></span>.›</span>
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> exec_gpv_oracle_bisim_bad_full<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ _ bisim inv inv<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_upd_idem<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> ELSE <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> rel_spmf_reflI<span class="main">)</span> <span class="operator">clarsimp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Now we can add the sampling of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">x</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">y</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in front of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">game<span class="hidden">⇩</span><sub>1</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">game<span class="hidden">⇩</span><sub>2</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
  apply the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] fundamental_lemma<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>
<span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"rel_spmf <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">win</span><span class="main">,</span> <span class="bound">bad</span><span class="main">)</span> <span class="main">(</span><span class="bound">win'</span><span class="main">,</span> <span class="bound">bad'</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">bad</span> <span class="main">⟷</span> <span class="bound">bad'</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">¬</span> <span class="bound">bad'</span> <span class="main">⟶</span> <span class="bound">win</span> <span class="main">⟷</span> <span class="bound">win'</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> rel_spmf_bind_reflI<span class="main">)</span>
<span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">¦</span>measure <span class="main">(</span>measure_spmf <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="main">(</span><span class="bound">win</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="bound">win</span><span class="main">}</span> <span class="main">-</span> measure <span class="main">(</span>measure_spmf <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="main">(</span><span class="bound">win</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="bound">win</span><span class="main">}</span><span class="main">¦</span>
      <span class="main">≤</span> measure <span class="main">(</span>measure_spmf <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">bad</span><span class="main">)</span><span class="main">.</span> <span class="bound">bad</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> split_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> fundamental_lemma<span class="main">)</span>
<span class="keyword1"><span class="command">moreover</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] fundamental_lemma<span class="antiquote"><span class="antiquote">}</span></span></span></span> is written in full generality for arbitrary events, 
  i.e., sets of elementary events.
  But in this formalization, the events of interest (correct guess and failure) are elementary events.
  We therefore transform the above statement to measure the probability of elementary events using <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">spmf</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>
<span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"measure <span class="main">(</span>measure_spmf <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="main">(</span><span class="bound">win</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="bound">win</span><span class="main">}</span> <span class="main">=</span> spmf <span class="main">(</span>map_spmf fst <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span> True"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"measure <span class="main">(</span>measure_spmf <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="main">(</span><span class="bound">win</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="bound">win</span><span class="main">}</span> <span class="main">=</span> spmf <span class="main">(</span>map_spmf fst <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span><span class="main">)</span> True"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"measure <span class="main">(</span>measure_spmf <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span> <span class="main">{</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">bad</span><span class="main">)</span><span class="main">.</span> <span class="bound">bad</span><span class="main">}</span> <span class="main">=</span> spmf <span class="main">(</span>map_spmf snd <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span> True"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> spmf_conv_measure_spmf measure_map_spmf <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> vimage_def split_def<span class="main">)</span>
<span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> hop12<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">¦</span>spmf <span class="main">(</span>map_spmf fst <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span> True <span class="main">-</span> spmf <span class="main">(</span>map_spmf fst <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span><span class="main">)</span> True<span class="main">¦</span>
  <span class="main">≤</span> spmf <span class="main">(</span>map_spmf snd <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span> True"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Optimistic sampling: the one-time-pad  \label{section:ghop-last}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
This step is based on the one-time-pad, which is an instance of optimistic sampling.
If two runs of the two games in an optimistic sampling step would use the same random bits,
then their results would be different.
However, if the adversary's choices are independent of the random bits, 
we may relate runs that use different random bits, as in the end, only the probabilities have to match.
The previous game hop from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">game<span class="hidden">⇩</span><sub>1</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">game<span class="hidden">⇩</span><sub>2</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> made the oracle's responses in the second phase
independent from the encrypted ciphertext.
So we can now change the bits used for encrypting the chosen message
and thereby make the ciphertext independent of the message.

To that end, we parametrize <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">game<span class="hidden">⇩</span><sub>2</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> by the part that does the optimistic sampling
and call this parametrized version <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">game<span class="hidden">⇩</span><sub>3</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>
<span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">game<span class="hidden">⇩</span><sub>3</sub></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>bool <span class="main">⇒</span> bitstring <span class="main">⇒</span> bitstring <span class="main">⇒</span> bitstring spmf<span class="main">)</span> <span class="main">⇒</span> nat <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="main">(</span>bool <span class="main">×</span> bool<span class="main">)</span> spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">game<span class="hidden">⇩</span><sub>3</sub></span> <span class="skolem">f</span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
  <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="bound">m<span class="hidden">⇩</span><sub>1</sub></span><span class="main">,</span> <span class="bound">m<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">s_h</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">oracle'</span> <span class="main">(</span><span class="skolem">𝒜<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">{}</span><span class="main">,</span> ro.initial<span class="main">)</span><span class="main">;</span>
  <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span>valid_plains <span class="bound">m<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">m<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">;</span>
    <span class="bound">h'</span> <span class="main">←</span> <span class="skolem">f</span> <span class="bound">b</span> <span class="bound">m<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">m<span class="hidden">⇩</span><sub>2</sub></span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">cipher</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">y</span><span class="main">,</span> <span class="bound">h'</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">b'</span><span class="main">,</span> <span class="main">(</span><span class="bound">s'</span><span class="main">,</span> <span class="bound">s_h'</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">oracle'</span> <span class="main">(</span><span class="skolem">𝒜<span class="hidden">⇩</span><sub>2</sub></span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">s_h</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">b'</span> <span class="main">=</span> <span class="bound">b</span><span class="main">,</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">*</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="bound">s'</span><span class="main">)</span>
  <span class="main">}</span> <span class="keyword1">ELSE</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">*</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="bound">s</span><span class="main">)</span>
  <span class="main">}</span>
<span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="skolem">x</span> <span class="skolem">y</span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Clearly, if we plug in the appropriate function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>?f›</span></span></span></span>, then we get <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">game<span class="hidden">⇩</span><sub>2</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>:
›</span></span>
<span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?f</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">b</span> <span class="bound">m<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">m<span class="hidden">⇩</span><sub>2</sub></span><span class="main">.</span> map_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">h</span><span class="main">.</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">m<span class="hidden">⇩</span><sub>1</sub></span> <span class="keyword1">else</span> <span class="bound">m<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="main">[⊕]</span> <span class="bound">h</span><span class="main">)</span> <span class="main">(</span>spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len_plain</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">have</span></span> game<span class="hidden">⇩</span><sub>2</sub>_game<span class="hidden">⇩</span><sub>3</sub><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">game<span class="hidden">⇩</span><sub>2</sub></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">=</span> <span class="skolem">game<span class="hidden">⇩</span><sub>3</sub></span> <span class="var">?f</span> <span class="skolem">x</span> <span class="skolem">y</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> game<span class="hidden">⇩</span><sub>2</sub>_def game<span class="hidden">⇩</span><sub>3</sub>_def Let_def bind_map_spmf xor_list_commute o_def<span class="main">)</span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
CryptHOL's <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] one_time_pad<span class="antiquote"><span class="antiquote">}</span></span></span></span> lemma now allows us to remove the exclusive or with the chosen message,
because the resulting distributions are the same.
The proof is slightly non-trivial because the one-time-pad lemma holds
only if the xor'ed bitstrings have the right length, which the assertion <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">valid_plains</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> ensures.
The congruence rules <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] try_spmf_cong bind_spmf_cong<span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">OF</span></span> refl<span class="main"><span class="main">]</span></span> if_cong<span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">OF</span></span> refl<span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
extract this information from the program of the game.
›</span></span>
<span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?f'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">b</span> <span class="bound">m<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">m<span class="hidden">⇩</span><sub>2</sub></span><span class="main">.</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len_plain</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">have</span></span> game<span class="hidden">⇩</span><sub>3</sub><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">game<span class="hidden">⇩</span><sub>3</sub></span> <span class="var">?f</span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">=</span> <span class="skolem">game<span class="hidden">⇩</span><sub>3</sub></span> <span class="var">?f'</span> <span class="skolem">x</span> <span class="skolem">y</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> try_spmf_cong bind_spmf_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span> if_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span> 
    <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> game<span class="hidden">⇩</span><sub>3</sub>_def split_def one_time_pad valid_plains_def 
    <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> map_spmf_of_set_inj_on bind_spmf_const <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The rest of the proof consists of simplifying <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">"<span class="skolem"><span class="skolem">game<span class="hidden">⇩</span><sub>3</sub></span></span> <span class="var"><span class="var">?f'</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
The steps are similar to what we have shown before, so we do not explain them in detail.
The interested reader can look at them in the theory file from which this document was generated.
At a high level, we see that there is no need to track the adversary's queries in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">game<span class="hidden">⇩</span><sub>2</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> or <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">game<span class="hidden">⇩</span><sub>3</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> any more
because this information is already stored in the random oracle's state.
So we change the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">oracle'</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> back into <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">ro.oracle</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> using the Transfer package.
With a bit of rewriting, the result is then the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">lcdh.game</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> for the adversary <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"elgamal_reduction <span class="free"><span class="free">𝒜</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
Moreover, the guess <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">b'</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> of the adversary is independent of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">b</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">"<span class="skolem"><span class="skolem">game<span class="hidden">⇩</span><sub>3</sub></span></span> <span class="var"><span class="var">?f</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, 
so the first boolean returned by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> [source] <span class="quoted"><span class="quoted">"<span class="skolem"><span class="skolem">game<span class="hidden">⇩</span><sub>3</sub></span></span> <span class="var"><span class="var">?f'</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is just a coin flip.
›</span></span>
<span class="keyword1"><span class="command">have</span></span> game<span class="hidden">⇩</span><sub>3</sub>_bad<span class="main">:</span> <span class="quoted"><span class="quoted">"map_spmf snd <span class="main">(</span><span class="var">?sample</span> <span class="main">(</span><span class="skolem">game<span class="hidden">⇩</span><sub>3</sub></span> <span class="var">?f'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> lcdh.game <span class="main">(</span>elgamal_reduction <span class="free">𝒜</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="operator">-</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">bisim</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">bisim</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span> <span class="main">(</span><span class="bound">s</span> <span class="main">::</span> <span class="tfree">'grp</span> set<span class="main">,</span> <span class="bound">σ'</span> <span class="main">::</span> <span class="tfree">'grp</span> <span class="main">⇀</span> bitstring<span class="main">)</span><span class="main">.</span> <span class="bound">s</span> <span class="main">=</span> dom <span class="bound">σ</span> <span class="main">∧</span> <span class="bound">σ</span> <span class="main">=</span> <span class="bound">σ'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">bisim</span> Map_empty <span class="main">(</span><span class="main">{}</span><span class="main">,</span> Map_empty<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bisim_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">bisim</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> rel_spmf <span class="main">(</span>rel_prod <span class="main">(=)</span> <span class="skolem">bisim</span><span class="main">)</span><span class="main">)</span> ro.oracle <span class="skolem">oracle'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oracle'_def split_def spmf_rel_map ro.oracle_def rel_fun_def bisim_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_spmf_bind_reflI<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> * <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">bisim</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> dom fst"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bisim_def rel_fun_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> * <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">bisim</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span> snd"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def bisim_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">game<span class="hidden">⇩</span><sub>3</sub></span> <span class="var">?f'</span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
    <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="bound">msg1</span><span class="main">,</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="main">←</span> exec_gpv ro.oracle <span class="main">(</span><span class="skolem">𝒜<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span> ro.initial<span class="main">;</span>
    <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span>valid_plains <span class="bound">msg1</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">h'</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len_plain</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">cipher</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">y</span><span class="main">,</span> <span class="bound">h'</span><span class="main">)</span><span class="main">;</span>
      <span class="main">(</span><span class="bound">b'</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">←</span> exec_gpv ro.oracle <span class="main">(</span><span class="skolem">𝒜<span class="hidden">⇩</span><sub>2</sub></span> <span class="bound">cipher</span> <span class="bound">σ</span><span class="main">)</span> <span class="bound">s</span><span class="main">;</span>
      return_spmf <span class="main">(</span><span class="bound">b'</span> <span class="main">=</span> <span class="bound">b</span><span class="main">,</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">*</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> dom <span class="bound">s'</span><span class="main">)</span>
    <span class="main">}</span> <span class="keyword1">ELSE</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>
      return_spmf <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">*</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> dom <span class="bound">s</span><span class="main">)</span>
    <span class="main">}</span>
  <span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
    <span class="keyword1"><span class="command">unfolding</span></span> game<span class="hidden">⇩</span><sub>3</sub>_def Map_empty_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> split_def fst_conv snd_conv prod.collapse
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">𝒢</span></span> <span class="quoted"><span class="free">len_plain</span></span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="skolem">y</span></span><span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_spmf snd <span class="main">(</span><span class="main">…</span> <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">zs</span> <span class="main">←</span> elgamal_reduction <span class="free">𝒜</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">y</span><span class="main">)</span><span class="main">;</span>
      return_spmf <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">*</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="bound">zs</span><span class="main">)</span>
    <span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def split_def map_try_spmf map_scale_spmf<span class="main">)</span>
      <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def map_try_spmf map_scale_spmf map_spmf_conv_bind_spmf<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> spmf.map_comp map_const_spmf_of_set<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def lcdh.game_def Let_def lcdh.nat_pow_pow<span class="main">)</span> 
<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">have</span></span> game<span class="hidden">⇩</span><sub>3</sub>_guess<span class="main">:</span> <span class="quoted"><span class="quoted">"map_spmf fst <span class="main">(</span><span class="skolem">game<span class="hidden">⇩</span><sub>3</sub></span> <span class="var">?f'</span> <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">=</span> coin_spmf"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">%</span>invisible <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_spmf fst <span class="main">(</span><span class="skolem">game<span class="hidden">⇩</span><sub>3</sub></span> <span class="var">?f'</span> <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="bound">msg1</span><span class="main">,</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">s_h</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">oracle'</span> <span class="main">(</span><span class="skolem">𝒜<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">{}</span><span class="main">,</span> ro.initial<span class="main">)</span><span class="main">;</span>
    <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span>valid_plains <span class="bound">msg1</span> <span class="bound">msg2</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">h'</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>nlists UNIV <span class="free">len_plain</span><span class="main">)</span><span class="main">;</span>
      <span class="main">(</span><span class="bound">b'</span><span class="main">,</span> <span class="main">(</span><span class="bound">s'</span><span class="main">,</span> <span class="bound">s_h'</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> exec_gpv <span class="skolem">oracle'</span> <span class="main">(</span><span class="skolem">𝒜<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">y</span><span class="main">,</span> <span class="bound">h'</span><span class="main">)</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">s_h</span><span class="main">)</span><span class="main">;</span>
      map_spmf <span class="main">(</span><span class="main">(=)</span> <span class="bound">b'</span><span class="main">)</span> coin_spmf
    <span class="main">}</span> <span class="keyword1">ELSE</span> coin_spmf
  <span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">y</span> 
    <span class="keyword1"><span class="command">including</span></span> monad_normalisation
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> game<span class="hidden">⇩</span><sub>3</sub>_def o_def split_def map_spmf_conv_bind_spmf try_spmf_bind_out weight_spmf_le_1 scale_bind_spmf try_spmf_bind_out1 bind_scale_spmf<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def <span class="dynamic"><span class="dynamic">if_distribs</span></span> spmf.map_comp map_eq_const_coin_spmf split_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Combining several game hops \label{section:combining:hops}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Finally, we combine all the (in)equalities of the previous steps to obtain the desired bound
using the lemmas for reasoning about reals from Isabelle's library.
›</span></span>
<span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ind_cpa.advantage <span class="main">(</span>ro.oracle<span class="main">,</span> ro.initial<span class="main">)</span> <span class="free">𝒜</span> <span class="main">=</span> <span class="main">¦</span>spmf <span class="main">(</span>map_spmf fst <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span><span class="main">)</span> True <span class="main">-</span> <span class="main">1</span> <span class="main">/</span> <span class="numeral">2</span><span class="main">¦</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> ind_cpa_game_eq_game<span class="hidden">⇩</span><sub>0</sub> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> game<span class="hidden">⇩</span><sub>0</sub>_game<span class="hidden">⇩</span><sub>1</sub> o_def<span class="main">)</span>
<span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">¦</span><span class="main">1</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">-</span> spmf <span class="main">(</span>map_spmf fst <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span><span class="main">)</span> True<span class="main">¦</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> abs_minus_commute<span class="main">)</span>
<span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">/</span> <span class="numeral">2</span> <span class="main">=</span> spmf <span class="main">(</span>map_spmf fst <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span> True"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> game<span class="hidden">⇩</span><sub>2</sub>_game<span class="hidden">⇩</span><sub>3</sub> game<span class="hidden">⇩</span><sub>3</sub> o_def game<span class="hidden">⇩</span><sub>3</sub>_guess spmf_of_set<span class="main">)</span>
<span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¦</span><span class="main">…</span> <span class="main">-</span> spmf <span class="main">(</span>map_spmf fst <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span><span class="main">)</span> True<span class="main">¦</span> <span class="main">≤</span> spmf <span class="main">(</span>map_spmf snd <span class="main">(</span><span class="var">?sample</span> <span class="skolem">game<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span> True"</span></span> 
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> hop12<span class="main">)</span>
<span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> lcdh.advantage <span class="main">(</span>elgamal_reduction <span class="free">𝒜</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> game<span class="hidden">⇩</span><sub>2</sub>_game<span class="hidden">⇩</span><sub>3</sub> game<span class="hidden">⇩</span><sub>3</sub> game<span class="hidden">⇩</span><sub>3</sub>_bad lcdh.advantage_def o_def <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> map_bind_spmf<span class="main">)</span>
<span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
This completes the concrete proof and we can end the locale <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">locale</span></span> hashed_elgamal<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Asymptotic security \label{section:asymptotic}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
An asymptotic security statement can be easily derived from a concrete security theorem.
This is done in two steps:
First, we have to introduce a security parameter <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">η</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> into the definitions and assumptions.
Only then can we state asymptotic security.
The proof is easy given the concrete security theorem.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Introducing a security parameter›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Since all our definitions were done in locales, it is easy to introduce a security parameter after the fact.
To that end, we define copies of all locales where their parameters now take the security parameter as an additional argument.
We illustrate it for the locale <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">locale</span></span> ind_cpa_pk<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

The <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> sublocale<span class="antiquote"><span class="antiquote">}</span></span></span></span> command brings all the definitions and theorems of the original <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">locale</span></span> ind_cpa_pk<span class="antiquote"><span class="antiquote">}</span></span></span></span> into the copy and adds the security parameter where necessary.
The type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">security</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is a synonym for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">nat</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>
<span class="keyword1"><span class="command">locale</span></span> ind_cpa_pk' <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">key_gen</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'pubkey</span> <span class="main">×</span> <span class="tfree">'privkey</span><span class="main">,</span> <span class="tfree">'query</span><span class="main">,</span> <span class="tfree">'response</span><span class="main">)</span> gpv"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">encrypt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="tfree">'pubkey</span> <span class="main">⇒</span> <span class="tfree">'plain</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'cipher</span><span class="main">,</span> <span class="tfree">'query</span><span class="main">,</span> <span class="tfree">'response</span><span class="main">)</span> gpv"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">decrypt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="tfree">'privkey</span> <span class="main">⇒</span> <span class="tfree">'cipher</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'query</span><span class="main">,</span> <span class="tfree">'response</span><span class="main">)</span> gpv"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">valid_plains</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="tfree">'plain</span> <span class="main">⇒</span> <span class="tfree">'plain</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">sublocale</span></span> ind_cpa_pk <span class="quoted"><span class="quoted">"<span class="free">key_gen</span> <span class="free">η</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">encrypt</span> <span class="free">η</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">decrypt</span> <span class="free">η</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">valid_plains</span> <span class="free">η</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">η</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> <span class="main">%</span>invisible list_cdh' <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">𝒢</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="tfree">'grp</span> cyclic_group"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> cyclic_group<span class="main">:</span> <span class="quoted"><span class="quoted">"cyclic_group <span class="main">(</span><span class="free">𝒢</span> <span class="free">η</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">sublocale</span></span> <span class="main">%</span>invisible cyclic_group <span class="quoted"><span class="quoted">"<span class="free">𝒢</span> <span class="free">η</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">η</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> cyclic_group<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="main">%</span>invisible

<span class="keyword1"><span class="command">locale</span></span> <span class="main">%</span>invisible random_oracle' <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">len</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> nat"</span></span> 
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">sublocale</span></span> <span class="main">%</span>invisible random_oracle <span class="quoted"><span class="quoted">"<span class="free">len</span> <span class="free">η</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">η</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="main">%</span>invisible

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> ind_cpa_pk<span class="main">)</span> advantage_nonneg<span class="main">:</span> <span class="quoted"><span class="quoted">"advantage <span class="free">oracle</span> <span class="free">𝒜</span> <span class="main">≥</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">oracle</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">%</span>invisible <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> list_cdh<span class="main">)</span> advantage_nonneg<span class="main">:</span> <span class="quoted"><span class="quoted">"advantage <span class="free">𝒜</span> <span class="main">≥</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> advantage_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
We do so similarly for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">locale</span></span> list_cdh<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">locale</span></span> random_oracle<span class="antiquote"><span class="antiquote">}</span></span></span></span>, and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">locale</span></span> hashed_elgamal<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">locale</span></span> hashed_elgamal' <span class="main">=</span>
  lcdh<span class="main">:</span> list_cdh' <span class="quoted"><span class="free">𝒢</span></span> <span class="main">+</span>
  ro<span class="main">:</span> random_oracle' <span class="quoted"><span class="free">len_plain</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">𝒢</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> <span class="tfree">'grp</span> cyclic_group"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">len_plain</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"security <span class="main">⇒</span> nat"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">sublocale</span></span> hashed_elgamal <span class="quoted"><span class="quoted">"<span class="free">𝒢</span> <span class="free">η</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">len_plain</span> <span class="free">η</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">η</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Asymptotic security statements \label{section:security:asymptotic}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
For asymptotic security statements, \CryptHOL{} defines the predicate <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">negligible</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
It states that the given real-valued function approaches 0 faster than the inverse of any polynomial.
A concrete security statement translates into an asymptotic one as follows:
\begin{itemize}
\item All advantages in the bound become negligibility assumptions.
\item All side conditions of the concrete security theorems remain assumptions, but wrapped into an <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">eventually</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> statement.
  This expresses that the side condition holds eventually, i.e., there is a security parameter from which on it holds.
\item The conclusion is that the bounded advantage is <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">negligible</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
\end{itemize}
›</span></span>
<span class="keyword1"><span class="command">theorem</span></span> asymptotic_security_elgamal<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"negligible <span class="main">(</span><span class="main">λ</span><span class="bound">η</span><span class="main">.</span> lcdh.advantage <span class="bound">η</span> <span class="main">(</span>elgamal_reduction <span class="bound">η</span> <span class="main">(</span><span class="free">𝒜</span> <span class="bound">η</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"eventually <span class="main">(</span><span class="main">λ</span><span class="bound">η</span><span class="main">.</span> ind_cpa.lossless <span class="main">(</span><span class="free">𝒜</span> <span class="bound">η</span><span class="main">)</span><span class="main">)</span> at_top"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"negligible <span class="main">(</span><span class="main">λ</span><span class="bound">η</span><span class="main">.</span> ind_cpa.advantage <span class="bound">η</span> <span class="main">(</span>ro.oracle <span class="bound">η</span><span class="main">,</span> ro.initial<span class="main">)</span> <span class="main">(</span><span class="free">𝒜</span> <span class="bound">η</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
The proof is canonical, too:
Using the lemmas about <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">negligible</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and Eberl's library for asymptotic reasoning~\cite{Eberl2015},
we transform the asymptotic statement into a concrete one and then simply use the concrete security statement.
›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> negligible_mono<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> landau_o.big_mono<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> eventually_rev_mp<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">intro</span> eventuallyI impI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> ind_cpa.advantage.simps <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ind_cpa.advantage_nonneg lcdh.advantage_nonneg<span class="main">)</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> concrete_security_elgamal<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="main">%</span>invisible
</pre>
</div>