<div id="Diffie_Hellman">
<div class="head"><h1>Theory Diffie_Hellman</h1>
<span class="command">theory</span> <span class="name">Diffie_Hellman</span><br/>
<span class="keyword">imports</span> <a href="../CryptHOL/Cyclic_Group_SPMF.html"><span class="name">Cyclic_Group_SPMF</span></a> <a href="../CryptHOL/Computational_Model.html"><span class="name">Computational_Model</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: Diffie_Hellman.thy
  Author: Andreas Lochbihler, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Specifying security using games›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Diffie_Hellman</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>CryptHOL.Cyclic_Group_SPMF</span><span>
</span><span>  </span><span>CryptHOL.Computational_Model</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The DDH game›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>ddh</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>𝒢</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp cyclic_group"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'grp'</span><span> </span><span>adversary</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp' ⇒ 'grp' ⇒ 'grp' ⇒ bool spmf"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ddh_0</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp adversary ⇒ bool spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ddh_0 𝒜 = do {
     x ← sample_uniform (order 𝒢);
     y ← sample_uniform (order 𝒢);
     𝒜 (<span class="hidden">❙</span><span class="bold">g</span> [^] x) (<span class="hidden">❙</span><span class="bold">g</span> [^] y) (<span class="hidden">❙</span><span class="bold">g</span> [^] (x * y))
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ddh_1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp adversary ⇒ bool spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ddh_1 𝒜 = do {
     x ← sample_uniform (order 𝒢);
     y ← sample_uniform (order 𝒢);
     z ← sample_uniform (order 𝒢);
     𝒜 (<span class="hidden">❙</span><span class="bold">g</span> [^] x) (<span class="hidden">❙</span><span class="bold">g</span> [^] y) (<span class="hidden">❙</span><span class="bold">g</span> [^] z)
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>advantage</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp adversary ⇒ real"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"advantage 𝒜 = ¦spmf (ddh_0 𝒜) True - spmf (ddh_1 𝒜) True¦"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lossless</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp adversary ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless 𝒜 ⟷ (∀α β γ. lossless_spmf (𝒜 α β γ))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lossless_ddh_0</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ lossless 𝒜; 0 &lt; order 𝒢 ⟧
  ⟹ lossless_spmf (ddh_0 𝒜)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lossless_def</span><span> </span><span>ddh_0_def</span><span> </span><span>split_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lossless_ddh_1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ lossless 𝒜; 0 &lt; order 𝒢 ⟧
  ⟹ lossless_spmf (ddh_1 𝒜)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lossless_def</span><span> </span><span>ddh_1_def</span><span> </span><span>split_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The LCDH game›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>lcdh</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>𝒢</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp cyclic_group"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'grp'</span><span> </span><span>adversary</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp' ⇒ 'grp' ⇒ 'grp' set spmf"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lcdh</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp adversary ⇒ bool spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lcdh 𝒜 = do { 
     x ← sample_uniform (order 𝒢);
     y ← sample_uniform (order 𝒢);
     zs ← 𝒜 (<span class="hidden">❙</span><span class="bold">g</span> [^] x) (<span class="hidden">❙</span><span class="bold">g</span> [^] y);
     return_spmf (<span class="hidden">❙</span><span class="bold">g</span> [^] (x * y) ∈ zs)
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>advantage</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp adversary ⇒ real"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"advantage 𝒜 = spmf (lcdh 𝒜) True"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lossless</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp adversary ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless 𝒜 ⟷ (∀α β. lossless_spmf (𝒜 α β))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lossless_lcdh</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ lossless 𝒜; 0 &lt; order 𝒢 ⟧
  ⟹ lossless_spmf (lcdh 𝒜)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lossless_def</span><span> </span><span>lcdh_def</span><span> </span><span>split_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="IND_CCA2">
<div class="head"><h1>Theory IND_CCA2</h1>
<span class="command">theory</span> <span class="name">IND_CCA2</span><br/>
<span class="keyword">imports</span> <a href="../CryptHOL/Computational_Model.html"><span class="name">Computational_Model</span></a> <a href="../CryptHOL/Negligible.html"><span class="name">Negligible</span></a> <a href="../CryptHOL/Environment_Functor.html"><span class="name">Environment_Functor</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: IND_CCA2.thy
  Author: Andreas Lochbihler, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>IND_CCA2</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>CryptHOL.Computational_Model</span><span>
</span><span>  </span><span>CryptHOL.Negligible</span><span>
</span><span>  </span><span>CryptHOL.Environment_Functor</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>pk_enc</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>key_gen</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ ('ekey × 'dkey) spmf"</span></span></span><span> </span><span class="comment">― ‹probabilistic›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>encrypt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ 'ekey ⇒ 'plain ⇒ 'cipher spmf"</span></span></span><span>  </span><span class="comment">― ‹probabilistic›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>decrypt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ 'dkey ⇒ 'cipher ⇒ 'plain option"</span></span></span><span> </span><span class="comment">― ‹deterministic, but not used›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>valid_plain</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ 'plain ⇒ bool"</span></span></span><span> </span><span class="comment">― ‹checks whether a plain text is valid, i.e., has the right format›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The IND-CCA2 game for public-key encryption›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  We model an IND-CCA2 security game in the multi-user setting as described in
  \cite{BellareBoldyrevaMicali2000EUROCRYPT}.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>ind_cca2</span><span> </span><span class="delimiter">=</span><span> </span><span>pk_enc</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">constrains</span></span><span> </span><span>key_gen</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ ('ekey × 'dkey) spmf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>encrypt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ 'ekey ⇒ 'plain ⇒ 'cipher spmf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>decrypt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ 'dkey ⇒ 'cipher ⇒ 'plain option"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>valid_plain</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ 'plain ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'ekey'</span><span class="delimiter">,</span><span> </span><span class="tfree">'dkey'</span><span class="delimiter">,</span><span> </span><span class="tfree">'cipher'</span><span class="delimiter">)</span><span> </span><span>state_oracle</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('ekey' × 'dkey' × 'cipher' list) option"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>decrypt_oracle</span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ ('ekey, 'dkey, 'cipher) state_oracle ⇒ 'cipher
  ⇒ ('plain option × ('ekey, 'dkey, 'cipher) state_oracle) spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"decrypt_oracle η None cipher = return_spmf (None, None)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"decrypt_oracle η (Some (ekey, dkey, cstars)) cipher = return_spmf
   (if cipher ∈ set cstars then None else decrypt η dkey cipher, Some (ekey, dkey, cstars))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>ekey_oracle</span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ ('ekey, 'dkey, 'cipher) state_oracle ⇒ unit ⇒ ('ekey × ('ekey, 'dkey, 'cipher) state_oracle) spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ekey_oracle η None _ = do {
      (ekey, dkey) ← key_gen η;
      return_spmf (ekey, Some (ekey, dkey, []))
    }"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ekey_oracle η (Some (ekey, rest)) _ = return_spmf (ekey, Some (ekey, rest))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ekey_oracle_conv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ekey_oracle η σ x =
  (case σ of None ⇒ map_spmf (λ(ekey, dkey). (ekey, Some (ekey, dkey, []))) (key_gen η) 
   | Some (ekey, rest) ⇒ return_spmf (ekey, Some (ekey, rest)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>σ</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>map_spmf_conv_bind_spmf</span><span> </span><span>split_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>bind_spmf_cong</span><span class="delimiter">[</span><span>fundef_cong</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span>encrypt_oracle</span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"bool ⇒ security ⇒ ('ekey, 'dkey, 'cipher) state_oracle ⇒ 'plain × 'plain
  ⇒ ('cipher × ('ekey, 'dkey, 'cipher) state_oracle) spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"encrypt_oracle b η None m01 = do { (_, σ) ← ekey_oracle η None (); encrypt_oracle b η σ m01 }"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"encrypt_oracle b η (Some (ekey, dkey, cstars)) (m0, m1) =
  (if valid_plain η m0 ∧ valid_plain η m1 then do {  
     let pb = (if b then m0 else m1);
     cstar ← encrypt η ekey pb;
     return_spmf (cstar, Some (ekey, dkey, cstar # cstars))
   } else return_pmf None)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>pat_completeness</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">termination</span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>relation</span><span> </span><span class="string"><span class="delete"><span class="delete">"Wellfounded.measure (λ(b, η, σ, m01). case σ of None ⇒ 1 | _ ⇒ 0)"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Single-user setting›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'plain'</span><span class="delimiter">,</span><span> </span><span class="tfree">'cipher'</span><span class="delimiter">)</span><span> </span><span>call<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"unit + 'cipher' + 'plain' × 'plain'"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'ekey'</span><span class="delimiter">,</span><span> </span><span class="tfree">'plain'</span><span class="delimiter">,</span><span> </span><span class="tfree">'cipher'</span><span class="delimiter">)</span><span> </span><span>ret<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ekey' + 'plain' option + 'cipher'"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>oracle<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"bool ⇒ security 
  ⇒ (('ekey, 'dkey, 'cipher) state_oracle, ('plain, 'cipher) call<span class="hidden">⇩</span><sub>1</sub>, ('ekey, 'plain, 'cipher) ret<span class="hidden">⇩</span><sub>1</sub>) oracle'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"oracle<span class="hidden">⇩</span><sub>1</sub> b η = ekey_oracle η ⊕<span class="hidden">⇩</span><sub>O</sub> (decrypt_oracle η ⊕<span class="hidden">⇩</span><sub>O</sub> encrypt_oracle b η)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>oracle<span class="hidden">⇩</span><sub>1</sub>_simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"oracle<span class="hidden">⇩</span><sub>1</sub> b η s (Inl x) = map_spmf (apfst Inl) (ekey_oracle η s x)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"oracle<span class="hidden">⇩</span><sub>1</sub> b η s (Inr (Inl y)) = map_spmf (apfst (Inr ∘ Inl)) (decrypt_oracle η s y)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"oracle<span class="hidden">⇩</span><sub>1</sub> b η s (Inr (Inr z)) = map_spmf (apfst (Inr ∘ Inr)) (encrypt_oracle b η s z)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle<span class="hidden">⇩</span><sub>1</sub>_def</span><span> </span><span>spmf.map_comp</span><span> </span><span>apfst_compose</span><span> </span><span>o_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'ekey'</span><span class="delimiter">,</span><span> </span><span class="tfree">'plain'</span><span class="delimiter">,</span><span> </span><span class="tfree">'cipher'</span><span class="delimiter">)</span><span> </span><span>adversary<span class="hidden">⇩</span><sub>1</sub>'</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(bool, ('plain', 'cipher') call<span class="hidden">⇩</span><sub>1</sub>, ('ekey', 'plain', 'cipher') ret<span class="hidden">⇩</span><sub>1</sub>) gpv"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'ekey'</span><span class="delimiter">,</span><span> </span><span class="tfree">'plain'</span><span class="delimiter">,</span><span> </span><span class="tfree">'cipher'</span><span class="delimiter">)</span><span> </span><span>adversary<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"security ⇒ ('ekey', 'plain', 'cipher') adversary<span class="hidden">⇩</span><sub>1</sub>'"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ind_cca2<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('ekey, 'plain, 'cipher) adversary<span class="hidden">⇩</span><sub>1</sub> ⇒ security ⇒ bool spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ind_cca2<span class="hidden">⇩</span><sub>1</sub> 𝒜 η = TRY do {
    b ← coin_spmf;
    (guess, s) ← exec_gpv (oracle<span class="hidden">⇩</span><sub>1</sub> b η) (𝒜 η) None;
    return_spmf (guess = b)
  } ELSE coin_spmf"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>advantage<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('ekey, 'plain, 'cipher) adversary<span class="hidden">⇩</span><sub>1</sub> ⇒ advantage"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"advantage<span class="hidden">⇩</span><sub>1</sub> 𝒜 η = ¦spmf (ind_cca2<span class="hidden">⇩</span><sub>1</sub> 𝒜 η) True - 1/2¦"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>advantage<span class="hidden">⇩</span><sub>1</sub>_nonneg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"advantage<span class="hidden">⇩</span><sub>1</sub> 𝒜 η ≥ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>advantage<span class="hidden">⇩</span><sub>1</sub>_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>secure_for<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('ekey, 'plain, 'cipher) adversary<span class="hidden">⇩</span><sub>1</sub> ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"secure_for<span class="hidden">⇩</span><sub>1</sub> 𝒜 ≡ negligible (advantage<span class="hidden">⇩</span><sub>1</sub> 𝒜)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ibounded_by<span class="hidden">⇩</span><sub>1</sub>'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('ekey, 'plain, 'cipher) adversary<span class="hidden">⇩</span><sub>1</sub>' ⇒ nat ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ibounded_by<span class="hidden">⇩</span><sub>1</sub>' 𝒜 q = interaction_any_bounded_by 𝒜 q"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>ibounded_by<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('ekey, 'plain, 'cipher) adversary<span class="hidden">⇩</span><sub>1</sub> ⇒ (security ⇒ nat) ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ibounded_by<span class="hidden">⇩</span><sub>1</sub> ≡ rel_envir ibounded_by<span class="hidden">⇩</span><sub>1</sub>'"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lossless<span class="hidden">⇩</span><sub>1</sub>'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('ekey, 'plain, 'cipher) adversary<span class="hidden">⇩</span><sub>1</sub>' ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless<span class="hidden">⇩</span><sub>1</sub>' 𝒜 = lossless_gpv ℐ_full 𝒜"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>lossless<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('ekey, 'plain, 'cipher) adversary<span class="hidden">⇩</span><sub>1</sub> ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless<span class="hidden">⇩</span><sub>1</sub> ≡ pred_envir lossless<span class="hidden">⇩</span><sub>1</sub>'"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lossless_decrypt_oracle</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_spmf (decrypt_oracle η σ cipher)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(η, σ, cipher)"</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>decrypt_oracle.cases</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lossless_ekey_oracle</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lossless_spmf (ekey_oracle η σ x) ⟷ (σ = None ⟶ lossless_spmf (key_gen η))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(η, σ, x)"</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>ekey_oracle.cases</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lossless_encrypt_oracle</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ σ = None ⟹ lossless_spmf (key_gen η);
    ⋀ekey m. valid_plain η m ⟹ lossless_spmf (encrypt η ekey m) ⟧
  ⟹ lossless_spmf (encrypt_oracle b η σ (m0, m1)) ⟷ valid_plain η m0 ∧ valid_plain η m1"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(b, η, σ, (m0, m1))"</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>encrypt_oracle.cases</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>split_beta</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>lossless_spmfD_set_spmf_nonempty</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Multi-user setting›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>oracle<span class="hidden">⇩</span><sub>n</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"bool ⇒ security
   ⇒ ('i ⇒ ('ekey, 'dkey, 'cipher) state_oracle, 'i × ('plain, 'cipher) call<span class="hidden">⇩</span><sub>1</sub>, ('ekey, 'plain, 'cipher) ret<span class="hidden">⇩</span><sub>1</sub>) oracle'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"oracle<span class="hidden">⇩</span><sub>n</sub> b η = family_oracle (λ_. oracle<span class="hidden">⇩</span><sub>1</sub> b η)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>oracle<span class="hidden">⇩</span><sub>n</sub>_apply</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"oracle<span class="hidden">⇩</span><sub>n</sub> b η s (i, x) = map_spmf (apsnd (fun_upd s i)) (oracle<span class="hidden">⇩</span><sub>1</sub> b η (s i) x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle<span class="hidden">⇩</span><sub>n</sub>_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'i</span><span class="delimiter">,</span><span> </span><span class="tfree">'ekey'</span><span class="delimiter">,</span><span> </span><span class="tfree">'plain'</span><span class="delimiter">,</span><span> </span><span class="tfree">'cipher'</span><span class="delimiter">)</span><span> </span><span>adversary<span class="hidden">⇩</span><sub>n</sub>'</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(bool, 'i × ('plain', 'cipher') call<span class="hidden">⇩</span><sub>1</sub>, ('ekey', 'plain', 'cipher') ret<span class="hidden">⇩</span><sub>1</sub>) gpv"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'i</span><span class="delimiter">,</span><span> </span><span class="tfree">'ekey'</span><span class="delimiter">,</span><span> </span><span class="tfree">'plain'</span><span class="delimiter">,</span><span> </span><span class="tfree">'cipher'</span><span class="delimiter">)</span><span> </span><span>adversary<span class="hidden">⇩</span><sub>n</sub></span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"security ⇒ ('i, 'ekey', 'plain', 'cipher') adversary<span class="hidden">⇩</span><sub>n</sub>'"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ind_cca2<span class="hidden">⇩</span><sub>n</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('i, 'ekey, 'plain, 'cipher) adversary<span class="hidden">⇩</span><sub>n</sub> ⇒ security ⇒ bool spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ind_cca2<span class="hidden">⇩</span><sub>n</sub> 𝒜 η = TRY do {
    b ← coin_spmf;
    (guess, σ) ← exec_gpv (oracle<span class="hidden">⇩</span><sub>n</sub> b η) (𝒜 η) (λ_. None);
    return_spmf (guess = b)
  } ELSE coin_spmf"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>advantage<span class="hidden">⇩</span><sub>n</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('i, 'ekey, 'plain, 'cipher) adversary<span class="hidden">⇩</span><sub>n</sub> ⇒ advantage"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"advantage<span class="hidden">⇩</span><sub>n</sub> 𝒜 η = ¦spmf (ind_cca2<span class="hidden">⇩</span><sub>n</sub> 𝒜 η) True - 1/2¦"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>advantage<span class="hidden">⇩</span><sub>n</sub>_nonneg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"advantage<span class="hidden">⇩</span><sub>n</sub> 𝒜 η ≥ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>advantage<span class="hidden">⇩</span><sub>n</sub>_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>secure_for<span class="hidden">⇩</span><sub>n</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('i, 'ekey, 'plain, 'cipher) adversary<span class="hidden">⇩</span><sub>n</sub> ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"secure_for<span class="hidden">⇩</span><sub>n</sub> 𝒜 ≡ negligible (advantage<span class="hidden">⇩</span><sub>n</sub> 𝒜)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ibounded_by<span class="hidden">⇩</span><sub>n</sub>'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('i, 'ekey, 'plain, 'cipher) adversary<span class="hidden">⇩</span><sub>n</sub>' ⇒ nat ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ibounded_by<span class="hidden">⇩</span><sub>n</sub>' 𝒜 q = interaction_any_bounded_by 𝒜 q"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>ibounded_by<span class="hidden">⇩</span><sub>n</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('i, 'ekey, 'plain, 'cipher) adversary<span class="hidden">⇩</span><sub>n</sub> ⇒ (security ⇒ nat) ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ibounded_by<span class="hidden">⇩</span><sub>n</sub> ≡ rel_envir ibounded_by<span class="hidden">⇩</span><sub>n</sub>'"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lossless<span class="hidden">⇩</span><sub>n</sub>'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('i, 'ekey, 'plain, 'cipher) adversary<span class="hidden">⇩</span><sub>n</sub>' ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless<span class="hidden">⇩</span><sub>n</sub>' 𝒜 = lossless_gpv ℐ_full 𝒜"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>lossless<span class="hidden">⇩</span><sub>n</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('i, 'ekey, 'plain, 'cipher) adversary<span class="hidden">⇩</span><sub>n</sub> ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless<span class="hidden">⇩</span><sub>n</sub> ≡ pred_envir lossless<span class="hidden">⇩</span><sub>n</sub>'"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cipher_queries</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('i ⇒ ('ekey, 'dkey, 'cipher) state_oracle) ⇒ 'cipher set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cipher_queries ose = (⋃(_, _, ciphers)∈ran ose. set ciphers)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cipher_queriesI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ ose n = Some (ek, dk, ciphers); x ∈ set ciphers ⟧ ⟹ x ∈ cipher_queries ose"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cipher_queries_def</span><span> </span><span>ran_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cipher_queriesE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ cipher_queries ose"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span class="delimiter">(</span><span>cipher_queries</span><span class="delimiter">)</span><span> </span><span>n</span><span> </span><span>ek</span><span> </span><span>dk</span><span> </span><span>ciphers</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ose n = Some (ek, dk, ciphers)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ set ciphers"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cipher_queries_def</span><span> </span><span>ran_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cipher_queries_updE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ cipher_queries (ose(n ↦ (ek, dk, ciphers)))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span class="delimiter">(</span><span>old</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ cipher_queries ose"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ set ciphers"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>new</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ set ciphers"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ set ciphers"</span></span></span><span class="delimiter">)</span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>cipher_queriesE</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>cipher_queriesI</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cipher_queries_empty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cipher_queries Map.empty = {}"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cipher_queries_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="IND_CCA2_sym">
<div class="head"><h1>Theory IND_CCA2_sym</h1>
<span class="command">theory</span> <span class="name">IND_CCA2_sym</span><br/>
<span class="keyword">imports</span> <a href="../CryptHOL/Computational_Model.html"><span class="name">Computational_Model</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: IND_CCA2_sym.thy
  Author: Andreas Lochbihler, ETH Zurich 
  Author: S. Reza Sefidgar, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The IND-CCA2 security for symmetric encryption schemes›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>IND_CCA2_sym</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>CryptHOL.Computational_Model</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>ind_cca</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>key_gen</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'key spmf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>encrypt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'key ⇒ 'message ⇒ 'cipher spmf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>decrypt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'key ⇒ 'cipher ⇒ 'message option"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>msg_predicate</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'message ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'message'</span><span class="delimiter">,</span><span> </span><span class="tfree">'cipher'</span><span class="delimiter">)</span><span> </span><span>adversary</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(bool, 'message' × 'message' + 'cipher', 'cipher' option + 'message' option) gpv"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>oracle_encrypt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'key ⇒ bool ⇒ ('message × 'message, 'cipher option, 'cipher set) callee"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"oracle_encrypt k b L = (λ(msg1, msg0).
     (case msg_predicate msg1 ∧ msg_predicate msg0 of
        True ⇒ do {
         c ← encrypt k (if b then msg1 else msg0);
         return_spmf (Some c, {c} ∪ L)
        }
     | False ⇒ return_spmf (None, L)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lossless_oracle_encrypt</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_spmf (encrypt k m1)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_spmf (encrypt k m0)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_spmf (oracle_encrypt k b L (m1, m0))"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle_encrypt_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>bool.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>oracle_decrypt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'key ⇒ ('cipher, 'message option, 'cipher set) callee"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"oracle_decrypt k L c = return_spmf (if c ∈ L then None else decrypt k c, L)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lossless_oracle_decrypt</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_spmf (oracle_decrypt k L c)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle_decrypt_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>game</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('message, 'cipher) adversary ⇒ bool spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"game 𝒜 = do {
    key ← key_gen;
    b ← coin_spmf;
    (b', L') ← exec_gpv (oracle_encrypt key b ⊕<span class="hidden">⇩</span><sub>O</sub> oracle_decrypt key) 𝒜 {};
    return_spmf (b = b')
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>advantage</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('message, 'cipher) adversary ⇒ real"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"advantage 𝒜 = ¦spmf (game 𝒜) True - 1 / 2¦"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>advantage_nonneg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ advantage 𝒜"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>advantage_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="IND_CPA">
<div class="head"><h1>Theory IND_CPA</h1>
<span class="command">theory</span> <span class="name">IND_CPA</span><br/>
<span class="keyword">imports</span> <a href="../CryptHOL/Computational_Model.html"><span class="name">Computational_Model</span></a> <a href="../CryptHOL/Negligible.html"><span class="name">Negligible</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: IND_CPA.thy
  Author: Andreas Lochbihler, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>IND_CPA</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>CryptHOL.Generative_Probabilistic_Value</span><span>
</span><span>  </span><span>CryptHOL.Computational_Model</span><span>
</span><span>  </span><span>CryptHOL.Negligible</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The IND-CPA game for symmetric encryption schemes›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>ind_cpa</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>key_gen</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'key spmf"</span></span></span><span> </span><span class="comment">― ‹probabilistic›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>encrypt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'key ⇒ 'plain ⇒ 'cipher spmf"</span></span></span><span>  </span><span class="comment">― ‹probabilistic›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>decrypt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'key ⇒ 'cipher ⇒ 'plain option"</span></span></span><span> </span><span class="comment">― ‹deterministic, but not used›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>valid_plain</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'plain ⇒ bool"</span></span></span><span> </span><span class="comment">― ‹checks whether a plain text is valid, i.e., has the right format›</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  We cannot incorporate the predicate @{term valid_plain} in the type @{typ "'plain"} of plaintexts,
  because the single @{typ "'plain"} must contain plaintexts for all values of the security parameter,
  as HOL does not have dependent types.  Consequently, the oracle has to ensure that the received
  plaintexts are valid.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'plain'</span><span class="delimiter">,</span><span> </span><span class="tfree">'cipher'</span><span class="delimiter">,</span><span> </span><span class="tfree">'state</span><span class="delimiter">)</span><span> </span><span>adversary</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(('plain' × 'plain') × 'state, 'plain', 'cipher') gpv
   × ('cipher' ⇒ 'state ⇒ (bool, 'plain', 'cipher') gpv)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>encrypt_oracle</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'key ⇒ unit ⇒ 'plain ⇒ ('cipher × unit) spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"encrypt_oracle key σ plain = do {
     cipher ← encrypt key plain;
     return_spmf (cipher, ())
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ind_cpa</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('plain, 'cipher, 'state) adversary ⇒ bool spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ind_cpa 𝒜 = do {
     let (𝒜1, 𝒜2) = 𝒜;
     key ← key_gen;
     b ← coin_spmf;
     (guess, _) ← exec_gpv (encrypt_oracle key) (do {
         ((m0, m1), σ) ← 𝒜1;
         if valid_plain m0 ∧ valid_plain m1 then do {
           cipher ← lift_spmf (encrypt key (if b then m0 else m1));
           𝒜2 cipher σ
         } else lift_spmf coin_spmf
       }) ();
     return_spmf (guess = b)
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>advantage</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('plain, 'cipher, 'state) adversary ⇒ real"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"advantage 𝒜 = ¦spmf (ind_cpa 𝒜) True - 1/2¦"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>advantage_nonneg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"advantage 𝒜 ≥ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>advantage_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ibounded_by</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('plain, 'cipher, 'state) adversary ⇒ enat ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ibounded_by = (λ(𝒜1, 𝒜2) q. 
  (∃q1 q2. interaction_any_bounded_by 𝒜1 q1 ∧ (∀cipher σ. interaction_any_bounded_by (𝒜2 cipher σ) q2) ∧ q1 + q2 ≤ q))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ibounded_byE</span><span> </span><span class="delimiter">[</span><span>consumes</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>ibounded_by</span><span class="delimiter">,</span><span> </span><span>elim</span><span class="delimiter">?</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ibounded_by (𝒜1, 𝒜2) q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>q1</span><span> </span><span>q2</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q1 + q2 ≤ q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"interaction_any_bounded_by 𝒜1 q1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀cipher σ. interaction_any_bounded_by (𝒜2 cipher σ) q2"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ibounded_by_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ibounded_byI</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">?</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ interaction_any_bounded_by 𝒜1 q1; ⋀cipher σ. interaction_any_bounded_by (𝒜2 cipher σ) q2; q1 + q2 ≤ q ⟧
  ⟹ ibounded_by (𝒜1, 𝒜2) q"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ibounded_by_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lossless</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('plain, 'cipher, 'state) adversary ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless = (λ(𝒜1, 𝒜2). lossless_gpv ℐ_full 𝒜1 ∧ (∀cipher σ. lossless_gpv ℐ_full (𝒜2 cipher σ)))"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="IND_CPA_PK">
<div class="head"><h1>Theory IND_CPA_PK</h1>
<span class="command">theory</span> <span class="name">IND_CPA_PK</span><br/>
<span class="keyword">imports</span> <a href="../CryptHOL/Computational_Model.html"><span class="name">Computational_Model</span></a> <a href="../CryptHOL/Negligible.html"><span class="name">Negligible</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: IND_CPA_PK.thy
  Author: Andreas Lochbihler, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>IND_CPA_PK</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>CryptHOL.Computational_Model</span><span>
</span><span>  </span><span>CryptHOL.Negligible</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The IND-CPA game for public-key encryption with oracle access›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>ind_cpa_pk</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>key_gen</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('pubkey × 'privkey, 'call, 'ret) gpv"</span></span></span><span> </span><span class="comment">― ‹probabilistic›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>aencrypt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'pubkey ⇒ 'plain ⇒ ('cipher, 'call, 'ret) gpv"</span></span></span><span>  </span><span class="comment">― ‹probabilistic w/ access to an oracle›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>adecrypt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'privkey ⇒ 'cipher ⇒ ('plain, 'call, 'ret) gpv"</span></span></span><span> </span><span class="comment">― ‹not used›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>valid_plains</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'plain ⇒ 'plain ⇒ bool"</span></span></span><span> </span><span class="comment">― ‹checks whether a pair of plaintexts is valid, i.e., they have the right format›</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  We cannot incorporate the predicate @{term valid_plain} in the type @{typ "'plain"} of plaintexts,
  because the single @{typ "'plain"} must contain plaintexts for all values of the security parameter,
  as HOL does not have dependent types.  Consequently, the game has to ensure that the received
  plaintexts are valid.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'pubkey'</span><span class="delimiter">,</span><span> </span><span class="tfree">'plain'</span><span class="delimiter">,</span><span> </span><span class="tfree">'cipher'</span><span class="delimiter">,</span><span> </span><span class="tfree">'call'</span><span class="delimiter">,</span><span> </span><span class="tfree">'ret'</span><span class="delimiter">,</span><span> </span><span class="tfree">'state</span><span class="delimiter">)</span><span> </span><span>adversary</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"('pubkey' ⇒ (('plain' × 'plain') × 'state, 'call', 'ret') gpv)
   × ('cipher' ⇒ 'state ⇒ (bool, 'call', 'ret') gpv)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>ind_cpa</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('pubkey, 'plain, 'cipher, 'call, 'ret, 'state) adversary ⇒ (bool, 'call, 'ret) gpv"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ind_cpa (𝒜1, 𝒜2) = TRY do {
     (pk, sk) ← key_gen;
     b ← lift_spmf coin_spmf;
     ((m0, m1), σ) ← (𝒜1 pk);
     assert_gpv (valid_plains m0 m1);
     cipher ← aencrypt pk (if b then m0 else m1);
     guess ← 𝒜2 cipher σ; 
     Done (guess = b)
   } ELSE lift_spmf coin_spmf"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>advantage</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('σ ⇒ 'call ⇒ ('ret × 'σ) spmf) ⇒ 'σ ⇒ ('pubkey, 'plain, 'cipher, 'call, 'ret, 'state) adversary ⇒ real"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"advantage oracle σ 𝒜 = ¦spmf (run_gpv oracle (ind_cpa 𝒜) σ) True - 1/2¦"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>advantage_nonneg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"advantage oracle σ 𝒜 ≥ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>advantage_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ibounded_by</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('call ⇒ bool) ⇒ ('pubkey, 'plain, 'cipher, 'call, 'ret, 'state) adversary ⇒ enat ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ibounded_by consider = (λ(𝒜1, 𝒜2) q. 
  (∃q1 q2. (∀pk. interaction_bounded_by consider (𝒜1 pk) q1) ∧ (∀cipher σ. interaction_bounded_by consider (𝒜2 cipher σ) q2) ∧ q1 + q2 ≤ q))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ibounded_by'E</span><span> </span><span class="delimiter">[</span><span>consumes</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>ibounded_by'</span><span class="delimiter">,</span><span> </span><span>elim</span><span class="delimiter">?</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ibounded_by consider (𝒜1, 𝒜2) q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>q1</span><span> </span><span>q2</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q1 + q2 ≤ q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀pk. interaction_bounded_by consider (𝒜1 pk) q1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀cipher σ. interaction_bounded_by consider (𝒜2 cipher σ) q2"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ibounded_by_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ibounded_byI</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">?</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ ⋀pk. interaction_bounded_by consider (𝒜1 pk) q1; ⋀cipher σ. interaction_bounded_by consider (𝒜2 cipher σ) q2; q1 + q2 ≤ q ⟧
  ⟹ ibounded_by consider (𝒜1, 𝒜2) q"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ibounded_by_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lossless</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('pubkey, 'plain, 'cipher, 'call, 'ret, 'state) adversary ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless = (λ(𝒜1, 𝒜2). (∀pk. lossless_gpv ℐ_full (𝒜1 pk)) ∧ (∀cipher σ. lossless_gpv ℐ_full (𝒜2 cipher σ)))"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="IND_CPA_PK_Single">
<div class="head"><h1>Theory IND_CPA_PK_Single</h1>
<span class="command">theory</span> <span class="name">IND_CPA_PK_Single</span><br/>
<span class="keyword">imports</span> <a href="../CryptHOL/Computational_Model.html"><span class="name">Computational_Model</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: IND_CPA_PK_Single.thy
  Author: Andreas Lochbihler, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>IND_CPA_PK_Single</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>CryptHOL.Computational_Model</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The IND-CPA game (public key, single instance)›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>ind_cpa</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>key_gen</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('pub_key × 'priv_key) spmf"</span></span></span><span> </span><span class="comment">― ‹probabilistic›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>aencrypt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'pub_key ⇒ 'plain ⇒ 'cipher spmf"</span></span></span><span>  </span><span class="comment">― ‹probabilistic›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>adecrypt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'priv_key ⇒ 'cipher ⇒ 'plain option"</span></span></span><span> </span><span class="comment">― ‹deterministic, but not used›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>valid_plains</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'plain ⇒ 'plain ⇒ bool"</span></span></span><span> </span><span class="comment">― ‹checks whether a pair of plaintexts is valid, i.e., they both have the right format›</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  We cannot incorporate the predicate @{term valid_plain} in the type @{typ "'plain"} of plaintexts,
  because the single @{typ "'plain"} must contain plaintexts for all values of the security parameter,
  as HOL does not have dependent types.  Consequently, the oracle has to ensure that the received
  plaintexts are valid.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'pub_key'</span><span class="delimiter">,</span><span> </span><span class="tfree">'plain'</span><span class="delimiter">,</span><span> </span><span class="tfree">'cipher'</span><span class="delimiter">,</span><span> </span><span class="tfree">'state</span><span class="delimiter">)</span><span> </span><span>adversary</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"('pub_key' ⇒ (('plain' × 'plain') × 'state) spmf)
   × ('cipher' ⇒ 'state ⇒ bool spmf)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>ind_cpa</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('pub_key, 'plain, 'cipher, 'state) adversary ⇒ bool spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ind_cpa (𝒜1, 𝒜2) = TRY do {
     (pk, sk) ← key_gen;
     ((m0, m1), σ) ← 𝒜1 pk;
     _ :: unit ← assert_spmf (valid_plains m0 m1);
     b ← coin_spmf;
     cipher ← aencrypt pk (if b then m0 else m1);
     b' ← 𝒜2 cipher σ;
     return_spmf (b = b')
  } ELSE coin_spmf"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>ind_cpa.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>advantage</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('pub_key, 'plain, 'cipher, 'state) adversary ⇒ real"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"advantage 𝒜 = ¦spmf (ind_cpa 𝒜) True - 1/2¦"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lossless</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('pub_key, 'plain, 'cipher, 'state) adversary ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lossless 𝒜 ⟷
   ((∀pk. lossless_spmf (fst 𝒜 pk)) ∧
        (∀cipher σ. lossless_spmf (snd 𝒜 cipher σ)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lossless_ind_cpa</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ lossless 𝒜; lossless_spmf (key_gen) ⟧ ⟹ lossless_spmf (ind_cpa 𝒜)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lossless_def</span><span> </span><span>ind_cpa_def</span><span> </span><span>split_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="SUF_CMA">
<div class="head"><h1>Theory SUF_CMA</h1>
<span class="command">theory</span> <span class="name">SUF_CMA</span><br/>
<span class="keyword">imports</span> <a href="../CryptHOL/Computational_Model.html"><span class="name">Computational_Model</span></a> <a href="../CryptHOL/Negligible.html"><span class="name">Negligible</span></a> <a href="../CryptHOL/Environment_Functor.html"><span class="name">Environment_Functor</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: SUF_CMA.thy
  Author: Andreas Lochbihler, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>SUF_CMA</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>CryptHOL.Computational_Model</span><span>
</span><span>  </span><span>CryptHOL.Negligible</span><span>
</span><span>  </span><span>CryptHOL.Environment_Functor</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Strongly existentially unforgeable signature scheme›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>sig_scheme</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>key_gen</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ ('vkey × 'sigkey) spmf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sign</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ 'sigkey ⇒ 'message ⇒ 'signature spmf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>verify</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ 'vkey ⇒ 'message ⇒ 'signature ⇒ bool"</span></span></span><span> </span><span class="comment">― ‹verification is deterministic›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>valid_message</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ 'message ⇒ bool"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>suf_cma</span><span> </span><span class="delimiter">=</span><span> </span><span>sig_scheme</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">constrains</span></span><span> </span><span>key_gen</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ ('vkey × 'sigkey) spmf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sign</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ 'sigkey ⇒ 'message ⇒ 'signature spmf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>verify</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ 'vkey ⇒ 'message ⇒ 'signature ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>valid_message</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ 'message ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'vkey'</span><span class="delimiter">,</span><span> </span><span class="tfree">'sigkey'</span><span class="delimiter">,</span><span> </span><span class="tfree">'message'</span><span class="delimiter">,</span><span> </span><span class="tfree">'signature'</span><span class="delimiter">)</span><span> </span><span>state_oracle</span><span> 
</span><span>  </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('vkey' × 'sigkey' × ('message' × 'signature') list) option"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>vkey_oracle</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ (('vkey, 'sigkey, 'message, 'signature) state_oracle, unit, 'vkey) oracle'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"vkey_oracle η None _ = do {
     (vkey, sigkey) ← key_gen η;
     return_spmf (vkey, Some (vkey, sigkey, []))
   }"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀log. vkey_oracle η (Some (vkey, sigkey, log)) _ = return_spmf (vkey, Some (vkey, sigkey, log))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>bind_spmf_cong</span><span class="delimiter">[</span><span>fundef_cong</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span>sign_oracle</span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ (('vkey, 'sigkey, 'message, 'signature) state_oracle, 'message, 'signature) oracle'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sign_oracle η None m = do { (_, σ) ← vkey_oracle η None (); sign_oracle η σ m }"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀log. sign_oracle η (Some (vkey, skey, log)) m =
  (if valid_message η m then do {
    sig ← sign η skey m;
    return_spmf (sig, Some (vkey, skey, (m, sig) # log)) 
  } else return_pmf None)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>pat_completeness</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">termination</span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>relation</span><span> </span><span class="string"><span class="delete"><span class="delete">"Wellfounded.measure (λ(η, σ, m). case σ of None ⇒ 1 | _ ⇒ 0)"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lossless_vkey_oracle</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lossless_spmf (vkey_oracle η σ x) ⟷ (σ = None ⟶ lossless_spmf (key_gen η))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(η, σ, x)"</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>vkey_oracle.cases</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lossless_sign_oracle</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ σ = None ⟹ lossless_spmf (key_gen η);
    ⋀skey m. valid_message η m ⟹ lossless_spmf (sign η skey m) ⟧
  ⟹ lossless_spmf (sign_oracle η σ m) ⟷ valid_message η m"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(η, σ, m)"</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>sign_oracle.cases</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>split_beta</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>lossless_spmfD_set_spmf_nonempty</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lossless_sign_oracle_Some</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>log</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lossless_spmf (sign_oracle η (Some (vkey, skey, log)) m) ⟷ lossless_spmf (sign η skey m) ∧ valid_message η m"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Single-user setting›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'message'</span><span> </span><span>call<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"unit + 'message'"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'vkey'</span><span class="delimiter">,</span><span> </span><span class="tfree">'signature'</span><span class="delimiter">)</span><span> </span><span>ret<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'vkey' + 'signature'"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>oracle<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security
  ⇒ (('vkey, 'sigkey, 'message, 'signature) state_oracle, 'message call<span class="hidden">⇩</span><sub>1</sub>, ('vkey, 'signature) ret<span class="hidden">⇩</span><sub>1</sub>) oracle'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"oracle<span class="hidden">⇩</span><sub>1</sub> η = vkey_oracle η ⊕<span class="hidden">⇩</span><sub>O</sub> sign_oracle η"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>oracle<span class="hidden">⇩</span><sub>1</sub>_simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"oracle<span class="hidden">⇩</span><sub>1</sub> η s (Inl x) = map_spmf (apfst Inl) (vkey_oracle η s x)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"oracle<span class="hidden">⇩</span><sub>1</sub> η s (Inr y) = map_spmf (apfst Inr) (sign_oracle η s y)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle<span class="hidden">⇩</span><sub>1</sub>_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'vkey'</span><span class="delimiter">,</span><span> </span><span class="tfree">'message'</span><span class="delimiter">,</span><span> </span><span class="tfree">'signature'</span><span class="delimiter">)</span><span> </span><span>adversary<span class="hidden">⇩</span><sub>1</sub>'</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(('message' × 'signature'), 'message' call<span class="hidden">⇩</span><sub>1</sub>, ('vkey', 'signature') ret<span class="hidden">⇩</span><sub>1</sub>) gpv"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'vkey'</span><span class="delimiter">,</span><span> </span><span class="tfree">'message'</span><span class="delimiter">,</span><span> </span><span class="tfree">'signature'</span><span class="delimiter">)</span><span> </span><span>adversary<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"security ⇒ ('vkey', 'message', 'signature') adversary<span class="hidden">⇩</span><sub>1</sub>'"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>suf_cma<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('vkey, 'message, 'signature) adversary<span class="hidden">⇩</span><sub>1</sub> ⇒ security ⇒ bool spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀log. suf_cma<span class="hidden">⇩</span><sub>1</sub> 𝒜 η = do {
    ((m, sig), σ) ← exec_gpv (oracle<span class="hidden">⇩</span><sub>1</sub> η) (𝒜 η) None;
    return_spmf (
      case σ of None ⇒ False
      | Some (vkey, skey, log) ⇒ verify η vkey m sig ∧ (m, sig) ∉ set log)
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>advantage<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('vkey, 'message, 'signature) adversary<span class="hidden">⇩</span><sub>1</sub> ⇒ advantage"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"advantage<span class="hidden">⇩</span><sub>1</sub> 𝒜 η = spmf (suf_cma<span class="hidden">⇩</span><sub>1</sub> 𝒜 η) True"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>advantage<span class="hidden">⇩</span><sub>1</sub>_nonneg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"advantage<span class="hidden">⇩</span><sub>1</sub> 𝒜 η ≥ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>advantage<span class="hidden">⇩</span><sub>1</sub>_def</span><span> </span><span>pmf_nonneg</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>secure_for<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('vkey, 'message, 'signature) adversary<span class="hidden">⇩</span><sub>1</sub> ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"secure_for<span class="hidden">⇩</span><sub>1</sub> 𝒜 ≡ negligible (advantage<span class="hidden">⇩</span><sub>1</sub> 𝒜)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ibounded_by<span class="hidden">⇩</span><sub>1</sub>'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('vkey, 'message, 'signature) adversary<span class="hidden">⇩</span><sub>1</sub>' ⇒ nat ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ibounded_by<span class="hidden">⇩</span><sub>1</sub>' 𝒜 q = (interaction_any_bounded_by 𝒜 q)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>ibounded_by<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('vkey, 'message, 'signature) adversary<span class="hidden">⇩</span><sub>1</sub> ⇒ (security ⇒ nat) ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ibounded_by<span class="hidden">⇩</span><sub>1</sub> ≡ rel_envir ibounded_by<span class="hidden">⇩</span><sub>1</sub>'"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lossless<span class="hidden">⇩</span><sub>1</sub>'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('vkey, 'message, 'signature) adversary<span class="hidden">⇩</span><sub>1</sub>' ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless<span class="hidden">⇩</span><sub>1</sub>' 𝒜 = (lossless_gpv ℐ_full 𝒜)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>lossless<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('vkey, 'message, 'signature) adversary<span class="hidden">⇩</span><sub>1</sub> ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless<span class="hidden">⇩</span><sub>1</sub> ≡ pred_envir lossless<span class="hidden">⇩</span><sub>1</sub>'"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Multi-user setting›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>oracle<span class="hidden">⇩</span><sub>n</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security
  ⇒ ('i ⇒ ('vkey, 'sigkey, 'message, 'signature) state_oracle, 'i × 'message call<span class="hidden">⇩</span><sub>1</sub>, ('vkey, 'signature) ret<span class="hidden">⇩</span><sub>1</sub>) oracle'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"oracle<span class="hidden">⇩</span><sub>n</sub> η = family_oracle (λ_. oracle<span class="hidden">⇩</span><sub>1</sub> η)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>oracle<span class="hidden">⇩</span><sub>n</sub>_apply</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"oracle<span class="hidden">⇩</span><sub>n</sub> η s (i, x) = map_spmf (apsnd (fun_upd s i)) (oracle<span class="hidden">⇩</span><sub>1</sub> η (s i) x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle<span class="hidden">⇩</span><sub>n</sub>_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'i</span><span class="delimiter">,</span><span> </span><span class="tfree">'vkey'</span><span class="delimiter">,</span><span> </span><span class="tfree">'message'</span><span class="delimiter">,</span><span> </span><span class="tfree">'signature'</span><span class="delimiter">)</span><span> </span><span>adversary<span class="hidden">⇩</span><sub>n</sub>'</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(('i × 'message' × 'signature'), 'i × 'message' call<span class="hidden">⇩</span><sub>1</sub>, ('vkey', 'signature') ret<span class="hidden">⇩</span><sub>1</sub>) gpv"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'i</span><span class="delimiter">,</span><span> </span><span class="tfree">'vkey'</span><span class="delimiter">,</span><span> </span><span class="tfree">'message'</span><span class="delimiter">,</span><span> </span><span class="tfree">'signature'</span><span class="delimiter">)</span><span> </span><span>adversary<span class="hidden">⇩</span><sub>n</sub></span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"security ⇒ ('i, 'vkey', 'message', 'signature') adversary<span class="hidden">⇩</span><sub>n</sub>'"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>suf_cma<span class="hidden">⇩</span><sub>n</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('i, 'vkey, 'message, 'signature) adversary<span class="hidden">⇩</span><sub>n</sub> ⇒ security ⇒ bool spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀log. suf_cma<span class="hidden">⇩</span><sub>n</sub> 𝒜 η = do {
    ((i, m, sig), σ) ← exec_gpv (oracle<span class="hidden">⇩</span><sub>n</sub> η) (𝒜 η) (λ_. None);
    return_spmf (
      case σ i of None ⇒ False
      | Some (vkey, skey, log) ⇒ verify η vkey m sig ∧ (m, sig) ∉ set log)
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>advantage<span class="hidden">⇩</span><sub>n</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('i, 'vkey, 'message, 'signature) adversary<span class="hidden">⇩</span><sub>n</sub> ⇒ advantage"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"advantage<span class="hidden">⇩</span><sub>n</sub> 𝒜 η = spmf (suf_cma<span class="hidden">⇩</span><sub>n</sub> 𝒜 η) True"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>advantage<span class="hidden">⇩</span><sub>n</sub>_nonneg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"advantage<span class="hidden">⇩</span><sub>n</sub> 𝒜 η ≥ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>advantage<span class="hidden">⇩</span><sub>n</sub>_def</span><span> </span><span>pmf_nonneg</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>secure_for<span class="hidden">⇩</span><sub>n</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('i, 'vkey, 'message, 'signature) adversary<span class="hidden">⇩</span><sub>n</sub> ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"secure_for<span class="hidden">⇩</span><sub>n</sub> 𝒜 ≡ negligible (advantage<span class="hidden">⇩</span><sub>n</sub> 𝒜)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ibounded_by<span class="hidden">⇩</span><sub>n</sub>'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('i, 'vkey, 'message, 'signature) adversary<span class="hidden">⇩</span><sub>n</sub>' ⇒ nat ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ibounded_by<span class="hidden">⇩</span><sub>n</sub>' 𝒜 q = (interaction_any_bounded_by 𝒜 q)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>ibounded_by<span class="hidden">⇩</span><sub>n</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('i, 'vkey, 'message, 'signature) adversary<span class="hidden">⇩</span><sub>n</sub> ⇒ (security ⇒ nat) ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ibounded_by<span class="hidden">⇩</span><sub>n</sub> ≡ rel_envir ibounded_by<span class="hidden">⇩</span><sub>n</sub>'"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lossless<span class="hidden">⇩</span><sub>n</sub>'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('i, 'vkey, 'message, 'signature) adversary<span class="hidden">⇩</span><sub>n</sub>' ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless<span class="hidden">⇩</span><sub>n</sub>' 𝒜 = (lossless_gpv ℐ_full 𝒜)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>lossless<span class="hidden">⇩</span><sub>n</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('i, 'vkey, 'message, 'signature) adversary<span class="hidden">⇩</span><sub>n</sub> ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless<span class="hidden">⇩</span><sub>n</sub> ≡ pred_envir lossless<span class="hidden">⇩</span><sub>n</sub>'"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Pseudo_Random_Function">
<div class="head"><h1>Theory Pseudo_Random_Function</h1>
<span class="command">theory</span> <span class="name">Pseudo_Random_Function</span><br/>
<span class="keyword">imports</span> <a href="../CryptHOL/Computational_Model.html"><span class="name">Computational_Model</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: Pseudo_Random_Function.thy
  Author: Andreas Lochbihler, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Pseudo_Random_Function</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>CryptHOL.Computational_Model</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Pseudo-random function›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>random_function</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>p</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'b</span><span class="delimiter">,</span><span class="tfree">'a'</span><span class="delimiter">)</span><span> </span><span>dict</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b ⇀ 'a'"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>random_oracle</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('b, 'a) dict ⇒ 'b ⇒ ('a × ('b, 'a) dict) spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"random_oracle σ x =
  (case σ x of Some y ⇒ return_spmf (y, σ)
   | None ⇒ p ⤜ (λy. return_spmf (y, σ(x ↦ y))))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>forgetful_random_oracle</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"unit ⇒ 'b ⇒ ('a × unit) spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"forgetful_random_oracle σ x = p ⤜ (λy. return_spmf (y, ()))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>weight_random_oracle</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"weight_spmf p = 1 ⟹ weight_spmf (random_oracle σ x) = 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>random_oracle_def</span><span> </span><span>weight_bind_spmf</span><span> </span><span>o_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lossless_random_oracle</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lossless_spmf p ⟹ lossless_spmf (random_oracle σ x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lossless_spmf_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>finite</span><span class="delimiter">:</span><span> </span><span>callee_invariant_on</span><span> </span><span>random_oracle</span><span> </span><span class="string"><span class="delete"><span class="delete">"λσ. finite (dom σ)"</span></span></span><span> </span><span>ℐ_full</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>random_oracle_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>card_dom_random_oracle</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"interaction_any_bounded_by 𝒜 q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(y, σ') ∈ set_spmf (exec_gpv random_oracle 𝒜 σ)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (dom σ)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (dom σ') ≤ q + card (dom σ)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>finite.interaction_bounded_by'_exec_gpv_count</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span>-</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>random_oracle_def</span><span> </span><span>fin</span><span> </span><span>card_insert_if</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>fun_upd_apply</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split_asm</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Pseudo-random function›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prf"</span></span></span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>key_gen</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'key spmf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prf"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'key ⇒ 'domain ⇒ 'range"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rand</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'range spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>random_function</span><span> </span><span class="string"><span class="delete"><span class="delete">"rand"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>prf_oracle</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'key ⇒ unit ⇒ 'domain ⇒ ('range × unit) spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prf_oracle key σ x = return_spmf (prf key x, ())"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'domain'</span><span class="delimiter">,</span><span> </span><span class="tfree">'range'</span><span class="delimiter">)</span><span> </span><span>adversary</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(bool, 'domain', 'range') gpv"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>game_0</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('domain, 'range) adversary ⇒ bool spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"game_0 𝒜 = do {
     key ← key_gen;
     (b, _) ← exec_gpv (prf_oracle key) 𝒜 ();
     return_spmf b
   }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>game_1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('domain, 'range) adversary ⇒ bool spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"game_1 𝒜 = do {
     (b, _) ← exec_gpv random_oracle 𝒜 Map.empty;
     return_spmf b
   }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>advantage</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('domain, 'range) adversary ⇒ real"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"advantage 𝒜 = ¦spmf (game_0 𝒜) True - spmf (game_1 𝒜) True¦"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>advantage_nonneg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"advantage 𝒜 ≥ 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>advantage_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>lossless</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('domain, 'range) adversary ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless ≡ lossless_gpv ℐ_full"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>ibounded_by</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('domain, 'range) adversary ⇒ enat ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ibounded_by ≡ interaction_any_bounded_by"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Pseudo_Random_Permutation">
<div class="head"><h1>Theory Pseudo_Random_Permutation</h1>
<span class="command">theory</span> <span class="name">Pseudo_Random_Permutation</span><br/>
<span class="keyword">imports</span> <a href="../CryptHOL/Computational_Model.html"><span class="name">Computational_Model</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: Pseudo_Random_Permutation.thy
  Author: Andreas Lochbihler, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Random permutation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Pseudo_Random_Permutation</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>CryptHOL.Computational_Model</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>random_permutation</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>A</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>random_permutation</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇀ 'b) ⇒ 'a ⇒ ('b × ('a ⇀ 'b)) spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"random_permutation σ x =
  (case σ x of Some y ⇒ return_spmf (y, σ)
   | None ⇒ spmf_of_set (A - ran σ) ⤜ (λy. return_spmf (y, σ(x ↦ y))))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>weight_random_oracle</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ finite A; A - ran σ ≠ {} ⟧ ⟹ weight_spmf (random_permutation σ x) = 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>random_permutation_def</span><span> </span><span>weight_bind_spmf</span><span> </span><span>o_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lossless_random_oracle</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ finite A; A - ran σ ≠ {} ⟧ ⟹ lossless_spmf (random_permutation σ x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lossless_spmf_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>finite</span><span class="delimiter">:</span><span> </span><span>callee_invariant_on</span><span> </span><span>random_permutation</span><span> </span><span class="string"><span class="delete"><span class="delete">"λσ. finite (dom σ)"</span></span></span><span> </span><span>ℐ_full</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>random_permutation_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>card_dom_random_oracle</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"interaction_any_bounded_by 𝒜 q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(y, σ') ∈ set_spmf (exec_gpv random_permutation 𝒜 σ)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (dom σ)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (dom σ') ≤ q + card (dom σ)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>finite.interaction_bounded_by'_exec_gpv_count</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span>-</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>random_permutation_def</span><span> </span><span>fin</span><span> </span><span>card_insert_if</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>fun_upd_apply</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split_asm</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Guessing_Many_One">
<div class="head"><h1>Theory Guessing_Many_One</h1>
<span class="command">theory</span> <span class="name">Guessing_Many_One</span><br/>
<span class="keyword">imports</span> <a href="../CryptHOL/Computational_Model.html"><span class="name">Computational_Model</span></a> <a href="../CryptHOL/GPV_Bisim.html"><span class="name">GPV_Bisim</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: Guessing_Many_One.thy
  Author: Andreas Lochbihler, ETH Zurich 
  Author: S. Reza Sefidgar, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Reducing games with many adversary guesses to games with single guesses›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Guessing_Many_One</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>CryptHOL.Computational_Model</span><span>
</span><span>  </span><span>CryptHOL.GPV_Bisim</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>guessing_many_one</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('c_o × 'c_a × 's) spmf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"oracle"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'c_o ⇒ 's ⇒ 'call ⇒ ('ret × 's) spmf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eval"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'c_o ⇒ 'c_a ⇒ 's ⇒ 'guess ⇒ bool spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'c_a'</span><span class="delimiter">,</span><span> </span><span class="tfree">'guess'</span><span class="delimiter">,</span><span> </span><span class="tfree">'call'</span><span class="delimiter">,</span><span> </span><span class="tfree">'ret'</span><span class="delimiter">)</span><span> </span><span>adversary_single</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'c_a' ⇒ ('guess', 'call', 'ret') gpv"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>game_single</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('c_a, 'guess, 'call, 'ret) adversary_single ⇒ bool spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"game_single 𝒜 = do {
    (c_o, c_a, s) ← init;
    (guess, s') ← exec_gpv (oracle c_o) (𝒜 c_a) s;
    eval c_o c_a s' guess
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>advantage_single</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('c_a, 'guess, 'call, 'ret) adversary_single ⇒ real"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"advantage_single 𝒜 = spmf (game_single 𝒜) True"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'c_a'</span><span class="delimiter">,</span><span> </span><span class="tfree">'guess'</span><span class="delimiter">,</span><span> </span><span class="tfree">'call'</span><span class="delimiter">,</span><span> </span><span class="tfree">'ret'</span><span class="delimiter">)</span><span> </span><span>adversary_many</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'c_a' ⇒ (unit, 'call' + 'guess', 'ret' + unit) gpv"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>eval_oracle</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'c_o ⇒ 'c_a ⇒ bool × 's ⇒ 'guess ⇒ (unit × (bool × 's)) spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eval_oracle c_o c_a = (λ(b, s') guess. map_spmf (λb'. ((), (b ∨ b', s'))) (eval c_o c_a s' guess))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>game_multi</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('c_a, 'guess, 'call, 'ret) adversary_many ⇒ bool spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"game_multi 𝒜 = do {
     (c_o, c_a, s) ← init;
     (_, (b, _)) ← exec_gpv
       (†(oracle c_o) ⊕<span class="hidden">⇩</span><sub>O</sub> eval_oracle c_o c_a)
       (𝒜 c_a)
       (False, s);
     return_spmf b
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>advantage_multi</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('c_a, 'guess, 'call, 'ret) adversary_many ⇒ real"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"advantage_multi 𝒜 = spmf (game_multi 𝒜) True"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'guess'</span><span> </span><span>reduction_state</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'guess' + nat"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>process_call</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'guess reduction_state ⇒ 'call ⇒ ('ret option × 'guess reduction_state, 'call, 'ret) gpv"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"process_call (Inr j) x = do {
    ret ← Pause x Done;
    Done (Some ret, Inr j)
  }"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"process_call (Inl guess) x = Done (None, Inl guess)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>process_guess</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'guess reduction_state ⇒ 'guess ⇒ (unit option × 'guess reduction_state, 'call, 'ret) gpv"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"process_guess (Inr j) guess = Done (if j &gt; 0 then (Some (), Inr (j - 1)) else (None, Inl guess))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"process_guess (Inl guess) _ = Done (None, Inl guess)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>reduction_oracle</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'guess + nat ⇒ 'call + 'guess ⇒ (('ret + unit) option × ('guess + nat), 'call, 'ret) gpv"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reduction_oracle ≡ plus_intercept_stop process_call process_guess"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>reduction</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ ('c_a, 'guess, 'call, 'ret) adversary_many ⇒ ('c_a, 'guess, 'call, 'ret) adversary_single"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"reduction q 𝒜 c_a = do {
    j_star ← lift_spmf (spmf_of_set {..&lt;q});
    (_, s) ← inline_stop reduction_oracle (𝒜 c_a) (Inr j_star);
    Done (projl s)
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>many_single_reduction</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>bound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀c_a c_o s. (c_o, c_a, s) ∈ set_spmf init ⟹ interaction_bounded_by (Not ∘ isl) (𝒜 c_a) q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lossless_oracle</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀c_a c_o s s' x. (c_o, c_a, s) ∈ set_spmf init ⟹ lossless_spmf (oracle c_o s' x)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lossless_eval</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀c_a c_o s s' guess. (c_o, c_a, s) ∈ set_spmf init ⟹ lossless_spmf (eval c_o c_a s' guess)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"advantage_multi 𝒜 ≤ advantage_single (reduction q 𝒜) * q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">including</span></span><span> </span><span>lifting_syntax</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>eval_oracle'</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eval_oracle' = (λc_o c_a ((id, occ :: nat option), s') guess. 
    map_spmf (λb'. case occ of Some j<span class="hidden">⇩</span><sub>0</sub> ⇒ ((), (Suc id, Some j<span class="hidden">⇩</span><sub>0</sub>), s')
                                | None ⇒ ((), (Suc id, (if b' then Some id else None)), s'))
      (eval c_o c_a s' guess))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?multi'_body</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λc_o c_a s. exec_gpv (†(oracle c_o) ⊕<span class="hidden">⇩</span><sub>O</sub> eval_oracle' c_o c_a) (𝒜 c_a) ((0, None), s)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>game_multi'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game_multi' = (λc_o c_a s. do {
    (_, ((id, j<span class="hidden">⇩</span><sub>0</sub>), s' :: 's)) ← ?multi'_body c_o c_a s;
    return_spmf (j<span class="hidden">⇩</span><sub>0</sub> ≠ None) })"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>initialize</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('c_o ⇒ 'c_a ⇒ 's ⇒ nat ⇒ bool spmf) ⇒ bool spmf"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"initialize body = do {
      (c_o, c_a, s) ← init;
      j<span class="hidden">⇩</span><sub>s</sub> ← spmf_of_set {..&lt;q};
      body c_o c_a s j<span class="hidden">⇩</span><sub>s</sub> }"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>body</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>body2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"body2 c_o c_a s j<span class="hidden">⇩</span><sub>s</sub> = do {
    (_, (id, j<span class="hidden">⇩</span><sub>0</sub>), s') ← ?multi'_body c_o c_a s;
    return_spmf (j<span class="hidden">⇩</span><sub>0</sub> = Some j<span class="hidden">⇩</span><sub>s</sub>) }"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>c_o</span><span> </span><span>c_a</span><span> </span><span>s</span><span> </span><span>j<span class="hidden">⇩</span><sub>s</sub></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?game2</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"initialize body2"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>stop_oracle</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"stop_oracle = (λc_o. 
     (λ(idgs, s) x. case idgs of Inr _ ⇒ map_spmf (λ(y, s). (Some y, (idgs, s))) (oracle c_o s x) | Inl _ ⇒ return_spmf (None, (idgs, s)))
     ⊕<span class="hidden">⇩</span><sub>O</sub><span class="hidden">⇧</span><sup>S</sup>
     (λ(idgs, s) guess :: 'guess. return_spmf (case idgs of Inr 0 ⇒ (None, Inl (guess, s), s) | Inr (Suc i) ⇒ (Some (), Inr i, s) | Inl _ ⇒ (None, idgs, s))))"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>body3</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"body3 c_o c_a s j<span class="hidden">⇩</span><sub>s</sub> = do {
    (_ :: unit option, idgs, _) ← exec_gpv_stop (stop_oracle c_o) (𝒜 c_a) (Inr j<span class="hidden">⇩</span><sub>s</sub>, s);
    (b' :: bool) ← case idgs of Inr _ ⇒ return_spmf False | Inl (g, s') ⇒ eval c_o c_a s' g;
    return_spmf b' }"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>c_o</span><span> </span><span>c_a</span><span> </span><span>s</span><span> </span><span>j<span class="hidden">⇩</span><sub>s</sub></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?game3</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"initialize body3"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"bool ⇒ nat × nat option ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ≡ λb' (id, occ). b' ⟷ (∃j<span class="hidden">⇩</span><sub>0</sub>. occ = Some j<span class="hidden">⇩</span><sub>0</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_prod S (=)"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>initial</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat × nat option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"initial = (0, None)"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>result</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat × nat option ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"result p = (snd p ≠ None)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>p</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(S ===&gt; (=)) (λb. b) result"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_fun_def</span><span> </span><span>result_def</span><span> </span><span>S_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S False initial"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>S_def</span><span> </span><span>initial_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eval_oracle'</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"((=) ===&gt; (=) ===&gt; ?S ===&gt; (=) ===&gt; rel_spmf (rel_prod (=) ?S))
       eval_oracle eval_oracle'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eval_oracle_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>eval_oracle'_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_fun_def</span><span> </span><span>S_def</span><span> </span><span>map_spmf_conv_bind_spmf</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bind_reflI</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>game_multi'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_multi 𝒜 = bind_spmf init (λ(c_o, c_a, s). game_multi' c_o c_a s)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>game_multi_def</span><span> </span><span>game_multi'_def</span><span> </span><span>initial_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"case_prod ⌑"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bind_spmf _ (case_prod ⌑)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ = bind_spmf _ ⌑"</span></span></span><span> </span><span>split_def</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="delimiter">(</span><span>fold</span><span> </span><span>result_def</span><span class="delimiter">;</span><span> </span><span>transfer_prover</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"spmf (game_multi' c_o c_a s) True = spmf (bind_spmf (spmf_of_set {..&lt;q}) (body2 c_o c_a s)) True * q"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c_o, c_a, s) ∈ set_spmf init"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>c_o</span><span> </span><span>c_a</span><span> </span><span>s</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bnd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"interaction_bounded_by (Not ∘ isl) (𝒜 c_a) q"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bound</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bound_occ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j<span class="hidden">⇩</span><sub>s</sub> &lt; q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>that</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"((), (id, Some j<span class="hidden">⇩</span><sub>s</sub>), s') ∈ set_spmf (?multi'_body c_o c_a s)"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s'</span><span> </span><span>id</span><span> </span><span>j<span class="hidden">⇩</span><sub>s</sub></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"id ≤ q"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>oi_True.interaction_bounded_by'_exec_gpv_count</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bnd</span><span> </span><span>that</span><span class="delimiter">,</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>count</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"fst ∘ fst"</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eval_oracle'_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>plus_oracle_split_asm</span><span> </span><span>option.split_asm</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?I</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ((id, occ), s'). case occ of None ⇒ True | Some j<span class="hidden">⇩</span><sub>s</sub> ⇒ j<span class="hidden">⇩</span><sub>s</sub> &lt; id"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"callee_invariant (†(oracle c_o) ⊕<span class="hidden">⇩</span><sub>O</sub> eval_oracle' c_o c_a) ?I"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>split_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>conjI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>callee_invariant_extend_state_oracle_const'</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eval_oracle'_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split_asm</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>callee_invariant_on.exec_gpv_invariant</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span> </span><span>that</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j<span class="hidden">⇩</span><sub>s</sub> &lt; id"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?M</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"measure (measure_spmf (?multi'_body c_o c_a s))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"spmf (game_multi' c_o c_a s) True = ?M {(u, (id, j<span class="hidden">⇩</span><sub>0</sub>), s'). j<span class="hidden">⇩</span><sub>0</sub> ≠ None}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>game_multi'_def</span><span> </span><span>map_spmf_conv_bind_spmf</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>split_def</span><span> </span><span>spmf_conv_measure_spmf</span><span> </span><span>measure_map_spmf</span><span> </span><span>vimage_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{(u, (id, j<span class="hidden">⇩</span><sub>0</sub>), s'). j<span class="hidden">⇩</span><sub>0</sub> ≠ None} =
      {((), (id, Some j<span class="hidden">⇩</span><sub>s</sub>), s') |j<span class="hidden">⇩</span><sub>s</sub> s' id. j<span class="hidden">⇩</span><sub>s</sub> &lt; q} ∪ {((), (id, Some j<span class="hidden">⇩</span><sub>s</sub>), s') |j<span class="hidden">⇩</span><sub>s</sub> s' id. j<span class="hidden">⇩</span><sub>s</sub> ≥ q}"</span></span></span><span>
</span><span>      </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ = ?A ∪ _"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?M … = ?M ?A"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>measure_spmf.measure_zero_union</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>measure_spmf_zero_iff</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>bound_occ</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = measure (measure_spmf (pair_spmf (spmf_of_set {..&lt; q}) (?multi'_body c_o c_a s)))
         {(j<span class="hidden">⇩</span><sub>s</sub>, (), (id, j<span class="hidden">⇩</span><sub>0</sub>), s') |j<span class="hidden">⇩</span><sub>s</sub> j<span class="hidden">⇩</span><sub>0</sub> s' id. j<span class="hidden">⇩</span><sub>0</sub> = Some j<span class="hidden">⇩</span><sub>s</sub> } * q"</span></span></span><span>
</span><span>      </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ = measure ?M' ?B * _"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?B = {(j<span class="hidden">⇩</span><sub>s</sub>, (), (id, j<span class="hidden">⇩</span><sub>0</sub>), s') |j<span class="hidden">⇩</span><sub>s</sub> j<span class="hidden">⇩</span><sub>0</sub> s' id. j<span class="hidden">⇩</span><sub>0</sub> = Some j<span class="hidden">⇩</span><sub>s</sub> ∧ j<span class="hidden">⇩</span><sub>s</sub> &lt; q} ∪
        {(j<span class="hidden">⇩</span><sub>s</sub>, (), (id, j<span class="hidden">⇩</span><sub>0</sub>), s') |j<span class="hidden">⇩</span><sub>s</sub> j<span class="hidden">⇩</span><sub>0</sub> s' id. j<span class="hidden">⇩</span><sub>0</sub> = Some j<span class="hidden">⇩</span><sub>s</sub> ∧ j<span class="hidden">⇩</span><sub>s</sub> ≥ q}"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ = ?Set1 ∪ ?Set2"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"measure ?M' ?B = measure ?M' (?Set1 ∪ ?Set2)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = measure ?M' ?Set1"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>measure_spmf.measure_zero_union</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>measure_spmf_zero_iff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∑j∈{0..&lt;q}. measure ?M' ({j} × {((), (id, Some j), s')|s' id. True}))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>measure_spmf.finite_measure_finite_Union</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span>measure</span><span class="delimiter">]</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>disjoint_family_on_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∑j∈{0..&lt;q}. 1 / q * measure (measure_spmf (?multi'_body c_o c_a s)) {((), (id, Some j), s')|s' id. True})"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>measure_pair_spmf_times</span><span> </span><span>spmf_conv_measure_spmf</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>spmf_of_set</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = 1 / q * measure (measure_spmf (?multi'_body c_o c_a s)) {((), (id, Some j<span class="hidden">⇩</span><sub>s</sub>), s')|j<span class="hidden">⇩</span><sub>s</sub> s' id. j<span class="hidden">⇩</span><sub>s</sub> &lt; q}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sum_distrib_left</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>measure_spmf.finite_measure_finite_Union</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span>measure</span><span class="delimiter">]</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>disjoint_family_on_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?B = (λ(j<span class="hidden">⇩</span><sub>s</sub>, _, (_, j<span class="hidden">⇩</span><sub>0</sub>), _). j<span class="hidden">⇩</span><sub>0</sub> = Some j<span class="hidden">⇩</span><sub>s</sub>) -` {True}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>vimage_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rw2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"measure ?M' … = spmf (bind_spmf (spmf_of_set {..&lt;q}) (body2 c_o c_a s)) True"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>body2_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>measure_map_spmf</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>map_spmf_conv_bind_spmf</span><span>
</span><span>        </span><span>split_def</span><span> </span><span>pair_spmf_alt_def</span><span> </span><span>spmf_conv_measure_spmf</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"spmf (bind_spmf init (λ(c_a, c_o, s). game_multi' c_a c_o s)) True = spmf ?game2 True * q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>initialize_def</span><span> </span><span>spmf_bind</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>p</span><span class="delimiter">=</span><span>init</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>integral_cong_AE</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>integral_mult_left_zero</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>integral_mult_left_zero</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ord_spmf (⟶) (body2 c_o c_a s j<span class="hidden">⇩</span><sub>s</sub>) (body3 c_o c_a s j<span class="hidden">⇩</span><sub>s</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>init</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(c_o, c_a, s) ∈ set_spmf init"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>j<span class="hidden">⇩</span><sub>s</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j<span class="hidden">⇩</span><sub>s</sub> &lt; Suc q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>c_o</span><span> </span><span>c_a</span><span> </span><span>s</span><span> </span><span>j<span class="hidden">⇩</span><sub>s</sub></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>oracle2'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"oracle2' ≡ λ(b, (id, gs), s) guess. if id = j<span class="hidden">⇩</span><sub>s</sub> then do {
        b' :: bool ← eval c_o c_a s guess;
        return_spmf ((), (Some b', (Suc id, Some (guess, s)), s))
      } else return_spmf ((), (b, (Suc id, gs), s))"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?R</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ((id1, j<span class="hidden">⇩</span><sub>0</sub>), s1) (b', (id2, gs), s2). s1 = s2 ∧ id1 = id2 ∧ (j<span class="hidden">⇩</span><sub>0</sub> = Some j<span class="hidden">⇩</span><sub>s</sub> ⟶ b' = Some True) ∧ (id2 ≤ j<span class="hidden">⇩</span><sub>s</sub> ⟶ b' = None)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>init</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_spmf (rel_prod (=) ?R)
      (exec_gpv (extend_state_oracle (oracle c_o) ⊕<span class="hidden">⇩</span><sub>O</sub> eval_oracle' c_o c_a) (𝒜 c_a) ((0, None), s))
      (exec_gpv (extend_state_oracle (extend_state_oracle (oracle c_o)) ⊕<span class="hidden">⇩</span><sub>O</sub> oracle2') (𝒜 c_a) (None, (0, None), s))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>exec_gpv_oracle_bisim</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>X</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"?R"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle2'_def</span><span> </span><span>eval_oracle'_def</span><span> </span><span>spmf_rel_map</span><span> </span><span>map_spmf_conv_bind_spmf</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>rel_spmf_return_spmf2</span><span> </span><span>lossless_eval</span><span> </span><span>o_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_reflI</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split_asm</span><span> </span><span>plus_oracle_split</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_spmf (⟶) (body2 c_o c_a s j<span class="hidden">⇩</span><sub>s</sub>) 
      (do {
        (_, b', _, _) ← exec_gpv (††(oracle c_o) ⊕<span class="hidden">⇩</span><sub>O</sub> oracle2') (𝒜 c_a) (None, (0, None), s);
        return_spmf (b' = Some True) })"</span></span></span><span>
</span><span>      </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_spmf _ _ ?body2'"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="comment">― ‹We do not get equality here because the right hand side may return @{const True} even
        when the bad event has happened before the @{text j<span class="hidden">⇩</span><sub>s</sub>}-th iteration.›</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>body2_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_spmf_bindI</span><span class="delimiter">)</span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?guess_oracle</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ((id, gs), s) guess. return_spmf ((), (Suc id, if id = j<span class="hidden">⇩</span><sub>s</sub> then Some (guess, s) else gs), s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?I</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(idgs, s). case idgs of (_, None) ⇒ False | (i, Some _) ⇒ j<span class="hidden">⇩</span><sub>s</sub> &lt; i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>I</span><span class="delimiter">:</span><span> </span><span>callee_invariant_on</span><span> </span><span class="string"><span class="delete"><span class="delete">"†(oracle c_o) ⊕<span class="hidden">⇩</span><sub>O</sub> ?guess_oracle"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?I"</span></span></span><span> </span><span>ℐ_full</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?f</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λs. case snd (fst s) of None ⇒ return_spmf False | Some a ⇒ eval c_o c_a (snd a) (fst a)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?X</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λj<span class="hidden">⇩</span><sub>s</sub> (b1, (id1, gs1), s1) (b2, (id2, gs2), s2). b1 = b2 ∧ id1 = id2 ∧ gs1 = gs2 ∧ s1 = s2 ∧ (b2 = None ⟷ gs2 = None) ∧ (id2 ≤ j<span class="hidden">⇩</span><sub>s</sub> ⟶ b2 = None)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?body2' = do {
      (a, r, s) ← exec_gpv (λ(r, s) x. do {
               (y, s') ← (†(oracle c_o) ⊕<span class="hidden">⇩</span><sub>O</sub> ?guess_oracle) s x;
               if ?I s' ∧ r = None then map_spmf (λr. (y, Some r, s')) (?f s') else return_spmf (y, r, s')
             })
         (𝒜 c_a) (None, (0, None), s);
      case r of None ⇒ ?f s ⤜ return_spmf | Some r' ⇒ return_spmf r' }"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>oracle2'_def</span><span> </span><span>spmf_rel_eq</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_spmf_bindI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>exec_gpv_oracle_bisim'</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>X</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"?X j<span class="hidden">⇩</span><sub>s</sub>"</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bind_map_spmf</span><span> </span><span>o_def</span><span> </span><span>spmf.map_comp</span><span> </span><span>split_beta</span><span> </span><span>conj_comms</span><span> </span><span>map_spmf_conv_bind_spmf</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>spmf_rel_map</span><span> </span><span>rel_spmf_reflI</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>conj_cong</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>plus_oracle_split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = do {
        us' ← exec_gpv (†(oracle c_o) ⊕<span class="hidden">⇩</span><sub>O</sub> ?guess_oracle) (𝒜 c_a) ((0, None), s);
        (b' :: bool) ← ?f (snd us');
        return_spmf b' }"</span></span></span><span>
</span><span>      </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ = ?body2''"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>I.exec_gpv_bind_materialize</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>plus_oracle_split_asm</span><span> </span><span>option.split_asm</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = do {
        us' ← exec_gpv_stop (lift_stop_oracle (†(oracle c_o) ⊕<span class="hidden">⇩</span><sub>O</sub> ?guess_oracle)) (𝒜 c_a) ((0, None), s);
        (b' :: bool) ← ?f (snd us');
        return_spmf b' }"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>lift_stop_oracle_transfer</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span> </span><span>gpv_stop_transfer</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span> </span><span>exec_gpv_parametric'</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ((id1, gs1), s1) ((id2, gs2), s2). gs1 = gs2 ∧ (gs2 = None ⟶ s1 = s2 ∧ id1 = id2) ∧ (gs1 = None ⟷ id1 ≤ j<span class="hidden">⇩</span><sub>s</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ord_spmf (⟶) … (exec_gpv_stop ((λ((id, gs), s) x. case gs of None ⇒ lift_stop_oracle (†(oracle c_o)) ((id, gs), s) x | Some _ ⇒ return_spmf (None, ((id, gs), s))) ⊕<span class="hidden">⇩</span><sub>O</sub><span class="hidden">⇧</span><sup>S</sup>
            (λ((id, gs), s) guess. return_spmf (if id ≥ j<span class="hidden">⇩</span><sub>s</sub> then None else Some (), (Suc id, if id = j<span class="hidden">⇩</span><sub>s</sub> then Some (guess, s) else gs), s)))
           (𝒜 c_a) ((0, None), s) ⤜
          (λus'. case snd (fst (snd us')) of None ⇒ return_spmf False | Some a ⇒ eval c_o c_a (snd a) (fst a)))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>body3_def</span><span> </span><span>stop_oracle_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ord_spmf_exec_gpv_stop</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>stop</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ((id, guess), _). guess ≠ None"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"?S"</span></span></span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>ord_spmf_bindI</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.split_asm</span><span> </span><span>plus_oracle_split_asm</span><span> </span><span>split</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>plus_oracle_stop_split</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>not_None_eq</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>spmf.map_comp</span><span> </span><span>o_def</span><span> </span><span>apfst_compose</span><span> </span><span>ord_spmf_map_spmf1</span><span> </span><span>ord_spmf_map_spmf2</span><span> </span><span>split_beta</span><span> </span><span>ord_spmf_return_spmf2</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ord_spmf_reflI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?X</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ((id, gs), s1) (idgs, s2). s1 = s2 ∧ (case (gs, idgs) of (None, Inr id') ⇒ id' = j<span class="hidden">⇩</span><sub>s</sub> - id ∧ id ≤ j<span class="hidden">⇩</span><sub>s</sub> | (Some gs, Inl gs') ⇒ gs = gs' ∧ id &gt; j<span class="hidden">⇩</span><sub>s</sub> | _ ⇒ False)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = body3 c_o c_a s j<span class="hidden">⇩</span><sub>s</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>body3_def</span><span> </span><span>spmf_rel_eq</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>stop_oracle_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>exec_gpv_oracle_bisim'</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>X</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"?X"</span></span></span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>rel_spmf_bindI</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split_asm</span><span> </span><span>plus_oracle_stop_split</span><span> </span><span>nat.splits</span><span> </span><span>split</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sum.split</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>spmf_rel_map</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_reflI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>pmf.rel_mono_strong</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>option.rel_cases</span><span> </span><span>ord_option.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ord_spmf (⟶) ?game2 ?game3"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>initialize_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ord_spmf_bind_reflI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?X</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(gsid, s) (gid, s'). s = s' ∧ rel_sum (λ(g, s1) g'. g = g' ∧ s1 = s') (=) gsid gid"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_spmf (⟶) ?game3 (game_single (reduction q 𝒜))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>body3_def</span><span> </span><span>stop_oracle_def</span><span> </span><span>game_single_def</span><span> </span><span>reduction_def</span><span> </span><span>split_def</span><span> </span><span>initialize_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bind_map_spmf</span><span> </span><span>exec_gpv_bind</span><span> </span><span>exec_gpv_inline</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bind_reflI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_spmf_bindI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>exec_gpv_oracle_bisim'</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>X</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"?X"</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>plus_oracle_stop_split</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_sum.cases</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>map_spmf_conv_bind_spmf</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>split_def</span><span> </span><span>spmf_rel_map</span><span> </span><span>rel_spmf_reflI</span><span> </span><span>rel_spmf_return_spmf1</span><span> </span><span>lossless_eval</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>nat.split</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ord_spmf (⟶) ?game2 (game_single (reduction q 𝒜))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>pmf.rel_mono_strong</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>option.rel_cases</span><span> </span><span>ord_option.cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>ord_spmf_measureD</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"{True}"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"spmf ?game2 True ≤ spmf (game_single (reduction q 𝒜)) True"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>spmf_conv_measure_spmf</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ord_le_eq_trans</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span>measure</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>advantage_multi_def</span><span> </span><span>advantage_single_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mult_right_mono</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Unpredictable_Function">
<div class="head"><h1>Theory Unpredictable_Function</h1>
<span class="command">theory</span> <span class="name">Unpredictable_Function</span><br/>
<span class="keyword">imports</span> <a href="Guessing_Many_One.html"><span class="name">Guessing_Many_One</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: Unpredictable_Function.thy
  Author: Andreas Lochbihler, ETH Zurich 
  Author: S. Reza Sefidgar, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Unpredictable function›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Unpredictable_Function</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Guessing_Many_One</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>upf</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>key_gen</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'key spmf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hash</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'key ⇒ 'x ⇒ 'hash"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'x'</span><span class="delimiter">,</span><span> </span><span class="tfree">'hash'</span><span class="delimiter">)</span><span> </span><span>adversary</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(unit, 'x' + ('x' × 'hash'), 'hash' + unit) gpv"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>oracle_hash</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'key ⇒ ('x, 'hash, 'x set) callee"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"oracle_hash k = (λL y. do {
    let t = hash k y;
    let L = insert y L;
    return_spmf (t, L)
  })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>oracle_flag</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'key ⇒ ('x × 'hash, unit, bool × 'x set) callee"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"oracle_flag = (λkey (flg, L) (y, t).
    return_spmf ((), (flg ∨ (t = (hash key y) ∧ y ∉ L), L)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"oracle"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'key ⇒ ('x + 'x × 'hash, 'hash + unit, bool × 'x set) callee"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"oracle key ≡ †(oracle_hash key) ⊕<span class="hidden">⇩</span><sub>O</sub> oracle_flag key"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>game</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('x, 'hash) adversary ⇒ bool spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"game 𝒜 = do {
    key ← key_gen;
    (_, (flag', L')) ← exec_gpv (oracle key) 𝒜 (False, {});
    return_spmf flag'
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>advantage</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('x, 'hash) adversary ⇒ real"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"advantage 𝒜 = spmf (game 𝒜) True"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'x'</span><span class="delimiter">,</span><span> </span><span class="tfree">'hash'</span><span class="delimiter">)</span><span> </span><span>adversary1</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('x' × 'hash', 'x', 'hash') gpv"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>game1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('x, 'hash) adversary1 ⇒ bool spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"game1 𝒜 = do {
    key ← key_gen;
    ((m, h), L) ← exec_gpv (oracle_hash key) 𝒜 {};
    return_spmf (h = hash key m ∧ m ∉ L)
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>advantage1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('x, 'hash) adversary1 ⇒ real"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"advantage1 𝒜 = spmf (game1 𝒜) True"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>advantage_advantage1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>bound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"interaction_bounded_by (Not ∘ isl) 𝒜 q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"advantage 𝒜 ≤ advantage1 (guessing_many_one.reduction q (λ_ :: unit. 𝒜) ()) * q"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?init</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"map_spmf (λkey. (key, (), {})) key_gen"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?oracle</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λkey . oracle_hash key"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?eval</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λkey (_ :: unit) L (x, h). return_spmf (h = hash key x ∧ x ∉ L)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>guessing_many_one</span><span> </span><span class="var">?init</span><span> </span><span class="var">?oracle</span><span> </span><span class="var">?eval</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"oracle_flag key = eval_oracle key ()"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>key</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle_flag_def</span><span> </span><span>eval_oracle_def</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game 𝒜 = game_multi (λ_. 𝒜)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>game_multi_def</span><span> </span><span>game_def</span><span> </span><span>bind_map_spmf</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>bind_spmf_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"advantage 𝒜 = advantage_multi (λ_. 𝒜)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>advantage_def</span><span> </span><span>advantage_multi_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ advantage_single (reduction q (λ_. 𝒜)) * q"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bound</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>many_single_reduction</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle_hash_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"advantage_single (reduction q (λ_. 𝒜)) = advantage1 (reduction q (λ_. 𝒜) ())"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>𝒜</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>advantage1_def</span><span> </span><span>advantage_single_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>game1_def</span><span> </span><span>game_single_def</span><span> </span><span>bind_map_spmf</span><span> </span><span>o_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>bind_spmf_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span>spmf</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Security_Spec">
<div class="head"><h1>Theory Security_Spec</h1>
<span class="command">theory</span> <span class="name">Security_Spec</span><br/>
<span class="keyword">imports</span> <a href="Diffie_Hellman.html"><span class="name">Diffie_Hellman</span></a> <a href="IND_CCA2.html"><span class="name">IND_CCA2</span></a> <a href="IND_CCA2_sym.html"><span class="name">IND_CCA2_sym</span></a> <a href="IND_CPA.html"><span class="name">IND_CPA</span></a> <a href="IND_CPA_PK.html"><span class="name">IND_CPA_PK</span></a> <a href="IND_CPA_PK_Single.html"><span class="name">IND_CPA_PK_Single</span></a> <a href="SUF_CMA.html"><span class="name">SUF_CMA</span></a> <a href="Pseudo_Random_Function.html"><span class="name">Pseudo_Random_Function</span></a> <a href="Pseudo_Random_Permutation.html"><span class="name">Pseudo_Random_Permutation</span></a> <a href="Unpredictable_Function.html"><span class="name">Unpredictable_Function</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: Game_Based_Crypto.thy
  Author: Andreas Lochbihler, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Security_Spec</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Diffie_Hellman</span><span>
</span><span>  </span><span>IND_CCA2</span><span>
</span><span>  </span><span>IND_CCA2_sym</span><span>
</span><span>  </span><span>IND_CPA</span><span>
</span><span>  </span><span>IND_CPA_PK</span><span>
</span><span>  </span><span>IND_CPA_PK_Single</span><span>
</span><span>  </span><span>SUF_CMA</span><span>
</span><span>  </span><span>Pseudo_Random_Function</span><span>
</span><span>  </span><span>Pseudo_Random_Permutation</span><span>
</span><span>  </span><span>Unpredictable_Function</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Elgamal">
<div class="head"><h1>Theory Elgamal</h1>
<span class="command">theory</span> <span class="name">Elgamal</span><br/>
<span class="keyword">imports</span> <a href="Diffie_Hellman.html"><span class="name">Diffie_Hellman</span></a> <a href="IND_CPA_PK_Single.html"><span class="name">IND_CPA_PK_Single</span></a> <a href="../CryptHOL/Negligible.html"><span class="name">Negligible</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: Elgamal.thy
  Author: Andreas Lochbihler, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Cryptographic constructions and their security›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Elgamal</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>CryptHOL.Cyclic_Group_SPMF</span><span>
</span><span>  </span><span>CryptHOL.Computational_Model</span><span>
</span><span>  </span><span>Diffie_Hellman</span><span>
</span><span>  </span><span>IND_CPA_PK_Single</span><span>
</span><span>  </span><span>CryptHOL.Negligible</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Elgamal encryption scheme›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>elgamal_base</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>𝒢</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp cyclic_group"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'grp'</span><span> </span><span>pub_key</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp'"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'grp'</span><span> </span><span>priv_key</span><span> </span><span class="delimiter">=</span><span> </span><span>nat</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'grp'</span><span> </span><span>plain</span><span> </span><span class="delimiter">=</span><span> </span><span class="tfree">'grp'</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'grp'</span><span> </span><span>cipher</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp' × 'grp'"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>key_gen</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('grp pub_key × 'grp priv_key) spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"key_gen = do {
     x ← sample_uniform (order 𝒢);
     return_spmf (<span class="hidden">❙</span><span class="bold">g</span> [^] x, x)
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>key_gen_alt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"key_gen = map_spmf (λx. (<span class="hidden">❙</span><span class="bold">g</span> [^] x, x)) (sample_uniform (order 𝒢))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>map_spmf_conv_bind_spmf</span><span> </span><span>key_gen_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>aencrypt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp pub_key ⇒ 'grp ⇒ 'grp cipher spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"aencrypt α msg = do {
    y ← sample_uniform (order 𝒢);
    return_spmf (<span class="hidden">❙</span><span class="bold">g</span> [^] y, (α [^] y) ⊗ msg)
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>aencrypt_alt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"aencrypt α msg = map_spmf (λy. (<span class="hidden">❙</span><span class="bold">g</span> [^] y, (α [^] y) ⊗ msg)) (sample_uniform (order 𝒢))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>map_spmf_conv_bind_spmf</span><span> </span><span>aencrypt_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>adecrypt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp priv_key ⇒ 'grp cipher ⇒ 'grp option"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"adecrypt x = (λ(β, ζ). Some (ζ ⊗ (inv (β [^] x))))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>valid_plains</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp ⇒ 'grp ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_plains msg1 msg2 ≡ msg1 ∈ carrier 𝒢 ∧ msg2 ∈ carrier 𝒢"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>ind_cpa</span><span class="delimiter">:</span><span> </span><span>ind_cpa</span><span> </span><span>key_gen</span><span> </span><span>aencrypt</span><span> </span><span>adecrypt</span><span> </span><span>valid_plains</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>ddh</span><span class="delimiter">:</span><span> </span><span>ddh</span><span> </span><span>𝒢</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>elgamal_adversary</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('grp pub_key, 'grp plain, 'grp cipher, 'state) ind_cpa.adversary ⇒ 'grp ddh.adversary"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"elgamal_adversary (𝒜1, 𝒜2) α β γ = TRY do {
    b ← coin_spmf;
    ((msg1, msg2), σ) ← 𝒜1 α;
    ― ‹have to check that the attacker actually sends two elements from the group; otherwise flip a coin›
    _ :: unit ← assert_spmf (valid_plains msg1 msg2);
    guess ← 𝒜2 (β, γ ⊗ (if b then msg1 else msg2)) σ;
    return_spmf (guess = b)
  } ELSE coin_spmf"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>elgamal</span><span> </span><span class="delimiter">=</span><span> </span><span>elgamal_base</span><span> </span><span class="delimiter">+</span><span> </span><span>cyclic_group</span><span> </span><span>𝒢</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>advantage_elgamal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ind_cpa.advantage 𝒜 = ddh.advantage (elgamal_adversary 𝒜)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">including</span></span><span> </span><span>monad_normalisation</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>𝒜1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>𝒜2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒜 = (𝒜1, 𝒜2)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>𝒜</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span> </span><span>order_gt_0_iff_finite</span><span> </span><span>finite_carrier</span><span> </span><span>try_spmf_bind_out</span><span> </span><span>split_def</span><span> </span><span>o_def</span><span> </span><span>spmf_of_set</span><span> </span><span>bind_map_spmf</span><span> </span><span>weight_spmf_le_1</span><span> </span><span>scale_bind_spmf</span><span> </span><span>bind_spmf_const</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">[</span><span>cong</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>bind_spmf_cong_simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ddh.ddh_1 (elgamal_adversary 𝒜) = TRY do {
       x ← sample_uniform (order 𝒢);
       y ← sample_uniform (order 𝒢);
       ((msg1, msg2), σ) ← 𝒜1 (<span class="hidden">❙</span><span class="bold">g</span> [^] x);
       _ :: unit ← assert_spmf (valid_plains msg1 msg2);
       b ← coin_spmf;
       z ← map_spmf (λz. <span class="hidden">❙</span><span class="bold">g</span> [^] z ⊗ (if b then msg1 else msg2)) (sample_uniform (order 𝒢));
       guess ← 𝒜2 (<span class="hidden">❙</span><span class="bold">g</span> [^] y, z) σ;
       return_spmf (guess ⟷ b)
     } ELSE coin_spmf"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ddh.ddh_1_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = TRY do {
       x ← sample_uniform (order 𝒢);
       y ← sample_uniform (order 𝒢);
       ((msg1, msg2), σ) ← 𝒜1 (<span class="hidden">❙</span><span class="bold">g</span> [^] x);
       _ :: unit ← assert_spmf (valid_plains msg1 msg2);
       z ← map_spmf (λz. <span class="hidden">❙</span><span class="bold">g</span> [^] z) (sample_uniform (order 𝒢));
       guess ← 𝒜2 (<span class="hidden">❙</span><span class="bold">g</span> [^] y, z) σ;
       map_spmf ((=) guess) coin_spmf
     } ELSE coin_spmf"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sample_uniform_one_time_pad</span><span> </span><span>map_spmf_conv_bind_spmf</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>p</span><span class="delimiter">=</span><span>coin_spmf</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = coin_spmf"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>map_eq_const_coin_spmf</span><span> </span><span>try_bind_spmf_lossless2'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ddh.ddh_0 (elgamal_adversary 𝒜) = ind_cpa.ind_cpa 𝒜"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ddh.ddh_0_def</span><span> </span><span>IND_CPA_PK_Single.ind_cpa.ind_cpa_def</span><span> </span><span>key_gen_def</span><span> </span><span>aencrypt_def</span><span> </span><span>nat_pow_pow</span><span> </span><span>eq_commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ddh.advantage_def</span><span> </span><span>ind_cpa.advantage_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>elgamal_asymp</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>𝒢</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ 'grp cyclic_group"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>elgamal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀η. elgamal (𝒢 η)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>elgamal</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒢 η"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>η</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>elgamal</span><span class="delimiter">)</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>elgamal_secure</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"negligible (λη. ind_cpa.advantage η (𝒜 η))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"negligible (λη. ddh.advantage η (elgamal_adversary η (𝒜 η)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>advantage_elgamal</span><span> </span><span>that</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>elgamal_base</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lossless_key_gen</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_spmf (key_gen) ⟷ 0 &lt; order 𝒢"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>key_gen_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lossless_aencrypt</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lossless_spmf (aencrypt key plain) ⟷ 0 &lt; order 𝒢"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>aencrypt_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lossless_elgamal_adversary</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ ind_cpa.lossless 𝒜; 0 &lt; order 𝒢 ⟧
  ⟹ ddh.lossless (elgamal_adversary 𝒜)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>𝒜</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ddh.lossless_def</span><span> </span><span>ind_cpa.lossless_def</span><span> </span><span>Let_def</span><span> </span><span>split_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Hashed_Elgamal">
<div class="head"><h1>Theory Hashed_Elgamal</h1>
<span class="command">theory</span> <span class="name">Hashed_Elgamal</span><br/>
<span class="keyword">imports</span> <a href="../CryptHOL/GPV_Bisim.html"><span class="name">GPV_Bisim</span></a> <a href="../CryptHOL/List_Bits.html"><span class="name">List_Bits</span></a> <a href="IND_CPA_PK.html"><span class="name">IND_CPA_PK</span></a> <a href="Diffie_Hellman.html"><span class="name">Diffie_Hellman</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: Hashed_Elgamal.thy
  Author: Andreas Lochbihler, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Hashed Elgamal in the Random Oracle Model›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Hashed_Elgamal</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>CryptHOL.GPV_Bisim</span><span>
</span><span>  </span><span>CryptHOL.Cyclic_Group_SPMF</span><span>
</span><span>  </span><span>CryptHOL.List_Bits</span><span>
</span><span>  </span><span>IND_CPA_PK</span><span>
</span><span>  </span><span>Diffie_Hellman</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>bitstring</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"bool list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>hash_oracle</span><span> </span><span class="delimiter">=</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>len</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>state</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇀ bitstring"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"oracle"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a state ⇒ 'a ⇒ (bitstring × 'a state) spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"oracle σ x = 
  (case σ x of None ⇒ do {
     bs ← spmf_of_set (nlists UNIV len);
     return_spmf (bs, σ(x ↦ bs))
   } | Some bs ⇒ return_spmf (bs, σ))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>initial</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a state"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"initial ≡ Map.empty"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>invariant</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a state ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>invariant</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ finite (dom σ); length ` ran σ ⊆ {len} ⟧ ⟹ invariant σ"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invariant_initial</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invariant initial"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>invariant.intros</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invariant_update</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ invariant σ; length bs = len ⟧ ⟹ invariant (σ(x ↦ bs))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invariant.simps</span><span> </span><span>ran_def</span><span class="delimiter">)</span><span>
</span><span>                           
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invariant</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"callee_invariant oracle invariant"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle_def</span><span> </span><span>in_nlists_UNIV</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split_asm</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invariant_in_dom</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"callee_invariant oracle (λσ. x ∈ dom σ)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split_asm</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lossless_oracle</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_spmf (oracle σ x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>card_dom_state</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>σ'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, σ') ∈ set_spmf (exec_gpv oracle gpv σ)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ibound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"interaction_any_bounded_by gpv n"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (dom σ') ≤ n + card (dom σ)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (dom σ)"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>callee_invariant_on</span><span> </span><span class="string"><span class="delete"><span class="delete">"oracle"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λσ. finite (dom σ)"</span></span></span><span> </span><span>ℐ_full</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split_asm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ibound</span><span> </span><span>σ'</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>interaction_bounded_by'_exec_gpv_count</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle_def</span><span> </span><span>card_insert_if</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>fun_upd_apply</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split_asm</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>callee_invariant_on</span><span> </span><span class="string"><span class="delete"><span class="delete">"oracle"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λσ'. dom σ ⊆ dom σ'"</span></span></span><span> </span><span>ℐ_full</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split_asm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>σ'</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dom σ ⊆ dom σ'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>exec_gpv_invariant</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"infinite (dom σ')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>finite_subset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>False</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>elgamal_base</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>𝒢</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp cyclic_group"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>len_plain</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>hash</span><span class="delimiter">:</span><span> </span><span>hash_oracle</span><span> </span><span class="string"><span class="delete"><span class="delete">"len_plain"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>hash</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp ⇒ (bitstring, 'grp, bitstring) gpv"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hash x ≡ Pause x Done"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'grp'</span><span> </span><span>pub_key</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp'"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'grp'</span><span> </span><span>priv_key</span><span> </span><span class="delimiter">=</span><span> </span><span>nat</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>plain</span><span> </span><span class="delimiter">=</span><span> </span><span>bitstring</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'grp'</span><span> </span><span>cipher</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp' × bitstring"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>key_gen</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('grp pub_key × 'grp priv_key) spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"key_gen = do {
     x ← sample_uniform (order 𝒢);
     return_spmf (<span class="hidden">❙</span><span class="bold">g</span> [^] x, x)
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>aencrypt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp pub_key ⇒ plain ⇒ ('grp cipher, 'grp, bitstring) gpv"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"aencrypt α msg = do {
    y ← lift_spmf (sample_uniform (order 𝒢));
    h ← hash (α [^] y);
    Done (<span class="hidden">❙</span><span class="bold">g</span> [^] y, h [⊕] msg)
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>adecrypt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp priv_key ⇒ 'grp cipher ⇒ (plain, 'grp, bitstring) gpv"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"adecrypt x = (λ(β, ζ). do {
    h ← hash (β [^] x);
    Done (ζ [⊕] h)
  })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>valid_plains</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"plain ⇒ plain ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_plains msg1 msg2 ⟷ length msg1 = len_plain ∧ length msg2 = len_plain"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lossless_aencrypt</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_gpv ℐ (aencrypt α msg) ⟷ 0 &lt; order 𝒢"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>aencrypt_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>interaction_bounded_by_aencrypt</span><span> </span><span class="delimiter">[</span><span>interaction_bound</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"interaction_bounded_by (λ_. True) (aencrypt α msg) 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>aencrypt_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>interaction_bound</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>one_enat_def</span><span> </span><span>SUP_le_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>ind_cpa</span><span class="delimiter">:</span><span> </span><span>ind_cpa_pk</span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_spmf key_gen"</span></span></span><span> </span><span>aencrypt</span><span> </span><span>adecrypt</span><span> </span><span>valid_plains</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>lcdh</span><span class="delimiter">:</span><span> </span><span>lcdh</span><span> </span><span>𝒢</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>elgamal_adversary</span><span>
</span><span>   </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('grp pub_key, plain, 'grp cipher, 'grp, bitstring, 'state) ind_cpa.adversary
   ⇒ 'grp lcdh.adversary"</span></span></span><span>                     
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"elgamal_adversary (𝒜1, 𝒜2) α β = do {
    (((msg1, msg2), σ), s) ← exec_gpv hash.oracle (𝒜1 α) hash.initial;
    ― ‹have to check that the attacker actually sends an element from the group; otherwise stop early›
    TRY do {
      _ :: unit ← assert_spmf (valid_plains msg1 msg2);
      h' ← spmf_of_set (nlists UNIV len_plain);
      (guess, s') ← exec_gpv hash.oracle (𝒜2 (β, h') σ) s;
      return_spmf (dom s')
    } ELSE return_spmf (dom s)
  }"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>elgamal</span><span> </span><span class="delimiter">=</span><span> </span><span>elgamal_base</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>cyclic_group</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cyclic_group 𝒢"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>cyclic_group</span><span> </span><span>𝒢</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fact</span><span> </span><span>cyclic_group</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>advantage_elgamal</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>lifting_syntax</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>lossless</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ind_cpa.lossless 𝒜"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ind_cpa.advantage hash.oracle hash.initial 𝒜 ≤ lcdh.advantage (elgamal_adversary 𝒜)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>cong</span><span> </span><span>del</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>if_weak_cong</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">[</span><span>split</span><span> </span><span>del</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>if_split</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>map_lift_spmf</span><span> </span><span>gpv.map_id</span><span> </span><span>lossless_weight_spmfD</span><span> </span><span>map_spmf_bind_spmf</span><span> </span><span>bind_spmf_const</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>𝒜1</span><span> </span><span>𝒜2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>𝒜</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒜 = (𝒜1, 𝒜2)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒜"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>cyclic_group</span><span class="delimiter">:</span><span> </span><span>cyclic_group</span><span> </span><span>𝒢</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>cyclic_group</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>finite_carrier</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"order 𝒢 &gt; 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>order_gt_0_iff_finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>lossless</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lossless1</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀pk. lossless_gpv ℐ_full (𝒜1 pk)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lossless2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀σ cipher. lossless_gpv ℐ_full (𝒜2 σ cipher)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ind_cpa.lossless_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We change the adversary's oracle to record the queries made by the adversary›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>hash_oracle'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hash_oracle' = (λσ x. do {
      h ← hash x;
      Done (h, insert x σ)
    })"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_gpv ℐ_full (hash_oracle' σ x)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>σ</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hash_oracle'_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_gpv ℐ_full (inline hash_oracle' (𝒜1 α) s)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>α</span><span> </span><span>s</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>lossless_inline</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ℐ</span><span class="delimiter">=</span><span>ℐ_full</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>game0</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game0 = TRY do {
      (pk, _) ← lift_spmf key_gen;
      b ← lift_spmf coin_spmf;
      (((msg1, msg2), σ), s) ← inline hash_oracle' (𝒜1 pk) {};
      assert_gpv (valid_plains msg1 msg2);
      cipher ← aencrypt pk (if b then msg1 else msg2);
      (guess, s') ← inline hash_oracle' (𝒜2 cipher σ) s;
      Done (guess = b)
    } ELSE lift_spmf coin_spmf"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>cr</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cr = (λ_ :: unit. λ_ :: 'a set. True)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cr () {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cr_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"((=) ===&gt; cr ===&gt; cr) (λ_ σ. σ) insert"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_fun_def</span><span> </span><span>cr_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(cr ===&gt; (=) ===&gt; rel_gpv (rel_prod (=) cr) (=)) id_oracle hash_oracle'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hash_oracle'_def</span><span> </span><span>id_oracle_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>bind_gpv_Pause</span><span> </span><span>bind_rpv_Done</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer_prover</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ind_cpa.ind_cpa 𝒜 = game0"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>game0_def</span><span> </span><span>𝒜</span><span> </span><span>ind_cpa_pk.ind_cpa.simps</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>transfer</span><span> </span><span>fixing</span><span class="delimiter">:</span><span> </span><span>𝒢</span><span> </span><span>len_plain</span><span> </span><span>𝒜1</span><span> </span><span>𝒜2</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bind_map_gpv</span><span> </span><span>o_def</span><span> </span><span>ind_cpa_pk.ind_cpa.simps</span><span> </span><span>split_def</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>game0</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>game0_alt_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"game0 = do {
      x ← lift_spmf (sample_uniform (order 𝒢));
      b ← lift_spmf coin_spmf;
      (((msg1, msg2), σ), s) ← inline hash_oracle' (𝒜1 (<span class="hidden">❙</span><span class="bold">g</span> [^] x)) {};
      TRY do {
        _ :: unit ← assert_gpv (valid_plains msg1 msg2);
        cipher ← aencrypt (<span class="hidden">❙</span><span class="bold">g</span> [^] x) (if b then msg1 else msg2);
        (guess, s') ← inline hash_oracle' (𝒜2 cipher σ) s;
        Done (guess = b)
      } ELSE lift_spmf coin_spmf
    }"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>split_def</span><span> </span><span>game0_def</span><span> </span><span>key_gen_def</span><span> </span><span>lift_spmf_bind_spmf</span><span> </span><span>bind_gpv_assoc</span><span> </span><span>try_gpv_bind_lossless</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>hash_oracle''</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hash_oracle'' = (λ(s, σ) (x :: 'a). do {
      (h, σ') ← case σ x of
          None ⇒ bind_spmf (spmf_of_set (nlists UNIV len_plain)) (λbs. return_spmf (bs, σ(x ↦ bs)))
        | Some (bs :: bitstring) ⇒ return_spmf (bs, σ);
      return_spmf (h, insert x s, σ')
    })"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"exec_gpv hash.oracle (inline hash_oracle' 𝒜 s) σ = 
    map_spmf (λ(a, b, c). ((a, b), c)) (exec_gpv hash_oracle'' 𝒜 (s, σ))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>𝒜</span><span> </span><span>σ</span><span> </span><span>s</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hash_oracle'_def</span><span> </span><span>hash_oracle''_def</span><span> </span><span>hash.oracle_def</span><span> </span><span>Let_def</span><span> </span><span>exec_gpv_inline</span><span> </span><span>exec_gpv_bind</span><span> </span><span>o_def</span><span> </span><span>split_def</span><span> </span><span>cong</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>option.case_cong_weak</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_spmf (hash_oracle'' s plain)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>plain</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hash_oracle''_def</span><span> </span><span>Let_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.split</span><span> </span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_spmf (exec_gpv hash_oracle'' (𝒜1 α) s)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>α</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>lossless_exec_gpv</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ℐ</span><span class="delimiter">=</span><span>ℐ_full</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_spmf (exec_gpv hash_oracle'' (𝒜2 σ cipher) s)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>σ</span><span> </span><span>cipher</span><span> </span><span>s</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>lossless_exec_gpv</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ℐ</span><span class="delimiter">=</span><span>ℐ_full</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?sample</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λf. bind_spmf (sample_uniform (order 𝒢)) (λx. bind_spmf (sample_uniform (order 𝒢)) (f x))"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>game1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game1 = (λ(x :: nat) (y :: nat). do {
      b ← coin_spmf;
      (((msg1, msg2), σ), (s, s_h)) ← exec_gpv hash_oracle'' (𝒜1 (<span class="hidden">❙</span><span class="bold">g</span> [^] x)) ({}, hash.initial);
      TRY do {
        _ :: unit ← assert_spmf (valid_plains msg1 msg2);
        (h, s_h') ← hash.oracle s_h (<span class="hidden">❙</span><span class="bold">g</span> [^] (x * y));
        let cipher = (<span class="hidden">❙</span><span class="bold">g</span> [^] y, h [⊕] (if b then msg1 else msg2));
        (guess, (s', s_h'')) ← exec_gpv hash_oracle'' (𝒜2 cipher σ) (s, s_h');
        return_spmf (guess = b, <span class="hidden">❙</span><span class="bold">g</span> [^] (x * y) ∈ s')
      } ELSE do {
        b ← coin_spmf;
        return_spmf (b, <span class="hidden">❙</span><span class="bold">g</span> [^] (x * y) ∈ s)
      }
    })"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>game01</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"run_gpv hash.oracle game0 hash.initial = map_spmf fst (?sample game1)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>exec_gpv_bind</span><span> </span><span>split_def</span><span> </span><span>bind_gpv_assoc</span><span> </span><span>aencrypt_def</span><span> </span><span>game0_alt_def</span><span> </span><span>game1_def</span><span> </span><span>o_def</span><span> </span><span>bind_map_spmf</span><span> </span><span>if_distribs</span><span> </span><span>*</span><span> </span><span>try_bind_assert_gpv</span><span> </span><span>try_bind_assert_spmf</span><span> </span><span>lossless_inline</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ℐ</span><span class="delimiter">=</span><span>ℐ_full</span><span class="delimiter">]</span><span> </span><span>bind_rpv_def</span><span> </span><span>nat_pow_pow</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>bind_spmf_const</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">including</span></span><span> </span><span>monad_normalisation</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bind_rpv_def</span><span> </span><span>nat_pow_pow</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>game2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game2 = (λ(x :: nat) (y :: nat). do {
    b ← coin_spmf;
    (((msg1, msg2), σ), (s, s_h)) ← exec_gpv hash_oracle'' (𝒜1 (<span class="hidden">❙</span><span class="bold">g</span> [^] x)) ({}, hash.initial);
    TRY do {
      _ :: unit ← assert_spmf (valid_plains msg1 msg2);
      h ← spmf_of_set (nlists UNIV len_plain);
      ― ‹We do not do the lookup in ‹s_h› here, so the rest differs only if the adversary guessed ‹y››
      let cipher = (<span class="hidden">❙</span><span class="bold">g</span> [^] y, h [⊕] (if b then msg1 else msg2));
      (guess, (s', s_h')) ← exec_gpv hash_oracle'' (𝒜2 cipher σ) (s, s_h);
      return_spmf (guess = b, <span class="hidden">❙</span><span class="bold">g</span> [^] (x * y) ∈ s')
    } ELSE do {
      b ← coin_spmf;
      return_spmf (b, <span class="hidden">❙</span><span class="bold">g</span> [^] (x * y) ∈ s)
    }
  })"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>inv''</span><span class="delimiter">:</span><span> </span><span>callee_invariant_on</span><span> </span><span class="string"><span class="delete"><span class="delete">"hash_oracle''"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(s, s_h). s = dom s_h"</span></span></span><span> </span><span>ℐ_full</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hash_oracle''_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split_asm</span><span> </span><span>if_split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>in_encrypt_oracle</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"callee_invariant hash_oracle'' (λ(s, _). x ∈ s)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hash_oracle''_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?bad</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(s, s_h). <span class="hidden">❙</span><span class="bold">g</span> [^] (x * y) ∈ s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?X</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(s, s_h) (s', s_h'). s = dom s_h ∧ s' = s ∧ s_h = s_h'(<span class="hidden">❙</span><span class="bold">g</span> [^] (x * y) := None)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bisim</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"rel_spmf (λ(a, s1') (b, s2'). ?bad s1' = ?bad s2' ∧ (¬ ?bad s2' ⟶ a = b ∧ ?X s1' s2'))
             (hash_oracle'' s1 plain) (hash_oracle'' s2 plain)"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?X s1 s2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s1</span><span> </span><span>s2</span><span> </span><span>plain</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bind_reflI</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hash_oracle''_def</span><span> </span><span>rel_spmf_return_spmf2</span><span> </span><span>fun_upd_twist</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>fun_upd_eqD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"callee_invariant hash_oracle'' ?bad"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hash_oracle''_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split_asm</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_spmf (λ(win, bad) (win', bad'). bad = bad' ∧ (¬ bad' ⟶ win = win')) (game2 x y) (game1 x y)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>game1_def</span><span> </span><span>game2_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>split_def</span><span> </span><span>o_def</span><span> </span><span>hash.oracle_def</span><span> </span><span>rel_spmf_bind_reflI</span><span> </span><span>if_distribs</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bind_reflI</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>bind_spmf_const</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_spmf_try_spmf</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b</span><span> </span><span>msg1</span><span> </span><span>msg2</span><span> </span><span>σ</span><span> </span><span>s</span><span> </span><span>s_h</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_spmf_bind_reflI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule</span><span> </span><span>inv''.exec_gpv_invariant</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"s_h (<span class="hidden">❙</span><span class="bold">g</span> [^] (x * y))"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="comment">― ‹case @{const None}›</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bind_reflI</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_spmf_bindI</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>exec_gpv_oracle_bisim_bad_full</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>bisim</span><span> </span><span>inv</span><span> </span><span>inv</span><span class="delimiter">,</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λ(x, s1) (y, s2). ?bad s1 = ?bad s2 ∧ (¬ ?bad s2 ⟶ x = y)"</span></span></span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_upd_idem</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bindI1</span><span> </span><span>rel_spmf_bindI2</span><span> </span><span>lossless_exec_gpv</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ℐ</span><span class="delimiter">=</span><span>ℐ_full</span><span class="delimiter">]</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>callee_invariant_on.exec_gpv_invariant</span><span class="delimiter">[</span><span>OF</span><span> </span><span>in_encrypt_oracle</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_spmf_reflI</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_spmf (λ(win, bad) (win', bad'). (bad ⟷ bad') ∧ (¬ bad' ⟶ win ⟷ win')) (?sample game2) (?sample game1)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>rel_spmf_bind_reflI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¦measure (measure_spmf (?sample game2)) {(x, _). x} - measure (measure_spmf (?sample game1)) {(y, _). y}¦
        ≤ measure (measure_spmf (?sample game2)) {(_, bad). bad}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>split_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>fundamental_lemma</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"measure (measure_spmf (?sample game2)) {(x, _). x} = spmf (map_spmf fst (?sample game2)) True"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"measure (measure_spmf (?sample game1)) {(y, _). y} = spmf (map_spmf fst (?sample game1)) True"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"measure (measure_spmf (?sample game2)) {(_, bad). bad} = spmf (map_spmf snd (?sample game2)) True"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>spmf_conv_measure_spmf</span><span> </span><span>measure_map_spmf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span>measure</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>fastforce</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>hop23</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¦spmf (map_spmf fst (?sample game2)) True - spmf (map_spmf fst (?sample game1)) True¦ ≤ spmf (map_spmf snd (?sample game2)) True"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>game3</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game3 = (λf :: _ ⇒ _ ⇒ _ ⇒ bitstring spmf ⇒ _ spmf. λ(x :: nat) (y :: nat). do {
      b ← coin_spmf;
      (((msg1, msg2), σ), (s, s_h)) ← exec_gpv hash_oracle'' (𝒜1 (<span class="hidden">❙</span><span class="bold">g</span> [^] x)) ({}, hash.initial);
      TRY do {
        _ :: unit ← assert_spmf (valid_plains msg1 msg2);
        h' ← f b msg1 msg2 (spmf_of_set (nlists UNIV len_plain));
        let cipher = (<span class="hidden">❙</span><span class="bold">g</span> [^] y, h');
        (guess, (s', s_h')) ← exec_gpv hash_oracle'' (𝒜2 cipher σ) (s, s_h);
        return_spmf (guess = b, <span class="hidden">❙</span><span class="bold">g</span> [^] (x * y) ∈ s')
      } ELSE do {
        b ← coin_spmf;
        return_spmf (b, <span class="hidden">❙</span><span class="bold">g</span> [^] (x * y) ∈ s)
      }
    })"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?f</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λb msg1 msg2. map_spmf (λh. (if b then msg1 else msg2) [⊕] h)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game2 x y = game3 ?f x y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>game2_def</span><span> </span><span>game3_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>bind_map_spmf</span><span> </span><span>xor_list_commute</span><span> </span><span>o_def</span><span> </span><span>nat_pow_pow</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game3 ?f x y = game3 (λ_ _ _ x. x) x y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* optimistic sampling *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>game3_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>try_spmf_cong</span><span> </span><span>bind_spmf_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span> </span><span>if_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>split_def</span><span> </span><span>one_time_pad</span><span> </span><span>valid_plains_def</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>map_spmf_of_set_inj_on</span><span> </span><span>bind_spmf_const</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>game23</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"game2 x y = game3 (λ_ _ _ x. x) x y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>hash_oracle'''</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hash_oracle''' = (λ(σ :: 'a ⇒ _). hash.oracle σ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>bisim</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bisim = (λσ (s :: 'a set, σ' :: 'a ⇀ bitstring). s = dom σ ∧ σ = σ')"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bisim Map_empty ({}, Map_empty)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bisim_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(bisim ===&gt; (=) ===&gt; rel_spmf (rel_prod (=) bisim)) hash_oracle''' hash_oracle''"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hash_oracle''_def</span><span> </span><span>split_def</span><span> </span><span>hash_oracle'''_def</span><span> </span><span>spmf_rel_map</span><span> </span><span>hash.oracle_def</span><span> </span><span>rel_fun_def</span><span> </span><span>bisim_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bind_reflI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(bisim ===&gt; (=)) dom fst"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bisim_def</span><span> </span><span>rel_fun_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(bisim ===&gt; (=)) (λx. x) snd"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_fun_def</span><span> </span><span>bisim_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game3 (λ_ _ _ x. x) x y = do {
        b ← coin_spmf;
        (((msg1, msg2), σ), s) ← exec_gpv hash_oracle''' (𝒜1 (<span class="hidden">❙</span><span class="bold">g</span> [^] x)) hash.initial;
        TRY do {
          _ :: unit ← assert_spmf (valid_plains msg1 msg2);
          h' ← spmf_of_set (nlists UNIV len_plain);
          let cipher = (<span class="hidden">❙</span><span class="bold">g</span> [^] y, h');
          (guess, s') ← exec_gpv hash_oracle''' (𝒜2 cipher σ) s;
          return_spmf (guess = b, <span class="hidden">❙</span><span class="bold">g</span> [^] (x * y) ∈ dom s')
        } ELSE do {
          b ← coin_spmf;
          return_spmf (b, <span class="hidden">❙</span><span class="bold">g</span> [^] (x * y) ∈ dom s)
        }
      }"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>game3_def</span><span> </span><span>Map_empty_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>split_def</span><span> </span><span>fst_conv</span><span> </span><span>snd_conv</span><span> </span><span>prod.collapse</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>transfer</span><span> </span><span>fixing</span><span class="delimiter">:</span><span> </span><span>𝒜1</span><span> </span><span>𝒢</span><span> </span><span>len_plain</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>𝒜2</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map_spmf snd (… x y) = do {
        zs ← elgamal_adversary 𝒜 (<span class="hidden">❙</span><span class="bold">g</span> [^] x) (<span class="hidden">❙</span><span class="bold">g</span> [^] y);
        return_spmf (<span class="hidden">❙</span><span class="bold">g</span> [^] (x * y) ∈ zs)
      }"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>o_def</span><span> </span><span>split_def</span><span> </span><span>hash_oracle'''_def</span><span> </span><span>map_try_spmf</span><span> </span><span>map_scale_spmf</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>o_def</span><span> </span><span>map_try_spmf</span><span> </span><span>map_scale_spmf</span><span> </span><span>map_spmf_conv_bind_spmf</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>spmf.map_comp</span><span> </span><span>map_const_spmf_of_set</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map_spmf snd (?sample (game3 (λ_ _ _ x. x))) = lcdh.lcdh (elgamal_adversary 𝒜)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>o_def</span><span> </span><span>lcdh.lcdh_def</span><span> </span><span>Let_def</span><span> </span><span>nat_pow_pow</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>game2_snd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"map_spmf snd (?sample game2) = lcdh.lcdh (elgamal_adversary 𝒜)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game23</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>o_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map_spmf fst (game3 (λ_ _ _ x. x) x y) = do {
      (((msg1, msg2), σ), (s, s_h)) ← exec_gpv hash_oracle'' (𝒜1 (<span class="hidden">❙</span><span class="bold">g</span> [^] x)) ({}, hash.initial);
      TRY do {
        _ :: unit ← assert_spmf (valid_plains msg1 msg2);
        h' ← spmf_of_set (nlists UNIV len_plain);
        (guess, (s', s_h')) ← exec_gpv hash_oracle'' (𝒜2 (<span class="hidden">❙</span><span class="bold">g</span> [^] y, h') σ) (s, s_h);
        map_spmf ((=) guess) coin_spmf
      } ELSE coin_spmf
    }"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">including</span></span><span> </span><span>monad_normalisation</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>game3_def</span><span> </span><span>o_def</span><span> </span><span>split_def</span><span> </span><span>map_spmf_conv_bind_spmf</span><span> </span><span>try_spmf_bind_out</span><span> </span><span>weight_spmf_le_1</span><span> </span><span>scale_bind_spmf</span><span> </span><span>try_spmf_bind_out1</span><span> </span><span>bind_scale_spmf</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>game3_fst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"map_spmf fst (game3 (λ_ _ _ x. x) x y) = coin_spmf"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>o_def</span><span> </span><span>if_distribs</span><span> </span><span>spmf.map_comp</span><span> </span><span>map_eq_const_coin_spmf</span><span> </span><span>split_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ind_cpa.advantage hash.oracle hash.initial 𝒜 = ¦spmf (map_spmf fst (?sample game1)) True - 1 / 2¦"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ind_cpa_pk.advantage_def</span><span> </span><span>game01</span><span> </span><span>o_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = ¦1 / 2 - spmf (map_spmf fst (?sample game1)) True¦"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>abs_minus_commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1 / 2 = spmf (map_spmf fst (?sample game2)) True"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>game23</span><span> </span><span>o_def</span><span> </span><span>game3_fst</span><span> </span><span>spmf_of_set</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>hop23</span><span> </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>game2_snd</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lcdh.advantage_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>elgamal_base</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lossless_key_gen</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_spmf key_gen ⟷ 0 &lt; order 𝒢"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>key_gen_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lossless_elgamal_adversary</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ ind_cpa.lossless 𝒜; ⋀η. 0 &lt; order 𝒢 ⟧
  ⟹ lcdh.lossless (elgamal_adversary 𝒜)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>𝒜</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lcdh.lossless_def</span><span> </span><span>ind_cpa.lossless_def</span><span> </span><span>split_def</span><span> </span><span>Let_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>lossless_exec_gpv</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ℐ</span><span class="delimiter">=</span><span>ℐ_full</span><span class="delimiter">]</span><span> </span><span>lossless_inline</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="RP_RF">
<div class="head"><h1>Theory RP_RF</h1>
<span class="command">theory</span> <span class="name">RP_RF</span><br/>
<span class="keyword">imports</span> <a href="Pseudo_Random_Function.html"><span class="name">Pseudo_Random_Function</span></a> <a href="Pseudo_Random_Permutation.html"><span class="name">Pseudo_Random_Permutation</span></a> <a href="../CryptHOL/GPV_Bisim.html"><span class="name">GPV_Bisim</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: RP_RF.thy
  Author: Andreas Lochbihler, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The random-permutation random-function switching lemma›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>RP_RF</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Pseudo_Random_Function</span><span>
</span><span>  </span><span>Pseudo_Random_Permutation</span><span>
</span><span>  </span><span>CryptHOL.GPV_Bisim</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rp_resample</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B ⊆ A ∪ C"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∩ C = {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C ⊆ B"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>finB</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite B"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bind_spmf (spmf_of_set B) (λx. if x ∈ A then spmf_of_set C else return_spmf x) = spmf_of_set C"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"C = {} ∨ A ∩ B = {}"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>A'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A' ≡ A ∩ B"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"C ≠ {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>A'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A' ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>A'_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"B = A' ∪ C"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>A'_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>finB</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>finA</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite A'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>finC</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>A'C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A' ∩ C = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>A'_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bind_spmf (spmf_of_set B) (λx. if x ∈ A then spmf_of_set C else return_spmf x) = 
        bind_spmf (spmf_of_set B) (λx. if x ∈ A' then spmf_of_set C else return_spmf x)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>bind_spmf_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>set_spmf_of_set</span><span> </span><span>finB</span><span> </span><span>A'_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = spmf_of_set C"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>spmf_eqI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑x∈C. spmf (if x ∈ A' then spmf_of_set C else return_spmf x) i) = indicator C i"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finA</span><span> </span><span>finC</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>disjoint_notin1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>A'C</span><span class="delimiter">]</span><span> </span><span>indicator_single_Some</span><span> </span><span>sum_mult_indicator</span><span class="delimiter">[</span><span>of</span><span> </span><span>C</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_. 1 :: real"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_. _"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λx. x"</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>split_indicator</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>conj_cong</span><span> </span><span>sum.cong</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"spmf ?lhs i = spmf ?rhs i"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B</span><span> </span><span>finA</span><span> </span><span>finC</span><span> </span><span>A'C</span><span> </span><span>C</span><span> </span><span>A'</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>spmf_bind</span><span> </span><span>integral_spmf_of_set</span><span> </span><span>sum_Un</span><span> </span><span>spmf_of_set</span><span> </span><span>field_simps</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>field_simps</span><span> </span><span>card_Un_disjoint</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span class="delimiter">(</span><span>use</span><span> </span><span>assms</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹auto 4 3 cong: bind_spmf_cong_simp simp add: subsetD bind_spmf_const spmf_of_set_empty disjoint_notin1 intro!: arg_cong[where f=spmf_of_set]›</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>rp_rf</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>rp</span><span class="delimiter">:</span><span> </span><span>random_permutation</span><span> </span><span>A</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span>rf</span><span class="delimiter">:</span><span> </span><span>random_function</span><span> </span><span class="string"><span class="delete"><span class="delete">"spmf_of_set A"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>A</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set"</span></span></span><span>
</span><span>  </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>finite_A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite A"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nonempty_A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ≠ {}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a'</span><span> </span><span>adversary</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(bool, 'a', 'a') gpv"</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>game</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"bool ⇒ 'a adversary ⇒ bool spmf"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"game b 𝒜 = run_gpv (if b then rp.random_permutation else rf.random_oracle) 𝒜 Map.empty"</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>prp_game</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a adversary ⇒ bool spmf"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prp_game ≡ game True"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>prf_game</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a adversary ⇒ bool spmf"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prf_game ≡ game False"</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>advantage</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a adversary ⇒ real"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"advantage 𝒜 = ¦spmf (prp_game 𝒜) True - spmf (prf_game 𝒜) True¦"</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>advantage_nonneg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ advantage 𝒜"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>advantage_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>advantage_le_1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"advantage 𝒜 ≤ 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>advantage_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>abs_leI</span><span class="delimiter">)</span><span class="delimiter">(</span><span>metis</span><span> </span><span>diff_0_right</span><span> </span><span>diff_left_mono</span><span> </span><span>order_trans</span><span> </span><span>pmf_le_1</span><span> </span><span>pmf_nonneg</span><span class="delimiter">)</span><span> </span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>ℐ.lifting</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>ℐ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'a) ℐ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λx. if x ∈ A then A else {})"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>outs_ℐ_ℐ</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"outs_ℐ ℐ = A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>responses_ℐ_ℐ</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"responses_ℐ ℐ x = (if x ∈ A then A else {})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lifting_update</span></span><span> </span><span>ℐ.lifting</span><span>
</span><span class="keyword1"><span class="command">lifting_forget</span></span><span> </span><span>ℐ.lifting</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rp_rf</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>bound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"interaction_any_bounded_by 𝒜 q"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lossless</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_gpv ℐ 𝒜"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>WT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℐ ⊢g 𝒜 √"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"advantage 𝒜 ≤ q * q / card A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">including</span></span><span> </span><span>lifting_syntax</span><span>  
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?run</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λb. exec_gpv (if b then rp.random_permutation else rf.random_oracle) 𝒜 Map.empty"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>rp_bad</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"bool × ('a ⇀ 'a) ⇒ 'a ⇒ ('a × (bool × ('a ⇀ 'a))) spmf"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rp_bad = (λ(bad, σ) x. case σ x of Some y ⇒ return_spmf (y, (bad, σ))
      | None ⇒ bind_spmf (spmf_of_set A) (λy. if y ∈ ran σ then map_spmf (λy'. (y', (True, σ(x ↦ y')))) (spmf_of_set (A - ran σ)) else return_spmf (y, (bad, (σ(x ↦ y))))))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rp_bad_simps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rp_bad (bad, σ) x = (case σ x of Some y ⇒ return_spmf (y, (bad, σ))
      | None ⇒ bind_spmf (spmf_of_set A) (λy. if y ∈ ran σ then map_spmf (λy'. (y', (True, σ(x ↦ y')))) (spmf_of_set (A - ran σ)) else return_spmf (y, (bad, (σ(x ↦ y))))))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>bad</span><span> </span><span>σ</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rp_bad_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_prod2 (=)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"bool × ('a ⇀ 'a)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"init = (False, Map.empty)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rp.random_permutation = (λσ x. case σ x of Some y ⇒ return_spmf (y, σ) 
    | None ⇒ bind_spmf (bind_spmf (spmf_of_set A) (λy. if y ∈ ran σ then spmf_of_set (A - ran σ) else return_spmf y)) (λy. return_spmf (y, σ(x ↦ y))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>rp_resample</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>finite_A</span><span> </span><span>rp.random_permutation_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(?S ===&gt; (=) ===&gt; rel_spmf (rel_prod (=) ?S)) rp.random_permutation rp_bad"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rp</span><span> </span><span>rp_bad_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_fun_def</span><span> </span><span>map_spmf_conv_bind_spmf</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bind_reflI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?S Map.empty init"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>init_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"spmf (prp_game 𝒜) True = spmf (run_gpv rp_bad 𝒜 init) True"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vimage_def</span><span> </span><span>game_def</span><span> </span><span>if_True</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer_prover</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>collision</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇀ 'a) ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"collision m ⟷ ¬ inj_on m (dom m)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>m</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ collision Map.empty"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>collision_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ collision m; m x = None ⟧ ⟹ collision (m(x := y))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>m</span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>collision_def</span><span> </span><span>fun_upd_idem</span><span> </span><span>dom_minus</span><span> </span><span>fun_upd_image</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>inj_on_fun_updD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>collision_map_updI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ m x = None; y ∈ ran m ⟧ ⟹ collision (m(x ↦ y))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>m</span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>collision_def</span><span> </span><span>ran_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rev_image_eqI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>collision_map_upd_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ collision m ⟹ collision (m(x ↦ y)) ⟷ y ∈ ran m ∧ m x ≠ Some y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>m</span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>collision_def</span><span> </span><span>ran_def</span><span> </span><span>fun_upd_idem</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>inj_on_fun_updI</span><span> </span><span>rev_image_eqI</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>inj_on_eq_iff</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?bad1</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"collision"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="var">?bad2</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="var">?X</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λσ1 (bad, σ2). σ1 = σ2 ∧ ¬ collision σ1 ∧ ¬ bad"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="var">?I1</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λσ1. dom σ1 ⊆ A ∧ ran σ1 ⊆ A"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="var">?I2</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(bad, σ2). dom σ2 ⊆ A ∧ ran σ2 ⊆ A"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?X_bad</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λσ1 s2. ?I1 σ1 ∧ ?I2 s2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℐ ⊢c rf.random_oracle s1 √"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ran s1 ⊆ A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s1</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>WT_calleeI</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rf.random_oracle_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>finite_A</span><span> </span><span>nonempty_A</span><span> </span><span>ran_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split_asm</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"callee_invariant_on rf.random_oracle ?I1 ℐ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rf.random_oracle_def</span><span> </span><span>finite_A</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split_asm</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>rf</span><span class="delimiter">:</span><span> </span><span>callee_invariant_on</span><span> </span><span>rf.random_oracle</span><span> </span><span class="var">?I1</span><span> </span><span>ℐ</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℐ ⊢c rp_bad s2 √ "</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ran (snd s2) ⊆ A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s2</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>WT_calleeI</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rp_bad_def</span><span> </span><span>finite_A</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.split_asm</span><span> </span><span>option.split_asm</span><span> </span><span>if_split_asm</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>ranI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"callee_invariant_on rf.random_oracle (λσ1. ?bad1 σ1 ∧ ?I1 σ1) ℐ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">)</span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rf.random_oracle_def</span><span> </span><span>finite_A</span><span>  </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split_asm</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"callee_invariant_on rp_bad (λs2. ?I2 s2) ℐ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>4</span><span> </span><span>3</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rp_bad_simps</span><span> </span><span>finite_A</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>if_split_asm</span><span> </span><span>iff</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>domIff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"callee_invariant_on rp_bad (λs2. ?bad2 s2 ∧ ?I2 s2) ℐ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>4</span><span> </span><span>3</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rp_bad_simps</span><span> </span><span>finite_A</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>if_split_asm</span><span> </span><span>iff</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>domIff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℐ ⊢c rp_bad (bad, σ2) √"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ran σ2 ⊆ A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>bad</span><span> </span><span>σ2</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>WT_calleeI</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rp_bad_def</span><span> </span><span>finite_A</span><span> </span><span>nonempty_A</span><span> </span><span>ran_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split_asm</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_spmf (rp_bad (b, σ2) x)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ A"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dom σ2 ⊆ A"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ran σ2 ⊆ A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b</span><span> </span><span>σ2</span><span> </span><span>x</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_A</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rp_bad_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nonempty_A</span><span> </span><span>dom_subset_ran_iff</span><span> </span><span>eq_None_iff_not_dom</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_spmf (λ(b1, σ1) (b2, state2). (?bad1 σ1 ⟷ ?bad2 state2) ∧ (if ?bad2 state2 then ?X_bad σ1 state2 else b1 = b2 ∧ ?X σ1 state2))
            ((if False then rp.random_permutation else rf.random_oracle) s1 x) (rp_bad s2 x)"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?X s1 s2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ outs_ℐ ℐ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?I1 s1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?I2 s2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s1</span><span> </span><span>s2</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>finite_A</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>option.split</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rf.random_oracle_def</span><span> </span><span>rp_bad_def</span><span> </span><span>rel_spmf_return_spmf1</span><span> </span><span>collision_map_updI</span><span> </span><span>dom_subset_ran_iff</span><span> </span><span>eq_None_iff_not_dom</span><span> </span><span>collision_map_upd_iff</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bind_reflI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_spmf
       (λ(b1, σ1) (b2, state2). (?bad1 σ1 ⟷ ?bad2 state2) ∧ (if ?bad2 state2 then ?X_bad σ1 state2 else b1 = b2 ∧ ?X σ1 state2))
       (?run False) (exec_gpv rp_bad 𝒜 init)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>exec_gpv_oracle_bisim_bad_invariant</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ℐ</span><span> </span><span class="delimiter">=</span><span> </span><span>ℐ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="var">?I1.0</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"?I1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="var">?I2.0</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"?I2"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>init_def</span><span> </span><span>WT</span><span> </span><span>lossless</span><span> </span><span>finite_A</span><span> </span><span>nonempty_A</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¦spmf (map_spmf fst (?run False)) True - spmf (run_gpv rp_bad 𝒜 init) True¦ ≤ spmf (map_spmf (?bad1 ∘ snd) (?run False)) True"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>spmf_conv_measure_spmf</span><span> </span><span>measure_map_spmf</span><span> </span><span>vimage_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>fundamental_lemma</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="var">?bad2.0</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λ(_, s2). ?bad2 s2"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>split_def</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>rel_spmf_mono</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ennreal … ≤ ennreal (q / card A) * (enat q)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>if_False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bound</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>WT</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>rf.interaction_bounded_by_exec_gpv_bad_count</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>count</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λs. card (dom s)"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rf.random_oracle_def</span><span> </span><span>finite_A</span><span> </span><span>nonempty_A</span><span> </span><span>card_insert_if</span><span> </span><span>finite_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>finite_A</span><span class="delimiter">]</span><span> </span><span>map_spmf_conv_bind_spmf</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>spmf.map_comp</span><span> </span><span>o_def</span><span> </span><span>collision_map_upd_iff</span><span> </span><span>map_mem_spmf_of_set</span><span> </span><span>card_gt_0_iff</span><span> </span><span>card_mono</span><span> </span><span>field_simps</span><span> </span><span>Int_absorb2</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>card_ran_le_dom</span><span class="delimiter">[</span><span>OF</span><span> </span><span>finite_subset</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>finite_A</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>order_trans</span><span class="delimiter">]</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"spmf (map_spmf (?bad1 ∘ snd) (?run False)) True ≤ q * q / card A"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ennreal_of_nat_eq_real_of_nat</span><span> </span><span>ennreal_times_divide</span><span> </span><span>ennreal_mult''</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¦spmf (run_gpv rp_bad 𝒜 init) True - spmf (run_gpv rf.random_oracle 𝒜 Map.empty) True¦ ≤ q * q / card A"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>advantage_def</span><span> </span><span>game_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="PRF_UHF">
<div class="head"><h1>Theory PRF_UHF</h1>
<span class="command">theory</span> <span class="name">PRF_UHF</span><br/>
<span class="keyword">imports</span> <a href="../CryptHOL/GPV_Bisim.html"><span class="name">GPV_Bisim</span></a> <a href="Pseudo_Random_Function.html"><span class="name">Pseudo_Random_Function</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: PRF_UHF.thy 
  Author: Bhargav Bhatt, ETH Zurich
  Author: Andreas Lochbihler, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Extending the input length of a PRF using a universal hash function›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ This example is taken from \cite[\S 4.2]{Shoup2004IACR}.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>PRF_UHF</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>CryptHOL.GPV_Bisim</span><span>
</span><span>  </span><span>Pseudo_Random_Function</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hash"</span></span></span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>seed_gen</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'seed spmf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hash"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'seed ⇒ 'domain ⇒ 'range"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>game_hash</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">" 'domain ⇒ 'domain ⇒ bool spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span> </span><span class="string"><span class="delete"><span class="delete">"game_hash w w' = do {
    seed ← seed_gen;
    return_spmf (hash seed w = hash seed w' ∧ w ≠ w')
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>game_hash_set</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'domain set ⇒ bool spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"game_hash_set W = do {
     seed  ← seed_gen;
     return_spmf (¬ inj_on (hash seed) W)
   }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ε_uh</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"real"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ε_uh  = (SUP w w'. spmf (game_hash w w') True)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ε_uh_nonneg</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ε_uh ≥ 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>4</span><span> </span><span>3</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>cSUP_upper2</span><span> </span><span>bdd_aboveI2</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>M</span><span class="delimiter">=</span><span>1</span><span class="delimiter">]</span><span> </span><span>cSUP_least</span><span> </span><span>pmf_le_1</span><span> </span><span>pmf_nonneg</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ε_uh_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hash_ineq_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite W"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"spmf (game_hash_set W) True ≤ ε_uh * card W * card W"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?M</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"measure (measure_spmf seed_gen)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?M {x. hash x w = hash x w' ∧ w ≠ w'} ≤ ε_uh"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>w</span><span> </span><span>w'</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?M {x. hash x w = hash x w' ∧ w ≠ w'} = spmf (game_hash w w') True"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>game_hash_def</span><span> </span><span>spmf_conv_measure_spmf</span><span> </span><span>map_spmf_conv_bind_spmf</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>measure_map_spmf</span><span> </span><span>vimage_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ ε_uh"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ε_uh_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>cSUP_upper2</span><span> </span><span>bdd_aboveI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>M</span><span class="delimiter">=</span><span>1</span><span class="delimiter">]</span><span> </span><span>cSUP_least</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pmf_le_1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"spmf (game_hash_set W) True = ?M {x. ∃xa∈W. ∃y∈W. hash x xa = hash x y ∧ xa ≠ y}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>game_hash_set_def</span><span> </span><span>inj_on_def</span><span> </span><span>map_spmf_conv_bind_spmf</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>spmf_conv_measure_spmf</span><span> </span><span>measure_map_spmf</span><span> </span><span>vimage_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{x. ∃xa∈W. ∃y∈W. hash x xa = hash x y ∧ xa ≠ y} = (⋃(w, w') ∈ W× W. {x. hash x w = hash x w' ∧ w ≠ w'})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?M … ≤ (∑(w, w')∈W × W. ?M {x. hash x w = hash x w' ∧ w ≠ w'})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>measure_spmf.finite_measure_subadditive_finite</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>split_def</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ (∑(w, w')∈W × W. ε_uh)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum_mono</span><span class="delimiter">)</span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bound</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… =  ε_uh * card(W) * card(W)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>card_cartesian_product</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>prf_hash</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'key ⇒ 'α ⇒ 'γ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'seed ⇒ 'β ⇒ 'α"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>key_gen</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'key spmf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>seed_gen</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'seed spmf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>range_f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'γ set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>lossless_seed_gen</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_spmf seed_gen"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>range_f_finite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite range_f"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>range_f_nonempty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"range_f ≠ {}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rand</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'γ spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rand = spmf_of_set range_f"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lossless_rand</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_spmf rand"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rand_def</span><span> </span><span>range_f_finite</span><span> </span><span>range_f_nonempty</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>key_seed_gen</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('key * 'seed) spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"key_seed_gen = do {
     k ← key_gen;
     s :: 'seed ← seed_gen;
     return_spmf (k, s)
   }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prf"</span></span></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prf"</span></span></span><span> </span><span>key_gen</span><span> </span><span>f</span><span> </span><span>rand</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>hash</span><span class="delimiter">:</span><span> </span><span>hash</span><span> </span><span class="string"><span class="delete"><span class="delete">"seed_gen"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h"</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>f'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'key × 'seed ⇒ 'β ⇒ 'γ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f' (key, seed) x = f key (h seed x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prf'"</span></span></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prf"</span></span></span><span> </span><span>key_seed_gen</span><span> </span><span>f'</span><span> </span><span>rand</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>reduction_oracle</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'seed ⇒ unit ⇒ 'β ⇒ ('γ × unit, 'α, 'γ) gpv"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reduction_oracle seed x b = Pause (h seed b) (λx. Done (x, ()))"</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>prf'_reduction</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">" ('β, 'γ) prf'.adversary ⇒ ('α, 'γ) prf.adversary"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prf'_reduction 𝒜 = do {
      seed  ← lift_spmf seed_gen;
      (b, σ) ← inline (reduction_oracle seed) 𝒜 ();
      Done b
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>prf_prf'_advantage</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prf'.lossless 𝒜"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bounded</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prf'.ibounded_by 𝒜 q"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prf'.advantage 𝒜  ≤ prf.advantage (prf'_reduction 𝒜) + hash.ε_uh * q * q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">including</span></span><span> </span><span>lifting_syntax</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?𝒜</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"prf'_reduction 𝒜"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>cr</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cr = (λ_ :: unit × unit. λ_ :: unit. True)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cr ((), ()) ()"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cr_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prf.game_0 ?𝒜 = prf'.game_0 𝒜"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>prf'.game_0_def</span><span> </span><span>prf.game_0_def</span><span> </span><span>prf'_reduction_def</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>key_seed_gen_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>exec_gpv_bind</span><span> </span><span>split_def</span><span> </span><span>exec_gpv_inline</span><span> </span><span>reduction_oracle_def</span><span> </span><span>bind_map_spmf</span><span> </span><span>prf.prf_oracle_def</span><span> </span><span>prf'.prf_oracle_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="delimiter">(</span><span>transfer_prover</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>hop1</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>semi_forgetful_RO</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"semi_forgetful_RO = (λseed :: 'seed. λ(σ :: 'α ⇀ 'β × 'γ, b :: bool). λx. 
    case σ (h seed x) of Some (a, y) ⇒ return_spmf (y, (σ, a ≠ x ∨ b))
     | None ⇒ bind_spmf rand (λy. return_spmf (y, (σ(h seed x ↦ (x, y)), b))))"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>game_semi_forgetful</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game_semi_forgetful = do {
     seed :: 'seed ← seed_gen;
     (b, rep) ← exec_gpv (semi_forgetful_RO seed) 𝒜 (Map.empty, False);
     return_spmf (b, rep) 
   }"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bad_semi_forgetful</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"callee_invariant (semi_forgetful_RO seed) snd"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>seed</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>semi_forgetful_RO_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split_asm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lossless_semi_forgetful</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_spmf (semi_forgetful_RO seed s1 x)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>seed</span><span> </span><span>s1</span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>semi_forgetful_RO_def</span><span> </span><span>split_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>cr</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cr = (λ(_ :: unit, σ) (σ' :: 'α ⇒ ('β × 'γ) option, _ :: bool). σ = map_option snd ∘ σ')"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>initial</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"initial = (Map.empty :: 'α ⇒ ('β × 'γ) option, False)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cr ((), Map.empty) initial"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cr_def</span><span> </span><span>initial_def</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"((=) ===&gt; cr ===&gt; (=) ===&gt; rel_spmf (rel_prod (=) cr))
        (λy p ya. do {y ← prf.random_oracle (snd p) (h y ya); return_spmf (fst y, (), snd y) })
        semi_forgetful_RO"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>semi_forgetful_RO_def</span><span> </span><span>cr_def</span><span> </span><span>prf.random_oracle_def</span><span> </span><span>rel_fun_def</span><span> </span><span>fun_eq_iff</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bind_reflI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prf.game_1 ?𝒜 = map_spmf fst game_semi_forgetful"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>prf.game_1_def</span><span> </span><span>prf'_reduction_def</span><span> </span><span>game_semi_forgetful_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>exec_gpv_bind</span><span> </span><span>exec_gpv_inline</span><span> </span><span>split_def</span><span> </span><span>bind_map_spmf</span><span> </span><span>map_spmf_bind_spmf</span><span> </span><span>o_def</span><span> </span><span>map_spmf_conv_bind_spmf</span><span> </span><span>reduction_oracle_def</span><span> </span><span>initial_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>transfer_prover</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>hop2</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>game_semi_forgetful_bad</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game_semi_forgetful_bad = do {
       seed :: 'seed ← seed_gen;
       x ← exec_gpv (semi_forgetful_RO seed) 𝒜 (Map.empty, False);
       return_spmf (snd x) 
       }"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>game_semi_forgetful_bad</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"map_spmf snd game_semi_forgetful = game_semi_forgetful_bad"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>game_semi_forgetful_bad_def</span><span> </span><span>game_semi_forgetful_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>map_spmf_bind_spmf</span><span> </span><span>o_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bad_random_oracle_A</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"callee_invariant prf.random_oracle (λσ. ¬ inj_on (h seed) (dom σ))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>seed</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>prf.random_oracle_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split_asm</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>invar</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar = (λseed (σ1, b) (σ2 :: 'β ⇒ 'γ option). ¬ b ∧ dom σ1 = h seed ` dom σ2 ∧ 
      (∀x ∈ dom σ2. σ1 (h seed x) = map_option (Pair x) (σ2 x)))"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rel_spmf_oracle_adv</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"rel_spmf (λ(x, s1) (y, s2). snd s1 ≠ inj_on (h seed) (dom s2) ∧ (inj_on (h seed) (dom s2) ⟶ x = y ∧ invar seed s1 s2))
      (exec_gpv (semi_forgetful_RO seed) 𝒜 (Map.empty, False))
      (exec_gpv prf.random_oracle 𝒜 Map.empty)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>seed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"seed ∈ set_spmf seed_gen"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>seed</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>invar_initial</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar seed (Map.empty, False) Map.empty"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>invarD_inj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inj_on (h seed) (dom s2)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar seed bs1 s2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>bs1</span><span> </span><span>s2</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>inj_onI</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span class="delimiter">)</span><span class="delimiter">(</span><span>metis</span><span> </span><span>domI</span><span> </span><span>domIff</span><span> </span><span>option.map_sel</span><span> </span><span>prod.inject</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?R</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(a, s1) (b, s2 :: 'β ⇒ 'γ option).
        snd s1 = (¬ inj_on (h seed) (dom s2)) ∧
        (¬ ¬ inj_on (h seed) (dom s2) ⟶ a = b ∧ invar seed s1 s2)"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_spmf ?R (semi_forgetful_RO seed σ1b x) (prf.random_oracle s2 x)"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>X</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar seed σ1b s2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s2</span><span> </span><span>σ1b</span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>σ1</span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ1b = (σ1, b)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>σ1b</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>X</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>not_b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ b"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dom σ1 = h seed ` dom s2"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x∈dom s2. σ1 (h seed x) = map_option (Pair x) (s2 x)"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>X</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inj_on (h seed) (dom s2)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>invarD_inj</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>not_in_image</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"h seed x ∉ h seed ` (dom s2 - {x})"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"σ1 (h seed x) = None"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>notI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h seed x ∈ h seed ` (dom s2 - {x})"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ dom s2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hx_hy</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"h seed x = h seed y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"σ1 (h seed y) = None"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h seed y ∉ h seed ` dom s2"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dom</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∉ dom s2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y ∈ dom s2›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ1 (h seed x)"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>σ1</span><span class="delimiter">:</span><span> </span><span>None</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>s2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s2 x = None"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dom</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"insert (h seed x) (dom σ1) = insert (h seed x) (h seed ` dom s2)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dom</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>invar_update</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar seed (σ1(h seed x ↦ (x, bs)), False) (s2(x ↦ bs))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>bs</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inj</span><span> </span><span>not_b</span><span> </span><span>not_in_image</span><span> </span><span>σ1</span><span> </span><span>dom</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invar_def</span><span> </span><span>domIff</span><span> </span><span>eq</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>domI</span><span> </span><span>domIff</span><span> </span><span>imageI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>σ1</span><span> </span><span>s2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inj</span><span> </span><span>not_b</span><span> </span><span>not_in_image</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>semi_forgetful_RO_def</span><span> </span><span>prf.random_oracle_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bind_reflI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>σ1</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Some</span><span> </span><span class="string"><span class="delete"><span class="delete">"by"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"s2 x"</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>s2</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Some</span><span> </span><span>z</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>eq</span><span> </span><span>σ1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"by = (x, z)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>domIff</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>σ1</span><span> </span><span>inj</span><span> </span><span>not_b</span><span> </span><span>s2</span><span> </span><span>X</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>semi_forgetful_RO_def</span><span> </span><span>prf.random_oracle_def</span><span> </span><span>split_beta</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>s2</span><span class="delimiter">:</span><span> </span><span>None</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>σ1</span><span> </span><span>dom</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ dom s2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"h seed x = h seed y"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>metis</span><span> </span><span>domIff</span><span> </span><span>imageE</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>y</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>z</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>z</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s2 y = Some z"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>eq</span><span> </span><span>z</span><span> </span><span>σ1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"by"</span></span></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"by = (y, z)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>*</span><span> </span><span>domIff</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>y</span><span> </span><span>s2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xny</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≠ y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>y</span><span> </span><span>*</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h seed x ∈ h seed ` (dom s2 - {x})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>σ1</span><span> </span><span>s2</span><span> </span><span>not_b</span><span> </span><span class="string"><span class="delete"><span class="delete">"by"</span></span></span><span> </span><span>xny</span><span> </span><span>inj</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>semi_forgetful_RO_def</span><span> </span><span>prf.random_oracle_def</span><span> </span><span>split_beta</span><span class="delimiter">)</span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_spmf_bindI2</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>invar_initial</span><span> </span><span>_</span><span> </span><span>step</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>exec_gpv_oracle_bisim_bad_full</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="var">?bad1.0</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="var">?bad2.0</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λσ. ¬ inj_on (h seed) (dom σ)"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>game_A</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game_A = do {
      seed :: 'seed ← seed_gen;
      (b, σ) ← exec_gpv prf.random_oracle 𝒜 Map.empty;
      return_spmf (b, ¬ inj_on (h seed) (dom σ))
    }"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?bad1</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λx. snd (snd x)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="var">?bad2</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>hop3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_spmf (λx xa. (?bad1 x ⟷ ?bad2 xa) ∧ (¬ ?bad2 xa ⟶ fst x ⟷ fst xa)) game_semi_forgetful game_A"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>game_semi_forgetful_def</span><span> </span><span>game_A_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>restrict_bind_spmf</span><span> </span><span>split_def</span><span> </span><span>map_spmf_bind_spmf</span><span> </span><span>restrict_return_spmf</span><span> </span><span>o_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bind_reflI</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>bind_return_spmf</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_spmf_bindI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>rel_spmf_oracle_adv</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bad1_bad2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"spmf (map_spmf (snd ∘ snd) game_semi_forgetful) True = spmf (map_spmf snd game_A) True"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fundamental_lemma_bad</span><span class="delimiter">[</span><span>OF</span><span> </span><span>hop3</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>measure_map_spmf</span><span> </span><span>spmf_conv_measure_spmf</span><span> </span><span>vimage_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bound_bad1_event</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¦spmf (map_spmf fst game_semi_forgetful) True - spmf (map_spmf fst game_A) True¦ ≤ spmf (map_spmf (snd ∘ snd) game_semi_forgetful) True"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fundamental_lemma</span><span class="delimiter">[</span><span>OF</span><span> </span><span>hop3</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>measure_map_spmf</span><span> </span><span>spmf_conv_measure_spmf</span><span> </span><span>vimage_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bound_bad2_event</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¦spmf (map_spmf fst game_semi_forgetful) True - spmf (map_spmf fst game_A) True¦ ≤ spmf (map_spmf snd game_A) True"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bad1_bad2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>game_B</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game_B = do {
      (b, σ) ← exec_gpv prf.random_oracle 𝒜 Map.empty;
      hash.game_hash_set (dom σ)
    }"</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>game_A_game_B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"map_spmf snd game_A = game_B"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>game_B_def</span><span> </span><span>game_A_def</span><span> </span><span>hash.game_hash_set_def</span><span> </span><span class="keyword1"><span class="command">including</span></span><span> </span><span>monad_normalisation</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>map_spmf_bind_spmf</span><span> </span><span>o_def</span><span> </span><span>split_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>game_B_bound</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"spmf game_B True ≤ hash.ε_uh * q * q"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>game_B_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>spmf_bind_leI</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>b</span><span> </span><span>σ</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(b, σ) ∈ set_spmf (exec_gpv prf.random_oracle 𝒜 Map.empty)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (dom σ)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>prf.finite.exec_gpv_invariant</span><span class="delimiter">[</span><span>OF</span><span> </span><span>*</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"spmf (hash.game_hash_set (dom σ)) True ≤ hash.ε_uh * (card (dom σ) * card (dom σ))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hash.hash_ineq_card</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"dom σ"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"card (dom σ) ≤ q + card (dom (Map.empty :: 'β ⇒ 'γ option))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>prf.card_dom_random_oracle</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bounded</span><span> </span><span>*</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (dom σ) * card (dom σ) ≤ q * q"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mult_le_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"spmf (hash.game_hash_set (dom σ)) True ≤ hash.ε_uh * q * q"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hash.ε_uh_nonneg</span><span> </span><span>mult_left_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hash.ε_uh_nonneg</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>hop4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prf'.game_1 𝒜 = map_spmf fst game_A"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>game_A_def</span><span> </span><span>prf'.game_1_def</span><span> </span><span>map_spmf_bind_spmf</span><span> </span><span>o_def</span><span> </span><span>split_def</span><span> </span><span>bind_spmf_const</span><span> </span><span>lossless_seed_gen</span><span> </span><span>lossless_weight_spmfD</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prf'.advantage 𝒜 ≤ ¦spmf (prf.game_0 ?𝒜) True - spmf (prf'.game_1 𝒜) True¦"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hop1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>prf'.advantage_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ prf.advantage ?𝒜 + ¦spmf (prf.game_1 ?𝒜) True - spmf (prf'.game_1 𝒜) True¦"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>prf.advantage_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¦spmf (prf.game_1 ?𝒜) True - spmf (prf'.game_1 𝒜) True¦ ≤
    ¦spmf (map_spmf fst game_semi_forgetful) True - spmf (prf'.game_1 𝒜) True¦"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hop2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ hash.ε_uh * q * q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game_A_game_B</span><span> </span><span>game_B_bound</span><span> </span><span>bound_bad2_event</span><span> </span><span>hop4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add_left_mono</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="PRF_IND_CPA">
<div class="head"><h1>Theory PRF_IND_CPA</h1>
<span class="command">theory</span> <span class="name">PRF_IND_CPA</span><br/>
<span class="keyword">imports</span> <a href="../CryptHOL/GPV_Bisim.html"><span class="name">GPV_Bisim</span></a> <a href="../CryptHOL/List_Bits.html"><span class="name">List_Bits</span></a> <a href="Pseudo_Random_Function.html"><span class="name">Pseudo_Random_Function</span></a> <a href="IND_CPA.html"><span class="name">IND_CPA</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: PRF_IND_CPA.thy
  Author: Andreas Lochbihler, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹IND-CPA from PRF›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>PRF_IND_CPA</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>CryptHOL.GPV_Bisim</span><span>
</span><span>  </span><span>CryptHOL.List_Bits</span><span>
</span><span>  </span><span>Pseudo_Random_Function</span><span>
</span><span>  </span><span>IND_CPA</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Formalises the construction from \cite{PetcherMorrisett2015POST}.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>simproc</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>let_simp</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>key</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"bool list"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>plain</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"bool list"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>cipher</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"bool list * bool list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>otp</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"key ⇒ bool list ⇒ bool list"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>len</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>length_f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀xs ys. ⟦ length xs = len; length ys = len ⟧ ⟹ length (f xs ys) = len"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>key_gen</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"bool list spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"key_gen = spmf_of_set (nlists UNIV len)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>valid_plain</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"plain ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_plain plain ⟷ length plain = len"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>encrypt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"key ⇒ plain ⇒ cipher spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"encrypt key plain = do {
     r ← spmf_of_set (nlists UNIV len);
     return_spmf (r, xor_list plain (f key r))
   }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>decrypt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"key ⇒ cipher ⇒ plain option"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"decrypt key (r, c) = Some (xor_list (f key r) c)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>encrypt_decrypt_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ length key = len; length plain = len ⟧
  ⟹ encrypt key plain ⤜ (λcipher. return_spmf (decrypt key cipher)) = return_spmf (Some plain)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>encrypt_def</span><span> </span><span>zip_map2</span><span> </span><span>o_def</span><span> </span><span>split_def</span><span> </span><span>bind_eq_return_spmf</span><span> </span><span>length_f</span><span> </span><span>in_nlists_UNIV</span><span> </span><span>xor_list_left_commute</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>ind_cpa</span><span class="delimiter">:</span><span> </span><span>ind_cpa</span><span> </span><span>key_gen</span><span> </span><span>encrypt</span><span> </span><span>decrypt</span><span> </span><span>valid_plain</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prf"</span></span></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prf"</span></span></span><span> </span><span>key_gen</span><span> </span><span>f</span><span> </span><span class="string"><span class="delete"><span class="delete">"spmf_of_set (nlists UNIV len)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>prf_encrypt_oracle</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"unit ⇒ plain ⇒ (cipher × unit, plain, plain) gpv"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prf_encrypt_oracle x plain = do {
     r ← lift_spmf (spmf_of_set (nlists UNIV len));
     Pause r (λpad. Done ((r, xor_list plain pad), ()))
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>interaction_bounded_by_prf_encrypt_oracle</span><span> </span><span class="delimiter">[</span><span>interaction_bound</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"interaction_any_bounded_by (prf_encrypt_oracle σ plain) 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>prf_encrypt_oracle_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lossless_prf_encyrpt_oracle</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_gpv ℐ_top (prf_encrypt_oracle s x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>prf_encrypt_oracle_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>prf_adversary</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(plain, cipher, 'state) ind_cpa.adversary ⇒ (plain, plain) prf.adversary"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prf_adversary 𝒜 = do {
     let (𝒜1, 𝒜2) = 𝒜;
     (((p1, p2), σ), n) ← inline prf_encrypt_oracle 𝒜1 ();
     if valid_plain p1 ∧ valid_plain p2 then do { 
       b ← lift_spmf coin_spmf;
       let pb = (if b then p1 else p2);
       r ← lift_spmf (spmf_of_set (nlists UNIV len));
       pad ← Pause r Done;
       let c = (r, xor_list pb pad);
       (b', _) ← inline prf_encrypt_oracle (𝒜2 c σ) n;
       Done (b' = b)
     } else lift_spmf coin_spmf
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>prf_encrypt_advantage</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ind_cpa.ibounded_by 𝒜 q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_gpv ℐ_full (fst 𝒜)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀cipher σ. lossless_gpv ℐ_full (snd 𝒜 cipher σ)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ind_cpa.advantage 𝒜 ≤ prf.advantage (prf_adversary 𝒜) + q / 2 ^ len"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>split</span><span> </span><span>del</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>if_split</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">[</span><span>cong</span><span> </span><span>del</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>if_weak_cong</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span>
</span><span>      </span><span>bind_spmf_const</span><span> </span><span>map_spmf_bind_spmf</span><span> </span><span>bind_map_spmf</span><span> 
</span><span>      </span><span>exec_gpv_bind</span><span> </span><span>exec_gpv_inline</span><span>
</span><span>      </span><span>rel_spmf_bind_reflI</span><span> </span><span>rel_spmf_reflI</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>𝒜1</span><span> </span><span>𝒜2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>𝒜</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒜 = (𝒜1, 𝒜2)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒜"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ind_cpa.ibounded_by _ _›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>q1</span><span> </span><span>q2</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>q1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"interaction_any_bounded_by 𝒜1 q1"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>q2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀cipher σ. interaction_any_bounded_by (𝒜2 cipher σ) q2"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q1 + q2 ≤ q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>𝒜</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ind_cpa.ibounded_byE</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>iadd_le_enat_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>𝒜</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lossless1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_gpv ℐ_full 𝒜1"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lossless2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀cipher σ. lossless_gpv ℐ_full (𝒜2 cipher σ)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>weight1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀oracle s. (⋀s x. lossless_spmf (oracle s x)) 
    ⟹ weight_spmf (exec_gpv oracle 𝒜1 s) = 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>lossless_weight_spmfD</span><span class="delimiter">)</span><span class="delimiter">(</span><span>rule</span><span> </span><span>lossless_exec_gpv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>lossless1</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>weight2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀oracle s cipher σ. (⋀s x. lossless_spmf (oracle s x)) 
    ⟹ weight_spmf (exec_gpv oracle (𝒜2 cipher σ) s) = 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>lossless_weight_spmfD</span><span class="delimiter">)</span><span class="delimiter">(</span><span>rule</span><span> </span><span>lossless_exec_gpv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>lossless2</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?oracle1</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λkey (s', s) y. map_spmf (λ((x, s'), s). (x, (), ())) (exec_gpv (prf.prf_oracle key) (prf_encrypt_oracle () y) ())"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bisim1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀key. rel_spmf (λ(x, _) (y, _). x = y)
          (exec_gpv (ind_cpa.encrypt_oracle key) 𝒜1 ())
          (exec_gpv (?oracle1 key) 𝒜1 ((), ()))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>TrueI</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>exec_gpv_oracle_bisim</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>encrypt_def</span><span> </span><span>prf_encrypt_oracle_def</span><span> </span><span>ind_cpa.encrypt_oracle_def</span><span> </span><span>prf.prf_oracle_def</span><span> </span><span>o_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bisim2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀key cipher σ. rel_spmf (λ(x, _) (y, _). x = y)
             (exec_gpv (ind_cpa.encrypt_oracle key) (𝒜2 cipher σ) ())
             (exec_gpv (?oracle1 key) (𝒜2 cipher σ) ((), ()))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>TrueI</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>exec_gpv_oracle_bisim</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>encrypt_def</span><span> </span><span>prf_encrypt_oracle_def</span><span> </span><span>ind_cpa.encrypt_oracle_def</span><span> </span><span>prf.prf_oracle_def</span><span> </span><span>o_def</span><span class="delimiter">)</span><span>
</span><span>   
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ind_cpa_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_spmf (=) (ind_cpa.ind_cpa 𝒜) (prf.game_0 (prf_adversary 𝒜))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IND_CPA.ind_cpa.ind_cpa_def</span><span> </span><span>𝒜</span><span> </span><span>key_gen_def</span><span> </span><span>Let_def</span><span> </span><span>prf_adversary_def</span><span> </span><span>Pseudo_Random_Function.prf.game_0_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rewrite</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bind_spmf _ ⌑"</span></span></span><span> </span><span>bind_commute_spmf</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_spmf_bind_reflI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_spmf_bindI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bisim1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>if_distribs</span><span> </span><span>bind_coin_spmf_eq_const'</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bindI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bisim2</span><span class="delimiter">]</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bind_reflI</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>encrypt_def</span><span> </span><span>prf.prf_oracle_def</span><span> </span><span>cong</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>if_cong</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>rf_encrypt</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rf_encrypt = (λs plain. bind_spmf (spmf_of_set (nlists UNIV len)) (λr :: bool list. 
    bind_spmf (prf.random_oracle s r) (λ(pad, s'). 
    return_spmf ((r, xor_list plain pad), s')))
  )"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>rf_finite</span><span class="delimiter">:</span><span> </span><span>callee_invariant_on</span><span> </span><span>rf_encrypt</span><span> </span><span class="string"><span class="delete"><span class="delete">"λs. finite (dom s)"</span></span></span><span> </span><span>ℐ_full</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rf_encrypt_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>prf.finite.callee_invariant</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lossless_rf_encrypt</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀s plain. lossless_spmf (rf_encrypt s plain)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rf_encrypt_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>game2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game2 = do {
    (((p0, p1), σ), s1) ← exec_gpv rf_encrypt 𝒜1 Map.empty;
    if valid_plain p0 ∧ valid_plain p1 then do {
      b ← coin_spmf;
      let pb = (if b then p0 else p1);
      (cipher, s2) ← rf_encrypt s1 pb;
      (b', s3) ← exec_gpv rf_encrypt (𝒜2 cipher σ) s2;
      return_spmf (b' = b)
    } else coin_spmf
  }"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?oracle2</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(s', s) y. map_spmf (λ((x, s'), s). (x, (), s)) (exec_gpv prf.random_oracle (prf_encrypt_oracle () y) s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?I</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(x, _, s) (y, s'). x = y ∧ s = s'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bisim1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_spmf ?I (exec_gpv ?oracle2 𝒜1 ((), Map.empty)) (exec_gpv rf_encrypt 𝒜1 Map.empty)"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>exec_gpv_oracle_bisim</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>X</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λ(_, s) s'. s = s'"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rf_encrypt_def</span><span> </span><span>prf_encrypt_oracle_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bind_reflI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bisim2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀cipher σ s. rel_spmf ?I (exec_gpv ?oracle2 (𝒜2 cipher σ) ((), s)) (exec_gpv rf_encrypt (𝒜2 cipher σ) s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>exec_gpv_oracle_bisim</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>X</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λ(_, s) s'. s = s'"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>prf_encrypt_oracle_def</span><span> </span><span>rf_encrypt_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bind_reflI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>game1_2</span><span> </span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>spmf_rel_eq</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_spmf (=) (prf.game_1 (prf_adversary 𝒜)) game2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>prf.game_1_def</span><span> </span><span>game2_def</span><span> </span><span>prf_adversary_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rewrite</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"if _ then ⌑ else _"</span></span></span><span> </span><span>rf_encrypt_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>𝒜</span><span> </span><span>if_distribs</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bindI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bisim2</span><span class="delimiter">]</span><span> </span><span>rel_spmf_bind_reflI</span><span> </span><span>rel_spmf_bindI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bisim1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>game2_a</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game2_a = do {
    r ← spmf_of_set (nlists UNIV len);
    (((p0, p1), σ), s1) ← exec_gpv rf_encrypt 𝒜1 Map.empty;
    let bad = r ∈ dom s1;
    if valid_plain p0 ∧ valid_plain p1 then do {
      b ← coin_spmf;
      let pb = (if b then p0 else p1);
      (pad, s2) ← prf.random_oracle s1 r;
      let cipher = (r, xor_list pb pad);
      (b', s3) ← exec_gpv rf_encrypt (𝒜2 cipher σ) s2;
      return_spmf (b' = b, bad)
    } else coin_spmf ⤜ (λb. return_spmf (b, bad))
  }"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>game2_b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game2_b = do {
    r ← spmf_of_set (nlists UNIV len);
    (((p0, p1), σ), s1) ← exec_gpv rf_encrypt 𝒜1 Map.empty;
    let bad = r ∈ dom s1;
    if valid_plain p0 ∧ valid_plain p1 then do {
      b ← coin_spmf;
      let pb = (if b then p0 else p1);
      pad ← spmf_of_set (nlists UNIV len);
      let cipher = (r, xor_list pb pad);
      (b', s3) ← exec_gpv rf_encrypt (𝒜2 cipher σ) (s1(r ↦ pad));
      return_spmf (b' = b, bad)
    } else coin_spmf ⤜ (λb. return_spmf (b, bad))
  }"</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game2 = do {
      r ← spmf_of_set (nlists UNIV len);
      (((p0, p1), σ), s1) ← exec_gpv rf_encrypt 𝒜1 Map.empty;
      if valid_plain p0 ∧ valid_plain p1 then do {
        b ← coin_spmf;
        let pb = (if b then p0 else p1);
        (pad, s2) ← prf.random_oracle s1 r;
        let cipher = (r, xor_list pb pad);
        (b', s3) ← exec_gpv rf_encrypt (𝒜2 cipher σ) s2;
        return_spmf (b' = b)
      } else coin_spmf
    }"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">including</span></span><span> </span><span>monad_normalisation</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>game2_def</span><span> </span><span>split_def</span><span> </span><span>rf_encrypt_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = map_spmf fst game2_a"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>game2_a_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>map_spmf_conv_bind_spmf</span><span> </span><span>Let_def</span><span> </span><span>if_distribR</span><span> </span><span>if_distrib</span><span> </span><span>split_def</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>if_cong</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>game2_2a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"game2 = …"</span></span></span><span>  </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map_spmf snd game2_a = map_spmf snd game2_b"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>game2_a_def</span><span> </span><span>game2_b_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>o_def</span><span> </span><span>Let_def</span><span> </span><span>split_def</span><span> </span><span>if_distribs</span><span> </span><span>weight2</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>bind_spmf_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_spmf (=) (map_spmf fst (game2_a ↿ (snd -` {False}))) (map_spmf fst (game2_b ↿ (snd -` {False})))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>game2_a_def</span><span> </span><span>game2_b_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>restrict_bind_spmf</span><span> </span><span>o_def</span><span> </span><span>Let_def</span><span> </span><span>if_distribs</span><span> </span><span>split_def</span><span> </span><span>restrict_return_spmf</span><span> </span><span>prf.random_oracle_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bind_reflI</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"spmf game2_a (True, False) = spmf game2_b (True, False)"</span></span></span><span> 
</span><span>     </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>spmf_rel_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>2</span><span class="delimiter">)</span><span> </span><span>spmf_map_restrict</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>game2a_2b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¦spmf (map_spmf fst game2_a) True - spmf (map_spmf fst game2_b) True¦ ≤ spmf (map_spmf snd game2_a) True"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>2</span><span class="delimiter">)</span><span> </span><span>spmf_conv_measure_spmf</span><span class="delimiter">)</span><span class="delimiter">(</span><span>rule</span><span> </span><span>identical_until_bad</span><span class="delimiter">;</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>spmf.map_id</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>id_def</span><span class="delimiter">]</span><span> </span><span>spmf_conv_measure_spmf</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>game2_a_bad</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game2_a_bad = do {
      r ← spmf_of_set (nlists UNIV len);
      (((p0, p1), σ), s1) ← exec_gpv rf_encrypt 𝒜1 Map.empty;
      return_spmf (r ∈ dom s1)
    }"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>game2a_bad</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"map_spmf snd game2_a = game2_a_bad"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>game2_a_def</span><span> </span><span>game2_a_bad_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>bind_spmf_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>o_def</span><span> </span><span>weight2</span><span> </span><span>Let_def</span><span> </span><span>split_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>card</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀B :: bool list set. card (B ∩ nlists UNIV len) ≤ card (nlists UNIV len :: bool list set)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>card_mono</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"spmf game2_a_bad True = ∫<span class="hidden">⇧</span><sup>+</sup> x. card (dom (snd x) ∩ nlists UNIV len) / 2 ^ len ∂measure_spmf (exec_gpv rf_encrypt 𝒜1 Map.empty)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>game2_a_bad_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rewrite</span><span> </span><span>bind_commute_spmf</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ennreal_spmf_bind</span><span> </span><span>split_def</span><span> </span><span>map_mem_spmf_of_set</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>map_spmf_conv_bind_spmf</span><span class="delimiter">]</span><span> </span><span>card_nlists</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>s</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, s) ∈ set_spmf (exec_gpv rf_encrypt 𝒜1 Map.empty)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (dom s)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>rf_finite.exec_gpv_invariant</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"card (dom s ∩ nlists UNIV len) ≤ card (dom s)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>card_mono</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>q1</span><span> </span><span>*</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (dom s) ≤ q1 + card (dom (Map.empty :: (plain, plain) prf.dict))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>rf_finite.interaction_bounded_by'_exec_gpv_count</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rf_encrypt_def</span><span> </span><span>eSuc_enat</span><span> </span><span>prf.random_oracle_def</span><span> </span><span>card_insert_if</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split_asm</span><span> </span><span>if_split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (dom s ∩ nlists UNIV len) ≤ q1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤  ∫<span class="hidden">⇧</span><sup>+</sup> x. q1 / 2 ^ len ∂measure_spmf (exec_gpv rf_encrypt 𝒜1 Map.empty)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>nn_integral_mono_AE</span><span class="delimiter">)</span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>field_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ q1 / 2 ^ len"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>measure_spmf.emeasure_eq_measure</span><span> </span><span>field_simps</span><span> </span><span>mult_left_le</span><span> </span><span>weight1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>game2a_bad_bound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"spmf game2_a_bad True ≤ q1 / 2 ^ len"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>rf_encrypt_bad</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rf_encrypt_bad = (λsecret (s :: (plain, plain) prf.dict, bad) plain. bind_spmf
     (spmf_of_set (nlists UNIV len)) (λr.
     bind_spmf (prf.random_oracle s r) (λ(pad, s').
     return_spmf ((r, xor_list plain pad), (s', bad ∨ r = secret)))))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rf_encrypt_bad_sticky</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀s. callee_invariant (rf_encrypt_bad s) snd"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rf_encrypt_bad_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lossless_rf_encrypt</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀challenge s plain. lossless_spmf (rf_encrypt_bad challenge s plain)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rf_encrypt_bad_def</span><span> </span><span>prf.random_oracle_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>game2_c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game2_c = do {
    r ← spmf_of_set (nlists UNIV len);
    (((p0, p1), σ), s1) ← exec_gpv rf_encrypt 𝒜1 Map.empty;
    if valid_plain p0 ∧ valid_plain p1 then do {
      b ← coin_spmf;
      let pb = (if b then p0 else p1);
      pad ← spmf_of_set (nlists UNIV len);
      let cipher = (r, xor_list pb pad);
      (b', (s2, bad)) ← exec_gpv (rf_encrypt_bad r) (𝒜2 cipher σ) (s1(r ↦ pad), False);
      return_spmf (b' = b, bad)
    } else coin_spmf ⤜ (λb. return_spmf (b, False))
  }"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bisim2c_bad</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀cipher σ s x r. rel_spmf (λ(x, _) (y, _). x = y)
    (exec_gpv rf_encrypt (𝒜2 cipher σ) (s(x ↦ r)))
    (exec_gpv (rf_encrypt_bad x) (𝒜2 cipher σ) (s(x ↦ r), False))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>exec_gpv_oracle_bisim</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>X</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λs (s', _). s = s'"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rf_encrypt_bad_def</span><span> </span><span>rf_encrypt_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bind_reflI</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>game2b_c</span><span> </span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>spmf_rel_eq</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_spmf (=) (map_spmf fst game2_b) (map_spmf fst game2_c)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>game2_b_def</span><span> </span><span>game2_c_def</span><span> </span><span>o_def</span><span> </span><span>split_def</span><span> </span><span>Let_def</span><span> </span><span>if_distribs</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bind_reflI</span><span> </span><span>rel_spmf_bindI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bisim2c_bad</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>game2_d</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game2_d = do {
    r ← spmf_of_set (nlists UNIV len);
    (((p0, p1), σ), s1) ← exec_gpv rf_encrypt 𝒜1 Map.empty;
    if valid_plain p0 ∧ valid_plain p1 then do {
      b ← coin_spmf;
      let pb = (if b then p0 else p1);
      pad ← spmf_of_set (nlists UNIV len);
      let cipher = (r, xor_list pb pad);
      (b', (s2, bad)) ← exec_gpv (rf_encrypt_bad r) (𝒜2 cipher σ) (s1, False);
      return_spmf (b' = b, bad)
    } else coin_spmf ⤜ (λb. return_spmf (b, False))
  }"</span></span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>cipher</span><span> </span><span>σ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span>plain</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span> </span><span>r</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?I</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(λ(x, s, bad) (y, s', bad'). (bad ⟷ bad') ∧ (¬ bad' ⟶ x ⟷ y))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?X</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(s, bad) (s', bad'). bad = bad' ∧ (∀z. z ≠ x ⟶ s z = s' z)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀s1 s2 x'. ?X s1 s2 ⟹ rel_spmf (λ(a, s1') (b, s2'). snd s1' = snd s2' ∧ (¬ snd s2' ⟶ a = b ∧ ?X s1' s2'))
       (rf_encrypt_bad x s1 x') (rf_encrypt_bad x s2 x')"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"x = x'"</span></span></span><span class="delimiter">)</span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rf_encrypt_bad_def</span><span> </span><span>prf.random_oracle_def</span><span> </span><span>rel_spmf_return_spmf1</span><span> </span><span>rel_spmf_return_spmf2</span><span> </span><span>Let_def</span><span> </span><span>split_def</span><span> </span><span>bind_UNION</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bind_reflI</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_spmf ?I
             (exec_gpv (rf_encrypt_bad x) (𝒜2 cipher σ) (s(x ↦ r), False))
             (exec_gpv (rf_encrypt_bad x) (𝒜2 cipher σ) (s, False))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>exec_gpv_oracle_bisim_bad_full</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lossless2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>bisim_bad</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>game2c_2d_bad</span><span> </span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>spmf_rel_eq</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_spmf (=) (map_spmf snd game2_c) (map_spmf snd game2_d)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>game2_c_def</span><span> </span><span>game2_d_def</span><span> </span><span>o_def</span><span> </span><span>Let_def</span><span> </span><span>split_def</span><span> </span><span>if_distribs</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bind_reflI</span><span> </span><span>rel_spmf_bindI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bisim_bad</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_spmf (=) (map_spmf fst (game2_c ↿ (snd -` {False}))) (map_spmf fst (game2_d ↿ (snd -` {False})))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>game2_c_def</span><span> </span><span>game2_d_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>restrict_bind_spmf</span><span> </span><span>o_def</span><span> </span><span>Let_def</span><span> </span><span>if_distribs</span><span> </span><span>split_def</span><span> </span><span>restrict_return_spmf</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bind_reflI</span><span> </span><span>rel_spmf_bindI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bisim_bad</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"spmf game2_c (True, False) = spmf game2_d (True, False)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>spmf_rel_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>2</span><span class="delimiter">)</span><span> </span><span>spmf_map_restrict</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>game2c_2d</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¦spmf (map_spmf fst game2_c) True - spmf (map_spmf fst game2_d) True¦ ≤ spmf (map_spmf snd game2_c) True"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>2</span><span class="delimiter">)</span><span> </span><span>spmf_conv_measure_spmf</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>identical_until_bad</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>spmf.map_id</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>id_def</span><span class="delimiter">]</span><span> </span><span>spmf_conv_measure_spmf</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>cipher</span><span> </span><span>σ</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>challenge</span><span> </span><span class="delimiter">::</span><span> </span><span>plain</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (nlists UNIV len ∩ (λx. x = challenge) -` {True}) ≤ card {challenge}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>card_mono</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"spmf (map_spmf (snd ∘ snd) (exec_gpv (rf_encrypt_bad challenge) (𝒜2 cipher σ) (s, False))) True ≤ (1 / 2 ^ len) * q2"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>oi_True.interaction_bounded_by_exec_gpv_bad</span><span class="delimiter">[</span><span>OF</span><span> </span><span>q2</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rf_encrypt_bad_def</span><span> </span><span>o_def</span><span> </span><span>split_beta</span><span> </span><span>map_spmf_conv_bind_spmf</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>spmf_map</span><span> </span><span>measure_spmf_of_set</span><span> </span><span>field_simps</span><span> </span><span>card_nlists</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∫<span class="hidden">⇧</span><sup>+</sup> x. ennreal (indicator {True} x) ∂measure_spmf (map_spmf (snd ∘ snd) (exec_gpv (rf_encrypt_bad challenge) (𝒜2 cipher σ) (s, False)))) ≤ (1 / 2 ^ len) * q2"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>ennreal_indicator</span><span> </span><span>nn_integral_indicator</span><span> </span><span>sets_measure_spmf</span><span> </span><span>sets_count_space</span><span> </span><span>Pow_UNIV</span><span> </span><span>UNIV_I</span><span> </span><span>emeasure_spmf_single</span><span class="delimiter">)</span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"spmf (map_spmf snd game2_d) True ≤
        ∫<span class="hidden">⇧</span><sup>+</sup> (r :: plain). ∫<span class="hidden">⇧</span><sup>+</sup> (((p0, p1), σ), s). (if valid_plain p0 ∧ valid_plain p1 then
             ∫<span class="hidden">⇧</span><sup>+</sup> b . ∫<span class="hidden">⇧</span><sup>+</sup> (pad :: plain). q2 / 2 ^ len ∂measure_spmf (spmf_of_set (nlists UNIV len)) ∂measure_spmf coin_spmf
              else 0)
           ∂measure_spmf (exec_gpv rf_encrypt 𝒜1 Map.empty) ∂measure_spmf (spmf_of_set (nlists UNIV len))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>game2_d_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ennreal_spmf_bind</span><span> </span><span>o_def</span><span> </span><span>split_def</span><span> </span><span>Let_def</span><span> </span><span>if_distribs</span><span> </span><span>if_distrib</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λx. ennreal (spmf x _)"</span></span></span><span class="delimiter">]</span><span> </span><span>indicator_single_Some</span><span> </span><span>nn_integral_mono</span><span> </span><span>if_mono_cong</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>nn_integral_const</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>if_cong</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ ∫<span class="hidden">⇧</span><sup>+</sup> (r :: plain). ∫<span class="hidden">⇧</span><sup>+</sup> (((p0, p1), σ), s). (if valid_plain p0 ∧ valid_plain p1 then ennreal (q2 / 2 ^ len) else q2 / 2 ^ len)
                   ∂measure_spmf (exec_gpv rf_encrypt 𝒜1 Map.empty) ∂measure_spmf (spmf_of_set (nlists UNIV len))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>split_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>nn_integral_mono</span><span> </span><span>if_mono_cong</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>measure_spmf.emeasure_eq_measure</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ q2 / 2 ^ len"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>split_def</span><span> </span><span>weight1</span><span> </span><span>measure_spmf.emeasure_eq_measure</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>game2_d_bad</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"spmf (map_spmf snd game2_d) True ≤ q2 / 2 ^ len"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>game3</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game3 = do {
      (((p0, p1), σ), s1) ← exec_gpv rf_encrypt 𝒜1 Map.empty;
      if valid_plain p0 ∧ valid_plain p1 then do {
        b ← coin_spmf;
        let pb = (if b then p0 else p1);
        r ← spmf_of_set (nlists UNIV len);
        pad ← spmf_of_set (nlists UNIV len);
        let cipher = (r, xor_list pb pad);
        (b', s2) ← exec_gpv rf_encrypt (𝒜2 cipher σ) s1;
        return_spmf (b' = b)
      } else coin_spmf
    }"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bisim2d_3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀cipher σ s r. rel_spmf (λ(x, _) (y, _). x = y)
             (exec_gpv (rf_encrypt_bad r) (𝒜2 cipher σ) (s, False))
             (exec_gpv rf_encrypt (𝒜2 cipher σ) s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>exec_gpv_oracle_bisim</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>X</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λ(s1, _) s2. s1 = s2"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rf_encrypt_bad_def</span><span> </span><span>rf_encrypt_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bind_reflI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>game2d_3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_spmf (=) (map_spmf fst game2_d) game3"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>game2_d_def</span><span> </span><span>game3_def</span><span> </span><span>Let_def</span><span> </span><span class="keyword1"><span class="command">including</span></span><span> </span><span>monad_normalisation</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>o_def</span><span> </span><span>split_def</span><span> </span><span>if_distribs</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>if_cong</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bind_reflI</span><span> </span><span>rel_spmf_bindI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bisim2d_3</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¦spmf game2 True - 1 / 2¦ ≤
    ¦spmf (map_spmf fst game2_a) True - spmf (map_spmf fst game2_b) True¦ + ¦spmf (map_spmf fst game2_b) True - 1 / 2¦"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>game2_2a</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>abs_diff_triangle_ineq2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ q1 / 2 ^ len + ¦spmf (map_spmf fst game2_b) True - 1 / 2¦"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game2a_2b</span><span> </span><span>game2a_bad_bound</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>game2a_bad</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>add_right_mono</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¦spmf (map_spmf fst game2_b) True - 1 / 2¦ ≤
    ¦spmf (map_spmf fst game2_c) True - spmf (map_spmf fst game2_d) True¦ + ¦spmf (map_spmf fst game2_d) True - 1 / 2¦"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>game2b_c</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>abs_diff_triangle_ineq2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="delimiter">(</span><span>add_left_mono_trans</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ q2 / 2 ^ len + ¦spmf (map_spmf fst game2_d) True - 1 / 2¦"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game2c_2d</span><span> </span><span>game2_d_bad</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>game2c_2d_bad</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>add_right_mono</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="delimiter">(</span><span>add_left_mono_trans</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>game2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¦spmf game2 True - 1 / 2¦ ≤ q1 / 2 ^ len + q2 / 2 ^ len +  ¦spmf game3 True - 1 / 2¦"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game2d_3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>field_simps</span><span> </span><span>spmf_rel_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game3 = do {
      (((p0, p1), σ), s1) ← exec_gpv rf_encrypt 𝒜1 Map.empty;
      if valid_plain p0 ∧ valid_plain p1 then do {
        b ← coin_spmf;
        let pb = (if b then p0 else p1);
        r ← spmf_of_set (nlists UNIV len);
        pad ← map_spmf (xor_list pb) (spmf_of_set (nlists UNIV len));
        let cipher = (r, xor_list pb pad);
        (b', s2) ← exec_gpv rf_encrypt (𝒜2 cipher σ) s1;
        return_spmf (b' = b)
      } else coin_spmf
    }"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valid_plain_def</span><span> </span><span>game3_def</span><span> </span><span>Let_def</span><span> </span><span>one_time_pad</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>bind_map_spmf</span><span> </span><span>map_spmf_of_set_inj_on</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>bind_spmf_cong_simp</span><span> </span><span>if_cong</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = do {
       (((p0, p1), σ), s1) ← exec_gpv rf_encrypt 𝒜1 Map.empty;
       if valid_plain p0 ∧ valid_plain p1 then do {
         b ← coin_spmf;
         let pb = (if b then p0 else p1);
         r ← spmf_of_set (nlists UNIV len);
         pad ← spmf_of_set (nlists UNIV len);
         let cipher = (r, pad);
         (b', _) ← exec_gpv rf_encrypt (𝒜2 cipher σ) s1;
         return_spmf (b' = b)
       } else coin_spmf
     }"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>game3_def</span><span> </span><span>Let_def</span><span> </span><span>valid_plain_def</span><span> </span><span>in_nlists_UNIV</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>bind_spmf_cong_simp</span><span> </span><span>if_cong</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = do {
      (((p0, p1), σ), s1) ← exec_gpv rf_encrypt 𝒜1 Map.empty;
      if valid_plain p0 ∧ valid_plain p1 then do {
        r ← spmf_of_set (nlists UNIV len);
        pad ← spmf_of_set (nlists UNIV len);
        let cipher = (r, pad);
        (b', _) ← exec_gpv rf_encrypt (𝒜2 cipher σ) s1;
        map_spmf ((=) b') coin_spmf
      } else coin_spmf
    }"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">including</span></span><span> </span><span>monad_normalisation</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>map_spmf_conv_bind_spmf</span><span> </span><span>split_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = coin_spmf"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>map_eq_const_coin_spmf</span><span> </span><span>Let_def</span><span> </span><span>split_def</span><span> </span><span>weight2</span><span> </span><span>weight1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>game3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"game3 = coin_spmf"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ind_cpa.advantage 𝒜 ≤ prf.advantage (prf_adversary 𝒜) + ¦spmf (prf.game_1 (prf_adversary 𝒜)) True - 1 / 2¦"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ind_cpa.advantage_def</span><span> </span><span>prf.advantage_def</span><span> </span><span>ind_cpa_0</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>spmf_rel_eq</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>abs_diff_triangle_ineq2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¦spmf (prf.game_1 (prf_adversary 𝒜)) True - 1 / 2¦ ≤ q1 / 2 ^ len + q2 / 2 ^ len"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game1_2</span><span> </span><span>game2</span><span> </span><span>game3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>spmf_of_set</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (q1 + q2) / 2 ^ len"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>field_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ q / 2 ^ len"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹q1 + q2 ≤ q›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>divide_right_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>field_simps</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>interaction_bounded_prf_adversary</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>q</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ind_cpa.ibounded_by 𝒜 q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prf.ibounded_by (prf_adversary 𝒜) (1 + q)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>η</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ind_cpa.ibounded_by 𝒜 q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>q1</span><span> </span><span>q2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"q1 + q2 ≤ q"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">[</span><span>interaction_bound</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"interaction_any_bounded_by (fst 𝒜) q1"</span></span></span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">"⋀x σ. interaction_any_bounded_by (snd 𝒜 x σ) q2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ind_cpa.ibounded_by_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>split_beta</span><span> </span><span>iadd_le_enat_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prf.ibounded_by (prf_adversary 𝒜) (1 + q)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>q</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>prf_adversary_def</span><span> </span><span>Let_def</span><span> </span><span>split_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>interaction_bound</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>iadd_SUP_le_iff</span><span> </span><span>SUP_le_iff</span><span> </span><span>add.assoc</span><span> </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>one_enat_def</span><span> </span><span>cong</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>image_cong_simp</span><span> </span><span>cong</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>SUP_cong_simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lossless_prf_adversary</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ind_cpa.lossless 𝒜 ⟹ prf.lossless (prf_adversary 𝒜)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>prf_adversary_def</span><span> </span><span>Let_def</span><span> </span><span>split_def</span><span> </span><span>ind_cpa.lossless_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>lossless_inline</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>otp_η</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ key ⇒ bool list ⇒ bool list"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>len</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ nat"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>length_f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀η xs ys. ⟦ length xs = len η; length ys = len η ⟧ ⟹ length (f η xs ys) = len η"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>negligible_len</span><span> </span><span class="delimiter">[</span><span>negligible_intros</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"negligible (λη. 1 / 2 ^ (len η))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>otp</span><span> </span><span class="string"><span class="delete"><span class="delete">"f η"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"len η"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>η</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">)</span><span class="delimiter">(</span><span>rule</span><span> </span><span>length_f</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>ind_cpa</span><span class="delimiter">:</span><span> </span><span>ind_cpa</span><span> </span><span class="string"><span class="delete"><span class="delete">"key_gen η"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"encrypt η"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"decrypt η"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_plain η"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>η</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prf"</span></span></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prf"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"key_gen η"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f η"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"spmf_of_set (nlists UNIV (len η))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>η</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prf_encrypt_secure_for</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>negligible_intros</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"negligible (λη. prf.advantage η (prf_adversary η (𝒜 η)))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀η. ind_cpa.ibounded_by (𝒜 η) (q η)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">[</span><span>negligible_intros</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"polynomial q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lossless</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀η. ind_cpa.lossless (𝒜 η)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"negligible (λη. ind_cpa.advantage η (𝒜 η))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>negligible_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"negligible (λη. prf.advantage η (prf_adversary η (𝒜 η)) + q η / 2 ^ len η)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>negligible_intros</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>η</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ind_cpa.ibounded_by _ _›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ind_cpa.ibounded_by (𝒜 η) (q η)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>lossless</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ind_cpa.lossless (𝒜 η)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_gpv ℐ_full (fst (𝒜 η))"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀cipher σ. lossless_gpv ℐ_full (snd (𝒜 η) cipher σ)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ind_cpa.lossless_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ind_cpa.advantage η (𝒜 η) ≤ prf.advantage η (prf_adversary η (𝒜 η)) + q η / 2 ^ len η"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>prf_encrypt_advantage</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eventually (λη. ¦ind_cpa.advantage η (𝒜 η)¦ ≤ 1 * ¦prf.advantage η (prf_adversary η (𝒜 η)) + q η / 2 ^ len η¦) at_top"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>always_eventually</span><span> </span><span>ind_cpa.advantage_nonneg</span><span> </span><span>prf.advantage_nonneg</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λη. ind_cpa.advantage η (𝒜 η)) ∈ O(λη. prf.advantage η (prf_adversary η (𝒜 η)) + q η / 2 ^ len η)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>bigoI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>c</span><span class="delimiter">=</span><span>1</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="PRF_UPF_IND_CCA">
<div class="head"><h1>Theory PRF_UPF_IND_CCA</h1>
<span class="command">theory</span> <span class="name">PRF_UPF_IND_CCA</span><br/>
<span class="keyword">imports</span> <a href="Pseudo_Random_Function.html"><span class="name">Pseudo_Random_Function</span></a> <a href="../CryptHOL/List_Bits.html"><span class="name">List_Bits</span></a> <a href="Unpredictable_Function.html"><span class="name">Unpredictable_Function</span></a> <a href="IND_CCA2_sym.html"><span class="name">IND_CCA2_sym</span></a> <a href="../CryptHOL/Negligible.html"><span class="name">Negligible</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: PRF_UPF_IND_CCA.thy
  Author: Andreas Lochbihler, ETH Zurich 
  Author: S. Reza Sefidgar, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹IND-CCA from a PRF and an unpredictable function›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>PRF_UPF_IND_CCA</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Pseudo_Random_Function</span><span>
</span><span>  </span><span>CryptHOL.List_Bits</span><span>
</span><span>  </span><span>Unpredictable_Function</span><span>
</span><span>  </span><span>IND_CCA2_sym</span><span>
</span><span>  </span><span>CryptHOL.Negligible</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Formalisation of Shoup's construction of an IND-CCA secure cipher from a PRF and an unpredictable function \cite[\S 7]{Shoup2004IACR}.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>bitstring</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"bool list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>simple_cipher</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span>PRF</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prf"</span></span></span><span> </span><span>prf_key_gen</span><span> </span><span>prf_fun</span><span> </span><span class="string"><span class="delete"><span class="delete">"spmf_of_set (nlists UNIV prf_clen)"</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span>UPF</span><span class="delimiter">:</span><span> </span><span>upf</span><span> </span><span>upf_key_gen</span><span> </span><span>upf_fun</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>prf_key_gen</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'prf_key spmf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prf_fun</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'prf_key ⇒ bitstring ⇒ bitstring"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prf_domain</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"bitstring set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prf_range</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"bitstring set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prf_dlen</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prf_clen</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>upf_key_gen</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'upf_key spmf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>upf_fun</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'upf_key ⇒ bitstring ⇒ 'hash"</span></span></span><span>
</span><span>  </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>prf_domain_finite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite prf_domain"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>prf_domain_nonempty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prf_domain ≠ {}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>prf_domain_length</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x ∈ prf_domain ⟹ length x = prf_dlen"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>prf_codomain_length</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⟦ key_prf ∈ set_spmf prf_key_gen; m ∈ prf_domain ⟧ ⟹ length (prf_fun key_prf m) = prf_clen"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>prf_key_gen_lossless</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_spmf prf_key_gen"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>upf_key_gen_lossless</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_spmf upf_key_gen"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'hash'</span><span> </span><span>cipher_text</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"bitstring × bitstring × 'hash'"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>key_gen</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('prf_key × 'upf_key) spmf"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"key_gen = do {
   k_prf ← prf_key_gen;
   k_upf :: 'upf_key ← upf_key_gen;
   return_spmf (k_prf, k_upf)
 }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lossless_key_gen</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_spmf key_gen"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>key_gen_def</span><span> </span><span>prf_key_gen_lossless</span><span> </span><span>upf_key_gen_lossless</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>encrypt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('prf_key × 'upf_key) ⇒ bitstring ⇒ 'hash cipher_text spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"encrypt (k_prf, k_upf) m = do {
    x ← spmf_of_set prf_domain;
    let c = prf_fun k_prf x [⊕] m;
    let t = upf_fun k_upf (x @ c);
    return_spmf ((x, c, t))
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lossless_encrypt</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_spmf (encrypt k m)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>k</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>prf_domain_nonempty</span><span> </span><span>prf_domain_finite</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>bool.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>decrypt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('prf_key × 'upf_key) ⇒ 'hash cipher_text ⇒ bitstring option"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"decrypt (k_prf, k_upf) (x, c, t) = (
    if upf_fun k_upf (x @ c) = t ∧ length x = prf_dlen then
      Some (prf_fun k_prf x [⊕] c)
    else
      None
  )"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cipher_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ k ∈ set_spmf key_gen; length m = prf_clen ⟧
  ⟹ encrypt k m ⤜ (λc. return_spmf (decrypt k c)) = return_spmf (Some m)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>k</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>prf_domain_nonempty</span><span> </span><span>prf_domain_finite</span><span> </span><span>prf_domain_length</span><span>
</span><span>  </span><span>prf_codomain_length</span><span> </span><span>key_gen_def</span><span> </span><span>bind_eq_return_spmf</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>encrypt.simps</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>ind_cca</span><span class="delimiter">:</span><span> </span><span>ind_cca</span><span> </span><span>key_gen</span><span> </span><span>encrypt</span><span> </span><span>decrypt</span><span> </span><span class="string"><span class="delete"><span class="delete">"λm. length m = prf_clen"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>ind_cca'</span><span class="delimiter">:</span><span> </span><span>ind_cca</span><span> </span><span>key_gen</span><span> </span><span>encrypt</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ _ _. None"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λm. length m = prf_clen"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>intercept_upf_enc</span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'prf_key ⇒ bool ⇒ 'hash cipher_text set × 'hash cipher_text set ⇒ bitstring × bitstring
  ⇒ ('hash cipher_text option × ('hash cipher_text set × 'hash cipher_text set),
     bitstring + (bitstring × 'hash), 'hash + unit) gpv"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"intercept_upf_enc k b = (λ(L, D) (m1, m0).
    (case (length m1 = prf_clen ∧ length m0 = prf_clen) of
      False ⇒ Done (None, L, D)
    | True ⇒ do {
        x ← lift_spmf (spmf_of_set prf_domain);
        let c = prf_fun k x [⊕] (if b then m1 else m0);
        t ← Pause (Inl (x @ c)) Done;
        Done ((Some (x, c, projl t)), (insert (x, c, projl t) L, D))
      }))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>intercept_upf_dec</span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'hash cipher_text set × 'hash cipher_text set ⇒ 'hash cipher_text
  ⇒ (bitstring option × ('hash cipher_text set × 'hash cipher_text set),
     bitstring + (bitstring × 'hash), 'hash + unit) gpv"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"intercept_upf_dec = (λ(L, D) (x, c, t).
    if (x, c, t) ∈ L ∨ length x ≠ prf_dlen then Done (None, (L, D)) else do {
      Pause (Inr (x @ c, t)) Done;
      Done (None, (L, insert (x, c, t) D))
    })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>intercept_upf</span><span> </span><span class="delimiter">::</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"'prf_key ⇒ bool ⇒ 'hash cipher_text set × 'hash cipher_text set ⇒ bitstring × bitstring + 'hash cipher_text
  ⇒ (('hash cipher_text option + bitstring option) × ('hash cipher_text set × 'hash cipher_text set),
     bitstring + (bitstring × 'hash), 'hash + unit) gpv"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"intercept_upf k b = plus_intercept (intercept_upf_enc k b) intercept_upf_dec"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>intercept_upf_simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"intercept_upf k b (L, D) (Inr (x, c, t)) =
    (if (x, c, t) ∈ L ∨ length x ≠ prf_dlen then Done (Inr None, (L, D)) else do {
      Pause (Inr (x @ c, t)) Done;
      Done (Inr None, (L, insert (x, c, t) D))
    })"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"intercept_upf k b (L, D) (Inl (m1, m0)) = 
    (case (length m1 = prf_clen ∧ length m0 = prf_clen) of
      False ⇒ Done (Inl None, L, D)
    | True ⇒ do {
        x ← lift_spmf (spmf_of_set prf_domain);
        let c = prf_fun k x [⊕] (if b then m1 else m0);
        t ← Pause (Inl (x @ c)) Done;
        Done (Inl (Some (x, c, projl t)), (insert (x, c, projl t) L, D))
      })"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>intercept_upf_def</span><span> </span><span>intercept_upf_dec_def</span><span> </span><span>intercept_upf_enc_def</span><span> </span><span>o_def</span><span> </span><span>map_gpv_bind_gpv</span><span> </span><span>gpv.map_id</span><span> </span><span>Let_def</span><span> </span><span>split</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>bool.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>interaction_bounded_by_upf_enc_Inr</span><span> </span><span class="delimiter">[</span><span>interaction_bound</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"interaction_bounded_by (Not ∘ isl) (intercept_upf_enc k b LD mm) 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>intercept_upf_enc_def</span><span> </span><span>case_prod_app</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>interaction_bound</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>SUP_constant</span><span> </span><span>bot_enat_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>interaction_bounded_by_upf_dec_Inr</span><span> </span><span class="delimiter">[</span><span>interaction_bound</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"interaction_bounded_by (Not ∘ isl) (intercept_upf_dec LD c) 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>intercept_upf_dec_def</span><span> </span><span>case_prod_app</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>interaction_bound</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>SUP_constant</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>interaction_bounded_by_intercept_upf_Inr</span><span> </span><span class="delimiter">[</span><span>interaction_bound</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"interaction_bounded_by (Not ∘ isl) (intercept_upf k b LD x) 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>intercept_upf_def</span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>interaction_bound</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>split_def</span><span> </span><span>one_enat_def</span><span> </span><span>SUP_le_iff</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>sum.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>interaction_bounded_by_intercept_upf_Inl</span><span> </span><span class="delimiter">[</span><span>interaction_bound</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"isl x ⟹ interaction_bounded_by (Not ∘ isl) (intercept_upf k b LD x) 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>intercept_upf_def</span><span> </span><span>case_prod_app</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>interaction_bound</span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>sum.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lossless_intercept_upf_enc</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_gpv (ℐ_full ⊕<span class="hidden">⇩</span><sub>ℐ</sub> ℐ_full) (intercept_upf_enc k b LD mm)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>intercept_upf_enc_def</span><span> </span><span>split_beta</span><span> </span><span>prf_domain_finite</span><span> </span><span>prf_domain_nonempty</span><span> </span><span>Let_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>bool.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lossless_intercept_upf_dec</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_gpv (ℐ_full ⊕<span class="hidden">⇩</span><sub>ℐ</sub> ℐ_full) (intercept_upf_dec LD mm)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>intercept_upf_dec_def</span><span> </span><span>split_beta</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lossless_intercept_upf</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_gpv (ℐ_full ⊕<span class="hidden">⇩</span><sub>ℐ</sub> ℐ_full) (intercept_upf k b LD x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>intercept_upf_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>results_gpv_intercept_upf</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"results_gpv (ℐ_full ⊕<span class="hidden">⇩</span><sub>ℐ</sub> ℐ_full) (intercept_upf k b LD x) ⊆ responses_ℐ (ℐ_full ⊕<span class="hidden">⇩</span><sub>ℐ</sub> ℐ_full) x × UNIV"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>intercept_upf_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>reduction_upf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(bitstring, 'hash cipher_text) ind_cca.adversary
  ⇒ (bitstring, 'hash) UPF.adversary"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reduction_upf 𝒜 = do {
    k ← lift_spmf prf_key_gen;
    b ← lift_spmf coin_spmf;
    (_, (L, D)) ← inline (intercept_upf k b) 𝒜 ({}, {});
    Done () }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lossless_reduction_upf</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lossless_gpv (ℐ_full ⊕<span class="hidden">⇩</span><sub>ℐ</sub> ℐ_full) 𝒜 ⟹ lossless_gpv (ℐ_full ⊕<span class="hidden">⇩</span><sub>ℐ</sub> ℐ_full) (reduction_upf 𝒜)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>reduction_upf_def</span><span> </span><span>prf_key_gen_lossless</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>lossless_inline</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>lifting_syntax</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>round_1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_gpv (ℐ_full ⊕<span class="hidden">⇩</span><sub>ℐ</sub> ℐ_full) 𝒜"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¦spmf (ind_cca.game 𝒜) True - spmf (ind_cca'.game 𝒜) True¦ ≤ UPF.advantage (reduction_upf 𝒜)"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>oracle_decrypt0'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"oracle_decrypt0' ≡ (λkey (bad, L) (x', c', t'). return_spmf (
      if (x', c', t') ∈ L ∨ length x' ≠ prf_dlen then (None, (bad, L))
      else (decrypt key (x', c', t'), (bad ∨ upf_fun (snd key) (x' @ c') = t', L))))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>oracle_decrypt0'_simps</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"oracle_decrypt0' key (bad, L) (x', c', t') = return_spmf (
       if (x', c', t') ∈ L ∨ length x' ≠ prf_dlen then (None, (bad, L))
       else (decrypt key (x', c', t'), (bad ∨ upf_fun (snd key) (x' @ c') = t', L)))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>key</span><span> </span><span>L</span><span> </span><span>bad</span><span> </span><span>x'</span><span> </span><span>c'</span><span> </span><span>t'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle_decrypt0'_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lossless_oracle_decrypt0'</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_spmf (oracle_decrypt0' k Lbad c)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span> </span><span>Lbad</span><span> </span><span>c</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle_decrypt0'_def</span><span> </span><span>split_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>callee_invariant_oracle_decrypt0'</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"callee_invariant (oracle_decrypt0' k) fst"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle_decrypt0'_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>oracle_decrypt1'</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"oracle_decrypt1' = (λ(key :: 'prf_key × 'upf_key) (bad, L) (x', c', t'). 
      return_spmf (None :: bitstring option,
        (bad ∨ upf_fun (snd key) (x' @ c') = t' ∧ (x', c', t') ∉ L ∧ length x' = prf_dlen), L))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>oracle_decrypt1'_simps</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"oracle_decrypt1' key (bad, L) (x', c', t') = 
    return_spmf (None, 
      (bad ∨ upf_fun (snd key) (x' @ c') = t' ∧ (x', c', t') ∉ L ∧ length x' = prf_dlen, L))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>key</span><span> </span><span>L</span><span> </span><span>bad</span><span> </span><span>x'</span><span> </span><span>c'</span><span> </span><span>t'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle_decrypt1'_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lossless_oracle_decrypt1'</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_spmf (oracle_decrypt1' k Lbad c)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span> </span><span>Lbad</span><span> </span><span>c</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle_decrypt1'_def</span><span> </span><span>split_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>callee_invariant_oracle_decrypt1'</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"callee_invariant (oracle_decrypt1' k) fst"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle_decrypt1'_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>game01'</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game01' = (λ(decrypt :: 'prf_key × 'upf_key ⇒ (bitstring × bitstring × 'hash, bitstring option, bool × (bitstring × bitstring × 'hash) set) callee) 𝒜. do {
    key ← key_gen;
    b ← coin_spmf;
    (b', (bad', L')) ← exec_gpv (†(ind_cca.oracle_encrypt key b) ⊕<span class="hidden">⇩</span><sub>O</sub> decrypt key) 𝒜 (False, {});
    return_spmf (b = b', bad') })"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?game0'</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"game01' oracle_decrypt0'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?game1'</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"game01' oracle_decrypt1'"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>game0'_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ind_cca.game 𝒜 = map_spmf fst (?game0' 𝒜)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?game0</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>game1'_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ind_cca'.game 𝒜 = map_spmf fst (?game1' 𝒜)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?game1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_prod2 (=)"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>initial</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"initial = (False, {} :: 'hash cipher_text set)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?S {} initial"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>initial_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"((=) ===&gt; ?S ===&gt; (=) ===&gt; rel_spmf (rel_prod (=) ?S))
       ind_cca.oracle_decrypt oracle_decrypt0'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ind_cca.oracle_decrypt_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>oracle_decrypt0'_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_spmf_return_spmf1</span><span> </span><span>rel_fun_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"((=) ===&gt; ?S ===&gt; (=) ===&gt; rel_spmf (rel_prod (=) ?S))
       ind_cca'.oracle_decrypt oracle_decrypt1'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ind_cca'.oracle_decrypt_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>oracle_decrypt1'_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_spmf_return_spmf1</span><span> </span><span>rel_fun_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>extend_state_oracle_transfer</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?game0</span><span> </span><span class="var">?game1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>game01'_def</span><span> </span><span>ind_cca.game_def</span><span> </span><span>ind_cca'.game_def</span><span> </span><span>initial_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>map_spmf_bind_spmf</span><span> </span><span>o_def</span><span> </span><span>split_def</span><span class="delimiter">)</span><span> </span><span>transfer_prover</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_spmf (λ(b'1, (bad1, L1)) (b'2, (bad2, L2)). bad1 = bad2 ∧ (¬ bad2 ⟶ b'1 = b'2))
         (exec_gpv (†(ind_cca.oracle_encrypt k b) ⊕<span class="hidden">⇩</span><sub>O</sub> oracle_decrypt1' k) 𝒜 (False, {}))
         (exec_gpv (†(ind_cca.oracle_encrypt k b) ⊕<span class="hidden">⇩</span><sub>O</sub> oracle_decrypt0' k) 𝒜 (False, {}))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span> </span><span>b</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>k</span><span class="delimiter">;</span><span> </span><span>rule</span><span> </span><span>exec_gpv_oracle_bisim_bad</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>X</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"(=)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="var">?bad1.0</span><span class="delimiter">=</span><span>fst</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="var">?bad2.0</span><span class="delimiter">=</span><span>fst</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ℐ</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℐ_full ⊕<span class="hidden">⇩</span><sub>ℐ</sub> ℐ_full"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rel_spmf_reflI</span><span> </span><span>callee_invariant_extend_state_oracle_const'</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>spmf_rel_map1</span><span> </span><span>spmf_rel_map2</span><span> </span><span>oracle_decrypt0'_simps</span><span> </span><span>oracle_decrypt1'_simps</span><span> </span><span>assms</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>plus_oracle_split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="comment">― ‹We cannot get rid of the losslessness assumption on @{term 𝒜} in this step, because if it 
      were not, then the bad event might still occur, but the adversary does not terminate in
      the case of @{term "?game1'"}. Thus, the reduction does not terminate either, but it cannot
      detect whether the bad event has happened. So the advantage in the UPF game could be lower than
      the probability of the bad event, if the adversary is not lossless.›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¦measure (measure_spmf (?game1' 𝒜)) {(b, bad). b} - measure (measure_spmf (?game0' 𝒜)) {(b, bad). b}¦ 
     ≤ measure (measure_spmf (?game1' 𝒜)) {(b, bad). bad}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fundamental_lemma</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="var">?bad2.0</span><span class="delimiter">=</span><span>snd</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bind_reflI</span><span> </span><span>rel_spmf_bindI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>*</span><span class="delimiter">]</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>game01'_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = spmf (map_spmf snd (?game1' 𝒜)) True"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>spmf_conv_measure_spmf</span><span> </span><span>measure_map_spmf</span><span> </span><span>split_def</span><span> </span><span>vimage_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map_spmf snd (?game1' 𝒜) = UPF.game (reduction_upf 𝒜)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>split</span><span> </span><span>del</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>if_split</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map_spmf (λx. fst (snd x)) (exec_gpv (†(ind_cca.oracle_encrypt (k_prf, k_upf) b) ⊕<span class="hidden">⇩</span><sub>O</sub> oracle_decrypt1' (k_prf, k_upf)) 𝒜 (False, {})) = 
        map_spmf (λx. fst (snd x)) (exec_gpv (UPF.oracle k_upf) (inline (intercept_upf k_prf b) 𝒜 ({}, {})) (False, {}))"</span></span></span><span>
</span><span>      </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map_spmf ?fl ?lhs = map_spmf ?fr ?rhs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map_spmf _ (exec_gpv ?oracle_normal _ ?init_normal) = _"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k_prf</span><span> </span><span>k_upf</span><span> </span><span>b</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>map_spmf_eq_map_spmfI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>oracle_intercept</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"oracle_intercept = (λ(s', s) y. map_spmf (λ((x, s'), s). (x, s', s))
         (exec_gpv (UPF.oracle k_upf) (intercept_upf k_prf b s' y) s))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?I</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(λ((L, D), (flg, Li)).
          (∀(x, c, t) ∈ L. upf_fun k_upf (x @ c) = t ∧ length x = prf_dlen) ∧
          (∀e∈Li. ∃(x,c,_) ∈ L. e = x @ c) ∧
          ((∃(x, c, t) ∈ D. upf_fun k_upf (x @ c) = t) ⟷ flg))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>callee_invariant_on</span><span> </span><span>oracle_intercept</span><span> </span><span class="string"><span class="delete"><span class="delete">"?I"</span></span></span><span> </span><span>ℐ_full</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>s'</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>s'</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>set_spmf_of_set_finite</span><span class="delimiter">[</span><span>OF</span><span> </span><span>prf_domain_finite</span><span class="delimiter">]</span><span>
</span><span>                </span><span>UPF.oracle_hash_def</span><span> </span><span>prf_domain_length</span><span> </span><span>exec_gpv_bind</span><span> </span><span>Let_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>bool.splits</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>exec_gpv_bind</span><span> </span><span>UPF.oracle_flag_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"bool × 'hash cipher_text set ⇒ ('hash cipher_text set × 'hash cipher_text set) ×  bool × bitstring set ⇒ bool"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S = (λ(bad, L1) ((L2, D), _). bad = (∃(x, c, t)∈D. upf_fun k_upf (x @ c) = t) ∧ L1 = L2) ↿ (λ_. True) ⊗ ?I"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>initial</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('hash cipher_text set × 'hash cipher_text set) ×  bool × bitstring set"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"initial = (({}, {}), (False, {}))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S ?init_normal initial"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>S_def</span><span> </span><span>initial_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(S ===&gt; (=) ===&gt; rel_spmf (rel_prod (=) S)) ?oracle_normal oracle_intercept"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>callee_invariant_restrict_relp</span><span class="delimiter">,</span><span> </span><span>unfold_locales</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_fun_def</span><span> </span><span>bind_spmf_of_set</span><span> </span><span>prf_domain_finite</span><span> </span><span>prf_domain_nonempty</span><span> </span><span>bind_spmf_pmf_assoc</span><span> </span><span>bind_assoc_pmf</span><span> </span><span>bind_return_pmf</span><span> </span><span>spmf_rel_map</span><span> </span><span>exec_gpv_bind</span><span> </span><span>Let_def</span><span> </span><span>ind_cca.oracle_encrypt_def</span><span> </span><span>oracle_decrypt1'_def</span><span> </span><span>encrypt.simps</span><span> </span><span>UPF.oracle_hash_def</span><span> </span><span>UPF.oracle_flag_def</span><span> </span><span>bind_map_spmf</span><span> </span><span>o_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>plus_oracle_split</span><span> </span><span>bool.split</span><span> </span><span>if_split</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bind_reflI</span><span> </span><span>rel_pmf_bind_reflI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_spmf (rel_prod (=) S) ?lhs (exec_gpv oracle_intercept 𝒜 initial)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>transfer_prover</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_spmf (λx y. ?fl x = ?fr y) ?lhs ?rhs"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>S_def</span><span> </span><span>exec_gpv_inline</span><span> </span><span>spmf_rel_map</span><span> </span><span>initial_def</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>rel_spmf_mono</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">including</span></span><span> </span><span>monad_normalisation</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>reduction_upf_def</span><span> </span><span>UPF.game_def</span><span> </span><span>game01'_def</span><span> </span><span>key_gen_def</span><span> </span><span>map_spmf_conv_bind_spmf</span><span> </span><span>split_def</span><span> </span><span>exec_gpv_bind</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>bind_spmf_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>game0'_eq</span><span> </span><span>game1'_eq</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>spmf_conv_measure_spmf</span><span> </span><span>measure_map_spmf</span><span> </span><span>vimage_def</span><span> </span><span>fst_def</span><span> </span><span>UPF.advantage_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>oracle_encrypt2</span><span> </span><span class="delimiter">::</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"('prf_key × 'upf_key) ⇒ bool ⇒ (bitstring, bitstring) PRF.dict ⇒ bitstring × bitstring 
    ⇒ ('hash cipher_text option × (bitstring, bitstring) PRF.dict) spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"oracle_encrypt2 = (λ(k_prf, k_upf) b D (msg1, msg0). (case (length msg1 = prf_clen ∧ length msg0 = prf_clen) of
      False ⇒ return_spmf (None, D)
    | True ⇒ do {
        x ← spmf_of_set prf_domain;
        P ← spmf_of_set (nlists UNIV prf_clen);
        let p = (case D x of Some r ⇒ r | None ⇒ P);
        let c = p [⊕] (if b then msg1 else msg0);
        let t = upf_fun k_upf (x @ c);
        return_spmf (Some (x, c, t), D(x ↦ p)) 
      }))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>oracle_decrypt2</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('prf_key × 'upf_key) ⇒ ('hash cipher_text, bitstring option, 'state) callee"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"oracle_decrypt2 = (λkey D cipher. return_spmf (None, D))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lossless_oracle_decrypt2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_spmf (oracle_decrypt2 k Dbad c)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle_decrypt2_def</span><span> </span><span>split_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>callee_invariant_oracle_decrypt2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"callee_invariant (oracle_decrypt2 key) fst"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle_decrypt2_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>oracle_decrypt2_parametric</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(rel_prod P U ===&gt; S ===&gt; rel_prod (=) (rel_prod (=) H) ===&gt; rel_spmf (rel_prod (=) S))
   oracle_decrypt2 oracle_decrypt2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>oracle_decrypt2_def</span><span> </span><span>split_def</span><span> </span><span>relator_eq</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer_prover</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>game2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(bitstring, 'hash cipher_text) ind_cca.adversary ⇒ bool spmf"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"game2 𝒜 ≡ do {
    key ← key_gen;
    b ← coin_spmf;
    (b', D) ← exec_gpv 
      (oracle_encrypt2 key b ⊕<span class="hidden">⇩</span><sub>O</sub> oracle_decrypt2 key) 𝒜 Map_empty;
    return_spmf (b = b')
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>intercept_prf</span><span> </span><span class="delimiter">::</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"'upf_key ⇒ bool ⇒ unit ⇒ (bitstring × bitstring) + 'hash cipher_text
  ⇒ (('hash cipher_text option + bitstring option) × unit, bitstring, bitstring) gpv"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"intercept_prf _ _ _ (Inr _) = Done (Inr None, ())"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"intercept_prf k b _ (Inl (m1, m0)) = (case (length m1) = prf_clen ∧ (length m0) = prf_clen of
      False ⇒ Done (Inl None, ())
    | True ⇒ do {
        x ← lift_spmf (spmf_of_set prf_domain);
        p ← Pause x Done;
        let c = p [⊕] (if b then m1 else m0);
        let t = upf_fun k (x @ c);
        Done (Inl (Some (x, c, t)), ())
      })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>reduction_prf</span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(bitstring, 'hash cipher_text) ind_cca.adversary ⇒ (bitstring, bitstring) PRF.adversary"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span> </span><span class="string"><span class="delete"><span class="delete">"reduction_prf 𝒜 = do {
   k ← lift_spmf upf_key_gen;
   b ← lift_spmf coin_spmf;
   (b', _) ← inline (intercept_prf k b) 𝒜 ();
   Done (b' = b)
 }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>round_2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¦spmf (ind_cca'.game 𝒜) True - spmf (game2 𝒜) True¦ = PRF.advantage (reduction_prf 𝒜)"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>oracle_encrypt1''</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"oracle_encrypt1'' = (λ(k_prf, k_upf) b (_ :: unit) (msg1, msg0). 
      case length msg1 = prf_clen ∧ length msg0 = prf_clen of
        False ⇒ return_spmf (None, ())
      | True ⇒ do {
          x ← spmf_of_set prf_domain;
          let p = prf_fun k_prf x;
          let c = p [⊕] (if b then msg1 else msg0);
          let t = upf_fun k_upf (x @ c);
          return_spmf (Some (x, c, t), ())})"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>game1''</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game1'' = do {
    key ← key_gen;
    b ← coin_spmf;
    (b', D) ← exec_gpv (oracle_encrypt1'' key b ⊕<span class="hidden">⇩</span><sub>O</sub> oracle_decrypt2 key) 𝒜 ();
    return_spmf (b = b')}"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ind_cca'.game 𝒜 = game1''"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>S</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S = (λ(L :: 'hash cipher_text set) (D :: unit). True)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S {} ()"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>S_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"((=) ===&gt; (=) ===&gt; S ===&gt; (=) ===&gt; rel_spmf (rel_prod (=) S))
       ind_cca'.oracle_encrypt oracle_encrypt1''"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ind_cca'.oracle_encrypt_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>oracle_encrypt1''_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_fun_def</span><span> </span><span>Let_def</span><span> </span><span>S_def</span><span> </span><span>encrypt.simps</span><span> </span><span>prf_domain_finite</span><span> </span><span>prf_domain_nonempty</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bind_reflI</span><span> </span><span>rel_pmf_bind_reflI</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>bool.split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"((=) ===&gt; S ===&gt; (=) ===&gt; rel_spmf (rel_prod (=) S)) 
       ind_cca'.oracle_decrypt oracle_decrypt2"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ind_cca'.oracle_decrypt_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>oracle_decrypt2_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_fun_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ind_cca'.game_def</span><span> </span><span>game1''_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer_prover</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = PRF.game_0 (reduction_prf 𝒜)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>k_prf</span><span> </span><span>k_upf</span><span> </span><span>b</span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>oracle_normal</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"oracle_normal = oracle_encrypt1'' (k_prf, k_upf) b ⊕<span class="hidden">⇩</span><sub>O</sub> oracle_decrypt2 (k_prf, k_upf)"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>oracle_intercept</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"oracle_intercept = (λ(s', s :: unit) y. map_spmf (λ((x, s'), s). (x, s', s)) (exec_gpv (PRF.prf_oracle k_prf) (intercept_prf k_upf b s' y) ()))"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>initial</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"initial = ()"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>S</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S = (λ(s2 :: unit, _ :: unit) (s1 :: unit). True)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S ((), ()) initial"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>S_def</span><span> </span><span>initial_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(S ===&gt; (=) ===&gt; rel_spmf (rel_prod (=) S)) oracle_intercept oracle_normal"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>oracle_normal_def</span><span> </span><span>oracle_intercept_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>bool.split</span><span> </span><span>plus_oracle_split</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>S_def</span><span> </span><span>rel_fun_def</span><span> </span><span>exec_gpv_bind</span><span> </span><span>PRF.prf_oracle_def</span><span> </span><span>oracle_encrypt1''_def</span><span> </span><span>Let_def</span><span> </span><span>map_spmf_conv_bind_spmf</span><span> </span><span>oracle_decrypt2_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bind_reflI</span><span> </span><span>rel_spmf_reflI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map_spmf (λx. b = fst x) (exec_gpv oracle_normal 𝒜 initial) =
        map_spmf (λx. b = fst (fst x)) (exec_gpv (PRF.prf_oracle k_prf) (inline (intercept_prf k_upf b) 𝒜 ()) ())"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>transfer</span><span> </span><span>fixing</span><span class="delimiter">:</span><span> </span><span>b</span><span> </span><span>𝒜</span><span> </span><span>prf_fun</span><span> </span><span>k_prf</span><span> </span><span>prf_domain</span><span> </span><span>prf_clen</span><span> </span><span>upf_fun</span><span> </span><span>k_upf</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>map_spmf_eq_map_spmf_iff</span><span> </span><span>exec_gpv_inline</span><span> </span><span>spmf_rel_map</span><span> </span><span>oracle_intercept_def</span><span> </span><span>split_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rel_spmf_reflI</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>game1''_def</span><span> </span><span>PRF.game_0_def</span><span> </span><span>key_gen_def</span><span> </span><span>reduction_prf_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>exec_gpv_bind_lift_spmf</span><span> </span><span>exec_gpv_bind</span><span> </span><span>map_spmf_conv_bind_spmf</span><span> </span><span>split_def</span><span> </span><span>eq_commute</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>bind_spmf_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game2 𝒜 = PRF.game_1 (reduction_prf 𝒜)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>split</span><span> </span><span>del</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>if_split</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>k_upf</span><span> </span><span>b</span><span> </span><span>k_prf</span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>oracle2</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"oracle2 = oracle_encrypt2 (k_prf, k_upf) b ⊕<span class="hidden">⇩</span><sub>O</sub> oracle_decrypt2 (k_prf, k_upf)"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>oracle_intercept</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"oracle_intercept = (λ(s', s) y. map_spmf (λ((x, s'), s). (x, s', s)) (exec_gpv PRF.random_oracle (intercept_prf k_upf b s' y) s))"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>S</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S = (λ(s2 :: unit, s2') (s1 :: (bitstring, bitstring) PRF.dict). s2' = s1)"</span></span></span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S ((), Map_empty) Map_empty"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>S_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(S ===&gt; (=) ===&gt; rel_spmf (rel_prod (=) S)) oracle_intercept oracle2"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>oracle2_def</span><span> </span><span>oracle_intercept_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>bool.split</span><span> </span><span>plus_oracle_split</span><span> </span><span>option.split</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>S_def</span><span> </span><span>rel_fun_def</span><span> </span><span>exec_gpv_bind</span><span> </span><span>PRF.random_oracle_def</span><span> </span><span>oracle_encrypt2_def</span><span> </span><span>Let_def</span><span> </span><span>map_spmf_conv_bind_spmf</span><span> </span><span>oracle_decrypt2_def</span><span> </span><span>rel_spmf_return_spmf1</span><span> </span><span>fun_upd_idem</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bind_reflI</span><span> </span><span>rel_spmf_reflI</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"map_spmf (λx. b = fst (fst x)) (exec_gpv (PRF.random_oracle) (inline (intercept_prf k_upf b) 𝒜 ()) Map.empty) = 
        map_spmf (λx. b = fst x) (exec_gpv oracle2 𝒜 Map_empty)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>transfer</span><span> </span><span>fixing</span><span class="delimiter">:</span><span> </span><span>b</span><span> </span><span>prf_clen</span><span> </span><span>prf_domain</span><span> </span><span>upf_fun</span><span> </span><span>k_upf</span><span> </span><span>𝒜</span><span> </span><span>k_prf</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>exec_gpv_inline</span><span> </span><span>map_spmf_conv_bind_spmf</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>spmf.map_comp</span><span> </span><span>o_def</span><span> </span><span>split_def</span><span> </span><span>oracle_intercept_def</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>game2_def</span><span> </span><span>PRF.game_1_def</span><span> </span><span>key_gen_def</span><span> </span><span>reduction_prf_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>exec_gpv_bind_lift_spmf</span><span> </span><span>exec_gpv_bind</span><span> </span><span>map_spmf_conv_bind_spmf</span><span> </span><span>split_def</span><span> </span><span>bind_spmf_const</span><span> </span><span>prf_key_gen_lossless</span><span> </span><span>lossless_weight_spmfD</span><span> </span><span>eq_commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>PRF.advantage_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>oracle_encrypt3</span><span> </span><span class="delimiter">::</span><span> 
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"('prf_key × 'upf_key) ⇒ bool ⇒ (bool × (bitstring, bitstring) PRF.dict) ⇒
    bitstring × bitstring ⇒ ('hash cipher_text option × (bool × (bitstring, bitstring) PRF.dict)) spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"oracle_encrypt3 = (λ(k_prf, k_upf) b (bad, D) (msg1, msg0). 
    (case (length msg1 = prf_clen ∧ length msg0 = prf_clen) of
      False ⇒ return_spmf (None, (bad, D))
    | True ⇒ do {
        x ← spmf_of_set prf_domain;
        P ← spmf_of_set (nlists UNIV prf_clen);
        let (p, F) = (case D x of Some r ⇒ (P, True) | None ⇒ (P, False));
        let c = p [⊕] (if b then msg1 else msg0);
        let t = upf_fun k_upf (x @ c);
        return_spmf (Some (x, c, t), (bad ∨ F, D(x ↦ p))) 
      }))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lossless_oracle_encrypt3</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lossless_spmf (oracle_encrypt3 k b D m10) "</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>m10</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle_encrypt3_def</span><span> </span><span>prf_domain_nonempty</span><span> </span><span>prf_domain_finite</span><span>
</span><span>    </span><span>split_def</span><span> </span><span>Let_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>bool.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>callee_invariant_oracle_encrypt3</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"callee_invariant (oracle_encrypt3 key b) fst"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle_encrypt3_def</span><span> </span><span>split_def</span><span> </span><span>Let_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>bool.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>game3</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(bitstring, 'hash cipher_text) ind_cca.adversary ⇒ (bool × bool) spmf"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"game3 𝒜 ≡ do {
    key ← key_gen;
    b ← coin_spmf;
    (b', (bad, D)) ← exec_gpv (oracle_encrypt3 key b ⊕<span class="hidden">⇩</span><sub>O</sub> oracle_decrypt2 key) 𝒜 (False, Map_empty);
    return_spmf (b = b', bad)
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>round_3</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_gpv (ℐ_full ⊕<span class="hidden">⇩</span><sub>ℐ</sub> ℐ_full) 𝒜"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¦measure (measure_spmf (game3 𝒜)) {(b, bad). b} - spmf (game2 𝒜) True¦ 
          ≤ measure (measure_spmf (game3 𝒜)) {(b, bad). bad}"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>oracle_encrypt2'</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"oracle_encrypt2' = (λ(k_prf :: 'prf_key, k_upf) b (bad, D) (msg1, msg0). 
      case length msg1 = prf_clen ∧ length msg0 = prf_clen of
        False ⇒ return_spmf (None, (bad, D))
      | True ⇒ do {
          x ← spmf_of_set prf_domain;
          P ← spmf_of_set (nlists UNIV prf_clen);
          let (p, F) = (case D x of Some r ⇒ (r, True) | None ⇒ (P, False));
          let c = p [⊕] (if b then msg1 else msg0);
          let t = upf_fun k_upf (x @ c);
          return_spmf (Some (x, c, t), (bad ∨ F, D(x ↦ p))) 
        })"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_spmf (oracle_encrypt2' key b D msg10) "</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>key</span><span> </span><span>b</span><span> </span><span>D</span><span> </span><span>msg10</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>msg10</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle_encrypt2'_def</span><span> </span><span>prf_domain_nonempty</span><span> </span><span>prf_domain_finite</span><span>
</span><span>      </span><span>split_def</span><span> </span><span>Let_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>bool.split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"callee_invariant (oracle_encrypt2' key b) fst"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>key</span><span> </span><span>b</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle_encrypt2'_def</span><span> </span><span>split_def</span><span> </span><span>Let_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>bool.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>game2'</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game2' = (λ𝒜. do {
      key ← key_gen;
      b ← coin_spmf;
      (b', (bad, D)) ← exec_gpv (oracle_encrypt2' key b ⊕<span class="hidden">⇩</span><sub>O</sub> oracle_decrypt2 key) 𝒜 (False, Map_empty);
      return_spmf (b = b', bad)})"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>game2'_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"game2 𝒜 = map_spmf fst (game2' 𝒜)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>S</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S = (λ(D1 :: (bitstring, bitstring) PRF.dict) (bad :: bool, D2). D1 = D2)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S Map_empty (b, Map_empty)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>S_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"((=) ===&gt; (=) ===&gt; S ===&gt; (=) ===&gt; rel_spmf (rel_prod (=) S))
      oracle_encrypt2 oracle_encrypt2'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>oracle_encrypt2_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>oracle_encrypt2'_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_fun_def</span><span> </span><span>Let_def</span><span> </span><span>split_def</span><span> </span><span>S_def</span><span>
</span><span>           </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bind_reflI</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>bool.split</span><span> </span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"((=) ===&gt; S ===&gt; (=) ===&gt; rel_spmf (rel_prod (=) S)) 
      oracle_decrypt2 oracle_decrypt2"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_fun_def</span><span> </span><span>oracle_decrypt2_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>game2_def</span><span> </span><span>game2'_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>map_spmf_bind_spmf</span><span> </span><span>o_def</span><span> </span><span>split_def</span><span> </span><span>Map_empty_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>Map_empty_def</span><span class="delimiter">)</span><span>
</span><span>         </span><span>transfer_prover</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_spmf (λ(b'1, bad1, L1) (b'2, bad2, L2). (bad1 ⟷ bad2) ∧ (¬ bad2 ⟶ b'1 ⟷ b'2))
    (exec_gpv (oracle_encrypt3 key b ⊕<span class="hidden">⇩</span><sub>O</sub> oracle_decrypt2 key) 𝒜 (False, Map_empty))
    (exec_gpv (oracle_encrypt2' key b ⊕<span class="hidden">⇩</span><sub>O</sub> oracle_decrypt2 key) 𝒜 (False, Map_empty))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>key</span><span> </span><span>b</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>exec_gpv_oracle_bisim_bad</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>X</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"(=)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>X_bad</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_ _. True"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="var">?bad1.0</span><span class="delimiter">=</span><span>fst</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="var">?bad2.0</span><span class="delimiter">=</span><span>fst</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ℐ</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"ℐ_full ⊕<span class="hidden">⇩</span><sub>ℐ</sub> ℐ_full"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>spmf_rel_map</span><span> </span><span>Let_def</span><span> </span><span>oracle_encrypt2'_def</span><span> </span><span>oracle_encrypt3_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>plus_oracle_split</span><span> </span><span>prod.split</span><span> </span><span>bool.split</span><span> </span><span>option.split</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bind_reflI</span><span> </span><span>rel_spmf_reflI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¦measure (measure_spmf (game3 𝒜)) {(b, bad). b} - measure (measure_spmf (game2' 𝒜)) {(b, bad). b}¦ ≤
    measure (measure_spmf (game3 𝒜)) {(b, bad). bad}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>game2'_def</span><span> </span><span>game3_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>fundamental_lemma</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="var">?bad2.0</span><span class="delimiter">=</span><span>snd</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span>intro</span><span> </span><span>rel_spmf_bind_reflI</span><span> </span><span>rel_spmf_bindI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>*</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>spmf_conv_measure_spmf</span><span> </span><span>measure_map_spmf</span><span> </span><span>vimage_def</span><span> </span><span>fst_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>round_4</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_gpv (ℐ_full ⊕<span class="hidden">⇩</span><sub>ℐ</sub> ℐ_full) 𝒜"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map_spmf fst (game3 𝒜) = coin_spmf"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>oracle_encrypt4</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"oracle_encrypt4 = (λ(k_prf :: 'prf_key, k_upf) (s :: unit) (msg1 :: bitstring, msg0 :: bitstring).
      case length msg1 = prf_clen ∧ length msg0 = prf_clen of
        False ⇒ return_spmf (None, s)
      | True ⇒ do {
          x ← spmf_of_set prf_domain;
          P ← spmf_of_set (nlists UNIV prf_clen);
          let c = P;
          let t = upf_fun k_upf (x @ c);
          return_spmf (Some (x, c, t), s) })"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_spmf (oracle_encrypt4 k s msg10)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span> </span><span>s</span><span> </span><span>msg10</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>msg10</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle_encrypt4_def</span><span> </span><span>prf_domain_finite</span><span> </span><span>prf_domain_nonempty</span><span>
</span><span>      </span><span>split_def</span><span> </span><span>Let_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>bool.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>game4</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game4 = (λ𝒜. do {
    key ← key_gen;
    (b', _) ← exec_gpv (oracle_encrypt4 key ⊕<span class="hidden">⇩</span><sub>O</sub> oracle_decrypt2 key) 𝒜 ();
    map_spmf ((=) b') coin_spmf})"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map_spmf fst (game3 𝒜) = game4 𝒜"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>split</span><span> </span><span>del</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>if_split</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>S</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S = (λ(_ :: unit) (_ :: bool × (bitstring, bitstring) PRF.dict). True)"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>initial3</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"initial3 = (False, Map.empty :: (bitstring, bitstring) PRF.dict)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S () initial3"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>S_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"((=) ===&gt; (=) ===&gt; S ===&gt; (=) ===&gt; rel_spmf (rel_prod (=) S))
       (λkey b. oracle_encrypt4 key) oracle_encrypt3"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>rel_funI</span><span class="delimiter">;</span><span> </span><span>hypsubst</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>key</span><span> </span><span>unit</span><span> </span><span>msg10</span><span> </span><span>b</span><span> </span><span>Dbad</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map_spmf fst (oracle_encrypt4 key () msg10) = map_spmf fst (oracle_encrypt3 key b Dbad msg10)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>oracle_encrypt3_def</span><span> </span><span>oracle_encrypt4_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>map_spmf_conv_bind_spmf</span><span> </span><span>Let_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>bool.split</span><span> </span><span>prod.split</span><span class="delimiter">;</span><span> </span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌑ = _"</span></span></span><span> </span><span>one_time_pad</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>xs</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"if b then fst msg10 else snd msg10"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bind_map_spmf</span><span> </span><span>o_def</span><span> </span><span>option.case_distrib</span><span> </span><span>case_option_collapse</span><span> </span><span>xor_list_commute</span><span> </span><span>split_def</span><span> </span><span>cong</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>option.case_cong_weak</span><span> </span><span>if_weak_cong</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_spmf (rel_prod (=) S) (oracle_encrypt4 key unit msg10) (oracle_encrypt3 key b Dbad msg10)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>spmf_rel_eq</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>spmf_rel_map</span><span> </span><span>S_def</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>rel_spmf_mono</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>game3_def</span><span> </span><span>game4_def</span><span> </span><span class="keyword1"><span class="command">including</span></span><span> </span><span>monad_normalisation</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>map_spmf_bind_spmf</span><span> </span><span>o_def</span><span> </span><span>split_def</span><span> </span><span>map_spmf_conv_bind_spmf</span><span> </span><span>initial3_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>eq_commute</span><span class="delimiter">)</span><span>
</span><span>         </span><span>transfer_prover</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = coin_spmf"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>map_eq_const_coin_spmf</span><span> </span><span>game4_def</span><span> </span><span>bind_spmf_const</span><span> </span><span>split_def</span><span> </span><span>lossless_exec_gpv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>lossless_weight_spmfD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>game3_bad</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"interaction_bounded_by isl 𝒜 q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"measure (measure_spmf (game3 𝒜)) {(b, bad). bad} ≤ q / card prf_domain * q"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"measure (measure_spmf (game3 𝒜)) {(b, bad). bad} = spmf (map_spmf snd (game3 𝒜)) True"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>spmf_conv_measure_spmf</span><span> </span><span>measure_map_spmf</span><span> </span><span>vimage_def</span><span> </span><span>snd_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"spmf (map_spmf (fst ∘ snd) (exec_gpv (oracle_encrypt3 k b ⊕<span class="hidden">⇩</span><sub>O</sub> oracle_decrypt2 k) 𝒜 (False, Map.empty))) True ≤ q / card prf_domain * q"</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"spmf (map_spmf _ (exec_gpv ?oracle _ _)) _ ≤  _"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"k ∈ set_spmf key_gen"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span> </span><span>b</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>callee_invariant_on.interaction_bounded_by'_exec_gpv_bad_count</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k_prf</span><span> </span><span>k_upf</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"k = (k_prf, k_upf)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?I</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(bad, D). finite (dom D) ∧ dom D ⊆ prf_domain"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"callee_invariant (oracle_encrypt3 k b) ?I"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>prf_domain_finite</span><span> </span><span>oracle_encrypt3_def</span><span> </span><span>Let_def</span><span> </span><span>split_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>bool.splits</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"callee_invariant (oracle_decrypt2 k) ?I"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>prf_domain_finite</span><span> </span><span>oracle_decrypt2_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"callee_invariant ?oracle ?I"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?count</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(bad, D). card (dom D)"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀s x y s'. ⟦ (y, s') ∈ set_spmf (?oracle s x); ?I s; isl x ⟧ ⟹ ?count s' ≤ Suc (?count s)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>isl_def</span><span> </span><span>oracle_encrypt3_def</span><span> </span><span>split_def</span><span> </span><span>Let_def</span><span> </span><span>card_insert_if</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>bool.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ (y, s') ∈ set_spmf (?oracle s x); ?I s; ¬ isl x ⟧ ⟹ ?count s' ≤ ?count s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>s'</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle_decrypt2_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"spmf (map_spmf (fst ∘ snd) (?oracle s' x)) True ≤ q / card prf_domain"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?I s'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bad</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ fst s'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>count</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?count s' &lt; q + ?count (False, Map.empty)"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isl x"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s'</span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>bad</span><span> </span><span>D</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s'</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s' = (bad, D)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>s'</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>x</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m1</span><span> </span><span>m0</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x = Inl (m1, m0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>islE</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(case D x of None ⇒ False | Some x ⇒ True) ⟷ x ∈ dom D"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"length m1 = prf_clen ∧ length m0 = prf_clen"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>bad</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"spmf (map_spmf (fst ∘ snd) (?oracle s' x)) True = pmf (bernoulli_pmf (card (dom D ∩ prf_domain) / card prf_domain)) True"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>spmf.map_comp</span><span> </span><span>o_def</span><span> </span><span>oracle_encrypt3_def</span><span> </span><span>k</span><span> </span><span>*</span><span> </span><span>bool.case_distrib</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>h</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λp. spmf (map_spmf _ p) _"</span></span></span><span class="delimiter">]</span><span> </span><span>option.case_distrib</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>h</span><span class="delimiter">=</span><span>snd</span><span class="delimiter">]</span><span> </span><span>map_spmf_bind_spmf</span><span> </span><span>Let_def</span><span> </span><span>split_beta</span><span> </span><span>bind_spmf_const</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>bool.case_cong</span><span> </span><span>option.case_cong</span><span> </span><span>split</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>if_split</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>bool.split</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>map_spmf_conv_bind_spmf</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>map_mem_spmf_of_set</span><span> </span><span>prf_domain_finite</span><span> </span><span>prf_domain_nonempty</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = card (dom D ∩ prf_domain) / card prf_domain"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>pmf_bernoulli_True</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>field_simps</span><span> </span><span>prf_domain_finite</span><span> </span><span>prf_domain_nonempty</span><span> </span><span>card_gt_0_iff</span><span> </span><span>card_mono</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dom D ∩ prf_domain = dom D"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>I</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (dom D) ≤ q"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>count</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>divide_right_mono</span><span> </span><span>o_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bad</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>spmf.map_comp</span><span> </span><span>o_def</span><span> </span><span>oracle_encrypt3_def</span><span> </span><span>k</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>bool.split</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>plus_oracle_split_asm</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle_decrypt2_def</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"spmf (map_spmf snd (game3 𝒜)) True ≤ q / card prf_domain * q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>4</span><span> </span><span>3</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>game3_def</span><span> </span><span>map_spmf_bind_spmf</span><span> </span><span>o_def</span><span> </span><span>split_def</span><span> </span><span>map_spmf_conv_bind_spmf</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>spmf_bind_leI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>security</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>lossless</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_gpv (ℐ_full ⊕<span class="hidden">⇩</span><sub>ℐ</sub> ℐ_full) 𝒜"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"interaction_bounded_by isl 𝒜 q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ind_cca.advantage 𝒜 ≤ 
    PRF.advantage (reduction_prf 𝒜) + UPF.advantage (reduction_upf 𝒜) +
    real q / real (card prf_domain) * real q"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?LHS ≤ _"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?LHS ≤ ¦spmf (ind_cca.game 𝒜) True - spmf (ind_cca'.game 𝒜) True¦ + ¦spmf (ind_cca'.game 𝒜) True - 1 / 2¦"</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ ≤ ?round1 + ?rest"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>abs_triangle_ineq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ind_cca.advantage_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?round1 ≤ UPF.advantage (reduction_upf 𝒜)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lossless</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>round_1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?rest ≤ ¦spmf (ind_cca'.game 𝒜) True - spmf (game2 𝒜) True¦ + ¦spmf (game2 𝒜) True - 1 / 2¦"</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ ≤ ?round2 + ?rest"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>abs_triangle_ineq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?round2 = PRF.advantage (reduction_prf 𝒜)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>round_2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?rest ≤ ¦measure (measure_spmf (game3 𝒜)) {(b, bad). b} - spmf (game2 𝒜) True¦ +
       ¦measure (measure_spmf (game3 𝒜)) {(b, bad). b} - 1 / 2¦"</span></span></span><span> 
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ ≤ ?round3 + _"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>abs_triangle_ineq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?round3 ≤ measure (measure_spmf (game3 𝒜)) {(b, bad). bad}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>round_3</span><span class="delimiter">[</span><span>OF</span><span> </span><span>lossless</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ q / card prf_domain * q"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bound</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>game3_bad</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"measure (measure_spmf (game3 𝒜)) {(b, bad). b} = spmf coin_spmf True"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>round_4</span><span class="delimiter">[</span><span>OF</span><span> </span><span>lossless</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>spmf_conv_measure_spmf</span><span> </span><span>measure_map_spmf</span><span> </span><span>vimage_def</span><span> </span><span>fst_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¦… - 1 / 2¦ = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>spmf_of_set</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>security1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>lossless</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_gpv (ℐ_full ⊕<span class="hidden">⇩</span><sub>ℐ</sub> ℐ_full) 𝒜"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"interaction_bounded_by isl 𝒜 q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>q'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"interaction_bounded_by (Not ∘ isl) 𝒜 q'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ind_cca.advantage 𝒜 ≤ 
    PRF.advantage (reduction_prf 𝒜) +
    UPF.advantage1 (guessing_many_one.reduction q' (λ_. reduction_upf 𝒜) ()) * q' +
    real q * real q / real (card prf_domain)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ind_cca.advantage 𝒜 ≤ 
    PRF.advantage (reduction_prf 𝒜) + UPF.advantage (reduction_upf 𝒜) +
    real q / real (card prf_domain) * real q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lossless</span><span> </span><span>q</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>security</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>q'</span><span class="delimiter">[</span><span>interaction_bound</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"interaction_bounded_by (Not ∘ isl) (reduction_upf 𝒜) q'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>reduction_upf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>interaction_bound</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>SUP_le_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"UPF.advantage (reduction_upf 𝒜) ≤ UPF.advantage1 (guessing_many_one.reduction q' (λ_. reduction_upf 𝒜) ()) * q'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>UPF.advantage_advantage1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>simple_cipher'</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>prf_key_gen</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ 'prf_key spmf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prf_fun</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ 'prf_key ⇒ bitstring ⇒ bitstring"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prf_domain</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ bitstring set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prf_range</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ bitstring set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prf_dlen</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ nat"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prf_clen</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ nat"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>upf_key_gen</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ 'upf_key spmf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>upf_fun</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ 'upf_key ⇒ bitstring ⇒ 'hash"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>simple_cipher</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀η. simple_cipher (prf_key_gen η) (prf_fun η) (prf_domain η) (prf_dlen η) (prf_clen η) (upf_key_gen η)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>simple_cipher</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prf_key_gen η"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prf_fun η"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prf_domain η"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prf_range η"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prf_dlen η"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prf_clen η"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"upf_key_gen η"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"upf_fun η"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>η</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>simple_cipher</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>security_asymptotic</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>q</span><span> </span><span>q'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ nat"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>lossless</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀η. lossless_gpv (ℐ_full ⊕<span class="hidden">⇩</span><sub>ℐ</sub> ℐ_full) (𝒜 η)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀η. interaction_bounded_by isl (𝒜 η) (q η)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bound'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀η. interaction_bounded_by (Not ∘ isl) (𝒜 η) (q' η)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">[</span><span>negligible_intros</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"polynomial q'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"polynomial q"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"negligible (λη. PRF.advantage η (reduction_prf η (𝒜 η)))"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"negligible (λη. UPF.advantage1 η (guessing_many_one.reduction (q' η) (λ_. reduction_upf η (𝒜 η)) ()))"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"negligible (λη. 1 / card (prf_domain η))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"negligible (λη. ind_cca.advantage η (𝒜 η))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"negligible (λη. PRF.advantage η (reduction_prf η (𝒜 η)) +
    UPF.advantage1 η (guessing_many_one.reduction (q' η) (λ_. reduction_upf η (𝒜 η)) ()) * q' η +
    real (q η) / real (card (prf_domain η)) * real (q η))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>negligible_intros</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>negligible_le</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>security1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>lossless</span><span> </span><span>bound</span><span> </span><span>bound'</span><span class="delimiter">]</span><span> </span><span>ind_cca.advantage_nonneg</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Cryptographic_Constructions">
<div class="head"><h1>Theory Cryptographic_Constructions</h1>
<span class="command">theory</span> <span class="name">Cryptographic_Constructions</span><br/>
<span class="keyword">imports</span> <a href="Elgamal.html"><span class="name">Elgamal</span></a> <a href="Hashed_Elgamal.html"><span class="name">Hashed_Elgamal</span></a> <a href="RP_RF.html"><span class="name">RP_RF</span></a> <a href="PRF_UHF.html"><span class="name">PRF_UHF</span></a> <a href="PRF_IND_CPA.html"><span class="name">PRF_IND_CPA</span></a> <a href="PRF_UPF_IND_CCA.html"><span class="name">PRF_UPF_IND_CCA</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: Cryptographic_Constructions.thy
  Author: Andreas Lochbihler, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Cryptographic_Constructions</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Elgamal</span><span>
</span><span>  </span><span>Hashed_Elgamal</span><span>
</span><span>  </span><span>RP_RF</span><span>
</span><span>  </span><span>PRF_UHF</span><span>
</span><span>  </span><span>PRF_IND_CPA</span><span>
</span><span>  </span><span>PRF_UPF_IND_CCA</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Game_Based_Crypto">
<div class="head"><h1>Theory Game_Based_Crypto</h1>
<span class="command">theory</span> <span class="name">Game_Based_Crypto</span><br/>
<span class="keyword">imports</span> <a href="Security_Spec.html"><span class="name">Security_Spec</span></a> <a href="Cryptographic_Constructions.html"><span class="name">Cryptographic_Constructions</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: Game_Based_Crypto.thy
  Author: Andreas Lochbihler, ETH Zurich *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Game_Based_Crypto</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Security_Spec</span><span>
</span><span>  </span><span>Cryptographic_Constructions</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="CryptHOL_Tutorial">
<div class="head"><h1>Theory CryptHOL_Tutorial</h1>
<span class="command">theory</span> <span class="name">CryptHOL_Tutorial</span><br/>
<span class="keyword">imports</span> <a href="../CryptHOL/CryptHOL.html"><span class="name">CryptHOL</span></a> <a href="LaTeXsugar.html"><span class="name">LaTeXsugar</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Andreas Lochbihler, Digital Asset 
   Author: S. Reza Sefidgar, ETH Zurich      *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹%
\clearpage
\addcontentsline{toc}{section}{A Tutorial Introduction to \CryptHOL{}}%
\begin{center}
  \normalfont
  {\huge A Tutorial Introduction to \CryptHOL{}}
  \\[1em]
  \large
  Andreas Lochbihler
  \\
  Digital Asset (Switzerland) GmbH, Zurich, Switzerland,
  \texttt{mail@andreas-lochbihler.de}
  \\[1ex]
  S. Reza Sefidgar
  \\
  Institute of Information Security, 
  Department of Computer Science, ETH Zurich, Zurich, Switzerland, \\
  \texttt{reza.sefidgar@inf.ethz.ch}
\end{center}
%
\begin{abstract}
  \noindent
  This tutorial demonstrates how cryptographic security notions, constructions, and game-based security proofs
  can be formalized using the \CryptHOL{} framework.
  As a running example, we formalize a variant of the hash-based ElGamal encryption scheme and its IND-CPA security in the random oracle model.
  This tutorial assumes basic familiarity with Isabelle/HOL and standard cryptographic terminology.
\end{abstract}
›</span></span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Introduction›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
\CryptHOL{}~\cite{Basin2017, Lochbihler2016} is a framework for constructing rigorous game-based
proofs using the proof assistant Isabelle/HOL~\cite{Nipkow2002}.
Games are expressed as probabilistic functional programs that are shallowly embedded in higher-order logic (HOL) using \CryptHOL{}'s combinators.
The security statements, both concrete and asymptotic, are expressed as Isabelle/HOL theorem statements, and their proofs are written declaratively in Isabelle's proof language Isar~\cite{Wenzel1999}.
This way, Isabelle mechanically checks that all definitions and statements are type-correct and each proof step is a valid logical inference in HOL.
This ensures that the resulting theorems are valid in higher-order logic.

This tutorial explains the \CryptHOL{} essentials using a simple security proof.
Our running example is a variant of the hashed ElGamal encryption scheme~\cite{Elgamal1985}.
We formalize the scheme, the indistinguishability under chosen plaintext (IND-CPA) security property, the computational Diffie-Hellman (CDH) hardness assumption~\cite{Diffie1976}, and the security proof in the random oracle model.
This illustrates how the following aspects of a cryptographic security proof are formalized using \CryptHOL{}:

\begin{itemize}
\item Game-based security definitions (CDH in \S\ref{section:lcdh} and IND-CPA in \S\ref{section:ind-cpa})
\item Oracles (a random oracle in \S\ref{section:random-oracle})
\item Cryptographic schemes, both generic (the concept of an encryption scheme) and a particular instance (the hashed Elgamal scheme in \S\ref{section:hashed-elgamal-scheme})
\item Security statements (concrete and asymptotic, \S\ref{section:security:concrete} and \S\ref{section:security:asymptotic})
\item Reductions (from IND-CPA to CDH for hashed Elgamal in \S\ref{section:reduction})
\item Different kinds of proof steps (\S\ref{section:ghop-first}--\ref{section:combining:hops}):
  \begin{itemize}
  \item Using intermediate games
  \item Defining failure events and applying indistinguishability-up-to lemmas
  \item Equivalence transformations on games
  \end{itemize}
\end{itemize}

This tutorial assumes that the reader knows the basics of Isabelle/HOL and game-based cryptography and wants to get hands-on experience with \CryptHOL{}.
The semantics behind CryptHOL's embedding in higher-order logic and its soundness are not discussed;
we refer the reader to the scientific articles for that~\cite{Basin2017, Lochbihler2016}.
Shoup's tutorial~\cite{Shoup2004IACR} provides a good introduction to game-based proofs.
The following Isabelle features are frequently used in \CryptHOL{} formalizations; the tutorials are available from the Documentation panel in Isabelle/jEdit.
\begin{itemize}
\item Function definitions (tutorials @{doc "prog-prove"} and @{doc "functions"},~\cite{Krauss2009}) for games and reductions
\item Locales (tutorial @{doc locales},~\cite{Ballarin2014}) to modularize the formalization
\item The Transfer package~\cite{Huffman2013} for automating parametricity and representation independence proofs
\end{itemize}

This document is generated from a corresponding Isabelle theory file available online~\cite{Lochbihler2017b}.%
\footnote{%
  The tutorial has been added to the Archive of Formal Proofs after the release of Isabelle2018.
  Until the subsequent Isabelle release, the tutorial is only available in the development version at
  \url{https://devel.isa-afp.org/entries/Game_Based_Crypto.html}.
  The version for Isabelle2018 is available at \url{http://www.andreas-lochbihler.de/pub/crypthol_tutorial.zip}.
}
It contains this text and all examples, including the security definitions and proofs.
We encourage all readers to download the latest version of the tutorial 
and follow the proofs and examples interactively in Isabelle/HOL.
In particular, a Ctrl-click on a formal entity (function, constant, theorem name, ...) jumps to the definition of the entity.

We split the tutorial into a series of recipes for common formalization tasks. In each section, we cover
a familiar cryptography concept and show how it is formalized in \CryptHOL{}. Simultaneously, we explain
the Isabelle/HOL and functional programming topics that are essential for formalizing game-based proofs. 
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Getting started›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
\CryptHOL{} is available as part of the Archive of Formal Proofs~\cite{Lochbihler2017a}.
Cryptography formalizations based on \CryptHOL{} are arranged in Isabelle theory files that import the relevant libraries.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Getting started›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
\CryptHOL{} is available as part of the Archive of Formal Proofs~\cite{Lochbihler2017a}.
Cryptography formalizations based on \CryptHOL{} are arranged in Isabelle theory files that import the relevant libraries.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>CryptHOL_Tutorial</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>CryptHOL.CryptHOL</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span class="string"><span class="delete"><span class="delete">"HOL-Library.LaTeXsugar"</span></span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">unbundle</span></span><span> </span><span class="delimiter">%</span><span>invisible</span><span> </span><span>lifting_syntax</span><span>
</span><span class="keyword1"><span class="command">no_adhoc_overloading</span></span><span> </span><span class="delimiter">%</span><span>invisible</span><span> </span><span>Monad_Syntax.bind</span><span> </span><span>bind_pmf</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">%</span><span>invisible</span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>names_short</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The file @{theory CryptHOL.CryptHOL} is the canonical entry point into \CryptHOL{}.
For the hashed Elgamal example in this tutorial, the \CryptHOL{} library contains everything that is needed.
Additional Isabelle libraries can be imported if necessary.
›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Modelling cryptography using \CryptHOL{}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
This section demonstrates how the following cryptographic concepts are modelled in \CryptHOL{}.
\begin{itemize}
\item A security property without oracles (\S\ref{section:lcdh})
\item An oracle (\S\ref{section:random-oracle})
\item A cryptographic concept (\S\ref{section:pk-enc})
\item A security property with an oracle (\S\ref{section:ind-cpa})
\item A concrete cryptographic scheme (\S\ref{section:hashed-elgamal-scheme})
\end{itemize}
›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Security notions without oracles: the CDH assumption \label{section:lcdh}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
In game-based cryptography, a security property is specified using a game between a benign challenger and an adversary.
The probability of an adversary to win the game against the challenger is called its advantage.
A cryptographic construction satisfies a security property if the advantage for any ``feasible'' adversary is ``negligible''.
A typical security proof reduces the security of a construction to the assumed security of its building blocks.
In a concrete security proof, where the security parameter is implicit, it is therefore not necessary to formally define ``feasibility'' and ''negligibility'', 
as the security statement establishes a concrete relation between the advantages of specific adversaries.%
\footnote{%
  The cryptographic literature sometimes abstracts over the adversary and 
  defines the advantage to be the advantage of the best "feasible" adversary against a game.
  Such abstraction would require a formalization of feasibility, for which \CryptHOL{} currently does not offer any support.
  We therefore always consider the advantage of a specific adversary.
}
We return to asymptotic security statements in \S\ref{section:asymptotic}.

A formalization of a security property must therefore specify all of the following:
\begin{itemize}
\item The operations of the scheme (e.g., an algebraic group, an encryption scheme)
\item The type of adversary
\item The game with the challenger
\item The advantage of the adversary as a function of the winning probability
\end{itemize}

For hashed Elgamal, the cyclic group must satisfy the computational Diffie-Hellman assumption.
To keep the proof simple, we formalize the equivalent list version of CDH.

\begin{definition}[The list computational Diffie-Hellman game]
Let ‹𝒢› be a group of order ‹q› with generator ‹<span class="hidden">❙</span><span class="bold">g</span>›.
The List Computational Diffie-Hellman (LCDH)
assumption holds for ‹𝒢› if any ``feasible'' adversary has ``negligible'' probability in winning 
the following \textbf{LCDH game} against a challenger:
  \begin{enumerate}
  \item The challenger picks ‹x› and ‹y› randomly (and independently) from
    $\{0, \dots, ‹q› - 1\}$.
  \item It passes $‹<span class="hidden">❙</span><span class="bold">g</span>›^x$ and $‹<span class="hidden">❙</span><span class="bold">g</span>›^y$ to the adversary.
    The adversary generates a set ‹L› of guesses about the value of $‹<span class="hidden">❙</span><span class="bold">g</span>›^{‹x›‹y›}$.
  \item The adversary wins the game if $‹<span class="hidden">❙</span><span class="bold">g</span>›^{‹x›‹y›} \in ‹L›$.
  \end{enumerate}
\end{definition}

The scheme for LCDH uses only a cyclic group.
To make the LCDH formalisation reusable, we formalize the LCDH game for an arbitrary cyclic group @{term "𝒢"} using Isabelle's module system based on locales.
The locale ‹list_cdh› fixes @{term "𝒢"} to be a finite cyclic group that has elements of type @{typ "'grp"} and comes with a generator @{term "<span class="hidden">❙</span><span class="bold">g</span><span class="hidden">⇘</span><sub>𝒢<span class="hidden">⇙</span></sub>"}.
Basic facts about finite groups are formalized in the \CryptHOL{} theory @{theory CryptHOL.Cyclic_Group}.%
\footnote{%
  The syntax directive @{theory_text "structure"} tells Isabelle that all group operations in the context of the locale refer to the group @{term "𝒢"} unless stated otherwise.
  For example, @{term "<span class="hidden">❙</span><span class="bold">g</span><span class="hidden">⇘</span><sub>𝒢<span class="hidden">⇙</span></sub>"} can be written as ‹<span class="hidden">❙</span><span class="bold">g</span>› inside the locale.

  Isabelle automatically adds the locale parameters and the assumptions on them to all definitions and lemmas inside that locale.
  Of course, we could have made the group @{term "𝒢"} an explicit argument of all functions ourselves, 
  but then we would not benefit from Isabelle's module system, in particular locale instantiation.
}
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>list_cdh</span><span> </span><span class="delimiter">=</span><span> </span><span>cyclic_group</span><span> </span><span>𝒢</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>𝒢</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp cyclic_group"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The LCDH game does not need oracles.
The adversary is therefore just a probabilistic function from two group elements to a set of guesses, which are again group elements.
In \CryptHOL{}, the probabilistic nature is expressed by the adversary returning a discrete subprobability distribution over sets of guesses, as expressed by the type constructor ‹spmf›.
(Subprobability distributions are like probability distributions except that the whole probability mass may be less than 1, i.e., some probability may be ``lost''.
A subprobability distribution is called lossless, written @{term lossless_spmf}, if its probability mass is 1.)
We define the following abbreviation as a shorthand for the type of LCDH adversaries.%
\footnote{%
  Actually, the type of group elements has already been fixed in the locale @{locale list_cdh} to the type variable @{typ "'grp"}.
  Unfortunately, such fixed type variables cannot be used in type declarations inside a locale in Isabelle2018.
  The @{command type_synonym} ‹adversary› is therefore parametrized by a different type variable @{typ 'grp'}, but it will be used below only with @{typ 'grp}.
}
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'grp'</span><span> </span><span>adversary</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp' ⇒ 'grp' ⇒ 'grp' set spmf"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The LCDH game itself is expressed as a function from the adversary @{term "𝒜"} to the subprobability distribution of the adversary winning.
\CryptHOL{} provides operators to express these distributions as probabilistic programs and reason about them using program logics:
\begin{itemize}
\item The ‹do› notation desugars to monadic sequencing in the monad of subprobabilities~\cite{Wadler1989}.
  Intuitively, every line ‹x ← p;› samples an element @{term x} from the distribution @{term p}.
  The sampling is independent, unless the distribution @{term p} depends on previously sampled variables.
  At the end of the block, the @{term "return_spmf DUMMY"} returns whether the adversary has won the game.
\item @{term "sample_uniform n"} denotes the uniform distribution over the set ‹{0, ..., n - 1}›.
\item @{term "order 𝒢"} denotes the order of @{term "𝒢"} and @{term [source] "([^]) :: 'grp ⇒ nat ⇒ 'grp"} is the group exponentiation operator.
\end{itemize}

The LCDH game formalizes the challenger's behavior against an adversary @{term "𝒜"}. 
In the following definition, the challenger randomly (and independently) picks two natural numbers 
@{term "x"} and @{term "y"} that are  between 0 and @{term "𝒢"}'s order and passes them to the adversary.
The adversary then returns a set @{term zs} of guesses for @{term "g ^ (x * y)"}, where @{term "g"} is the 
generator of @{term "𝒢"}. The game finally returns a @{typ bool}ean that indicates whether the 
adversary produced a right guess. Formally, @{term "game 𝒜"} is a @{typ bool}ean random variable.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>game</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp adversary ⇒ bool spmf"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"game 𝒜 = do { 
    x ← sample_uniform (order 𝒢);
    y ← sample_uniform (order 𝒢);
    zs ← 𝒜 (<span class="hidden">❙</span><span class="bold">g</span> [^] x) (<span class="hidden">❙</span><span class="bold">g</span> [^] y);
    return_spmf (<span class="hidden">❙</span><span class="bold">g</span> [^] (x * y) ∈ zs)
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹

The advantage of the adversary is equivalent to its probability of winning the LCDH game.
The function @{term [source] "spmf :: 'a spmf ⇒ 'a ⇒ real"} returns the probability of an elementary event under a given subprobability distribution.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>advantage</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp adversary ⇒ real"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"advantage 𝒜 = spmf (game 𝒜) True"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
This completes the formalisation of the LCDH game and we close the locale @{locale list_cdh} with @{command end}.
The above definitions are now accessible under the names @{term "list_cdh.game"} and @{term "list_cdh.advantage"}.
Furthermore, when we later instantiate the locale @{locale list_cdh}, they will be specialized to the given pararameters.
We will return to this topic in \S\ref{section:hashed-elgamal-scheme}.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A Random Oracle \label{section:random-oracle}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
A cryptographic oracle grants an adversary black-box access to a certain information or functionality.
In this section, we formalize a random oracle, i.e., an oracle that models a random function with a finite codomain.
In the Elgamal security proof, the random oracle represents the hash function:
the adversary can query the oracle for a value and the oracle responds with the corresponding ``hash''.

Like for the LCDH formalization, we wrap the random oracle in the locale ‹random_oracle› for modularity.
The random oracle will return a ‹bitstring›, i.e. a list of booleans, of length ‹len›.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>bitstring</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"bool list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>random_oracle</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>len</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
In \CryptHOL{}, oracles are modeled as probabilistic transition systems that given an initial state
and an input, return a subprobability distribution over the output and the successor state.
The type synonym @{typ [source] "('s, 'a, 'b) oracle'"} abbreviates @{typ "'s ⇒ 'a ⇒ ('b × 's) spmf"}.


A random oracle accepts queries of type @{typ "'a"} and generates a random bitstring of length @{term len}.
The state of the random oracle remembers its previous responses in a mapping of type @{typ [source] "'a ⇀ bitstring"}.
Upon a query @{term "x"}, the oracle first checks whether this query was received before.
If so, the oracle returns the same answer again.
Otherwise, the oracle randomly samples a bitstring of length @{term "len"}, stores it 
in its state, and returns it alongside with the new state.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>state</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇀ bitstring"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"oracle"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a state ⇒ 'a ⇒ (bitstring × 'a state) spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"oracle σ x = (case σ x of 
    None ⇒ do {
      bs ← spmf_of_set (nlists UNIV len);
      return_spmf (bs, σ(x ↦ bs)) } 
  | Some bs ⇒ return_spmf (bs, σ))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Initially, the state of a random oracle is the empty map @{term Map.empty}, as no queries have been asked.
For readability, we introduce an abbreviation:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>initial</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a state"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"initial ≡ Map.empty"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
This actually completes the formalization of the random oracle.
Before we close the locale, we prove two technical lemmas:
\begin{enumerate}
\item The lemma ‹lossless_oracle› states that the distribution over answers and successor states is \emph{lossless}, i.e., a full probability distribution.
  Many reasoning steps in game-based proofs are only valid for lossless distributions, so it is generally recommended to prove losslessness of all definitions if possible.
\item The lemma ‹fresh› describes random oracle's behavior when the query is fresh.
  This lemma makes it possible to automatically unfold the random oracle only when it is known that the query is fresh.
\end{enumerate}
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lossless_oracle</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_spmf (oracle σ x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fresh</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"oracle σ x =
   (do { bs ← spmf_of_set (nlists UNIV len);
      return_spmf (bs, σ(x ↦ bs)) })"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"σ x = None"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
\paragraph{Remark: Independence is the default.}
Note that @{typ "_ spmf"} represents a discrete probability distribution rather than a random variable.
The difference is that every spmf is independent of all other spmfs.
There is no implicit space of elementary events via which information may be passed from one random variable to the other.
If such information passing is necessary, this must be made explicit in the program.
That is why the random oracle explicitly takes a state of previous responses and returns the updated states.
Later, whenever the random oracle is used, the user must pass the state around as needed.
This also applies to adversaries that may want to store some information.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Cryptographic concepts: public-key encryption \label{section:pk-enc}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
A cryptographic concept consists of a set of operations and their functional behaviour.
We have already seen two simple examples:
the cyclic group in \S\ref{section:lcdh} and the random oracle in \S\ref{section:random-oracle}.
We have formalized both of them as locales; we have not modelled their functional behavior as this is not needed for the proof.
In this section, we now present a more realistic example: public-key encryption with oracle access.

A public-key encryption scheme consists of three algorithms: key generation, encryption, and decryption.
They are all probabilistic and, in the most general case, they may access an oracle jointly with the adversary, e.g., a random oracle modelling a hash function.
As before, the operations are modelled as parameters of a locale, ‹ind_cpa_pk›.

\begin{itemize}
\item The key generation algorithm ‹key_gen› outputs a public-private key pair.
\item The encryption operation ‹encrypt› takes a public key and a plaintext of type @{typ "'plain"} and outputs a ciphertext of type @{typ 'cipher}.
\item The decryption operation ‹decrypt› takes a private key and a ciphertext and outputs a plaintext.
\item Additionally, the predicate ‹valid_plains› tests whether the adversary has chosen a valid pair of plaintexts.
  This operation is needed only in the IND-CPA game definition in the next section, but we include it already here for convenience.
\end{itemize}
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>ind_cpa_pk</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>key_gen</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('pubkey × 'privkey, 'query, 'response) gpv"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>encrypt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'pubkey ⇒ 'plain ⇒ ('cipher, 'query, 'response) gpv"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>decrypt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'privkey ⇒ 'cipher ⇒ ('plain, 'query, 'response) gpv"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>valid_plains</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'plain ⇒ 'plain ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The three actual operations are generative probabilistic values (GPV) of type @{typ [source] "(_, 'query, 'response) gpv"}.
A GPV is a probabilistic algorithm that has not yet been connected to its oracles; see the theoretical paper @{cite Basin2017} for details.
The interface to the oracle is abstracted in the two type parameters @{typ 'query} for queries and @{typ 'response} for responses.
As before, we omit the specification of the functional behavior, namely that decrypting an encryption with a key pair returns the plaintext.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Security notions with oracles: IND-CPA security \label{section:ind-cpa}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
In general, there are several security notions for the same cryptographic concept.
For encryption schemes, an indistinguishability notion of security~\cite{Goldwasser1982} is often used.
We now formalize the notion indistinguishability under chosen plaintext attacks (IND-CPA) for public-key encryption schemes.
Goldwasser et al.~\cite{Goldwasser1984} showed that IND-CPA is equivalent to semantic security.

\begin{definition}[IND-CPA @{cite Shoup2004IACR}]
Let @{term key_gen}, @{term encrypt} and @{term decrypt} denote a public-key encryption scheme.
The IND-CPA game is a two-stage game between the \emph{adversary} and a \emph{challenger}:
\begin{description}
\item[Stage 1 (find):]
  \strut
  \begin{enumerate}
  \item The challenger generates a public key @{term pk} using @{term key_gen} and gives the public key to the adversary.
  \item The adversary returns two messages @{term "m<span class="hidden">⇩</span><sub>0</sub>"} and @{term "m<span class="hidden">⇩</span><sub>1</sub>"}.
  \item The challenger checks that the two messages are a valid pair of plaintexts.
    (For example, both messages must have the same length.)
  \end{enumerate}
\item[Stage 2 (guess):]
  \strut
  \begin{enumerate}
  \item The challenger flips a coin @{term b} (either 0 or 1) and gives @{term "encrypt pk m<span class="hidden">⇩</span><sub>b</sub>"} to the adversary.
  \item The adversary returns a bit @{term b'}.
  \end{enumerate}
\end{description}
The adversary wins the game if his guess @{term b'} is the value of @{term b}.
Let @{term "P<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>n</sub>"} denote the winning probability.
His advantage is @{term "¦P<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>n</sub> - 1/2¦ :: real"}
\end{definition}

Like with the encryption scheme, we will define the game such that the challenger and the adversary have access to a shared oracle, but the oracle is still unspecified.
Consequently, the corresponding \CryptHOL{} game is a GPV, like the operations of the abstract encryption scheme.
When we specialize the definitions in the next section to the hashed Elgamal scheme, the GPV will be connected to the random oracle.

The type of adversary is now more complicated: It is a pair of probabilistic functions with oracle access, one for each stage of the game.
The first computes the pair of plaintext messages and the second guesses the challenge bit.
The additional @{typ 'state} parameter allows the adversary to maintain state between the two stages.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'pubkey'</span><span class="delimiter">,</span><span> </span><span class="tfree">'plain'</span><span class="delimiter">,</span><span> </span><span class="tfree">'cipher'</span><span class="delimiter">,</span><span> </span><span class="tfree">'query'</span><span class="delimiter">,</span><span> </span><span class="tfree">'response'</span><span class="delimiter">,</span><span> </span><span class="tfree">'state</span><span class="delimiter">)</span><span> </span><span>adversary</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"('pubkey' ⇒ (('plain' × 'plain') × 'state, 'query', 'response') gpv)
   × ('cipher' ⇒ 'state ⇒ (bool, 'query', 'response') gpv)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The IND-CPA game formalization below follows the above informal definition.
There are three points that need some explanation.
First, this game differs from the simpler LCDH game in that it works with GPVs instead of SPMFs.
Therefore, probability distributions like coin flips @{term coin_spmf} must be lifted from SPMFs to GPVs using the coercion @{term lift_spmf}.
Second, the assertion @{term "assert_gpv (valid_plains m<span class="hidden">⇩</span><sub>0</sub> m<span class="hidden">⇩</span><sub>1</sub>)"} ensures that the pair of messages is valid.
Third, the construct @{term "TRY DUMMY ELSE DUMMY :: (_, _, _) gpv"} catches a violated assertion.
In that case, the adversary's advantage drops to 0 because the result of the game is a coin flip, as we are in the ‹ELSE› branch.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>game</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('pubkey, 'plain, 'cipher, 'query, 'response, 'state) adversary
  ⇒ (bool, 'query, 'response) gpv"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"game (𝒜<span class="hidden">⇩</span><sub>1</sub>, 𝒜<span class="hidden">⇩</span><sub>2</sub>) = TRY do {
    (pk, sk) ← key_gen;
    ((m<span class="hidden">⇩</span><sub>0</sub>, m<span class="hidden">⇩</span><sub>1</sub>), σ) ← 𝒜<span class="hidden">⇩</span><sub>1</sub> pk;
    assert_gpv (valid_plains m<span class="hidden">⇩</span><sub>0</sub> m<span class="hidden">⇩</span><sub>1</sub>);
    b ← lift_spmf coin_spmf;
    cipher ← encrypt pk (if b then m<span class="hidden">⇩</span><sub>0</sub> else m<span class="hidden">⇩</span><sub>1</sub>);
    b' ← 𝒜<span class="hidden">⇩</span><sub>2</sub> cipher σ; 
    Done (b' = b)
  } ELSE lift_spmf coin_spmf"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
\input{fig-1}

Figure~\ref{fig:1} visualizes this game as a grey box.
The dashed boxes represent parameters of the game or the locale, i.e., parts that have not yet been instantiated.
The actual probabilistic program is shown on the left half, which uses the dashed boxes as sub-programs.
Arrows in the grey box from the left to the right pass the contents of the variables to the sub-program.
Those in the other direction bind the result of the sub-program to new variables.
The arrows leaving box indicate the query-response interaction with an oracle.
The thick arrows emphasize that the adversary's state is passed around explicitly.
The double arrow represents the return value of the game.
We will use this to define the adversary's advantage.

As the oracle is not specified in the game, the advantage, too, is parametrized by the oracle,
given by the transition function @{term [source] "oracle :: ('s, 'query, 'response) oracle'"}
and the initial state @{term [source] "σ :: 's"} its initial state.
The operator @{term "run_gpv"} connects the game with the oracle, whereby the GPV becomes an SPMF.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>advantage</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('σ, 'query, 'response) oracle' × 'σ
  ⇒ ('pubkey, 'plain, 'cipher, 'query, 'response, 'state) adversary ⇒ real"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"advantage (oracle, σ) 𝒜 = ¦spmf (run_gpv oracle (game 𝒜) σ) True - 1/2¦"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Concrete cryptographic constructions: the hashed ElGamal encryption scheme \label{section:hashed-elgamal-scheme}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
With all the above modelling definitions in place,
we are now ready to explain how concrete cryptographic constructions are expressed in \CryptHOL.
In general, a cryptographic construction builds a cryptographic concept from possibly several simpler cryptographic concepts.
In the running example, the hashed ElGamal cipher~\cite{Elgamal1985} constructs a public-key encryption scheme from a finite cyclic group and a hash function.
Accordingly, the formalisation consists of three steps:

\begin{enumerate}
\item Import the cryptographic concepts on which the construction builds.
\item Define the concrete construction.
\item Instantiate the abstract concepts with the construction.
\end{enumerate}

First, we declare a new locale that imports the two building blocks: 
the cyclic group from the LCDH game with namespace ‹lcdh› and the random oracle for the hash function with namespace ‹ro›.
This ensures that the construction can be used for arbitrary cyclic groups. 
For the message space, it suffices to fix the length ‹len_plain› of the plaintexts.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>hashed_elgamal</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>lcdh</span><span class="delimiter">:</span><span> </span><span>list_cdh</span><span> </span><span>𝒢</span><span> </span><span class="delimiter">+</span><span> 
</span><span>  </span><span>ro</span><span class="delimiter">:</span><span> </span><span>random_oracle</span><span> </span><span>len_plain</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>𝒢</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp cyclic_group"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>len_plain</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Second, we formalize the hashed ElGamal encryption scheme.
Here is the well-known informal definition.

\begin{definition}[Hashed Elgamal encryption scheme]
Let $G$ be a cyclic group of order $q$ that has a generator $g$. Furthermore, let $h$ be a hash
function that maps the elements of $G$ to bitstrings, and $\oplus$ be the xor operator on
bitstrings. The Hashed-ElGamal encryption scheme is given by the following algorithms:
\begin{description}
\item[Key generation]
  Pick an element $x$ randomly from the set $\{0, \dots, q-1\}$
  and output the pair $(g^x, x)$, where $g^x$ is the public key and $x$ is the private key.
\item[Encryption]
  Given the public key $pk$ and the message $m$,
  pick $y$ randomly from the set $\{0, \dots, q-1\}$
  and output the pair $(g^y, h(pk^y) \oplus m)$.
  Here $\oplus$ denotes the bitwise exclusive-or of two bitstrings.
\item[Decryption]
  Given the private key $sk$ and the ciphertext $(\alpha, \beta)$,
  output $h(\alpha^{sk}) \oplus \beta$.
\end{description}
\end{definition}

As we can see, the public key is a group element, the private key a natural number, a plaintext a bitstring, and a ciphertext a pair of a group element and a bitstring.%
\footnote{%
  More precisely, the private key ranges between 0 and $q - 1$ and the bitstrings are of length ‹len_plain›.
  However, Isabelle/HOL's type system cannot express such properties that depend on locale parameters.
}
For readability, we introduce meaningful abbreviations for these concepts.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'grp'</span><span> </span><span>pub_key</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp'"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'grp'</span><span> </span><span>priv_key</span><span> </span><span class="delimiter">=</span><span> </span><span>nat</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>plain</span><span> </span><span class="delimiter">=</span><span> </span><span>bitstring</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'grp'</span><span> </span><span>cipher</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp' × bitstring"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
We next translate the three algorithms into \CryptHOL{} definitions.
The definitions are straightforward except for the hashing.
Since we analyze the security in the random oracle model, 
an application of the hash function $H$ is modelled as a query to the random oracle using the GPV @{term hash}.
Here, @{term "Pause x Done"} calls the oracle with query @{term x} and returns the oracle's response.
Furthermore, we define the plaintext validity predicate to check the length of the adversary's messages produced by the adversary.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>hash</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp ⇒ (bitstring, 'grp, bitstring) gpv"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash x ≡ Pause x Done"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>key_gen</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('grp pub_key × 'grp priv_key) spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"key_gen = do {
    x ← sample_uniform (order 𝒢);
    return_spmf (<span class="hidden">❙</span><span class="bold">g</span> [^] x, x)
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>encrypt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp pub_key ⇒ plain ⇒ ('grp cipher, 'grp, bitstring) gpv"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"encrypt α msg = do {
    y ← lift_spmf (sample_uniform (order 𝒢));
    h ← hash (α [^] y);
    Done (<span class="hidden">❙</span><span class="bold">g</span> [^] y, h [⊕] msg)
  }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>decrypt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp priv_key ⇒ 'grp cipher ⇒ (plain, 'grp, bitstring) gpv"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"decrypt x = (λ(β, ζ). do {
    h ← hash (β [^] x);
    Done (ζ [⊕] h)
  })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>valid_plains</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"plain ⇒ plain ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"valid_plains msg1 msg2 ⟷ length msg1 = len_plain ∧ length msg2 = len_plain"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
The third and last step instantiates the interface of the encryption scheme with the hashed Elgamal scheme.
This specializes all definition and theorems in the locale @{locale ind_cpa_pk} to our scheme.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>ind_cpa</span><span class="delimiter">:</span><span> </span><span>ind_cpa_pk</span><span> </span><span class="string"><span class="delete"><span class="delete">"(lift_spmf key_gen)"</span></span></span><span> </span><span>encrypt</span><span> </span><span>decrypt</span><span> </span><span>valid_plains</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Figure~\ref{fig:2} illustrates the instantiation.
In comparison to Fig.~\ref{fig:1}, the boxes for the key generation and the encryption algorithm have been instantiated with the hashed Elgamal definitions from this section.
We nevertheless draw the boxes to indicate that the definitions of these algorithms has not yet been inlined in the game definition.
The thick grey border around the key generation algorithm denotes the @{term lift_spmf} operator, which embeds the probabilistic @{term key_gen} without oracle access into the type of GPVs with oracle access.
The oracle has also been instantiated with the random oracle @{term ro.oracle} imported from @{locale "hashed_elgamal"}'s parent locale @{locale random_oracle} with prefix ‹ro›.

\input{fig-2}
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Cryptographic proofs in \CryptHOL{}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
This section explains how cryptographic proofs are expressed in \CryptHOL{}.
We will continue our running example by stating and proving the IND-CPA security of the hashed Elgamal encryption scheme
under the computational Diffie-Hellman assumption in the random oracle model, using the definitions from the previous section.
More precisely, we will formalize a reduction argument (\S\ref{section:reduction}) and bound the IND-CPA advantage using the CDH advantage.
We will \emph{not} formally state the result that CDH hardness in the cyclic group implies IND-CPA security, 
which quantifies over all feasible adversaries--%
to that end, we would have to formally define feasibility, for which \CryptHOL{} currently does not offer any support.

The actual proof of the bound consists of several game transformations.
We will focus on those steps that illustrate common steps in cryptographic proofs (\S\ref{section:ghop-first}--\S\ref{section:combining:hops}) .
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The reduction \label{section:reduction}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The security proof involves a reduction argument:
We will derive a bound on the advantage of an arbitrary adversary in the IND-CPA game @{term "ind_cpa.game"} for hashed Elgamal
that depends on another adversary's advantage in the LCDH game @{term "lcdh.game"} of the underlying group.
The reduction transforms every IND-CPA adversary @{term "𝒜"} into a LCDH adversary @{term "elgamal_reduction 𝒜"},
using @{term "𝒜"} as a black box.
In more detail, it simulates an execution of the IND-CPA game including the random oracle.
At the end of the game, the reduction outputs the set of queries that the adversary has sent to the random oracle.
The reduction works as follows given a two part IND-CPA adversary @{term "𝒜 = (𝒜<span class="hidden">⇩</span><sub>1</sub>, 𝒜<span class="hidden">⇩</span><sub>2</sub>)"}
(Figure~\ref{fig:3} visualizes the reduction as the dotted box):
\begin{enumerate}
\item It receives two group elements @{term "α"} and @{term "β"} from the LCDH challenger.
\item The reduction passes @{term "α"} to the adversary as the public key and runs @{term "𝒜<span class="hidden">⇩</span><sub>1</sub>"} to get messages @{term "m<span class="hidden">⇩</span><sub>1</sub>"} and @{term "m<span class="hidden">⇩</span><sub>2</sub>"}.
  The adversary is given access to the random oracle with the initial state @{term ro.initial}.
\item The assertion checks that the adversary returns two valid plaintexts, i.e., @{term m<span class="hidden">⇩</span><sub>1</sub>} and @{term m<span class="hidden">⇩</span><sub>2</sub>} are strings of length @{term len_plain}.
\item Instead of actually performing an encryption, the reduction generates a random bitstring @{term h} of length @{term len_plain} 
(@{term "nlists UNIV len_plain"} denotes the set of all bitstrings of length @{term len_plain} and
@{term spmf_of_set} converts the set into a uniform distribution over the set.)
\item The reduction passes @{term "(β, h)"} as the challenge ciphertext to the adversary in the second phase of the IND-CPA game.
\item The actual guess @{term b'} of the adversary is ignored; 
  instead the reduction returns the set @{term "dom s'"} of all queries that the adversary made to the random oracle as its guess for the CDH game.
\item If any of the steps after the first phase fails, the reduction's guess is the set @{term "dom s"} of oracle queries made during the first phase.
\end{enumerate}

\input{fig-3}
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>elgamal_reduction</span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('grp pub_key, plain, 'grp cipher, 'grp, bitstring, 'state) ind_cpa.adversary
  ⇒ 'grp lcdh.adversary"</span></span></span><span>                     
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"elgamal_reduction (𝒜<span class="hidden">⇩</span><sub>1</sub>, 𝒜<span class="hidden">⇩</span><sub>2</sub>) α β = do {
    (((m<span class="hidden">⇩</span><sub>1</sub>, m<span class="hidden">⇩</span><sub>2</sub>), σ), s) ← exec_gpv ro.oracle (𝒜<span class="hidden">⇩</span><sub>1</sub> α) ro.initial;
    TRY do {
      _ :: unit ← assert_spmf (valid_plains m<span class="hidden">⇩</span><sub>1</sub> m<span class="hidden">⇩</span><sub>2</sub>);
      h ← spmf_of_set (nlists UNIV len_plain);
      (b', s') ← exec_gpv ro.oracle (𝒜<span class="hidden">⇩</span><sub>2</sub> (β, h) σ) s;
      return_spmf (dom s')
    } ELSE return_spmf (dom s)
  }"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Concrete security statement \label{section:security:concrete}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
A concrete security statement in \CryptHOL{} has the form:
Subject to some side conditions for the adversary @{term 𝒜}, the advantage in one game is bounded
by a function of the transformed adversary's advantage in a different game.%
\footnote{%
  A security proof often involves several reductions.
  The bound then depends on several advantages, one for each reduction.
}
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>concrete_security</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"side conditions for 𝒜"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"advantage<span class="hidden">⇩</span><sub>1</sub> 𝒜 ≤ f (advantage<span class="hidden">⇩</span><sub>2</sub> (reduction 𝒜))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">oops</span></span><span> </span><span class="delimiter">%</span><span>invisible</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
For the hashed Elgamal scheme, the theorem looks as follows, i.e., the function @{term f} is the identity function.
›</span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="delimiter">%</span><span>invisible</span><span> </span><span class="comment">― ‹These six lines allow us to show the concrete theorem statement before we define the side condition on 𝒜. They should not occur in a normal formalisation.›</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="delimiter">%</span><span>invisible</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span> 
</span><span class="keyword1"><span class="command">local_setup</span></span><span> </span><span class="delimiter">%</span><span>invisible</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Local_Theory.map_background_naming (Name_Space.mandatory_path "ind_cpa")›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">%</span><span>invisible</span><span> </span><span>lossless</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless = undefined"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="delimiter">%</span><span>invisible</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="delimiter">%</span><span>invisible</span><span> </span><span>hashed_elgamal</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>concrete_security_elgamal</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>lossless</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ind_cpa.lossless 𝒜"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ind_cpa.advantage (ro.oracle, ro.initial) 𝒜 ≤ lcdh.advantage (elgamal_reduction 𝒜)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">oops</span></span><span class="delimiter">%</span><span>invisible</span><span> </span><span class="comment">― ‹This aborts the proof as we have not yet defined @{term ind_cpa.lossless} properly. We restate the theorem below properly.›</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Such a statement captures the essence of a concrete security proof.
For if there was a feasible adversary @{term 𝒜} with non-negligible advantage against the @{term ind_cpa.game},
then @{term "elgamal_reduction 𝒜"} would be an adversary against the @{term lcdh.game} with at least the same advantage.
This implies the existence of an adversary with non-negligible advantage against the cryptographic primitive that was assumed to be secure.
What we cannot state formally is that the transformed adversary @{term "elgamal_reduction 𝒜"} is feasible
as we have not formalized the notion of feasibility.
The readers of the formalization must convince themselves that the reduction preserves feasibility.

In the case of @{term elgamal_reduction}, this should be obvious from the definition (given the theorem's side condition)
as the reduction does nothing more than sampling and redirecting data.

Our proof for the concrete security theorem needs the side condition that the adversary is lossless.
Losslessness for adversaries is similar to losslessness for subprobability distributions.
It ensures that the adversary always terminates and returns an answer to the challenger.
For the IND-CPA game, we define losslessness as follows:
›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>ind_cpa_pk</span><span class="delimiter">)</span><span> </span><span>lossless</span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('pubkey, 'plain, 'cipher, 'query, 'response, 'state) adversary ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lossless = (λ(𝒜<span class="hidden">⇩</span><sub>1</sub>, 𝒜<span class="hidden">⇩</span><sub>2</sub>). (∀pk. lossless_gpv ℐ_full (𝒜<span class="hidden">⇩</span><sub>1</sub> pk)) 
               ∧ (∀cipher σ. lossless_gpv ℐ_full (𝒜<span class="hidden">⇩</span><sub>2</sub> cipher σ)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="delimiter">%</span><span>invisible</span><span> </span><span>concrete_security_elgamal</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>lossless</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ind_cpa.lossless 𝒜"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ind_cpa.advantage (ro.oracle, ro.initial) 𝒜 ≤ lcdh.advantage (elgamal_reduction 𝒜)"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="delimiter">%</span><span>visible</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
So now let's start with the proof.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">%</span><span>visible</span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="delimiter">%</span><span>invisible</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    For this proof, we configure Isabelle's simplifier such that the proofs become reasonably short.
    Initially, when writing the proof, we had added those lemmas manually to to invocation
    of the simplifier and then collected the useful rules in a polishing step.
  ›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">%</span><span>invisible</span><span> </span><span class="delimiter">[</span><span>cong</span><span> </span><span>del</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>if_weak_cong</span><span> 
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">[</span><span>split</span><span> </span><span>del</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>if_split</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>map_lift_spmf</span><span> </span><span>gpv.map_id</span><span> </span><span>lossless_weight_spmfD</span><span> </span><span>map_spmf_bind_spmf</span><span> </span><span>bind_spmf_const</span><span> </span><span>lcdh.order_gt_0</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">[</span><span>if_distribs</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>if_distrib</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λx. try_spmf x _"</span></span></span><span class="delimiter">]</span><span> </span><span>if_distrib</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"weight_spmf"</span></span></span><span class="delimiter">]</span><span> </span><span>if_distrib</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λr. scale_spmf r _"</span></span></span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="delimiter">%</span><span>visible</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
As a preparatory step, we split the adversary @{term "𝒜"} into its two phases @{term "𝒜<span class="hidden">⇩</span><sub>1</sub>"} and @{term "𝒜<span class="hidden">⇩</span><sub>2</sub>"}.
We could have made the two phases explicit in the theorem statement, but our form is easier to read and use.
We also immediately decompose the losslessness assumption on @{term "𝒜"}.%
\footnote{%
  Later in the proof, we will often prove losslessness of the definitions in the proof.
  We will not show them in this document, but they are in the Isabelle sources from which this document is generated.
}
›</span></span></span><span>
</span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>𝒜<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>𝒜<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>𝒜</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒜 = (𝒜<span class="hidden">⇩</span><sub>1</sub>, 𝒜<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒜"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">from</span></span><span> </span><span>lossless</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lossless1</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀pk. lossless_gpv ℐ_full (𝒜<span class="hidden">⇩</span><sub>1</sub> pk)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lossless2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀σ cipher. lossless_gpv ℐ_full (𝒜<span class="hidden">⇩</span><sub>2</sub> σ cipher)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ind_cpa.lossless_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Recording adversary queries \label{section:ghop-first}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  As can be seen in Fig.~\ref{fig:2}, both the adversary and the encryption of the challenge ciphertext use the random oracle.
  The reduction, however, returns only the queries that the adversary makes to the oracle (in Fig.~\ref{fig:3}, $h$ is generated independently of the random oracle).
  To bridge this gap, we introduce an @{term interceptor} between the adversary and the oracle that records all adversary's queries.
›</span></span></span><span>
</span><span class="keyword3"><span class="command">define</span></span><span> </span><span>interceptor</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp set ⇒ 'grp ⇒ (bitstring × 'grp set, _, _) gpv"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"interceptor σ x = (do {
    h ← hash x;
    Done (h, insert x σ)
  })"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>σ</span><span> </span><span>x</span><span>
</span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">%</span><span>invisible</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_gpv ℐ_full (interceptor σ x)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>σ</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>interceptor_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">%</span><span>invisible</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_gpv ℐ_full (inline interceptor (𝒜<span class="hidden">⇩</span><sub>1</sub> α) s)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>α</span><span> </span><span>s</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>lossless_inline</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ℐ</span><span class="delimiter">=</span><span>ℐ_full</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">%</span><span>invisible</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_gpv ℐ_full (inline interceptor (𝒜<span class="hidden">⇩</span><sub>2</sub> σ c) s)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>σ</span><span> </span><span>c</span><span> </span><span>s</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>lossless_inline</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ℐ</span><span class="delimiter">=</span><span>ℐ_full</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  We integrate this interceptor into the @{term "ind_cpa.game"} using the @{term "inline"} function as illustrated in Fig.~\ref{fig:4}
  and name the result @{term "game<span class="hidden">⇩</span><sub>0</sub>"}.

\input{fig-4}
›</span></span></span><span>
</span><span>
</span><span class="keyword3"><span class="command">define</span></span><span> </span><span>game<span class="hidden">⇩</span><sub>0</sub></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"game<span class="hidden">⇩</span><sub>0</sub> = TRY do {
  (pk, _) ← lift_spmf key_gen;
  (((m<span class="hidden">⇩</span><sub>1</sub>, m<span class="hidden">⇩</span><sub>2</sub>), σ), s) ← inline interceptor (𝒜<span class="hidden">⇩</span><sub>1</sub> pk) {};
  assert_gpv (valid_plains m<span class="hidden">⇩</span><sub>1</sub> m<span class="hidden">⇩</span><sub>2</sub>);
  b ← lift_spmf coin_spmf;
  c ← encrypt pk (if b then m<span class="hidden">⇩</span><sub>1</sub> else m<span class="hidden">⇩</span><sub>2</sub>);
  (b', s') ← inline interceptor (𝒜<span class="hidden">⇩</span><sub>2</sub> c σ) s;
  Done (b' = b)
} ELSE lift_spmf coin_spmf"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
We claim that the above modifications do not affect the output of the IND-CPA game at all.
This might seem obvious since we are only logging the adversary's queries without modifying them.
However, in a formal proof, this needs to be precisely justified.

More precisely, we have been very careful that the two games @{term "ind_cpa.game 𝒜"} and 
@{term game<span class="hidden">⇩</span><sub>0</sub>} have identical structure. They differ only in that @{term game<span class="hidden">⇩</span><sub>0</sub>} uses the adversary
@{term "(λpk. inline interceptor (𝒜<span class="hidden">⇩</span><sub>1</sub> pk) {}, λcipher σ. inline interceptor (𝒜<span class="hidden">⇩</span><sub>2</sub> cipher σ))"}
instead of @{term "𝒜"}. The formal justification for this replacement happens in two steps:
\begin{enumerate}
\item We replace the oracle transformer @{term interceptor} with @{term id_oracle}, which merely passes queries and results to the oracle.
\item Inlining the identity oracle transformer @{term id_oracle} does not change an adversary and can therefore be dropped.
\end{enumerate}

The first step is automated using Isabelle's Transfer package~\cite{Huffman2013},
which is based on Mitchell's representation independence~\cite{Mitchell1986}.
The replacement is controlled by so-called transfer rules of the form @{term "R x y"} which
indicates that @{term x} shall replace @{term y}; the correspondence relation @{term R} captures the 
kind of replacement.
The @{method transfer} proof method then constructs a constraint system with one constraint
for each atom in the proof goal where the correspondence relation and the replacement are unknown.
It then tries to solve the constraint system using the rules that have been declared with 
the attribute ‹[transfer_rule]›.
Atoms that do not have a suitable transfer rule are not changed and their correspondence relation is
instantiated with the identity relation @{term "(=)"}.

The second step is automated using Isabelle's simplifier.  

In the example, the crucial change happens in the state of the oracle transformer:
@{term interceptor} records all queries in a set whereas @{term id_oracle} has no state, which 
is modelled with the singleton type @{typ unit}.
To capture the change, we define the correspondence relation @{term cr} on the states of the oracle transformers.
(As we are in the process of adding this state, this state is irrelevant and @{term cr} is therefore always true.
We nevertheless have to make an explicit definition such that Isabelle does not automatically beta-reduce terms, which would confuse @{method transfer}.) 
We then prove that it relates the initial states and that @{term cr} is a bisimulation relation
for the two oracle transformers; see @{cite Basin2017} for details.
The bisimulation proof itself is automated, too: A bit of term rewriting (@{command "unfolding"}) 
makes the two oracle transformers structurally identical except for the state update function.
Having proved that the state update function @{term "λ_ σ. σ"} is a correct replacement for
@{term "insert"} w.r.t. @{term cr}, the @{method transfer_prover} then lifts this replacement
to the bisimulation rule.
Here, @{method transfer_prover} is similar to @{method transfer} except that it works only for
transfer rules and builds the constraint system only for the term to be replaced.

The theory source of this tutorial contains a step-by-step proof to illustrate how transfer works.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>cr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"unit ⇒ 'grp set ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cr σ σ' = True"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>σ</span><span> </span><span>σ'</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cr () {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cr_def</span><span class="delimiter">)</span><span> </span><span class="comment">― ‹initial states›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"((=) ===&gt; cr ===&gt; cr) (λ_ σ. σ) insert"</span></span></span><span> </span><span class="comment">― ‹state update›</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_fun_def</span><span> </span><span>cr_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="comment">― ‹@{term cr} is a bisimulation for the oracle transformers›</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(cr ===&gt; (=) ===&gt; rel_gpv (rel_prod (=) cr) (=)) id_oracle interceptor"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>interceptor_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>id_oracle_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>bind_gpv_Pause</span><span> </span><span>bind_rpv_Done</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer_prover</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ind_cpa.game 𝒜 = game<span class="hidden">⇩</span><sub>0</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>game<span class="hidden">⇩</span><sub>0</sub>_def</span><span> </span><span>𝒜</span><span> </span><span>ind_cpa.game.simps</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bind_map_gpv</span><span> </span><span>o_def</span><span> </span><span>ind_cpa.game.simps</span><span> </span><span>split_def</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">%</span><span>invisible</span><span> </span><span>ind_cpa_game_eq_game<span class="hidden">⇩</span><sub>0</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>
</span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="delimiter">%</span><span> </span><span>invisible</span><span> </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹And now the same proof again, but step by step.›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>cr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"unit ⇒ 'grp set ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cr σ σ' = True"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>σ</span><span> </span><span>σ'</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cr () {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cr_def</span><span class="delimiter">)</span><span> </span><span class="comment">― ‹initial states›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"((=) ===&gt; cr ===&gt; cr) (λ_ σ. σ) insert"</span></span></span><span> </span><span class="comment">― ‹state update›</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_fun_def</span><span> </span><span>cr_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="comment">― ‹@{term cr} is a bisimulation for the oracle transformers›</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(cr ===&gt; (=) ===&gt; rel_gpv (rel_prod (=) cr) (=)) id_oracle interceptor"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹1. Unfold the definitions of the oracle transformers and massage them to have the same structure.›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>interceptor_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>id_oracle_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>bind_gpv_Pause</span><span> </span><span>bind_rpv_Done</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹2. Build the constraint system for the second argument of the correspondence relation, namely @{term interceptor} with the rewrite rules applied.›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer_prover_start</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹3. Solve the constraint system prolog-style by resolving with the rules from @{thm [source] transfer_raw}.›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer_step</span><span> </span><span class="comment">― ‹This step uses the state update transfer rule proven in the previous @{command have}.›</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer_step</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer_step</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer_step</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹4. Check that the found solution is the expected one, namely the first argument of the correspondence relation, here @{term id_oracle} with the rewrite rules applied.›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer_prover_end</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ind_cpa.game 𝒜 = game<span class="hidden">⇩</span><sub>0</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹1. Unfold the definitions›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>game<span class="hidden">⇩</span><sub>0</sub>_def</span><span> </span><span>𝒜</span><span> </span><span>ind_cpa.game.simps</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹2. Build the constraint system for the whole subgoal. The ‹fixing› tells transfer
      that it must not replace the variables @{term "𝒢"}, @{term "len_plain"}, @{term "𝒜<span class="hidden">⇩</span><sub>1</sub>"} and @{term "𝒜<span class="hidden">⇩</span><sub>2</sub>"}.›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer_start</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹3. Solve all constraints with the transfer rules›</span></span></span><span>
</span><span>                        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer_step</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer_end</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹4. Get rid of the identity oracle transformer @{term id_oracle} by rewriting. Really curious readers may dare to look at the simplifer trace.›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>simp_trace_new</span><span> </span><span>mode</span><span class="delimiter">=</span><span>full</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bind_map_gpv</span><span> </span><span>o_def</span><span> </span><span>ind_cpa.game.simps</span><span> </span><span>split_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="delimiter">%</span><span>visible</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Equational program transformations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Before we move on, we need to simplify @{term game<span class="hidden">⇩</span><sub>0</sub>} and inline a few of the definitions.
All these simplifications are equational program transformations, so the Isabelle simplifier can justify them.
We combine the @{term interceptor} with the random oracle @{term ro.oracle} into a new oracle @{term oracle'} 
with which the adversary interacts.
›</span></span></span><span>
</span><span class="keyword3"><span class="command">define</span></span><span> </span><span>oracle'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'grp set × ('grp ⇀ bitstring) ⇒ 'grp ⇒ _"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"oracle' = (λ(s, σ) x. do {
  (h, σ') ← case σ x of
      None ⇒ do {
          bs ← spmf_of_set (nlists UNIV len_plain);
          return_spmf (bs, σ(x ↦ bs)) }
    | Some bs ⇒ return_spmf (bs, σ);
  return_spmf (h, insert x s, σ')
})"</span></span></span><span>
</span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">%</span><span>invisible</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_spmf (oracle' s plain)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>plain</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle'_def</span><span> </span><span>Let_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.split</span><span> </span><span>option.split</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">%</span><span>invisible</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_spmf (exec_gpv oracle' (𝒜<span class="hidden">⇩</span><sub>1</sub> α) s)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>α</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>lossless_exec_gpv</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ℐ</span><span class="delimiter">=</span><span>ℐ_full</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">%</span><span>invisible</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lossless_spmf (exec_gpv oracle' (𝒜<span class="hidden">⇩</span><sub>2</sub> σ cipher) s)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>σ</span><span> </span><span>cipher</span><span> </span><span>s</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>lossless_exec_gpv</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ℐ</span><span class="delimiter">=</span><span>ℐ_full</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"exec_gpv ro.oracle (inline interceptor 𝒜 s) σ = 
  map_spmf (λ(a, b, c). ((a, b), c)) (exec_gpv oracle' 𝒜 (s, σ))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>𝒜</span><span> </span><span>σ</span><span> </span><span>s</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>interceptor_def</span><span> </span><span>oracle'_def</span><span> </span><span>ro.oracle_def</span><span> </span><span>Let_def</span><span> 
</span><span>     </span><span>exec_gpv_inline</span><span> </span><span>exec_gpv_bind</span><span> </span><span>o_def</span><span> </span><span>split_def</span><span> </span><span>cong</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>option.case_cong_weak</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
We also want to inline the key generation and encryption algorithms,
push the @{term "TRY DUMMY ELSE DUMMY :: (_, _, _) gpv"} towards the assertion (which is possible because the adversary is lossless by assumption),
and rearrange the samplings a bit.
The latter is automated using ‹monad_normalisation›~\cite{Schneider2017}.%
\footnote{%
  The tool ‹monad_normalisation› augments Isabelle's simplifier with a normalization procedure for commutative monads based on higher-order ordered rewriting.
  It can also commute across control structures like ‹if› and ‹case›.
  Although it is not complete as a decision procedure (as the normal forms are not unique), it usually works in practice.
}
›</span></span></span><span>
</span><span class="keyword1"><span class="command">have</span></span><span> </span><span>game<span class="hidden">⇩</span><sub>0</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"run_gpv ro.oracle game<span class="hidden">⇩</span><sub>0</sub> ro.initial = do {
  x ← sample_uniform (order 𝒢);
  y ← sample_uniform (order 𝒢);
  b ← coin_spmf;
  (((msg1, msg2), σ), (s, s_h)) ←
    exec_gpv oracle' (𝒜<span class="hidden">⇩</span><sub>1</sub> (<span class="hidden">❙</span><span class="bold">g</span> [^] x)) ({}, ro.initial);
  TRY do {
    _ :: unit ← assert_spmf (valid_plains msg1 msg2);
    (h, s_h') ← ro.oracle s_h (<span class="hidden">❙</span><span class="bold">g</span> [^] (x * y));
    let cipher = (<span class="hidden">❙</span><span class="bold">g</span> [^] y, h [⊕] (if b then msg1 else msg2));
    (b', (s', s_h'')) ← exec_gpv oracle' (𝒜<span class="hidden">⇩</span><sub>2</sub> cipher σ) (s, s_h');
    return_spmf (b' = b)
  } ELSE do {
    b ← coin_spmf;
    return_spmf b
  }
}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">including</span></span><span> </span><span>monad_normalisation</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>game<span class="hidden">⇩</span><sub>0</sub>_def</span><span> </span><span>key_gen_def</span><span> </span><span>encrypt_def</span><span> </span><span>*</span><span> </span><span>exec_gpv_bind</span><span> </span><span>bind_map_spmf</span><span> </span><span>assert_spmf_def</span><span>
</span><span>    </span><span>try_bind_assert_gpv</span><span> </span><span>try_gpv_bind_lossless</span><span> </span><span>split_def</span><span> </span><span>o_def</span><span> </span><span>if_distribs</span><span> </span><span>lcdh.nat_pow_pow</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
This call to Isabelle's simplifier may look complicated at first, but it can be constructed incrementally 
by adding a few theorems and looking at the resulting goal state and searching for suitable theorems using @{command find_theorems}.
As always in Isabelle, some intuition and knowledge about the library of lemmas is crucial. 
\begin{itemize}
\item We knew that the definitions @{thm [source] game<span class="hidden">⇩</span><sub>0</sub>_def}, @{thm [source] key_gen_def}, and @{thm [source] encrypt_def} should be unfolded,
  so they are added first to the simplifier's set of rewrite rules.
\item The equations @{thm [source] exec_gpv_bind}, @{thm [source] try_bind_assert_gpv}, and @{thm [source] try_gpv_bind_lossless}
  ensure that the operator @{term exec_gpv}, which connects the @{term game<span class="hidden">⇩</span><sub>0</sub>} with the random oracle, is distributed over the sequencing.
  Together with @{thm [source] * }, this gives the adversary access to @{term oracle'} instead of the interceptor and the random oracle, 
  and makes the call to the random oracle in the encryption of the chosen message explicit.
\item The theorem @{thm [source] lcdh.nat_pow_pow} rewrites the iterated exponentiation @{term "(<span class="hidden">❙</span><span class="bold">g</span> [^] x) [^] y"} to @{term "<span class="hidden">❙</span><span class="bold">g</span> [^] (x * y)"}.
\item The other theorems @{thm [source] bind_map_spmf}, @{thm [source] assert_spmf_def},
  @{thm [source] split_def}, @{thm [source] o_def}, and @{thm [source] if_distribs}
  take care of all the boilerplate code that makes all these transformations type-correct.
  These theorems often have to be used together.
\end{itemize}

Note that the state of the oracle @{term oracle'} is changed between @{term "𝒜<span class="hidden">⇩</span><sub>1</sub>"} and @{term "𝒜<span class="hidden">⇩</span><sub>2</sub>"}.
Namely, the random oracle's part @{term s_h} may change when the chosen message is encrypted,
but the state that records the adversary's queries @{term s} is passed on unchanged.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹\input{fig-5}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Capturing a failure event›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Suppose that two games behave the same except when a so-called failure event occurs @{cite Shoup2004IACR}.
Then the chance of an adversary distinguishing the two games is bounded by the probability of the failure event.
In other words, the simulation of the reduction is allowed to break if the failure event occurs.
In the running example, such an argument is a key step to derive the bound on the adversary's advantage.
But to reason about failure events, we must first introduce them into the games we consider.
This is because in \CryptHOL{}, the probabilistic programs describe probability distributions over what they return (@{term return_spmf}).
The variables that are used internally in the program are not accessible from the outside,
i.e., there is no memory to which these are written.
This has the advantage that we never have to worry about the names of the variables, e.g., to avoid clashes.
The drawback is that we must explicitly introduce all the events that we are interested in.

Introducing a failure event into a game is straightforward.
So far, the games @{term ind_cpa.game} and @{term game<span class="hidden">⇩</span><sub>0</sub>} simply denoted the probability distribution of whether the adversary has guessed right.
For hashed Elgamal, the simulation breaks if the adversary queries the random oracle with the same query @{term "<span class="hidden">❙</span><span class="bold">g</span> [^] (x * y)"} that is used for encrypting the chosen message ‹m<span class="hidden">⇩</span><sub>b</sub>›.
So we simply change the return type of the game to return whether the adversary guessed right \emph{and} whether the failure event has occurred.
The next definition @{term game<span class="hidden">⇩</span><sub>1</sub>} does so.
(Recall that @{term oracle'} stores in its first state component @{term s} the queries by the adversary.)
In preparation of the next reasoning step, we also split off the first two samplings, namely of @{term x} and @{term y}, and make them parameters of @{term game<span class="hidden">⇩</span><sub>1</sub>}.
›</span></span></span><span>
</span><span class="keyword3"><span class="command">define</span></span><span> </span><span>game<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat ⇒ (bool × bool) spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game<span class="hidden">⇩</span><sub>1</sub> x y = do {
  b ← coin_spmf;
  (((m<span class="hidden">⇩</span><sub>1</sub>, m<span class="hidden">⇩</span><sub>2</sub>), σ), (s, s_h)) ← exec_gpv oracle' (𝒜<span class="hidden">⇩</span><sub>1</sub> (<span class="hidden">❙</span><span class="bold">g</span> [^] x)) ({}, ro.initial);
  TRY do {
    _ :: unit ← assert_spmf (valid_plains m<span class="hidden">⇩</span><sub>1</sub> m<span class="hidden">⇩</span><sub>2</sub>);
    (h, s_h') ← ro.oracle s_h (<span class="hidden">❙</span><span class="bold">g</span> [^] (x * y));
    let c = (<span class="hidden">❙</span><span class="bold">g</span> [^] y, h [⊕] (if b then m<span class="hidden">⇩</span><sub>1</sub> else m<span class="hidden">⇩</span><sub>2</sub>));
    (b', (s', s_h'')) ← exec_gpv oracle' (𝒜<span class="hidden">⇩</span><sub>2</sub> c σ) (s, s_h');
    return_spmf (b' = b, <span class="hidden">❙</span><span class="bold">g</span> [^] (x * y) ∈ s')
  } ELSE do {
    b ← coin_spmf;
    return_spmf (b, <span class="hidden">❙</span><span class="bold">g</span> [^] (x * y) ∈ s)
  }
}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
It is easy to prove that @{term game<span class="hidden">⇩</span><sub>0</sub>} combined with the random oracle is a projection of @{term game<span class="hidden">⇩</span><sub>1</sub>} with the sampling added, as formalized in ‹game<span class="hidden">⇩</span><sub>0</sub>_game<span class="hidden">⇩</span><sub>1</sub>›.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?sample</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λf :: nat ⇒ nat ⇒ _ spmf. do {
   x ← sample_uniform (order 𝒢);
   y ← sample_uniform (order 𝒢);
   f x y }"</span></span></span><span>
</span><span class="keyword1"><span class="command">have</span></span><span> </span><span>game<span class="hidden">⇩</span><sub>0</sub>_game<span class="hidden">⇩</span><sub>1</sub></span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"run_gpv ro.oracle game<span class="hidden">⇩</span><sub>0</sub> ro.initial = map_spmf fst (?sample game<span class="hidden">⇩</span><sub>1</sub>)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>game<span class="hidden">⇩</span><sub>0</sub></span><span> </span><span>game<span class="hidden">⇩</span><sub>1</sub>_def</span><span> </span><span>o_def</span><span> </span><span>split_def</span><span> </span><span>map_try_spmf</span><span> </span><span>map_scale_spmf</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Game hop based on a failure event›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
A game hop based on a failure event changes one game into another such that they behave identically unless the failure event occurs.
The @{thm [source] "fundamental_lemma"} bounds the absolute difference between the two games by the probability of the failure event.
In the running example, we would like to avoid querying the random oracle when encrypting the chosen message.
The next game @{term game<span class="hidden">⇩</span><sub>2</sub>} is identical except that the call to the random oracle @{term ro.oracle} is replaced with sampling a random bitstring.%
\footnote{%
  In Shoup's terminology @{cite Shoup2004IACR}, such a step makes (a gnome sitting inside) the random oracle forgetting the query.
}
›</span></span></span><span>
</span><span class="keyword3"><span class="command">define</span></span><span> </span><span>game<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat ⇒ (bool × bool) spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game<span class="hidden">⇩</span><sub>2</sub> x y = do {
  b ← coin_spmf;
  (((m<span class="hidden">⇩</span><sub>1</sub>, m<span class="hidden">⇩</span><sub>2</sub>), σ), (s, s_h)) ← exec_gpv oracle' (𝒜<span class="hidden">⇩</span><sub>1</sub> (<span class="hidden">❙</span><span class="bold">g</span> [^] x)) ({}, ro.initial);
  TRY do {
    _ :: unit ← assert_spmf (valid_plains m<span class="hidden">⇩</span><sub>1</sub> m<span class="hidden">⇩</span><sub>2</sub>);
    h ← spmf_of_set (nlists UNIV len_plain);
    ― ‹We do not query the random oracle for @{term ‹<span class="hidden">❙</span><span class="bold">g</span> [^] (x * y)›}, but instead sample a random bitstring @{term h} directly.
        So the rest differs from @{term game<span class="hidden">⇩</span><sub>1</sub>} only if the adversary queries @{term ‹<span class="hidden">❙</span><span class="bold">g</span> [^] (x * y)›}.›
    let cipher = (<span class="hidden">❙</span><span class="bold">g</span> [^] y, h [⊕] (if b then m<span class="hidden">⇩</span><sub>1</sub> else m<span class="hidden">⇩</span><sub>2</sub>));
    (b', (s', s_h')) ← exec_gpv oracle' (𝒜<span class="hidden">⇩</span><sub>2</sub> cipher σ) (s, s_h);
    return_spmf (b' = b, <span class="hidden">❙</span><span class="bold">g</span> [^] (x * y) ∈ s')
  } ELSE do {
    b ← coin_spmf;
    return_spmf (b, <span class="hidden">❙</span><span class="bold">g</span> [^] (x * y) ∈ s)
  }
}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
To apply the @{thm [source] fundamental_lemma}, we first have to prove that the two games are indeed the same
except when the failure event occurs.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_spmf (λ(win, bad) (win', bad'). bad = bad' ∧ (¬ bad' ⟶ win = win')) (game<span class="hidden">⇩</span><sub>2</sub> x y) (game<span class="hidden">⇩</span><sub>1</sub> x y)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  This proof requires two invariants on the state of @{term oracle'}.
  First, @{term "s = dom s_h"}.
  Second, @{term s} only becomes larger.
  The next two statements capture the two invariants:
›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>inv_oracle'</span><span class="delimiter">:</span><span> </span><span>callee_invariant_on</span><span> </span><span class="string"><span class="delete"><span class="delete">"oracle'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λ(s, s_h). s = dom s_h)"</span></span></span><span> </span><span>ℐ_full</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle'_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split_asm</span><span> </span><span>if_split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>bad</span><span class="delimiter">:</span><span> </span><span>callee_invariant_on</span><span> </span><span class="string"><span class="delete"><span class="delete">"oracle'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λ(s, _). z ∈ s)"</span></span></span><span> </span><span>ℐ_full</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>z</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle'_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  First, we identify a bisimulation relation ‹?X› between the different states of @{term oracle'} for the second phase of the game.
  Namely, the invariant @{term "s = dom s_h"} holds, the set of queries are the same, 
  and the random oracle's state (a map from queries to responses) differs only at the point @{term "<span class="hidden">❙</span><span class="bold">g</span> [^] (x * y)"}.
  ›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?X</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(s, s_h) (s', s_h'). s = dom s_h ∧ s' = s ∧ s_h = s_h'(<span class="hidden">❙</span><span class="bold">g</span> [^] (x * y) := None)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Then, we can prove that @{term [source] "?X"} really is a bisimulation for @{term oracle'} except when the failure event occurs.
  The next statement expresses this.
  ›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?bad</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ(s, s_h). <span class="hidden">❙</span><span class="bold">g</span> [^] (x * y) ∈ s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?R</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(λ(a, s1') (b, s2'). ?bad s1' = ?bad s2' ∧ (¬ ?bad s2' ⟶ a = b ∧ ?X s1' s2'))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bisim</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_spmf ?R (oracle' s1 plain) (oracle' s2 plain)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?X s1 s2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s1</span><span> </span><span>s2</span><span> </span><span>plain</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bind_reflI</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle'_def</span><span> </span><span>rel_spmf_return_spmf2</span><span> </span><span>fun_upd_twist</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>fun_upd_eqD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"callee_invariant oracle' ?bad"</span></span></span><span>
</span><span>    </span><span class="comment">― ‹Once the failure event has happened, it will not be forgotten any more.›</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle'_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split_asm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Now we are ready to prove that the two games @{term game<span class="hidden">⇩</span><sub>1</sub>} and @{term game<span class="hidden">⇩</span><sub>2</sub>} are sufficiently similar.
  The Isar proof now switches into an @{command apply} script that manipulates the goal state directly.
  This is sometimes convenient when it would be too cumbersome to spell out every intermediate goal state.
›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>game<span class="hidden">⇩</span><sub>1</sub>_def</span><span> </span><span>game<span class="hidden">⇩</span><sub>2</sub>_def</span><span>
</span><span>    </span><span class="comment">― ‹Peel off the first phase of the game using the structural decomposition rules @{thm [source] rel_spmf_bind_reflI} and @{thm [source] rel_spmf_try_spmf}.›</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bind_reflI</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>bind_spmf_const</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_spmf_try_spmf</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span>TRY</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b</span><span> </span><span>m<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>m<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>σ</span><span> </span><span>s</span><span> </span><span>s_h</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_spmf_bind_reflI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="comment">― ‹Exploit that in the first phase of the game, the set @{term s} of queried strings and the map of the random oracle @{term s_h} are updated in lock step, i.e., @{term "s = dom s_h"}.›</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule</span><span> </span><span>inv_oracle'.exec_gpv_invariant</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="comment">― ‹Has the adversary queried the random oracle with @{term "<span class="hidden">❙</span><span class="bold">g</span> [^] (x * y)"} during the first phase?›</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"<span class="hidden">❙</span><span class="bold">g</span> [^] (x * y) ∈ s"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span>True</span><span> </span><span class="comment">― ‹Then the failure event has already happened and there is nothing more to do. 
        We just have to prove that the two games on both sides terminate with the same probability.›</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bindI1</span><span> </span><span>rel_spmf_bindI2</span><span> </span><span>lossless_exec_gpv</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ℐ</span><span class="delimiter">=</span><span>ℐ_full</span><span class="delimiter">]</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>bad.exec_gpv_invariant</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span>False</span><span> </span><span class="comment">― ‹Then let's see whether the adversary queries @{term "<span class="hidden">❙</span><span class="bold">g</span> [^] (x * y)"} in the second phase.
        Thanks to @{thm [source] ro.fresh}, the call to the random oracle simplifies to sampling a random bitstring.›</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>iff</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>domIff</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>domIff</span><span> </span><span>ro.fresh</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bind_reflI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_spmf_bindI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"?R"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="comment">― ‹The lemma @{thm [source] exec_gpv_oracle_bisim_bad_full} lifts the bisimulation for @{term oracle'}
             to the adversary @{term 𝒜<span class="hidden">⇩</span><sub>2</sub>} interacting with @{term oracle'}.›</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>exec_gpv_oracle_bisim_bad_full</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>bisim</span><span> </span><span>inv</span><span> </span><span>inv</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_upd_idem</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span>ELSE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_spmf_reflI</span><span class="delimiter">)</span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Now we can add the sampling of @{term x} and @{term y} in front of @{term game<span class="hidden">⇩</span><sub>1</sub>} and @{term game<span class="hidden">⇩</span><sub>2</sub>},
  apply the @{thm [source] fundamental_lemma}.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_spmf (λ(win, bad) (win', bad'). (bad ⟷ bad') ∧ (¬ bad' ⟶ win ⟷ win')) (?sample game<span class="hidden">⇩</span><sub>2</sub>) (?sample game<span class="hidden">⇩</span><sub>1</sub>)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>rel_spmf_bind_reflI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¦measure (measure_spmf (?sample game<span class="hidden">⇩</span><sub>2</sub>)) {(win, _). win} - measure (measure_spmf (?sample game<span class="hidden">⇩</span><sub>1</sub>)) {(win, _). win}¦
      ≤ measure (measure_spmf (?sample game<span class="hidden">⇩</span><sub>2</sub>)) {(_, bad). bad}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>split_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>fundamental_lemma</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The @{thm [source] fundamental_lemma} is written in full generality for arbitrary events, 
  i.e., sets of elementary events.
  But in this formalization, the events of interest (correct guess and failure) are elementary events.
  We therefore transform the above statement to measure the probability of elementary events using @{term spmf}.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"measure (measure_spmf (?sample game<span class="hidden">⇩</span><sub>2</sub>)) {(win, _). win} = spmf (map_spmf fst (?sample game<span class="hidden">⇩</span><sub>2</sub>)) True"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"measure (measure_spmf (?sample game<span class="hidden">⇩</span><sub>1</sub>)) {(win, _). win} = spmf (map_spmf fst (?sample game<span class="hidden">⇩</span><sub>1</sub>)) True"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"measure (measure_spmf (?sample game<span class="hidden">⇩</span><sub>2</sub>)) {(_, bad). bad} = spmf (map_spmf snd (?sample game<span class="hidden">⇩</span><sub>2</sub>)) True"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>spmf_conv_measure_spmf</span><span> </span><span>measure_map_spmf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>vimage_def</span><span> </span><span>split_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>hop12</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¦spmf (map_spmf fst (?sample game<span class="hidden">⇩</span><sub>2</sub>)) True - spmf (map_spmf fst (?sample game<span class="hidden">⇩</span><sub>1</sub>)) True¦
  ≤ spmf (map_spmf snd (?sample game<span class="hidden">⇩</span><sub>2</sub>)) True"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Optimistic sampling: the one-time-pad  \label{section:ghop-last}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
This step is based on the one-time-pad, which is an instance of optimistic sampling.
If two runs of the two games in an optimistic sampling step would use the same random bits,
then their results would be different.
However, if the adversary's choices are independent of the random bits, 
we may relate runs that use different random bits, as in the end, only the probabilities have to match.
The previous game hop from @{term game<span class="hidden">⇩</span><sub>1</sub>} to @{term game<span class="hidden">⇩</span><sub>2</sub>} made the oracle's responses in the second phase
independent from the encrypted ciphertext.
So we can now change the bits used for encrypting the chosen message
and thereby make the ciphertext independent of the message.

To that end, we parametrize @{term game<span class="hidden">⇩</span><sub>2</sub>} by the part that does the optimistic sampling
and call this parametrized version @{term game<span class="hidden">⇩</span><sub>3</sub>}.
›</span></span></span><span>
</span><span class="keyword3"><span class="command">define</span></span><span> </span><span>game<span class="hidden">⇩</span><sub>3</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(bool ⇒ bitstring ⇒ bitstring ⇒ bitstring spmf) ⇒ nat ⇒ nat ⇒ (bool × bool) spmf"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game<span class="hidden">⇩</span><sub>3</sub> f x y = do {
  b ← coin_spmf;
  (((m<span class="hidden">⇩</span><sub>1</sub>, m<span class="hidden">⇩</span><sub>2</sub>), σ), (s, s_h)) ← exec_gpv oracle' (𝒜<span class="hidden">⇩</span><sub>1</sub> (<span class="hidden">❙</span><span class="bold">g</span> [^] x)) ({}, ro.initial);
  TRY do {
    _ :: unit ← assert_spmf (valid_plains m<span class="hidden">⇩</span><sub>1</sub> m<span class="hidden">⇩</span><sub>2</sub>);
    h' ← f b m<span class="hidden">⇩</span><sub>1</sub> m<span class="hidden">⇩</span><sub>2</sub>;
    let cipher = (<span class="hidden">❙</span><span class="bold">g</span> [^] y, h');
    (b', (s', s_h')) ← exec_gpv oracle' (𝒜<span class="hidden">⇩</span><sub>2</sub> cipher σ) (s, s_h);
    return_spmf (b' = b, <span class="hidden">❙</span><span class="bold">g</span> [^] (x * y) ∈ s')
  } ELSE do {
    b ← coin_spmf;
    return_spmf (b, <span class="hidden">❙</span><span class="bold">g</span> [^] (x * y) ∈ s)
  }
}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Clearly, if we plug in the appropriate function ‹?f›, then we get @{term game<span class="hidden">⇩</span><sub>2</sub>}:
›</span></span></span><span>
</span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?f</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λb m<span class="hidden">⇩</span><sub>1</sub> m<span class="hidden">⇩</span><sub>2</sub>. map_spmf (λh. (if b then m<span class="hidden">⇩</span><sub>1</sub> else m<span class="hidden">⇩</span><sub>2</sub>) [⊕] h) (spmf_of_set (nlists UNIV len_plain))"</span></span></span><span>
</span><span class="keyword1"><span class="command">have</span></span><span> </span><span>game<span class="hidden">⇩</span><sub>2</sub>_game<span class="hidden">⇩</span><sub>3</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"game<span class="hidden">⇩</span><sub>2</sub> x y = game<span class="hidden">⇩</span><sub>3</sub> ?f x y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>game<span class="hidden">⇩</span><sub>2</sub>_def</span><span> </span><span>game<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>Let_def</span><span> </span><span>bind_map_spmf</span><span> </span><span>xor_list_commute</span><span> </span><span>o_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
CryptHOL's @{thm [source] one_time_pad} lemma now allows us to remove the exclusive or with the chosen message,
because the resulting distributions are the same.
The proof is slightly non-trivial because the one-time-pad lemma holds
only if the xor'ed bitstrings have the right length, which the assertion @{term valid_plains} ensures.
The congruence rules @{thm [source] try_spmf_cong bind_spmf_cong[OF refl] if_cong[OF refl]}
extract this information from the program of the game.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?f'</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λb m<span class="hidden">⇩</span><sub>1</sub> m<span class="hidden">⇩</span><sub>2</sub>. spmf_of_set (nlists UNIV len_plain)"</span></span></span><span>
</span><span class="keyword1"><span class="command">have</span></span><span> </span><span>game<span class="hidden">⇩</span><sub>3</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"game<span class="hidden">⇩</span><sub>3</sub> ?f x y = game<span class="hidden">⇩</span><sub>3</sub> ?f' x y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>try_spmf_cong</span><span> </span><span>bind_spmf_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span> </span><span>if_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span> 
</span><span>    </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>game<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>split_def</span><span> </span><span>one_time_pad</span><span> </span><span>valid_plains_def</span><span> 
</span><span>    </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>map_spmf_of_set_inj_on</span><span> </span><span>bind_spmf_const</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The rest of the proof consists of simplifying @{term [source] "game<span class="hidden">⇩</span><sub>3</sub> ?f'"}.
The steps are similar to what we have shown before, so we do not explain them in detail.
The interested reader can look at them in the theory file from which this document was generated.
At a high level, we see that there is no need to track the adversary's queries in @{term game<span class="hidden">⇩</span><sub>2</sub>} or @{term game<span class="hidden">⇩</span><sub>3</sub>} any more
because this information is already stored in the random oracle's state.
So we change the @{term oracle'} back into @{term ro.oracle} using the Transfer package.
With a bit of rewriting, the result is then the @{term lcdh.game} for the adversary @{term "elgamal_reduction 𝒜"}.
Moreover, the guess @{term b'} of the adversary is independent of @{term b} in @{term [source] "game<span class="hidden">⇩</span><sub>3</sub> ?f"}, 
so the first boolean returned by @{term [source] "game<span class="hidden">⇩</span><sub>3</sub> ?f'"} is just a coin flip.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">have</span></span><span> </span><span>game<span class="hidden">⇩</span><sub>3</sub>_bad</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"map_spmf snd (?sample (game<span class="hidden">⇩</span><sub>3</sub> ?f')) = lcdh.game (elgamal_reduction 𝒜)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">%</span><span>invisible</span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>bisim</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bisim = (λσ (s :: 'grp set, σ' :: 'grp ⇀ bitstring). s = dom σ ∧ σ = σ')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bisim Map_empty ({}, Map_empty)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bisim_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(bisim ===&gt; (=) ===&gt; rel_spmf (rel_prod (=) bisim)) ro.oracle oracle'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>oracle'_def</span><span> </span><span>split_def</span><span> </span><span>spmf_rel_map</span><span> </span><span>ro.oracle_def</span><span> </span><span>rel_fun_def</span><span> </span><span>bisim_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_spmf_bind_reflI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(bisim ===&gt; (=)) dom fst"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bisim_def</span><span> </span><span>rel_fun_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(bisim ===&gt; (=)) (λx. x) snd"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_fun_def</span><span> </span><span>bisim_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"game<span class="hidden">⇩</span><sub>3</sub> ?f' x y = do {
    b ← coin_spmf;
    (((msg1, msg2), σ), s) ← exec_gpv ro.oracle (𝒜<span class="hidden">⇩</span><sub>1</sub> (<span class="hidden">❙</span><span class="bold">g</span> [^] x)) ro.initial;
    TRY do {
      _ :: unit ← assert_spmf (valid_plains msg1 msg2);
      h' ← spmf_of_set (nlists UNIV len_plain);
      let cipher = (<span class="hidden">❙</span><span class="bold">g</span> [^] y, h');
      (b', s') ← exec_gpv ro.oracle (𝒜<span class="hidden">⇩</span><sub>2</sub> cipher σ) s;
      return_spmf (b' = b, <span class="hidden">❙</span><span class="bold">g</span> [^] (x * y) ∈ dom s')
    } ELSE do {
      b ← coin_spmf;
      return_spmf (b, <span class="hidden">❙</span><span class="bold">g</span> [^] (x * y) ∈ dom s)
    }
  }"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>game<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>Map_empty_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>split_def</span><span> </span><span>fst_conv</span><span> </span><span>snd_conv</span><span> </span><span>prod.collapse</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>transfer</span><span> </span><span>fixing</span><span class="delimiter">:</span><span> </span><span>𝒢</span><span> </span><span>len_plain</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map_spmf snd (… x y) = do {
      zs ← elgamal_reduction 𝒜 (<span class="hidden">❙</span><span class="bold">g</span> [^] x) (<span class="hidden">❙</span><span class="bold">g</span> [^] y);
      return_spmf (<span class="hidden">❙</span><span class="bold">g</span> [^] (x * y) ∈ zs)
    }"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>o_def</span><span> </span><span>split_def</span><span> </span><span>map_try_spmf</span><span> </span><span>map_scale_spmf</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>o_def</span><span> </span><span>map_try_spmf</span><span> </span><span>map_scale_spmf</span><span> </span><span>map_spmf_conv_bind_spmf</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>spmf.map_comp</span><span> </span><span>map_const_spmf_of_set</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>o_def</span><span> </span><span>lcdh.game_def</span><span> </span><span>Let_def</span><span> </span><span>lcdh.nat_pow_pow</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">have</span></span><span> </span><span>game<span class="hidden">⇩</span><sub>3</sub>_guess</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"map_spmf fst (game<span class="hidden">⇩</span><sub>3</sub> ?f' x y) = coin_spmf"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">%</span><span>invisible</span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map_spmf fst (game<span class="hidden">⇩</span><sub>3</sub> ?f' x y) = do {
    (((msg1, msg2), σ), (s, s_h)) ← exec_gpv oracle' (𝒜<span class="hidden">⇩</span><sub>1</sub> (<span class="hidden">❙</span><span class="bold">g</span> [^] x)) ({}, ro.initial);
    TRY do {
      _ :: unit ← assert_spmf (valid_plains msg1 msg2);
      h' ← spmf_of_set (nlists UNIV len_plain);
      (b', (s', s_h')) ← exec_gpv oracle' (𝒜<span class="hidden">⇩</span><sub>2</sub> (<span class="hidden">❙</span><span class="bold">g</span> [^] y, h') σ) (s, s_h);
      map_spmf ((=) b') coin_spmf
    } ELSE coin_spmf
  }"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">including</span></span><span> </span><span>monad_normalisation</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>game<span class="hidden">⇩</span><sub>3</sub>_def</span><span> </span><span>o_def</span><span> </span><span>split_def</span><span> </span><span>map_spmf_conv_bind_spmf</span><span> </span><span>try_spmf_bind_out</span><span> </span><span>weight_spmf_le_1</span><span> </span><span>scale_bind_spmf</span><span> </span><span>try_spmf_bind_out1</span><span> </span><span>bind_scale_spmf</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>o_def</span><span> </span><span>if_distribs</span><span> </span><span>spmf.map_comp</span><span> </span><span>map_eq_const_coin_spmf</span><span> </span><span>split_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Combining several game hops \label{section:combining:hops}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Finally, we combine all the (in)equalities of the previous steps to obtain the desired bound
using the lemmas for reasoning about reals from Isabelle's library.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ind_cpa.advantage (ro.oracle, ro.initial) 𝒜 = ¦spmf (map_spmf fst (?sample game<span class="hidden">⇩</span><sub>1</sub>)) True - 1 / 2¦"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ind_cpa_game_eq_game<span class="hidden">⇩</span><sub>0</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>game<span class="hidden">⇩</span><sub>0</sub>_game<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>o_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = ¦1 / 2 - spmf (map_spmf fst (?sample game<span class="hidden">⇩</span><sub>1</sub>)) True¦"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>abs_minus_commute</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1 / 2 = spmf (map_spmf fst (?sample game<span class="hidden">⇩</span><sub>2</sub>)) True"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>game<span class="hidden">⇩</span><sub>2</sub>_game<span class="hidden">⇩</span><sub>3</sub></span><span> </span><span>game<span class="hidden">⇩</span><sub>3</sub></span><span> </span><span>o_def</span><span> </span><span>game<span class="hidden">⇩</span><sub>3</sub>_guess</span><span> </span><span>spmf_of_set</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¦… - spmf (map_spmf fst (?sample game<span class="hidden">⇩</span><sub>1</sub>)) True¦ ≤ spmf (map_spmf snd (?sample game<span class="hidden">⇩</span><sub>2</sub>)) True"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>hop12</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = lcdh.advantage (elgamal_reduction 𝒜)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>game<span class="hidden">⇩</span><sub>2</sub>_game<span class="hidden">⇩</span><sub>3</sub></span><span> </span><span>game<span class="hidden">⇩</span><sub>3</sub></span><span> </span><span>game<span class="hidden">⇩</span><sub>3</sub>_bad</span><span> </span><span>lcdh.advantage_def</span><span> </span><span>o_def</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>map_bind_spmf</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
This completes the concrete proof and we can end the locale @{locale hashed_elgamal}.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Asymptotic security \label{section:asymptotic}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
An asymptotic security statement can be easily derived from a concrete security theorem.
This is done in two steps:
First, we have to introduce a security parameter @{term η} into the definitions and assumptions.
Only then can we state asymptotic security.
The proof is easy given the concrete security theorem.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Introducing a security parameter›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Since all our definitions were done in locales, it is easy to introduce a security parameter after the fact.
To that end, we define copies of all locales where their parameters now take the security parameter as an additional argument.
We illustrate it for the locale @{locale ind_cpa_pk}.

The @{command sublocale} command brings all the definitions and theorems of the original @{locale ind_cpa_pk} into the copy and adds the security parameter where necessary.
The type @{typ security} is a synonym for @{typ nat}.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>ind_cpa_pk'</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>key_gen</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ ('pubkey × 'privkey, 'query, 'response) gpv"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>encrypt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ 'pubkey ⇒ 'plain ⇒ ('cipher, 'query, 'response) gpv"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>decrypt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ 'privkey ⇒ 'cipher ⇒ ('plain, 'query, 'response) gpv"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>valid_plains</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ 'plain ⇒ 'plain ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>ind_cpa_pk</span><span> </span><span class="string"><span class="delete"><span class="delete">"key_gen η"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"encrypt η"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"decrypt η"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_plains η"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>η</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span class="delimiter">%</span><span>invisible</span><span> </span><span>list_cdh'</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>𝒢</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ 'grp cyclic_group"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>cyclic_group</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cyclic_group (𝒢 η)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span class="delimiter">%</span><span>invisible</span><span> </span><span>cyclic_group</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒢 η"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>η</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fact</span><span> </span><span>cyclic_group</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="delimiter">%</span><span>invisible</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span class="delimiter">%</span><span>invisible</span><span> </span><span>random_oracle'</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>len</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ nat"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span class="delimiter">%</span><span>invisible</span><span> </span><span>random_oracle</span><span> </span><span class="string"><span class="delete"><span class="delete">"len η"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>η</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="delimiter">%</span><span>invisible</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">%</span><span>invisible</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>ind_cpa_pk</span><span class="delimiter">)</span><span> </span><span>advantage_nonneg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"advantage oracle 𝒜 ≥ 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"oracle"</span></span></span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">%</span><span>invisible</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>list_cdh</span><span class="delimiter">)</span><span> </span><span>advantage_nonneg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"advantage 𝒜 ≥ 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>advantage_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
We do so similarly for @{locale list_cdh}, @{locale random_oracle}, and @{locale hashed_elgamal}.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>hashed_elgamal'</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>lcdh</span><span class="delimiter">:</span><span> </span><span>list_cdh'</span><span> </span><span>𝒢</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span>ro</span><span class="delimiter">:</span><span> </span><span>random_oracle'</span><span> </span><span>len_plain</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>𝒢</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ 'grp cyclic_group"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>len_plain</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"security ⇒ nat"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>hashed_elgamal</span><span> </span><span class="string"><span class="delete"><span class="delete">"𝒢 η"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"len_plain η"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>η</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Asymptotic security statements \label{section:security:asymptotic}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
For asymptotic security statements, \CryptHOL{} defines the predicate @{term negligible}.
It states that the given real-valued function approaches 0 faster than the inverse of any polynomial.
A concrete security statement translates into an asymptotic one as follows:
\begin{itemize}
\item All advantages in the bound become negligibility assumptions.
\item All side conditions of the concrete security theorems remain assumptions, but wrapped into an @{term eventually} statement.
  This expresses that the side condition holds eventually, i.e., there is a security parameter from which on it holds.
\item The conclusion is that the bounded advantage is @{term negligible}.
\end{itemize}
›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>asymptotic_security_elgamal</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"negligible (λη. lcdh.advantage η (elgamal_reduction η (𝒜 η)))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eventually (λη. ind_cpa.lossless (𝒜 η)) at_top"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"negligible (λη. ind_cpa.advantage η (ro.oracle η, ro.initial) (𝒜 η))"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The proof is canonical, too:
Using the lemmas about @{term negligible} and Eberl's library for asymptotic reasoning~\cite{Eberl2015},
we transform the asymptotic statement into a concrete one and then simply use the concrete security statement.
›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>negligible_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>landau_o.big_mono</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>eventually_rev_mp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>eventuallyI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>ind_cpa.advantage.simps</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ind_cpa.advantage_nonneg</span><span> </span><span>lcdh.advantage_nonneg</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>concrete_security_elgamal</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="delimiter">%</span><span>invisible</span><span>
</span></pre>
</div>
</div>