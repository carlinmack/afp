<div id="Notation">
<div class="head"><h1>Theory Notation</h1>
<span class="command">theory</span> <span class="name">Notation</span><br/>
<span class="keyword">imports</span> <a href="LaTeXsugar.html"><span class="name">LaTeXsugar</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      Notation for hotel key card system
    Author:     Tobias Nipkow, TU Muenchen
*)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Notation</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.LaTeXsugar"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"SomeFloor"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(⌊_⌋)"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌊x⌋ ≡ Some x"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Notation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
HOL conforms largely to everyday mathematical notation.
This section introduces further non-standard notation and in particular
a few basic data types with their primitive operations.
\sloppy
\begin{description}

\item[Types] The type of truth values is called @{typ bool}.  The
space of total functions is denoted by ‹⇒›. Type variables
start with a quote, as in @{typ"'a"}, @{typ"'b"} etc. The notation
$t$~‹::›~$\tau$ means that term $t$ has type $\tau$.

\item[Functions] can be updated at ‹x› with new value ‹y›,
written @{term"f(x:=y)"}.  The range of a function is @{term"range f"},
@{prop"inj f"} means ‹f› is injective.

\item[Pairs] come with the two projection functions
‹fst :: 'a × 'b ⇒ 'a› and ‹snd :: 'a × 'b ⇒ 'b›.

\item[Sets] have type @{typ"'a set"}.

\item[Lists] (type @{typ"'a list"}) come with the empty list
@{term"[]"}, the infix constructor ‹⋅›, the infix ‹@›
that appends two lists, and the conversion function @{term set} from
lists to sets.  Variable names ending in ``s'' usually stand for
lists.

\item[Records] are constructed like this ‹⦇f<span class="hidden">⇩</span><sub>1</sub> = v<span class="hidden">⇩</span><sub>1</sub>, …⦈›
and updated like this \mbox{‹r⦇f<span class="hidden">⇩</span><sub>i</sub> := v<span class="hidden">⇩</span><sub>i</sub>, …⦈›},
where the ‹f<span class="hidden">⇩</span><sub>i</sub>› are the field names,
the ‹v<span class="hidden">⇩</span><sub>i</sub>› the values and ‹r› is a record.

\end{description}\fussy
Datatype ‹option› is defined like this
\begin{center}
\isacommand{datatype} ‹'a option = None | Some 'a›
\end{center}
and adjoins a new element @{term None} to a type @{typ 'a}. For
succinctness we write @{term"Some a"} instead of @{term[source]"Some a"}.

Note that ‹⟦A<span class="hidden">⇩</span><sub>1</sub>; …; A<span class="hidden">⇩</span><sub>n</sub>⟧ ⟹ A›
abbreviates ‹A<span class="hidden">⇩</span><sub>1</sub> ⟹ … ⟹ A<span class="hidden">⇩</span><sub>n</sub> ⟹ A›, which is the same as
``If ‹A<span class="hidden">⇩</span><sub>1</sub>› and \dots\ and ‹A<span class="hidden">⇩</span><sub>n</sub>› then ‹A›''.
›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="Basis">
<div class="head"><h1>Theory Basis</h1>
<span class="command">theory</span> <span class="name">Basis</span><br/>
<span class="keyword">imports</span> <a href="Notation.html"><span class="name">Notation</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      Basis for hotel key card system

    Author:     Tobias Nipkow, TU Muenchen
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Basis</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Notation</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">typedecl</span></span><span> </span><span>guest</span><span>
</span><span class="keyword1"><span class="command">typedecl</span></span><span> </span><span>key</span><span>
</span><span class="keyword1"><span class="command">typedecl</span></span><span> </span><span>room</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>card</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"key * key"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="State">
<div class="head"><h1>Theory State</h1>
<span class="command">theory</span> <span class="name">State</span><br/>
<span class="keyword">imports</span> <a href="Basis.html"><span class="name">Basis</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      A state based hotel key card system

    Author:     Tobias Nipkow, TU Muenchen
*)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>State</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Basis</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>if_split_asm</span><span class="delimiter">[</span><span>split</span><span class="delimiter">]</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹A state based model›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The model is based on three opaque types @{typ guest},
@{typ key} and @{typ room}. Type @{typ card} is just an abbreviation
for @{typ"key × key"}.

The state of the system is modelled as a record which combines the
information about the front desk, the rooms and the guests.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">record</span></span><span> </span><span>state</span><span> </span><span class="delimiter">=</span><span>
</span><span> </span><span>owns</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"room ⇒ guest option"</span></span></span><span>
</span><span> </span><span>currk</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"room ⇒ key"</span></span></span><span>
</span><span> </span><span>issued</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"key set"</span></span></span><span>
</span><span> </span><span>cards</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"guest ⇒ card set"</span></span></span><span>
</span><span> </span><span>roomk</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"room ⇒ key"</span></span></span><span>
</span><span> </span><span>isin</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"room ⇒ guest set"</span></span></span><span>
</span><span> </span><span>safe</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"room ⇒ bool"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹\noindent Reception records who @{const owns} a room (if anybody, hence
@{typ"guest option"}), the current key @{const currk} that has been
issued for a room, and which keys have been @{const issued} so
far. Each guest has a set of @{const cards}. Each room has a key
@{const roomk} recorded in the lock and a set @{const isin} of
occupants. The auxiliary variable @{const safe} is explained further
below; we ignore it for now.

In specification languages like Z, VDM and B we would now define a
number of operations on this state space. Since they are the only
permissible operations on the state, this defines a set of
\emph{reachable} states. In a purely logical environment like
Isabelle/HOL this set can be defined directly by an inductive
definition. Each clause of the definition corresponds to a
transition/operation/event. This is the standard approach to modelling
state machines in theorem provers.

The set of reachable states of the system (called ‹reach›) is
defined by four transitions: initialization, checking in, entering a room,
and leaving a room:›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">inductive_set</span></span><span> </span><span>reach</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"state set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>init</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"inj initk ⟹
⦇ owns = (λr. None), currk = initk, issued = range initk,
  cards = (λg. {}), roomk = initk, isin = (λr. {}),
  safe = (λr. True) ⦈ ∈ reach"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>check_in</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦ s ∈ reach; k ∉ issued s ⟧ ⟹
s⦇ currk := (currk s)(r := k), issued := issued s ∪ {k},
   cards := (cards s)(g := cards s g ∪ {(currk s r, k)}),
   owns :=  (owns s)(r := Some g),
   safe := (safe s)(r := False) ⦈ ∈ reach"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>enter_room</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦ s ∈ reach; (k,k') ∈ cards s g; roomk s r ∈ {k,k'} ⟧ ⟹
s⦇ isin := (isin s)(r := isin s r ∪ {g}),
   roomk := (roomk s)(r := k'),
   safe := (safe s)(r := owns s r = ⌊g⌋ ∧ isin s r = {} ∧ k' = currk s r
                              ∨ safe s r)
  ⦈ ∈ reach"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>exit_room</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦ s ∈ reach;  g ∈ isin s r ⟧ ⟹
s⦇ isin := (isin s)(r := isin s r - {g}) ⦈ ∈ reach"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹\bigskip There is no check-out event because it is implicit in the next
check-in for that room: this covers the cases where a guest leaves without checking out (in which case the room should not be blocked forever) or where
the hotel decides to rent out a room prematurely, probably by accident.
Neither do guests have to return their cards at any point because they may
loose cards or may pretended to have lost them.
We will now explain the events.
\begin{description}
\item[‹init›]
Initialization requires that every room has a different key, i.e.\
that @{const currk} is injective. Nobody
owns a room, the keys of all rooms are recorded as issued, nobody has
a card, and all rooms are empty.
\item[@{thm[source] enter_room}]
A guest may enter if either of the two keys on his card equal the room key.
Then ‹g› is added to the occupants of ‹r› and
the room key is set to the second key on the card.
Normally this has no effect because the second key is already the room key.
But when entering for the first time, the first key on the card equals
the room key and then the lock is actually recoded.
\item[‹exit_room›]
removes an occupant from the occupants of a room.
\item[‹check_in›] for room ‹r› and guest ‹g›
issues the card @{term"(currk s r, k)"}
to ‹g›, where ‹k› is new, makes ‹g› the owner of the room,
and sets @{term"currk s r"} to the new key ‹k›.
\end{description}

The reader can easily check that our specification allows the intended
distributed implementation: entering only reads and writes the key in
that lock, and check-in only reads and writes the information at
reception.

In contrast to Jackson we require that initially distinct rooms have
distinct keys. This protects the hotel from its guests: otherwise a
guest may be able to enter rooms he does not own, potentially stealing
objects from those rooms. Of course he can also steal objects from his
own room, but in that case it is easier to hold him responsible. In
general, the hotel may just want to minimize the opportunity for
theft.

The main difference to Jackson's model is that his can talk about
transitions between states rather than merely about reachable
states. This means that he can specify that unauthorized entry into a
room should not occur. Because our specification does not formalize
the transition relation itself, we need to include the ‹isin›
component in order to
express the same requirement. In the end, we would like to establish
that the system is \emph{safe}: only the owner of a room can be in a
room:
\begin{center}
@{prop"s ∈ reach ⟹ g ∈ isin s r ⟹ owns s r = Some g"}
\end{center}
Unfortunately, this is just not true. It does not take a PhD in
computer science to come up with the following scenario: because
guests can retain their cards, there is nothing to stop a guest from
reentering his old room after he has checked out (in our model: after
the next guest has checked in), but before the next guest has entered
his room. Hence the best we can do is to prove a conditional safety
property: under certain conditions, the above safety property
holds. The question is: which conditions? It is clear that the room
must be empty when its owner enters it, or all bets
are off. But is that sufficient? Unfortunately not. Jackson's Alloy tool
took 2 seconds~\cite[p.~303]{Jackson06}
to find the following ``guest-in-the-middle'' attack:

\begin{enumerate}

\item Guest 1 checks in and obtains a card $(k_1,k_2)$ for room 1 (whose key
in the lock is $k_1$). Guest 1 does not enter room 1.

\item Guest 2 checks in, obtains a card $(k_2,k_3)$ for room 1, but
does not enter room 1 either.

\item Guest 1 checks in again, obtains a card $(k_3,k_4)$, goes to
room 1, opens it with his old card $(k_1,k_2)$, finds the room empty,
and feels safe \ldots

\end{enumerate}
After Guest~1 has left his room, Guest~2 enters and makes off with the
luggage.

Jackson now assumes that guests return their cards upon
check-out, which can be modelled as follows: upon check-in, the new card
is not added to the guest's set of cards but it replaces his previous
set of cards, i.e.\ guests return old cards the next time they check
in.  Under this assumption, Alloy finds no more counterexamples to
safety --- at least not up to 6 cards and keys and 3 guests and
rooms. This is not a proof but a strong indication that the given
assumptions suffice for safety. We prove that this is indeed the case.

It should be noted that the system also suffers from a liveness
problem: if a guest never enters the room he checked in to, that room
is forever blocked. In practice this is dealt with by a master key. We
ignore liveness.

\subsection{Formalizing safety}
\label{sec:formalizing-safety}

It should be clear that one cannot force guests to always return their
cards (or, equivalently, never to use an old card). We can only prove that if
they do, their room is safe. However, we do not follow Jackson's
approach of globally assuming everybody returns their old cards upon
check-in. Instead we would like to take a local approach where it is up
to each guest whether he follows this safety policy. We allow
guests to keep their cards but make safety dependent on how they use
them.  This generality requires a finer grained model: we need to
record if a guest has entered his room in a safe manner,
i.e.\ if it was empty and if he used the latest key for the room, the
one stored at reception.
The auxiliary variable @{const safe} records for each room if this
was the case at some point between his last check-in and now.
The main theorem will be that if a room is safe in this
manner, then only the owner can be in the room.
Now we explain how @{const safe} is modified with each event:

\begin{description}
\item[‹init›] sets @{const safe} to @{const True} for every room.
\item[‹check_in›] for room ‹r› resets @{prop"safe s r"}
because it is not safe for the new owner yet.
\item[@{thm[source] enter_room}] for room ‹r› sets @{prop"safe s r"} if
the owner entered an empty room using the latest card issued for that room
by reception, or if the room was already safe.
\item[‹exit_room›] does not modify @{const safe}.
\end{description}

The reader should convince his or herself that @{const safe}
corresponds to the informal safety policy set out above.  Note that a
guest may find his room non-empty the first time he enters, and
@{const safe} will not be set, but he may come back later, find the
room empty, and then @{const safe} will be set. Furthermore, it is
important that @{thm[source] enter_room} cannot reset @{const safe}
due to the disjunct ‹∨ safe s r›.  Hence ‹check_in› is
the only event that can reset @{const safe}.  That is, a room stays
safe until the next ‹check_in›.  Additionally @{const safe} is
initially @{const True}, which is fine because initially injectivity
of ‹initk› prohibits illegal entries by non-owners.

Note that because none of the other state components depend on @{const
safe}, it is truly auxiliary: it can be deleted from the system and
the same set of reachable states is obtained, modulo the absence of
@{const safe}.

We have formalized a very general safety policy of always using the
latest card. A special case of this policy is the one called
\emph{NoIntervening} by Jackson~\cite[p.~200]{Jackson06}: every ‹check_in› must immediately be followed by the corresponding @{thm[source]
enter_room}.
›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>currk_issued</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s : reach ⟹ currk s r : issued s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>set</span><span class="delimiter">:</span><span> </span><span>reach</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>key1_issued</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s : reach ⟹ (k,k') : cards s g ⟹ k : issued s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>set</span><span class="delimiter">:</span><span> </span><span>reach</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>key2_issued</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s : reach ⟹ (k,k') : cards s g ⟹ k' : issued s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>set</span><span class="delimiter">:</span><span> </span><span>reach</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>roomk_issued</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s : reach ⟹ roomk s k : issued s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>set</span><span class="delimiter">:</span><span> </span><span>reach</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>currk_inj</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"s : reach ⟹ ∀r r'. (currk s r = currk s r') = (r = r')"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>set</span><span class="delimiter">:</span><span> </span><span>reach</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>inj_on_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>key1_not_currk</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"s : reach ⟹ (currk s r,k') ∉ cards s g"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>set</span><span class="delimiter">:</span><span> </span><span>reach</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>guest_key2_disj</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ s : reach; (k<span class="hidden">⇩</span><sub>1</sub>,k) ∈ cards s g<span class="hidden">⇩</span><sub>1</sub>; (k<span class="hidden">⇩</span><sub>2</sub>,k) ∈ cards s g<span class="hidden">⇩</span><sub>2</sub> ⟧ ⟹ g<span class="hidden">⇩</span><sub>1</sub>=g<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>set</span><span class="delimiter">:</span><span> </span><span>reach</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>safe_roomk_currk</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"s : reach ⟹ safe s r ⟹ roomk s r = currk s r"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>set</span><span class="delimiter">:</span><span> </span><span>reach</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>safe_only_owner_enter_normal_aux</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ s : reach; safe s r; (k',roomk s r) ∈ cards s g ⟧ ⟹ owns s r = Some g"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>set</span><span class="delimiter">:</span><span> </span><span>reach</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>safe_only_owner_enter_normal</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s : reach"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ safe s r; (k',roomk s r) ∈ cards s g ⟧ ⟹ owns s r = Some g"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>induct</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>enter_room</span><span> </span><span>s</span><span> </span><span>k</span><span> </span><span>k1</span><span> </span><span>g1</span><span> </span><span>r1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s'</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"s⦇isin := (isin s)(r1 := isin s r1 ∪ {g1}),
               roomk := (roomk s)(r1 := k1),
               safe := (safe s)
                 (r1 :=
                    owns s r1 = Some g1 ∧ isin s r1 = {} ∧ k1 = currk s r1 ∨
                    safe s r1)⦈"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>s</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ∈ reach›</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⟦ safe s r; (k', roomk s r) ∈ cards s g ⟧ ⟹ owns s r = Some g›</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>card_g1</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(k,k1) ∈ cards s g1›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>safe</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹safe ?s' r›</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>card_g</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(k',roomk ?s' r) ∈ cards ?s' g›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"roomk s r1 = k ∨ roomk s r1 = k1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹roomk s r1 ∈ {k,k1}›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"roomk s r1 = k"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"r1 = r"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r1 ≠ r"</span></span></span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>IH</span><span> </span><span>safe</span><span> </span><span>card_g</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r1 = r"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>safe'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"owns s r = Some g1 ∨ safe s r"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>safe</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"safe s r"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>s</span><span> </span><span>card_g1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"owns s r = Some g1"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"owns ?s' r = Some g"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s</span><span> </span><span>card_g</span><span> </span><span>card_g1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"roomk s r1 = k1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>enter_room</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s : reach ⟹ safe s r ⟹ g : isin s r ⟹ owns s r = Some g"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>set</span><span class="delimiter">:</span><span> </span><span>reach</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>safe</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s : reach"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"safe s r ⟹ g : isin s r ⟹ owns s r = Some g"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>induct</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>enter_room</span><span> </span><span>s</span><span> </span><span>k1</span><span> </span><span>k2</span><span> </span><span>g1</span><span> </span><span>r1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s'</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"s⦇isin := (isin s)(r1 := isin s r1 ∪ {g1}),
               roomk := (roomk s)(r1 := k2),
               safe := (safe s)
                 (r1 :=
                    owns s r1 = Some g1 ∧ isin s r1 = {} ∧ k2 = currk s r1 ∨
                    safe s r1)⦈"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>s</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ∈ reach›</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⟦ safe s r; g ∈ isin s r ⟧ ⟹ owns s r = Some g›</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>card_g1</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(k1,k2) ∈ cards s g1›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>safe</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹safe ?s' r›</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>isin</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹g ∈ isin ?s' r›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"r1 = r"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r1 ≠ r"</span></span></span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>IH</span><span> </span><span>isin</span><span> </span><span>safe</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r1 = r"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g ∈ isin s r ∨ g = g1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>isin</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>g</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g ∈ isin s r"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"safe s r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>safe</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>g</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g = g1"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k2 = roomk s r1 ∨ k1 = roomk s r1"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹roomk s r1 ∈ {k1,k2}›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k2 = roomk s r1"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>card_g1</span><span> </span><span>s</span><span> </span><span>safe</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"k1 = roomk s r1"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"owns s r = Some g1 ∨ safe s r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>safe</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"owns s r = Some g1"</span></span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"safe s r"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s</span><span> </span><span>card_g1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

\subsection{Verifying safety}
\label{sec:verisafe}

All of our lemmas are invariants of @{const reach}.
The complete list, culminating in the main theorem, is this:
\begin{lemma}\label{state-lemmas}
\begin{enumerate}
\item @{thm currk_issued}
\item @{thm key1_issued}
\item @{thm key2_issued}
\item @{thm roomk_issued}
\item \label{currk_inj} @{thm currk_inj}
\item \label{key1_not_currk} @{thm key1_not_currk}
\item @{thm guest_key2_disj}
\item \label{safe_roomk_currk} @{thm[display] safe_roomk_currk}
\item \label{safe_only_owner_enter_normal} @{thm safe_only_owner_enter_normal}
\end{enumerate}
\end{lemma}
\begin{theorem}\label{safe-state}
@{thm[mode=IfThen] safe}
\end{theorem}
The lemmas and the theorem are proved in this order, each one is marked as a
simplification rule, and each proof is a one-liner: induction on
@{prop"s ∈ reach"} followed by ‹auto›.

Although, or maybe even because these proofs work so smoothly one may
like to understand why. Hence we examine the proof of
Theorem~\ref{safe-state} in more detail. The only interesting case is
@{thm[source] enter_room}. We assume that guest ‹g<span class="hidden">⇩</span><sub>1</sub>› enters room
‹r<span class="hidden">⇩</span><sub>1</sub>› with card @{term"(k<span class="hidden">⇩</span><sub>1</sub>,k<span class="hidden">⇩</span><sub>2</sub>)"} and call the new state ‹t›.
We assume @{prop"safe t r"} and @{prop"g ∈ isin t r"} and prove
@{prop"owns t r = ⌊g⌋"} by case distinction.
If @{prop"r<span class="hidden">⇩</span><sub>1</sub> ≠ r"}, the claim follows directly from the induction hypothesis
using \mbox{@{prop"safe s r"}} and @{prop"g ∈ isin t r"}
because @{prop"owns t r = owns s r"} and @{prop"safe t r = safe s r"}.
If @{prop"r<span class="hidden">⇩</span><sub>1</sub> = r"} then @{prop"g ∈ isin t r"} is equivalent with
@{prop"g ∈ isin s r ∨ g = g<span class="hidden">⇩</span><sub>1</sub>"}. If @{prop"g ∈ isin s r"} then
\mbox{@{prop"safe s r"}} follows from @{prop"safe t r"} by
definition of @{thm[source]enter_room} because @{prop"g ∈ isin s r"}
implies @{prop"isin s r ≠ {}"}. Hence the induction hypothesis implies the
claim.  If @{prop"g = g<span class="hidden">⇩</span><sub>1</sub>"} we make another case distinction.
If @{prop"k<span class="hidden">⇩</span><sub>2</sub> = roomk s r"}, the claim follows immediately from
Lemma~\ref{state-lemmas}.\ref{safe_only_owner_enter_normal} above:
only the owner of a room can possess a card where the second
key is the room key.
If @{prop"k<span class="hidden">⇩</span><sub>1</sub> = roomk s r"} then, by definition of @{thm[source]enter_room},
@{prop"safe t r"} implies @{prop"owns s r = ⌊g⌋ ∨ safe s r"}.
In the first case the claim is immediate. If @{prop"safe s r"}
then @{prop"roomk s r = currk s r"}
(by Lemma~\ref{state-lemmas}.\ref{safe_roomk_currk})
and thus @{prop"(currk s r, k<span class="hidden">⇩</span><sub>2</sub>) ∈ cards s g"} by assumption
@{prop"(k<span class="hidden">⇩</span><sub>1</sub>,k<span class="hidden">⇩</span><sub>2</sub>) ∈ cards s g<span class="hidden">⇩</span><sub>1</sub>"}, thus contradicting
Lemma~\ref{state-lemmas}.\ref{key1_not_currk}.

This detailed proof shows that a number of case distinctions are
required. Luckily, they all suggest themselves to Isabelle via the
definition of function update (‹:=›) or via disjunctions that
arise automatically.
›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="NewCard">
<div class="head"><h1>Theory NewCard</h1>
<span class="command">theory</span> <span class="name">NewCard</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      State based hotel key card system with "new card"

    Author:     Tobias Nipkow, TU Muenchen

Like State.thy but with additional features: cards can be lost and new
ones can be issued. Cannot build on State.thy because record state
needs to be extended with a new field. This would require explaining
Isabelle's record inheritance. An interesting project, but not now.
*)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>NewCard</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"SomeFloor"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(⌊_⌋)"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⌊x⌋ ≡ Some x"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>if_split_asm</span><span class="delimiter">[</span><span>split</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">typedecl</span></span><span> </span><span>guest</span><span>
</span><span class="keyword1"><span class="command">typedecl</span></span><span> </span><span>key</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>card</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"key * key"</span></span></span><span>
</span><span class="keyword1"><span class="command">typedecl</span></span><span> </span><span>room</span><span>
</span><span>
</span><span class="keyword1"><span class="command">record</span></span><span> </span><span>state</span><span> </span><span class="delimiter">=</span><span>
</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* reception: *)</span></span></span></span></span><span>
</span><span> </span><span>owns</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"room ⇒ guest option"</span></span></span><span>
</span><span> </span><span>prevk</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"room ⇒ key"</span></span></span><span>
</span><span> </span><span>currk</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"room ⇒ key"</span></span></span><span>
</span><span> </span><span>issued</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"key set"</span></span></span><span>
</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* guests: *)</span></span></span></span></span><span>
</span><span> </span><span>cards</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"guest ⇒ card set"</span></span></span><span>
</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* rooms: *)</span></span></span></span></span><span>
</span><span> </span><span>roomk</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"room ⇒ key"</span></span></span><span>
</span><span> </span><span>isin</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"room ⇒ guest set"</span></span></span><span>
</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* ghost variable: *)</span></span></span></span></span><span>
</span><span> </span><span>safe</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"room ⇒ bool"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_set</span></span><span> </span><span>reach</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"state set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>init</span><span class="delimiter">:</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* prevk = arbitrary prevents the invariant prevk : issued *)</span></span></span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"∀r r'. (initk r = initk r') = (r = r') ⟹
⦇ owns = (λr. None), prevk = initk, currk = initk, issued = range initk,
  cards = (λg. {}), roomk = initk, isin = (λr. {}),
  safe = (λr. True) ⦈ ∈ reach"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>enter_room</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦ s ∈ reach; (k,k') ∈ cards s g; roomk s r ∈ {k,k'} ⟧ ⟹
s⦇ isin := (isin s)(r := isin s r ∪ {g}),
   roomk := (roomk s)(r := k'),
   safe := (safe s)(r := owns s r = ⌊g⌋ ∧ isin s r = {} ∧ k' = currk s r
                              ∨ safe s r)
  ⦈ ∈ reach"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>exit_room</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦ s ∈ reach;  g ∈ isin s r ⟧ ⟹
s⦇ isin := (isin s)(r := isin s r - {g}) ⦈ ∈ reach"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>check_in</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦ s : reach; k ∉ issued s ⟧ ⟹
 s⦇currk := (currk s)(r := k), prevk := (prevk s)(r := currk s r),
   issued := issued s ∪ {k},
   cards := (cards s)(g := cards s g ∪ {(currk s r, k)}),
   owns :=  (owns s)(r := Some g),
   safe := (safe s)(r := False) ⦈ : reach"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>loose_card</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"s : reach ⟹ c : cards s g ⟹
 s⦇cards := (cards s)(g := cards s g - {c})⦈ : reach"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>new_card</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"s : reach ⟹ owns s r = Some g ⟹
 s⦇cards := (cards s)(g := cards s g ∪ {(prevk s r, currk s r)})⦈ : reach"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>currk_issued</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s : reach ⟹ currk s r : issued s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>set</span><span class="delimiter">:</span><span> </span><span>reach</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prevk_issued</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s : reach ⟹ prevk s r : issued s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>set</span><span class="delimiter">:</span><span> </span><span>reach</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>key2_issued</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s : reach ⟹ (k,k') : cards s g ⟹ k' : issued s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>set</span><span class="delimiter">:</span><span> </span><span>reach</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>key1_issued</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s : reach ⟹ (k,k') : cards s g ⟹ k : issued s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>set</span><span class="delimiter">:</span><span> </span><span>reach</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>roomk_issued</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s : reach ⟹ roomk s k : issued s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>set</span><span class="delimiter">:</span><span> </span><span>reach</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>currk_inj</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"s : reach ⟹ ∀r r'. (currk s r = currk s r') = (r = r')"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>set</span><span class="delimiter">:</span><span> </span><span>reach</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>currk_not_prevk</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"s : reach ⟹ owns s r' = Some g ⟹ currk s r ≠ prevk s r'"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>set</span><span class="delimiter">:</span><span> </span><span>reach</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>key1_not_currk</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"s : reach ⟹ (currk s r,k') ∉ cards s g"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>set</span><span class="delimiter">:</span><span> </span><span>reach</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>key2_not_currk</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"s : reach ⟹ owns s r = Some g ⟹ g ≠ g' ⟹ (k, currk s r) ∉ cards s g'"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>set</span><span class="delimiter">:</span><span> </span><span>reach</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>guest_key2_disj2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦ s : reach; (k<span class="hidden">⇩</span><sub>1</sub>,k) ∈ cards s g<span class="hidden">⇩</span><sub>1</sub>; (k<span class="hidden">⇩</span><sub>2</sub>,k) ∈ cards s g<span class="hidden">⇩</span><sub>2</sub> ⟧ ⟹ g<span class="hidden">⇩</span><sub>1</sub>=g<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>set</span><span class="delimiter">:</span><span> </span><span>reach</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>key2_not_currk</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>safe_roomk_currk</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"s : reach ⟹ safe s r ⟹ roomk s r = currk s r"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>set</span><span class="delimiter">:</span><span> </span><span>reach</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>only_owner_enter_normal</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ s : reach; safe s r; (k',roomk s r) ∈ cards s g ⟧ ⟹ owns s r = Some g"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>set</span><span class="delimiter">:</span><span> </span><span>reach</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s : reach ⟹ safe s r ⟹ g : isin s r ⟹ owns s r = Some g"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>set</span><span class="delimiter">:</span><span> </span><span>reach</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>new_invs</span><span> </span><span class="delimiter">=</span><span> </span><span>prevk_issued</span><span> </span><span>currk_not_prevk</span><span> </span><span>key2_not_currk</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹An extension›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
To test the flexibility of our model we extended it with the
possibility for obtaining a new card, e.g.\ when one has lost one's
card. Now reception needs to remember not just the current but also
the previous key for each room, i.e.\ a new field ‹prevk :: room
⇒ key› is added to @{typ state}. It is initialized with the same value
as @{const currk}: though strictly speaking it could be arbitrary,
this permits the convenient invariant @{prop"prevk s r ∈ issued s"}.
Upon check-in we set ‹prevk› to \mbox{@{term"(prevk s)(r := currk s r)"}}.
Event ‹new_card› is simple enough:
@{thm[display] new_card}

The verification is not seriously affected. Some additional
invariants are required
@{thm[display] new_invs}
but the proofs are still of the same trivial induct-auto format.

Adding a further event for loosing a card has no impact at all on the proofs.
›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="Trace">
<div class="head"><h1>Theory Trace</h1>
<span class="command">theory</span> <span class="name">Trace</span><br/>
<span class="keyword">imports</span> <a href="Basis.html"><span class="name">Basis</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Trace</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Basis</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>Let_def</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span>if_split_asm</span><span class="delimiter">[</span><span>split</span><span class="delimiter">]</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹A trace based model›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The only clumsy aspect of the state based model is ‹safe›: we use a state component to record if the sequence of events
that lead to a state satisfies some property. That is, we simulate a
condition on traces via the state. Unsurprisingly, it is not trivial
to convince oneself that ‹safe› really has the informal meaning
set out at the beginning of subsection~\ref{sec:formalizing-safety}.
Hence we now describe an alternative, purely trace based model,
similar to Paulson's inductive protocol model~\cite{Paulson-JCS98}.
The events are:
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>event</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>Check_in</span><span> </span><span>guest</span><span> </span><span>room</span><span> </span><span>card</span><span> </span><span class="delimiter">|</span><span> </span><span>Enter</span><span> </span><span>guest</span><span> </span><span>room</span><span> </span><span>card</span><span> </span><span class="delimiter">|</span><span> </span><span>Exit</span><span> </span><span>guest</span><span> </span><span>room</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Instead of a state, we have a trace, i.e.\ list of events, and
extract the state from the trace:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span>
</span><span>  </span><span>initk</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"room ⇒ key"</span></span></span><span>
</span><span>   
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>owns</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"event list ⇒ room ⇒ guest option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"owns [] r = None"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"owns (e#s) r = (case e of
 Check_in g r' c ⇒ if r' = r then Some g else owns s r |
 Enter g r' c ⇒ owns s r |
 Exit g r' ⇒ owns s r)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>currk</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"event list ⇒ room ⇒ key"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"currk [] r = initk r"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"currk (e#s) r = (let k = currk s r in
    case e of Check_in g r' c ⇒ if r' = r then snd c else k
            | Enter g r' c ⇒ k
            | Exit g r ⇒ k)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>issued</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"event list ⇒ key set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"issued [] = range initk"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"issued (e#s) = issued s ∪
  (case e of Check_in g r c ⇒ {snd c} | Enter g r c ⇒ {} | Exit g r ⇒ {})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>cards</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"event list ⇒ guest ⇒ card set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"cards [] g = {}"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"cards (e#s) g = (let C = cards s g in
                    case e of Check_in g' r c ⇒ if g' = g then insert c C
                                                else C
                            | Enter g r c ⇒ C
                            | Exit g r ⇒ C)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>roomk</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"event list ⇒ room ⇒ key"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"roomk [] r = initk r"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"roomk (e#s) r = (let k = roomk s r in
    case e of Check_in g r' c ⇒ k
            | Enter g r' (x,y) ⇒ if r' = r ⌦‹∧ x = k› then y else k
            | Exit g r ⇒ k)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>isin</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"event list ⇒ room ⇒ guest set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"isin [] r = {}"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"isin (e#s) r = (let G = isin s r in
                 case e of Check_in g r c ⇒ G
                 | Enter g r' c ⇒ if r' = r then {g} ∪ G else G
                 | Exit g r' ⇒ if r'=r then G - {g} else G)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>hotel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"event list ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"hotel []  = True"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"hotel (e # s) = (hotel s &amp; (case e of
  Check_in g r (k,k') ⇒ k = currk s r ∧ k' ∉ issued s |
  Enter g r (k,k') ⇒ (k,k') : cards s g &amp; (roomk s r : {k, k'}) |
  Exit g r ⇒ g : isin s r))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Except for @{const initk}, which is completely unspecified,
all these functions are defined by primitive recursion over traces:
@{thm[display]owns.simps}
@{thm[display]currk.simps}
@{thm[display]issued.simps}
@{thm[display]cards.simps}
@{thm[display]roomk.simps}
@{thm[display]isin.simps}

However, not every trace is possible. Function @{const hotel} tells us
which traces correspond to real hotels:
@{thm[display]hotel.simps}
Alternatively we could have followed Paulson~\cite{Paulson-JCS98}
in defining @{const hotel} as an inductive set of traces.
The difference is only slight.

\subsection{Formalizing safety}
\label{sec:FormalSafetyTrace}

The principal advantage of the trace model is the intuitive
specification of safety. Using the auxiliary predicate ‹no_Check_in›
›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>no_Check_in</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"event list ⇒ room ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"no_Check_in s r ≡ ¬(∃g c. Check_in g r c ∈ set s)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹\medskip\noindent we define a trace to be ‹safe<span class="hidden">⇩</span><sub>0</sub>› for a
room if the card obtained at the last @{const Check_in} was later
actually used to @{const Enter} the room:›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>safe<span class="hidden">⇩</span><sub>0</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"event list ⇒ room ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"safe<span class="hidden">⇩</span><sub>0</sub> s r = (∃s<span class="hidden">⇩</span><sub>1</sub> s<span class="hidden">⇩</span><sub>2</sub> s<span class="hidden">⇩</span><sub>3</sub> g c.
 s = s<span class="hidden">⇩</span><sub>3</sub> @ [Enter g r c] @ s<span class="hidden">⇩</span><sub>2</sub> @ [Check_in g r c] @ s<span class="hidden">⇩</span><sub>1</sub> ∧ no_Check_in (s<span class="hidden">⇩</span><sub>3</sub> @ s<span class="hidden">⇩</span><sub>2</sub>) r)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹\medskip\noindent A trace is ‹safe› if additionally the room was
empty when it was entered:›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>safe</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"event list ⇒ room ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"safe s r = (∃s<span class="hidden">⇩</span><sub>1</sub> s<span class="hidden">⇩</span><sub>2</sub> s<span class="hidden">⇩</span><sub>3</sub> g c.
 s = s<span class="hidden">⇩</span><sub>3</sub> @ [Enter g r c] @ s<span class="hidden">⇩</span><sub>2</sub> @ [Check_in g r c] @ s<span class="hidden">⇩</span><sub>1</sub> ∧
 no_Check_in (s<span class="hidden">⇩</span><sub>3</sub> @ s<span class="hidden">⇩</span><sub>2</sub>) r ∧ isin (s<span class="hidden">⇩</span><sub>2</sub> @ [Check_in g r c] @ s<span class="hidden">⇩</span><sub>1</sub>) r = {})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹\medskip\noindent The two notions of safety are distinguished because,
except for the main theorem, @{const safe<span class="hidden">⇩</span><sub>0</sub>} suffices.

The alert reader may already have wondered why, in contrast to the
state based model, we do not require @{const initk} to be
injective. If @{const initk} is not injective, e.g.\ @{prop"initk
r<span class="hidden">⇩</span><sub>1</sub> = initk r<span class="hidden">⇩</span><sub>2</sub>"} and @{prop"r<span class="hidden">⇩</span><sub>1</sub> ≠ r<span class="hidden">⇩</span><sub>2</sub>"},
then @{term"[Enter g r<span class="hidden">⇩</span><sub>2</sub> (initk r<span class="hidden">⇩</span><sub>1</sub>,k), Check_in g
r<span class="hidden">⇩</span><sub>1</sub> (initk r<span class="hidden">⇩</span><sub>1</sub>,k)]"} is a legal trace and guest ‹g› ends up in a room he is not the owner of.  However, this is not a
safe trace for room ‹r<span class="hidden">⇩</span><sub>2</sub>› according to our
definition. This reflects that hotel rooms are not safe until
the first time their owner has entered them. We no longer protect the
hotel from its guests.›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* state thm w/o "isin"
hotel s ==&gt; s = Enter g # s' ⟹ owns s' r = Some g ∨ s' = s1 @ Checkin g @ s2 ∧ 
no checkin, no enter in s1

*)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>safe_safe</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"safe s r ⟹ safe<span class="hidden">⇩</span><sub>0</sub> s r"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe<span class="hidden">⇩</span><sub>0</sub>_def</span><span> </span><span>safe_def</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>initk_issued</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hotel s ⟹ initk r ∈ issued s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span>event.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>currk_issued</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hotel s ⟹ currk s r ∈ issued s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span>event.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>key1_issued</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hotel s ⟹ (k,k') : cards s g ⟹ k ∈ issued s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span>event.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>key2_issued</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hotel s ⟹ (k,k') : cards s g ⟹ k' ∈ issued s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span>event.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>roomk_issued</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hotel s ⟹ roomk s r ∈ issued s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span>event.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>issued_app</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"issued (s @ s') = issued s ∪ issued s'"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span>event.split</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s'</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span>event.split</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>owns_app</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"no_Check_in s<span class="hidden">⇩</span><sub>2</sub> r ⟹ owns (s<span class="hidden">⇩</span><sub>2</sub> @ s<span class="hidden">⇩</span><sub>1</sub>) r = owns s<span class="hidden">⇩</span><sub>1</sub> r"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s<span class="hidden">⇩</span><sub>2</sub></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span>event.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>currk_app</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"no_Check_in s<span class="hidden">⇩</span><sub>2</sub> r ⟹ currk (s<span class="hidden">⇩</span><sub>2</sub> @ s<span class="hidden">⇩</span><sub>1</sub>) r = currk s<span class="hidden">⇩</span><sub>1</sub> r"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s<span class="hidden">⇩</span><sub>2</sub></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span>event.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>currk_Check_in</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ hotel (s<span class="hidden">⇩</span><sub>2</sub> @ Check_in g r (k, k')# s<span class="hidden">⇩</span><sub>1</sub>);
    k' = currk (s<span class="hidden">⇩</span><sub>2</sub> @ Check_in g r (k, k') # s<span class="hidden">⇩</span><sub>1</sub>) r' ⟧ ⟹ r' = r"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s<span class="hidden">⇩</span><sub>2</sub></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>issued_app</span><span> </span><span>split</span><span class="delimiter">:</span><span>event.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_checkin_no_newkey</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦ hotel(s<span class="hidden">⇩</span><sub>2</sub> @ [Check_in g r (k,k')] @ s<span class="hidden">⇩</span><sub>1</sub>); no_Check_in s<span class="hidden">⇩</span><sub>2</sub> r ⟧
 ⟹ (k',k'') ∉ cards (s<span class="hidden">⇩</span><sub>2</sub> @ Check_in g r (k,k') # s<span class="hidden">⇩</span><sub>1</sub>) g'"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>s<span class="hidden">⇩</span><sub>2</sub></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>split</span><span class="delimiter">:</span><span>event.splits</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>currk_Check_in</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>guest_key2_disj2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">"⟦ hotel s; (k<span class="hidden">⇩</span><sub>1</sub>,k) ∈ cards s g<span class="hidden">⇩</span><sub>1</sub>; (k<span class="hidden">⇩</span><sub>2</sub>,k) ∈ cards s g<span class="hidden">⇩</span><sub>2</sub> ⟧ ⟹ g<span class="hidden">⇩</span><sub>1</sub>=g<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span>event.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>safe_roomk_currk</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"hotel s ⟹ safe<span class="hidden">⇩</span><sub>0</sub> s r ⟹ roomk s r = currk s r"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span>safe<span class="hidden">⇩</span><sub>0</sub>_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>hypsubst_thin</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span>s<span class="hidden">⇩</span><sub>3</sub></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span>event.split</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>guest</span><span> </span><span>ba</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"(b, ba)
        ∉ cards ((list @ Enter g r (a, b) # s<span class="hidden">⇩</span><sub>2</sub>) @ Check_in g r (a, b) # s<span class="hidden">⇩</span><sub>1</sub>)
           guest"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>no_checkin_no_newkey</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>only_owner_enter_normal</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ hotel s; safe<span class="hidden">⇩</span><sub>0</sub> s r; (k,roomk s r) ∈ cards s g ⟧ ⟹ owns s r = Some g"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span>safe<span class="hidden">⇩</span><sub>0</sub>_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>hypsubst_thin</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span>s<span class="hidden">⇩</span><sub>3</sub></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>issued_app</span><span> </span><span>split</span><span class="delimiter">:</span><span>event.split</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* A short proof *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ hotel s; safe s r; g ∈ isin s r ⟧ ⟹ owns s r = Some g"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>safe_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>hypsubst_thin</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>g'</span><span> </span><span>k</span><span> </span><span>k'</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span>s<span class="hidden">⇩</span><sub>3</sub></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span>event.split</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subgoal_tac</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"safe<span class="hidden">⇩</span><sub>0</sub> (list @ Enter g' r (k,k') # s<span class="hidden">⇩</span><sub>2</sub> @ Check_in g' r (k, k') # s<span class="hidden">⇩</span><sub>1</sub>) r"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>safe<span class="hidden">⇩</span><sub>0</sub>_def</span><span class="delimiter">)</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cut_tac</span><span> </span><span>s<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"list @ Enter g' r (k, k') # s<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>no_checkin_no_newkey</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subgoal_tac</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"safe<span class="hidden">⇩</span><sub>0</sub> (list @ Enter g' r (k,k') # s<span class="hidden">⇩</span><sub>2</sub> @ Check_in g' r (k, k') # s<span class="hidden">⇩</span><sub>1</sub>) r"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>only_owner_enter_normal</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>safe<span class="hidden">⇩</span><sub>0</sub>_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_set_conv_decomp_firstD</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P x"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ set xs ⟹
  ∃ys x zs. xs = ys @ x # zs ∧ P x ∧ (∀y ∈ set ys. ¬ P y)"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ ⟹ ∃ys x zs. ?P xs ys x zs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = a ∨ P a"</span></span></span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?P (a#xs) [] a xs"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹P x›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(x = a ∨ P a)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span>Cons</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>clarsimp</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>Cons_eq_appendI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ownsD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"owns s r = Some g ⟹
 ∃s<span class="hidden">⇩</span><sub>1</sub> s<span class="hidden">⇩</span><sub>2</sub> g c. s = s<span class="hidden">⇩</span><sub>2</sub> @ [Check_in g r c] @ s<span class="hidden">⇩</span><sub>1</sub> ∧ no_Check_in s<span class="hidden">⇩</span><sub>2</sub> r"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span>event.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>s<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>s<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>s<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_Check_in_owns</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"no_Check_in s r ⟹ owns s r = None"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span>event.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Enter_safe</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ hotel(Enter g r c # s); safe<span class="hidden">⇩</span><sub>0</sub> s r ⟧ ⟹ owns s r = Some g"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃s<span class="hidden">⇩</span><sub>1</sub> s<span class="hidden">⇩</span><sub>2</sub> g c. s = s<span class="hidden">⇩</span><sub>2</sub> @ [Check_in g r c] @ s<span class="hidden">⇩</span><sub>1</sub> ∧ no_Check_in s<span class="hidden">⇩</span><sub>2</sub> r"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>safe<span class="hidden">⇩</span><sub>0</sub>_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>elim</span><span> </span><span>exE</span><span> </span><span>conjE</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>s<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>elim</span><span> </span><span>exE</span><span> </span><span>conjE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>no_checkin_no_newkey</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>frule</span><span> </span><span>only_owner_enter_normal</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>safe_future</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"safe<span class="hidden">⇩</span><sub>0</sub> s r ⟹ no_Check_in s' r ⟹ safe<span class="hidden">⇩</span><sub>0</sub> (s' @ s) r"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span>safe<span class="hidden">⇩</span><sub>0</sub>_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>s<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>s<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>Enter_safe_future</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ hotel(Enter g r c # s' @ s); safe<span class="hidden">⇩</span><sub>0</sub> s r; no_Check_in s' r ⟧
 ⟹ owns s r = Some g"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>safe_future</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Enter_safe</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
  \begin{figure}
  \begin{center}\begin{minipage}{\textwidth}  
  \isastyle\isamarkuptrue
›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>safe</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hotel s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"safe s r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g ∈ isin s r"</span></span></span><span>
</span><span>                    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"owns s r = ⌊g⌋"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>s<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>s<span class="hidden">⇩</span><sub>3</sub></span><span> </span><span>g'</span><span> </span><span>k</span><span> </span><span>k'</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?b</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"[Enter g' r (k,k')] @ s<span class="hidden">⇩</span><sub>2</sub> @ [Check_in g' r (k,k')] @ s<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"s<span class="hidden">⇩</span><sub>3</sub> @ ?b"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isin (s<span class="hidden">⇩</span><sub>2</sub> @ [Check_in g' r (k,k')] @ s<span class="hidden">⇩</span><sub>1</sub>) r = {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ hotel ?s; no_Check_in (s<span class="hidden">⇩</span><sub>3</sub> @ s<span class="hidden">⇩</span><sub>2</sub>) r; g ∈ isin ?s r ⟧ ⟹ g' = g"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>s<span class="hidden">⇩</span><sub>3</sub></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>e</span><span> </span><span>s<span class="hidden">⇩</span><sub>3</sub></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?s</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"s<span class="hidden">⇩</span><sub>3</sub> @ ?b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="var">?t</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(e ⋅ s<span class="hidden">⇩</span><sub>3</sub>) @ ?b"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Enter</span><span> </span><span>g''</span><span> </span><span>r'</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g' = g"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r' = r"</span></span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g' = g"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g'' = g"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hotel ?s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∈ cards ?s g"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹hotel ?t›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"safe ?s r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹no_Check_in ((e ⋅ s<span class="hidden">⇩</span><sub>3</sub>) @ s<span class="hidden">⇩</span><sub>2</sub>) r›</span></span></span><span> </span><span>0</span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>safe_def</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>            </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>k<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c = (k<span class="hidden">⇩</span><sub>1</sub>,k<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"roomk ?s r = k'"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>safe_roomk_currk</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>safe_safe</span><span class="delimiter">[</span><span>OF</span><span> </span><span>3</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>                </span><span class="cartouche"><span class="delete"><span class="delete">‹no_Check_in ((e ⋅ s<span class="hidden">⇩</span><sub>3</sub>) @ s<span class="hidden">⇩</span><sub>2</sub>) r›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k<span class="hidden">⇩</span><sub>1</sub> ≠ roomk ?s r"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_checkin_no_newkey</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"s<span class="hidden">⇩</span><sub>3</sub> @ [Enter g' r (k,k')] @ s<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span class="delimiter">]</span><span>
</span><span>                </span><span>1</span><span> </span><span>2</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹no_Check_in ((e ⋅ s<span class="hidden">⇩</span><sub>3</sub>) @ s<span class="hidden">⇩</span><sub>2</sub>) r›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k<span class="hidden">⇩</span><sub>2</sub> = roomk ?s r"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹hotel ?t›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>only_owner_enter_normal</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>safe_safe</span><span class="delimiter">[</span><span>OF</span><span> </span><span>3</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>2</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"owns ?t r =  ⌊g⌋"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"owns ?t r = ⌊g'⌋"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹hotel ?t›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹no_Check_in ((e ⋅ s<span class="hidden">⇩</span><sub>3</sub>) @ s<span class="hidden">⇩</span><sub>2</sub>) r›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g' = g"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g'' ≠ g"</span></span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g' = g"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r' ≠ r"</span></span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g' = g"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>Cons</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"owns s r = ⌊g⌋"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>safe_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
  \end{minipage}
  \end{center}
  \caption{Isar proof of Theorem~\ref{safe}}\label{fig:proof}
  \end{figure}
›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
\subsection{Verifying safety}

Lemma~\ref{state-lemmas} largely carries over after replacing
\mbox{@{prop"s : reach"}} by @{prop"hotel s"} and @{const safe} by
@{const safe<span class="hidden">⇩</span><sub>0</sub>}. Only properties \ref{currk_inj} and
\ref{key1_not_currk} no longer hold because we no longer assume that
@{const roomk} is initially injective.
They are replaced by two somewhat similar properties:
\begin{lemma}\label{trace-lemmas}\mbox{}
\begin{enumerate}
\item @{thm[display,margin=80]currk_Check_in}
\item \label{no_checkin_no_newkey}
  @{thm[display,margin=100] no_checkin_no_newkey}
\end{enumerate}
\end{lemma}
Both are proved by induction on ‹s<span class="hidden">⇩</span><sub>2</sub>›.
In addition we need some easy structural properties:
\begin{lemma}\label{app-lemmas}
\begin{enumerate}
\item @{thm issued_app}
\item @{thm owns_app}
\item \label{currk_app} @{thm currk_app}
\end{enumerate}
\end{lemma}

The main theorem again correspond closely to its state based
counterpart:
\begin{theorem}\label{safe}
@{thm[mode=IfThen] safe}
\end{theorem}
Let us examine the proof of this theorem to show how it differs from
the state based version. For the core of the proof let
@{prop"s = s<span class="hidden">⇩</span><sub>3</sub> @ [Enter g' r (k,k')] @ s<span class="hidden">⇩</span><sub>2</sub> @ [Check_in g' r (k,k')] @ s<span class="hidden">⇩</span><sub>1</sub>"}
and assume
@{prop"isin (s<span class="hidden">⇩</span><sub>2</sub> @ [Check_in g' r (k,k')] @ s<span class="hidden">⇩</span><sub>1</sub>) r = {}"} (0). By induction on
‹s<span class="hidden">⇩</span><sub>3</sub>› we prove
@{prop[display]"⟦hotel s; no_Check_in (s<span class="hidden">⇩</span><sub>3</sub> @ s<span class="hidden">⇩</span><sub>2</sub>) r; g ∈ isin s r ⟧ ⟹ g' = g"}
The actual theorem follows by definition of @{const safe}.
The base case of the induction follows from (0). For the induction step let
@{prop"t = (e#s<span class="hidden">⇩</span><sub>3</sub>) @ [Enter g' r (k,k')] @ s<span class="hidden">⇩</span><sub>2</sub> @ [Check_in g' r (k,k')] @ s<span class="hidden">⇩</span><sub>1</sub>"}.
We assume @{prop"hotel t"}, @{prop"no_Check_in ((e#s<span class="hidden">⇩</span><sub>3</sub>) @ s<span class="hidden">⇩</span><sub>2</sub>) r"},
and @{prop"g ∈ isin s r"}, and show @{prop"g' = g"}.
The proof is by case distinction on the event ‹e›.
The cases @{const Check_in} and @{const Exit} follow directly from the
induction hypothesis because the set of occupants of ‹r›
can only decrease. Now we focus on the case @{prop"e = Enter g'' r' c"}.
If @{prop"r' ≠ r"} the set of occupants of ‹r› remains unchanged
and the claim follow directly from the induction hypothesis.
If @{prop"g'' ≠ g"} then ‹g› must already have been in ‹r›
before the ‹Enter› event and the claim again follows directly
from the induction hypothesis. Now assume @{prop"r' = r"}
and @{prop"g'' = g"}.
From @{prop"hotel t"} we obtain @{prop"hotel s"} (1) and
@{prop"c ∈ cards s g"} (2), and
from @{prop"no_Check_in (s<span class="hidden">⇩</span><sub>3</sub> @ s<span class="hidden">⇩</span><sub>2</sub>) r"} and (0)
we obtain @{prop"safe s r"} (3). Let @{prop"c = (k<span class="hidden">⇩</span><sub>1</sub>,k<span class="hidden">⇩</span><sub>2</sub>)"}.
From Lemma~\ref{state-lemmas}.\ref{safe_roomk_currk} and
Lemma~\ref{app-lemmas}.\ref{currk_app} we obtain
‹roomk s r = currk s r = k'›.
Hence @{prop"k<span class="hidden">⇩</span><sub>1</sub> ≠ roomk s r"} by
Lemma~\ref{trace-lemmas}.\ref{no_checkin_no_newkey}
using (1), (2) and @{prop"no_Check_in (s<span class="hidden">⇩</span><sub>3</sub> @ s<span class="hidden">⇩</span><sub>2</sub>) r"}.
Hence @{prop"k<span class="hidden">⇩</span><sub>2</sub> = roomk s r"} by @{prop"hotel t"}.
With Lemma~\ref{state-lemmas}.\ref{safe_only_owner_enter_normal}
and (1--3) we obtain
@{prop"owns t r =  ⌊g⌋"}. At the same time we have @{prop"owns t r = ⌊g'⌋"}
because @{prop"hotel t"} and @{prop"no_Check_in ((e # s<span class="hidden">⇩</span><sub>3</sub>) @ s<span class="hidden">⇩</span><sub>2</sub>) r"}: nobody
has checked in to room ‹r› after ‹g'›. Thus the claim
@{prop"g' = g"} follows.

The details of this proof differ from those of Theorem~\ref{safe-state}
but the structure is very similar.

\subsection{Eliminating \isa{isin}}

In the state based approach we needed @{const isin} to express our
safety guarantees. In the presence of traces, we can do away with it
and talk about @{const Enter} events instead. We show that if somebody
enters a safe room, he is the owner:
\begin{theorem}\label{Enter_safe}
@{thm[mode=IfThen] Enter_safe}
\end{theorem}
From @{prop"safe<span class="hidden">⇩</span><sub>0</sub> s r"} it follows that ‹s› must be of the form
@{term"s<span class="hidden">⇩</span><sub>2</sub> @ [Check_in g<span class="hidden">⇩</span><sub>0</sub> r c'] @ s<span class="hidden">⇩</span><sub>1</sub>"} such that @{prop"no_Check_in s<span class="hidden">⇩</span><sub>2</sub> r"}.
Let @{prop"c = (x,y)"} and @{prop"c' = (k,k')"}.
By Lemma~\ref{state-lemmas}.\ref{safe_roomk_currk} we have
‹roomk s r = currk s r = k'›.
From @{prop"hotel(Enter g r c # s)"} it follows that
@{prop"(x,y) ∈ cards s g"} and @{prop"k' ∈ {x,y}"}.
By Lemma~\ref{trace-lemmas}.\ref{no_checkin_no_newkey}
@{prop"x = k'"} would contradict @{prop"(x,y) ∈ cards s g"}.
Hence @{prop"y = k'"}.
With Lemma~\ref{state-lemmas}.\ref{safe_only_owner_enter_normal}
we obtain @{prop"owns s r = ⌊g⌋"}.

Having dispensed with @{const isin} we could also eliminate @{const
Exit} to arrive at a model closer to the ones in~\cite{Jackson06}.

Finally one may quibble that all the safety theorems proved so far
assume safety of the room at that point in time when somebody enters
it.  That is, the owner of the room must be sure that once a room is
safe, it stays safe, in order to profit from those safety theorems.
Of course, this is the case as long as nobody else checks in to that room:
\begin{lemma}
@{thm[mode=IfThen]safe_future}
\end{lemma}
It follows easily that Theorem~\ref{Enter_safe} also extends until check-in:
\begin{corollary}
@{thm[mode=IfThen]Enter_safe_future}
\end{corollary}

\subsection{Completeness of @{const safe}}

Having proved correctness of @{const safe}, i.e.\ that safe behaviour
protects against intruders, one may wonder if @{const safe} is
complete, i.e.\ if it covers all safe behaviour, or if it is too
restrictive. It turns out that @{const safe} is incomplete for two
different reasons.  The trivial one is that in case @{const initk} is
injective, every room is protected against intruders right from the
start. That is, @{term"[Check_in g r c]"} will only allow @{term g} to
enter ‹r› until somebody else checks in to ‹r›. The
second, more subtle incompleteness is that even if there are previous
owners of a room, it may be safe to enter a room with an old card
‹c›: one merely needs to make sure that no other guest checked
in after the check-in where one obtained ‹c›. However,
formalizing this is not only messy, it is also somewhat pointless:
this liberalization is not something a guest can take advantage of
because there is no (direct) way he can find out which of his cards
meets this criterion. But without this knowledge, the only safe thing
to do is to make sure he has used his latest card. This incompleteness
applies to the state based model as well.
›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="Equivalence">
<div class="head"><h1>Theory Equivalence</h1>
<span class="command">theory</span> <span class="name">Equivalence</span><br/>
<span class="keyword">imports</span> <a href="State.html"><span class="name">State</span></a> <a href="Trace.html"><span class="name">Trace</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Equivalence</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>State</span><span> </span><span>Trace</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"safe [] = (%r. False)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>Trace.safe_def</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"safe (Exit g r # t) r' = safe t r'"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>Trace.safe_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>s<span class="hidden">⇩</span><sub>3</sub></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>s<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>s<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>s<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>s<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ safe (Check_in g r c # t) r"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>Trace.safe_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>s<span class="hidden">⇩</span><sub>3</sub></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r ≠ r' ⟹ safe (Check_in g r' c # t) r = safe t r"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>Trace.safe_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>s<span class="hidden">⇩</span><sub>3</sub></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>s<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>s<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>s<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>s<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r ≠ r' ⟹ safe (Enter g r' c # t) r = safe t r"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>Trace.safe_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>s<span class="hidden">⇩</span><sub>3</sub></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>s<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>s<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>s<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>s<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reach_cong</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r : reach ⟹ r = r' ⟹ r' : reach"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cards_app</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cards (s @ s') g = cards s g ∪ cards s' g"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span>event.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ownsD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"owns s r = Some g ⟹
 ∃s<span class="hidden">⇩</span><sub>1</sub> s<span class="hidden">⇩</span><sub>2</sub> c. s = s<span class="hidden">⇩</span><sub>2</sub> @ [Check_in g r c] @ s<span class="hidden">⇩</span><sub>1</sub> ∧ no_Check_in s<span class="hidden">⇩</span><sub>2</sub> r"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span>event.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>s<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>s<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>s<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"safe t r ⟹ safe (Enter g r c # t) r"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span>Trace.safe_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>s<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>s<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>same_key2D</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"hotel (s<span class="hidden">⇩</span><sub>2</sub> @ Check_in g r (k<span class="hidden">⇩</span><sub>2</sub>,k) # s<span class="hidden">⇩</span><sub>1</sub>) ⟹
 (k<span class="hidden">⇩</span><sub>1</sub>,k) : cards(s<span class="hidden">⇩</span><sub>2</sub> @ Check_in g r (k<span class="hidden">⇩</span><sub>2</sub>,k) # s<span class="hidden">⇩</span><sub>1</sub>) g' ⟹ g=g' ∧ k<span class="hidden">⇩</span><sub>1</sub>=k<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>s<span class="hidden">⇩</span><sub>2</sub></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>simp_depth_limit</span><span> </span><span class="delimiter">=</span><span> </span><span>5</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>issued_app</span><span> </span><span>split</span><span class="delimiter">:</span><span>event.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>safe_Enter</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hotel (Enter g r (k,k') # t) ⟹
 safe (Enter g r (k,k') # t) r =
 (owns t r = ⌊g⌋ ∧ isin t r = {} ∧ k' = currk t r ∨ safe t r)"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>frule_tac</span><span> </span><span>g</span><span class="delimiter">=</span><span>g</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Trace.safe</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>Trace.safe_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>s<span class="hidden">⇩</span><sub>3</sub></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>conjE</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule</span><span> </span><span>ownsD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>Trace.safe_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>same_key2D</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>s<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>s<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hotel_reach</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inj initk ⟹ hotel t ⟹ ⦇ state.owns = owns t,
 state.currk = currk t,
 state.issued = issued t,
 state.cards = cards t,
 state.roomk = roomk t,
 state.isin = isin t,
 state.safe = (%r. safe t r ∨ owns t r =  None)⦈ : reach"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>insert</span><span> </span><span>State.init</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>initk</span><span class="delimiter">=</span><span>initk</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>reach_cong</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span>event.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>3</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule</span><span> </span><span>exit_room</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>reach_cong</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>guest</span><span> </span><span>room</span><span> </span><span>key</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>g</span><span> </span><span class="delimiter">=</span><span> </span><span>guest</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>r</span><span> </span><span class="delimiter">=</span><span> </span><span>room</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>check_in</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>reach_cong</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>guest</span><span> </span><span>room</span><span> </span><span>key1</span><span> </span><span>key2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>g</span><span> </span><span class="delimiter">=</span><span> </span><span>guest</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>r</span><span> </span><span class="delimiter">=</span><span> </span><span>room</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>enter_room</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>reach_cong</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reach_hotel</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s : reach ⟹
 ∃t ik. initk = ik ⟶ hotel t ∧
 state.cards s = cards t ∧
 state.isin s =  isin t ∧
 state.roomk s = roomk t ∧ state.owns s = owns t ∧
 state.currk s = currk t ∧
 state.issued s = issued t ∧
 state.safe s = (λr. safe t r ∨ owns t r = None)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>reach.induct</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Check_in g r (currk t r,k) # t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span>room</span><span class="delimiter">]</span><span> </span><span>fun_eq_iff</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span>guest</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span>room</span><span class="delimiter">]</span><span> </span><span>fun_eq_iff</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span>guest</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="tfree">'b</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"(key × key) set"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Enter g r (roomk t r,k') # t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Enter g r (k, roomk t r) # t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Exit g r # t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span>room</span><span class="delimiter">]</span><span> </span><span>fun_eq_iff</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span>guest</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="tfree">'b</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"(key × key) set"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Equivalence›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Although the state based and the trace based model look similar
enough, the
nagging feeling remains that they could be subtly different. Hence I
wanted to show the equivalence formally. This was very fortunate,
because it revealed some unintended discrepancies (no longer
present). Although I had proved both systems safe, it turned out that
the state based version of safety was more restrictive than the trace
based one. In the state based version of ‹safe› the room had to
be empty the first time the owner enters with the latest card, whereas
in the trace based version any time the owner enters with the latest
card can make a room safe.  Such errors in an automaton checking a
trace property are very common and show the superiority of the trace
based formalism.

When comparing the two models we have to take two slight differences
into account:
\begin{itemize}

\item The initial setting of the room keys @{const Trace.initk} in the
trace based model is an arbitrary but fixed value.  In the state based
model any injective initial value is fine.

\item As a consequence (see the end of
Section~\ref{sec:FormalSafetyTrace}) @{const state.safe} is initially
true whereas @{const Trace.safe} is initially false.

\end{itemize}
Since many names occur in both models they are disambiguated by the
prefixes ‹state› and ‹Trace›.

In the one direction I have shown that any hotel trace starting
with an injective @{const initk} gives rise to a reachable state
when the components of that state are computed by the trace functions:
@{thm[display]hotel_reach}

Conversely, for any reachable state there is a hotel trace leading to it:
@{thm[display]reach_hotel}
The precondition @{prop"initk = ik"} just says that we can find some
interpretation for @{const initk} that works, namely the one that was
chosen as the initial setting for the keys in @{term s}.

\sloppy
The proofs are almost automatic, except for the ‹safe›
component. In essence, we have to show that the procedural @{const
state.safe} implements the declarative @{const Trace.safe}. The proof
was complicated by the fact that initially it was not true and I had
to debug @{const Trace.safe} by proof.
Unfortunately Isabelle's current counterexample
finders~\cite{BerghoferN-SEFM04,Weber05bounded}
did not seem to work here due to search space reasons.
Once the bugs were ironed out, the following key lemma,
together with some smaller lemmas,
automated the correspondence proof for ‹safe›:
@{thm[display]safe_Enter}
In addition we used many lemmas from the trace model, including
Theorem~\ref{safe}.
\fussy

›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div>