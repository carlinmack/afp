<div id="MC">
<div class="head"><h1>Theory MC</h1>
<span class="command">theory</span> <span class="name">MC</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Kripke structures and CTL"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We apply Kripke structures and CTL to model state based systems and analyse properties under 
dynamic state changes. Snapshots of systems are the states on which we define a state transition. 
Temporal logic is then employed to express security and privacy properties.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>MC</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Lemmas to support least and greatest fixpoints"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>predtrans_empty</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mono (τ :: 'a set ⇒ 'a set)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ i. (τ ^^ i) ({}) ⊆ (τ ^^(i + 1))({})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>funpow_decreasing</span><span> </span><span>le_add1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ex_card</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite S ⟹ ∃ n:: nat. card S = n"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>less_not_le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦(x:: nat) &lt; y; y ≤ x⟧ ⟹ False"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>infchain_outruns_all</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (UNIV :: 'a set)"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i :: nat. ((τ :: 'a set ⇒ 'a set)^^ i) ({}:: 'a set) ⊂ (τ ^^ (i + 1)) {}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀j :: nat. ∃i :: nat. j &lt; card ((τ ^^ i) {})"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span class="delimiter">,</span><span> </span><span>induct_tac</span><span> </span><span>j</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃i. 0 &lt; card ((τ ^^ i) {})"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>bot.not_eq_extremum</span><span> </span><span>card_gt_0_iff</span><span> </span><span>finite_subset</span><span> </span><span>subset_UNIV</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀j n. ∃i. n &lt; card ((τ ^^ i) {}) 
             ⟹ ∃i. Suc n &lt; card ((τ ^^ i) {})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>j</span><span> </span><span>n</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃i. n &lt; card ((τ ^^ i) {})"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n &lt; card ((τ ^^ i) {})"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ i. Suc n &lt; card ((τ ^^ i) {})"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>finite_subset</span><span> </span><span>le_less_trans</span><span> </span><span>le_simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>psubset_card_mono</span><span> </span><span>subset_UNIV</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_infinite_subset_chain</span><span class="delimiter">:</span><span> 
</span><span>   </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (UNIV :: 'a set)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"mono (τ :: ('a set ⇒ 'a set))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀i :: nat. ((τ :: 'a set ⇒ 'a set) ^^ i) {} ⊂ (τ ^^ (i + (1 :: nat))) ({} :: 'a set)"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Proof idea: since @{term "UNIV"} is finite, we have from @{text ‹ex_card›} that there is
    an n with @{term "card UNIV = n"}. Now, use @{text ‹infchain_outruns_all›} to show as 
    contradiction point that
    @{term "∃ i :: nat. card UNIV &lt; card ((τ ^^ i) {})"}. 
    Since all sets are subsets of @{term "UNIV"}, we also have 
    @{term "card ((τ ^^ i) {}) ≤ card UNIV"}:
    Contradiction!, i.e. proof of False  ›</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ (j :: nat). (∃ (i :: nat). (j :: nat) &lt; card((τ ^^ i)({} :: 'a set)))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>τ</span><span> </span><span class="delimiter">=</span><span> </span><span>τ</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>infchain_outruns_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ (n :: nat). card(UNIV :: 'a set) = n"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>S</span><span> </span><span class="delimiter">=</span><span> </span><span>UNIV</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>ex_card</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"card(UNIV :: 'a set) = n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>exE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span>   </span><span>d</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃i. card UNIV &lt; card ((τ ^^ i) {})"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"card UNIV"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"card (UNIV :: 'a set) &lt; card ((τ ^^ i) {})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>exE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(card((τ ^^ i){})) ≤ (card (UNIV :: 'a set))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>A</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"((τ ^^ i){})"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Finite_Set.card_mono</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subset_UNIV</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>e</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>y</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"card((τ ^^ i){})"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>less_not_le</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_fixp</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite(UNIV :: 'a set)"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mono (τ :: ('a set ⇒ 'a set))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ i. (τ ^^ i) ({}) = (τ ^^(i + 1))({})"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Proof idea: 
with @{text predtrans_empty} we know 

@{term "∀ i. (τ ^^ i){} ⊆ (τ ^^(i + 1))({})"} (1).

If we can additionally show 

@{term "∃ i.  (τ ^^ i)({}) ⊇ (τ ^^(i + 1))({})"} (2),

we can get the goal together with equalityI 
@{text "⊆ + ⊇ ⟶ ="}. 
To prove (1) we observe that 
@{term "(τ ^^ i)({}) ⊇ (τ ^^(i + 1))({})"} 
can be inferred from 
@{term "¬((τ ^^ i)({}) ⊆ (τ ^^(i + 1))({}))"} 
and (1).
Finally, the latter is solved directly by @{text ‹no_infinite_subset_chain›}.›</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i. (τ ^^ i) ({}:: 'a set) ⊆ (τ ^^ (i + (1))) {}"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>predtrans_empty</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (∀ i :: nat. (τ ^^ i) {} ⊂ (τ ^^(i + 1)) {})"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>notI</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>no_infinite_subset_chain</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>assms</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃ i :: nat. ¬((τ ^^ i) {} ⊂ (τ ^^(i + 1)) {}))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>a3</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ i. (τ ^^ i) ({}) = (τ ^^(i + 1))({})"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>predtrans_UNIV</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mono (τ :: ('a set ⇒ 'a set))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ i. (τ ^^ i) (UNIV) ⊇ (τ ^^(i + 1))(UNIV)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span class="delimiter">,</span><span> </span><span>induct_tac</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(τ ^^ ((0) + (1))) UNIV ⊆ (τ ^^ (0)) UNIV"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀(i) n.
       (τ ^^ (n + (1))) UNIV ⊆ (τ ^^ n) UNIV ⟹ (τ ^^ (Suc n + (1))) UNIV ⊆ (τ ^^ Suc n) UNIV"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(τ ^^ (n + (1))) UNIV ⊆ (τ ^^ n) UNIV"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(τ ((τ ^^ n) UNIV)) ⊇ (τ ((τ ^^ (n + (1 :: nat))) UNIV))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>a</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>monoE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(τ ^^ (Suc n + (1))) UNIV ⊆ (τ ^^ Suc n) UNIV"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Suc_less_le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x &lt; (y - n) ⟹ x ≤ (y - (Suc n))"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>card_univ_subtract</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (UNIV :: 'a set)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"mono τ"</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"(∀i :: nat. ((τ :: 'a set ⇒ 'a set) ^^ (i + (1 :: nat)))(UNIV :: 'a set) ⊂ (τ ^^ i) UNIV)"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀ i :: nat. card((τ ^^ i) (UNIV ::'a set)) ≤ (card (UNIV :: 'a set)) - i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span class="delimiter">,</span><span> </span><span>induct_tac</span><span> </span><span>i</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card ((τ ^^ (0)) UNIV) ≤ card (UNIV :: 'a set) - (0)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀(i) n.
       card ((τ ^^ n) (UNIV :: 'a set)) ≤ card (UNIV :: 'a set) - n ⟹
       card ((τ ^^ Suc n) (UNIV :: 'a set)) ≤ card (UNIV :: 'a set) - Suc n"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"card ((τ ^^ n) (UNIV :: 'a set)) ≤ card (UNIV :: 'a set) - n"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(τ ^^ (n + (1)))(UNIV :: 'a set) ⊂ (τ ^^ n) UNIV"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card((τ ^^ (n + (1 :: nat)))(UNIV :: 'a set)) &lt; card((τ ^^ n) (UNIV :: 'a set))"</span></span></span><span>       
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>psubset_card_mono</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>finite_subset</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>subset_UNIV</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card ((τ ^^ Suc n) (UNIV :: 'a set)) ≤ card (UNIV :: 'a set) - Suc n"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>card_UNIV_tau_i_below_zero</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (UNIV :: 'a set)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mono τ"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"(∀i :: nat. ((τ :: ('a set ⇒ 'a set)) ^^ (i + (1 :: nat)))(UNIV :: 'a set) ⊂ (τ ^^ i) UNIV)"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card((τ ^^ (card (UNIV ::'a set))) (UNIV ::'a set)) ≤ 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀ i :: nat. card((τ ^^ i) (UNIV ::'a set)) ≤ (card (UNIV :: 'a set)) - i)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>card_univ_subtract</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card((τ ^^ (card (UNIV ::'a set))) (UNIV ::'a set)) ≤ 0"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"card (UNIV ::'a set)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_card_zero_empty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ finite S; card S ≤ 0⟧ ⟹ S = {}"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>UNIV_tau_i_is_empty</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (UNIV :: 'a set)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mono (τ :: ('a set ⇒ 'a set))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"(∀i :: nat. ((τ :: 'a set ⇒ 'a set) ^^ (i + (1 :: nat)))(UNIV :: 'a set) ⊂ (τ ^^ i) UNIV)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(τ ^^ (card (UNIV ::'a set))) (UNIV ::'a set) = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>assms</span><span> </span><span>card_UNIV_tau_i_below_zero</span><span> </span><span>finite_card_zero_empty</span><span> </span><span>finite_subset</span><span> </span><span>subset_UNIV</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>down_chain_reaches_empty</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (UNIV :: 'a set)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mono (τ :: 'a set ⇒ 'a set)"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀i :: nat. ((τ :: 'a set ⇒ 'a set) ^^ (i + (1 :: nat))) UNIV ⊂ (τ ^^ i) UNIV)"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ (j :: nat). (τ ^^ j) UNIV = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>UNIV_tau_i_is_empty</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_infinite_subset_chain2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (UNIV :: 'a set)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mono (τ :: ('a set ⇒ 'a set))"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i :: nat. (τ ^^ i) UNIV ⊃ (τ ^^ (i + (1 :: nat))) UNIV"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ j :: nat. (τ ^^ j) UNIV = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>down_chain_reaches_empty</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>j</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(τ ^^ j) UNIV = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>exE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(τ ^^ (j + (1))) UNIV ⊂ (τ ^^ j) UNIV"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>j</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_fixp2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite(UNIV :: 'a set)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mono (τ :: ('a set ⇒ 'a set))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ i. (τ ^^ i) UNIV = (τ ^^(i + 1)) UNIV"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i. (τ ^^ (i + (1))) UNIV ⊆ (τ ^^ i) UNIV"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>predtrans_UNIV</span><span> </span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃i. ¬ (τ ^^ (i + (1))) UNIV ⊂ (τ ^^ i) UNIV"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (∀ i :: nat. (τ ^^ i) UNIV ⊃ (τ ^^(i + 1)) UNIV)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>no_infinite_subset_chain2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃i. ¬ (τ ^^ (i + (1))) UNIV ⊂ (τ ^^ i) UNIV"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ i. (τ ^^ i) UNIV = (τ ^^(i + 1)) UNIV"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lfp_loop</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (UNIV :: 'b set)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mono (τ :: ('b set ⇒ 'b set))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ n . lfp τ  = (τ ^^ n) {}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃i. (τ ^^ i) {} = (τ ^^ (i + (1))) {}"</span></span></span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>finite_fixp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" (τ ^^ i) {} = (τ ^^ (i + (1))) {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>exE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(τ ^^ i) {} = (τ ^^ Suc i) {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(τ ^^ Suc i) {} = (τ ^^ i) {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lfp τ = (τ ^^ i) {}"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>lfp_Kleene_iter</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ n . lfp τ  = (τ ^^ n) {}"</span></span></span><span> 
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹These next two are repeated from the corresponding
   theorems in HOL/ZF/Nat.thy for the sake of self-containedness of the exposition.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Kleene_iter_gpfp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mono f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ≤ f p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ≤ (f^^k) (top::'a::order_top)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Suc</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>monoD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Suc</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gfp_loop</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (UNIV :: 'b set)"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mono (τ :: ('b set ⇒ 'b set))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ n . gfp τ  = (τ ^^ n)UNIV"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" ∃i. (τ ^^ i)(UNIV :: 'b set) = (τ ^^ (i + (1))) UNIV"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>finite_fixp2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(τ ^^ i)UNIV = (τ ^^ (i + (1))) UNIV"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>exE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ n . gfp τ  = (τ ^^ n)UNIV"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>gfp_Kleene_iter</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Generic type of state with state transition and CTL operators›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The system states and their transition relation are defined as a class called
 @{text ‹state›} containing an abstract constant@{text ‹state_transition›}. It introduces the 
syntactic infix notation @{text ‹I →<span class="hidden">⇩</span><sub>i</sub> I'›} to denote that system state @{text ‹I›} and @{text ‹I’›} 
are in this relation over an arbitrary (polymorphic) type @{text ‹'a›}.›</span></span></span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>state</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>state_transition</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"['a :: type, 'a] ⇒ bool"</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"→<span class="hidden">⇩</span><sub>i</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The above class definition lifts Kripke structures and CTL to a general level. 
The definition of the inductive relation is given by a set of specific rules which are, 
however, part of an application like infrastructures. Branching time temporal logic CTL 
is defined in general over Kripke structures with arbitrary state transitions and can later 
be applied to suitable theories, like infrastructures.
Based on the generic state transition @{text ‹→›} of the type class state, the CTL-operators 
EX and AX express that property f holds in some or all next states, respectively.›</span></span></span><span> 
</span><span>    
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>AX</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"AX f ≡ {s. {f0. s →<span class="hidden">⇩</span><sub>i</sub> f0} ⊆ f}"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>EX'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"EX' f ≡ {s . ∃ f0 ∈ f. s →<span class="hidden">⇩</span><sub>i</sub> f0 }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The CTL formula @{text ‹AG f›} means that on all paths branching from a state @{text ‹s›} 
the formula @{text ‹f›} is always true (@{text ‹G›} stands for ‘globally’). It can be defined 
using the Tarski fixpoint theory by applying the greatest fixpoint operator. In a similar way, 
the other CTL operators are defined.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>AF</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"AF f ≡ lfp (λ Z. f ∪ AX Z)"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>EF</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"EF f ≡ lfp (λ Z. f ∪ EX' Z)"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>AG</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"AG f ≡ gfp (λ Z. f ∩ AX Z)"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>EG</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"EG f ≡ gfp (λ Z. f ∩ EX' Z)"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>AU</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"AU f1 f2 ≡ lfp(λ Z. f2 ∪ (f1 ∩ AX Z))"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>EU</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"EU f1 f2 ≡ lfp(λ Z. f2 ∪ (f1 ∩ EX' Z))"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>AR</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"AR f1 f2 ≡ gfp(λ Z. f2 ∩ (f1 ∪ AX Z))"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ER</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ER f1 f2 ≡ gfp(λ Z. f2 ∩ (f1 ∪ EX' Z))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹Kripke structures and Modelchecking›</span></span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">'a</span><span> </span><span>kripke</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span>Kripke</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>states</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"states (Kripke S I) = S"</span></span></span><span> 
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>init</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"init (Kripke S I) = I"</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The formal Isabelle definition of what it means that formula f holds 
in a Kripke structure M can be stated as: the initial states of the Kripke 
structure init M need to be contained in the set of all states states M that 
imply f.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>check</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ⊢ _"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M ⊢ f ≡ (init M) ⊆ {s ∈ (states M). s ∈ f }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>state_transition_refl</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"→<span class="hidden">⇩</span><sub>i</sub>*"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s →<span class="hidden">⇩</span><sub>i</sub>* s' ≡ ((s,s') ∈ {(x,y). state_transition x y}<span class="hidden">⇧</span><sup>*</sup>)"</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lemmas for CTL operators›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹EF lemmas›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>EF_lem0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x ∈ EF f) = (x ∈ f ∪ EX' (lfp (λZ :: ('a :: state) set. f ∪ EX' Z)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lfp (λZ :: ('a :: state) set. f ∪ EX' Z) = 
                    f ∪ (EX' (lfp (λZ :: 'a set. f ∪ EX' Z)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>def_lfp_unfold</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>reflexive</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>mono_def</span><span> </span><span>EX'_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x ∈ EF (f :: ('a :: state) set)) = (x ∈ f ∪ EX' (lfp (λZ :: ('a :: state) set. f ∪ EX' Z)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>EF_def</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>EF_lem00</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(EF f) = (f ∪ EX' (lfp (λ Z :: ('a :: state) set. f ∪ EX' Z)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>EF_lem0</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>EF_lem000</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(EF f) = (f ∪ EX' (EF f))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>EF_def</span><span> </span><span>EF_lem00</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>EF_lem1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ f ∨ x ∈ (EX' (EF f)) ⟹ x ∈ EF f"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>EF_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ f ∨ x ∈ EX' (lfp (λZ::'a set. f ∪ EX' Z))"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ lfp (λZ::'a set. f ∪ EX' Z)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lfp (λZ :: ('a :: state) set. f ∪ EX' Z) =
                    f ∪ (EX' (lfp (λZ :: ('a :: state) set. f ∪ EX' Z)))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>EF_def</span><span> </span><span>EF_lem00</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ lfp (λZ::'a set. f ∪ EX' Z)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>b</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>   
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>EF_lem2b</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ (EX' (EF f))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ EF f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>EF_lem1</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>EF_lem2a</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ EF f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>EF_lem1</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>EF_lem2c</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ EF (- f)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>EF_lem1</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>EF_lem2d</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ EF f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>EF_lem1</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>EF_lem3b</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ EX' (f ∪ EX' (EF f))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ (EF f)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>EF_lem000</span><span> </span><span>EF_lem2b</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>EX_lem0l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ (EX' f) ⟹ x ∈ (EX' (f ∪ g))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>EX'_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>EX_lem0r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ (EX' g) ⟹ x ∈ (EX' (f ∪ g))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>EX'_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>EX_step</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x  →<span class="hidden">⇩</span><sub>i</sub> y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ EX' f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>EX'_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>EF_E</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ f. x ∈ (EF f) ⟶ x ∈ (f ∪ EX' (EF f))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>EF_lem000</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>EF_step</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x  →<span class="hidden">⇩</span><sub>i</sub> y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ EF f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>EF_lem3b</span><span> </span><span>EX_step</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>EF_step_step</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x  →<span class="hidden">⇩</span><sub>i</sub> y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ EF f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"x ∈ EF f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>EF_lem2b</span><span> </span><span>EX_step</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>EF_step_star</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ x  →<span class="hidden">⇩</span><sub>i</sub>* y; y ∈ f ⟧ ⟹ x ∈ EF f"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>state_transition_refl_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ {(x::'a, y::'a). x →<span class="hidden">⇩</span><sub>i</sub> y}<span class="hidden">⇧</span><sup>*</sup> ⟹ y ∈ f ⟹ x ∈ EF f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>converse_rtrancl_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ f ⟹ y ∈ EF f"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>EF_lem2a</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ya z::'a. y ∈ f ⟹
                 (ya, z) ∈ {(x,y). x →<span class="hidden">⇩</span><sub>i</sub> y} ⟹
                 (z, y) ∈ {(x,y). x →<span class="hidden">⇩</span><sub>i</sub> y}<span class="hidden">⇧</span><sup>*</sup> ⟹ z ∈ EF f ⟹ ya ∈ EF f"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>EF_step_step</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>EF_induct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a::'a::state) ∈ EF f ⟹
    mono (λ Z. f ∪ EX' Z) ⟹
    (⋀x. x ∈ ((λ Z. f ∪ EX' Z)(EF f ∩ {x::'a::state. P x})) ⟹ P x) ⟹
    P a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>EF_def</span><span> </span><span>def_lfp_induct_set</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valEF_E</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"M ⊢ EF f ⟹ x ∈ init M ⟹ x ∈ EF f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>check_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>EF_step_star_rev</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ EF s ⟹  (∃ y ∈ s.  x  →<span class="hidden">⇩</span><sub>i</sub>* y)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>EF_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mono (λZ::'a set. s ∪ EX' Z)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mono_def</span><span> </span><span>EX'_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x::'a. x ∈ s ∪ EX' (EF s ∩ {x::'a. ∃y::'a∈s. x →<span class="hidden">⇩</span><sub>i</sub>* y}) ⟹ ∃y::'a∈s. x →<span class="hidden">⇩</span><sub>i</sub>* y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>UnE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>state_transition_refl_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>EX'_def</span><span> </span><span>state_transition_refl_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>converse_rtrancl_into_rtrancl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>EF_step_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(I ⊆ {sa::'s :: state. (∃i∈I. i →<span class="hidden">⇩</span><sub>i</sub>* sa) ∧ sa ∈ EF s})  
         ⟹ ∀ x ∈ I. ∃ y ∈ s. x →<span class="hidden">⇩</span><sub>i</sub>* y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>EF_step_star_rev</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹AG lemmas›</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>AG_in_lem</span><span class="delimiter">:</span><span>   </span><span class="string"><span class="delete"><span class="delete">"x ∈ AG s ⟹ x ∈ s"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>AG_def</span><span> </span><span>gfp_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>AG_lem1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ s ∧ x ∈ (AX (AG s)) ⟹ x ∈ AG s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>AG_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gfp (λZ::'a set. s ∩ AX Z) = s ∩ (AX (gfp (λZ::'a set. s ∩ AX Z)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>def_gfp_unfold</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mono_def</span><span> </span><span>AX_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ s ∧ x ∈ AX (gfp (λZ::'a set. s ∩ AX Z)) ⟹ x ∈ gfp (λZ::'a set. s ∩ AX Z)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>AG_lem2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ AG s ⟹ x ∈ (s ∩ (AX (AG s)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"AG s = s ∩ (AX (AG s))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>AG_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>def_gfp_unfold</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mono_def</span><span> </span><span>AX_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ AG s ⟹ x ∈ (s ∩ (AX (AG s)))"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>subst</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>AG_lem3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"AG s = (s ∩ (AX (AG s)))"</span></span></span><span>    
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AG_lem1</span><span> </span><span>AG_lem2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>AG_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y →<span class="hidden">⇩</span><sub>i</sub> z ⟹ y ∈ AG s ⟹ z ∈ AG s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AG_lem2</span><span> </span><span>AX_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>AG_all_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" x →<span class="hidden">⇩</span><sub>i</sub>* y ⟹ x ∈ AG s ⟹ y ∈ AG s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>state_transition_refl_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, y) ∈ {(x,y). x →<span class="hidden">⇩</span><sub>i</sub> y}<span class="hidden">⇧</span><sup>*</sup> ⟹ x ∈ AG s ⟹ y ∈ AG s"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>rtrancl_induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>AG_step</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>AG_imp_notnotEF</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">"I ≠ {} ⟹ ((Kripke {s. ∃ i ∈ I. (i →<span class="hidden">⇩</span><sub>i</sub>* s)} I  ⊢ AG s)) ⟹ 
 (¬(Kripke {s. ∃ i ∈ I. (i →<span class="hidden">⇩</span><sub>i</sub>* s)} (I :: ('s :: state)set)  ⊢ EF (- s)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>notI</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>check_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"I ≠ {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"I ⊆ {sa::'s. (∃i∈I. i →<span class="hidden">⇩</span><sub>i</sub>* sa) ∧ sa ∈ AG s}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"I ⊆ {sa::'s. (∃i∈I. i →<span class="hidden">⇩</span><sub>i</sub>* sa) ∧ sa ∈ EF (- s)}"</span></span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{sa::'s. (∃i∈I. i →<span class="hidden">⇩</span><sub>i</sub>* sa) ∧ sa ∈ AG s} ∩
                        {sa::'s. (∃i∈I. i →<span class="hidden">⇩</span><sub>i</sub>* sa) ∧ sa ∈ EF (- s)} = {}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(? x. x ∈ {sa::'s. (∃i∈I. i →<span class="hidden">⇩</span><sub>i</sub>* sa) ∧ sa ∈ AG s} ∧
                           x ∈ {sa::'s. (∃i∈I. i →<span class="hidden">⇩</span><sub>i</sub>* sa) ∧ sa ∈ EF (- s)}) ⟹ False"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(? x. x ∈ {sa::'s. (∃i∈I. i →<span class="hidden">⇩</span><sub>i</sub>* sa) ∧ sa ∈ AG s} ∧
                           x ∈ {sa::'s. (∃i∈I. i →<span class="hidden">⇩</span><sub>i</sub>* sa) ∧ sa ∈ EF (- s)})"</span></span></span><span>          
</span><span>            </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a4</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>  </span><span>a5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ {sa::'s. (∃i∈I. i →<span class="hidden">⇩</span><sub>i</sub>* sa) ∧ sa ∈ AG s} ∧
                                   x ∈ {sa::'s. (∃i∈I. i →<span class="hidden">⇩</span><sub>i</sub>* sa) ∧ sa ∈ EF (- s)}"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>exE</span><span class="delimiter">)</span><span> 
</span><span>            </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>AG_all_s</span><span> </span><span>AG_in_lem</span><span> </span><span>ComplD</span><span> </span><span>EF_step_star_rev</span><span> </span><span>a5</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{sa::'s. (∃i∈I. i →<span class="hidden">⇩</span><sub>i</sub>* sa) ∧ sa ∈ AG s} ∩
                        {sa::'s. (∃i∈I. i →<span class="hidden">⇩</span><sub>i</sub>* sa) ∧ sa ∈ EF (- s)} = {}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"? x. x : I"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ I"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>a2</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A simplified way of Modelchecking is given by the following lemma.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>check2_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Kripke S I ⊢ f) = (I ⊆ S ∩ f)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>check_def</span><span class="delimiter">)</span><span>
</span><span>    
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="AT">
<div class="head"><h1>Theory AT</h1>
<span class="command">theory</span> <span class="name">AT</span><br/>
<span class="keyword">imports</span> <a href="MC.html"><span class="name">MC</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Attack Trees"</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>AT</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>MC</span><span> 
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Attack Trees are an intuitive and practical formal method to analyse and quantify
attacks on security and privacy. They are very useful to identify the steps an attacker
takes through a system when approaching the attack goal. Here, we provide 
a proof calculus to analyse concrete attacks using a notion of attack validity.
We define a state based semantics with Kripke models and the temporal logic
CTL in the proof assistant Isabelle \cite{npw:02} using its Higher Order Logic 
(HOL). We prove the correctness and completeness (adequacy) of Attack Trees in Isabelle 
with respect to the model.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Attack Tree datatype"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The following datatype definition @{text ‹attree›} defines attack trees.
The simplest case of an attack tree is a base attack.
The principal idea is that base attacks are defined by a pair of
state sets representing the initial states and the {\it attack property}
-- a set of states characterized by the fact that this property holds
in them. 
Attacks can also be combined as the conjunction or disjunction of other attacks. 
The operator @{text ‹⊕<span class="hidden">⇩</span><sub>∨</sub>›} creates or-trees and @{text ‹⊕<span class="hidden">⇩</span><sub>∧</sub>›} creates and-trees.
And-attack trees @{text ‹l ⊕<span class="hidden">⇩</span><sub>∧</sub> s›} and or-attack trees @{text ‹l ⊕<span class="hidden">⇩</span><sub>∨</sub> s›} 
combine lists of attack trees $l$ either conjunctively or disjunctively and
consist of a list of sub-attacks -- again attack trees.›</span></span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'s</span><span> </span><span class="delimiter">::</span><span> </span><span>state</span><span class="delimiter">)</span><span> </span><span>attree</span><span> </span><span class="delimiter">=</span><span> </span><span>BaseAttack</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s set) * ('s set)"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"𝒩<span class="hidden">⇘</span><sub>(_)<span class="hidden">⇙</span></sub>"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">|</span><span>
</span><span>                  </span><span>AndAttack</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s attree) list"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"('s set) * ('s set)"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>(_)<span class="hidden">⇖</span></sup>"</span></span></span><span> </span><span>60</span><span class="delimiter">)</span><span> </span><span class="delimiter">|</span><span> 
</span><span>                  </span><span>OrAttack</span><span>  </span><span class="string"><span class="delete"><span class="delete">"('s attree) list"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"('s set) * ('s set)"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>(_)<span class="hidden">⇖</span></sup>"</span></span></span><span> </span><span>61</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>attack</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s :: state) attree ⇒ ('s set) * ('s set)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span class="string"><span class="delete"><span class="delete">"attack (BaseAttack b) = b"</span></span></span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"attack (AndAttack as s) = s"</span></span></span><span>  </span><span class="delimiter">|</span><span> 
</span><span class="string"><span class="delete"><span class="delete">"attack (OrAttack as s) = s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Attack Tree refinement›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹When we develop an attack tree, we proceed from an abstract attack, given
by an attack goal, by breaking it down into a series of sub-attacks. This
proceeding corresponds to a process of {\it refinement}. Therefore, as part of
the attack tree calculus, we provide a notion of attack tree refinement.

The relation @{text ‹refines_to›} "constructs" the attack tree. Here the above
defined attack vectors are used to define how nodes in an attack tree 
can be expanded into more detailed (refined) attack sequences. This 
process of refinement @{text "⊑"} allows to eventually reach a fully detailed
attack that can then be proved using @{text "⊢"}.›</span></span></span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>refines_to</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[('s :: state) attree, 's attree] ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ⊑ _"</span></span></span><span> </span><span class="delimiter">[</span><span>40</span><span class="delimiter">]</span><span> </span><span>40</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>refI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦  A = ((l @ [ 𝒩<span class="hidden">⇘</span><sub>(si',si'')<span class="hidden">⇙</span></sub>] @ l'')⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>(si,si''')<span class="hidden">⇖</span></sup> );
          A' = (l' ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>(si',si'')<span class="hidden">⇖</span></sup>);
          A'' = (l @ l' @ l'' ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>(si,si''')<span class="hidden">⇖</span></sup>)
        ⟧ ⟹ A ⊑ A''"</span></span></span><span class="delimiter">|</span><span> 
</span><span>ref_or</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ as ≠ []; ∀ A' ∈ set(as). (A  ⊑ A') ∧ attack A = s ⟧ ⟹ A ⊑ (as ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>s<span class="hidden">⇖</span></sup>)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>ref_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ A ⊑ A'; A' ⊑ A'' ⟧ ⟹ A ⊑ A''"</span></span></span><span class="delimiter">|</span><span>
</span><span>ref_refl</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ⊑ A"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Validity of Attack Trees›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A valid attack, intuitively, is one which is fully refined into fine-grained
attacks that are feasible in a model. The general model we provide is
a Kripke structure, i.e., a set of states and a generic state transition.
Thus, feasible steps in the model are single steps of the state transition.
We call them valid base attacks.
The composition of sequences of valid base attacks into and-attacks yields
again valid attacks if the base attacks line up with respect to the states
in the state transition. If there are different valid attacks for the same
attack goal starting from the same initial state set, these can be 
summarized in an or-attack.
More precisely, the different cases of the validity predicate are distinguished
by pattern matching over the attack tree structure.
\begin{itemize}
\item A  base attack @{text ‹𝒩(s0,s1)›} is  valid if from all
states in the pre-state set @{text ‹s0›} we can get with a single step of the 
state transition relation to a state in the post-state set ‹s1›. Note,
that it is sufficient for a post-state to exist for each pre-state. After all,
we are aiming to validate attacks, that is, possible attack paths to some
state that fulfills the attack property.
\item An and-attack @{text ‹As ⊕<span class="hidden">⇩</span><sub>∧</sub> (s0,s1)›} is a valid attack
 if either of the following cases holds:
  \begin{itemize}
   \item empty attack sequence @{text ‹As›}: in this case 
       all pre-states in @{text ‹s0›} must already be attack states 
       in @{text ‹s1›}, i.e., @{text ‹s0 ⊆ s1›};
   \item attack sequence @{text ‹As›} is singleton: in this case, the 
      singleton element attack @{text ‹a›} in @{text ‹[a]›}, 
      must be a valid attack and it must be an attack with pre-state 
      @{text ‹s0›} and post-state @{text ‹s1›};
   \item otherwise, @{text ‹As›} must be a list matching @{text ‹a # l›} for
     some attack @{text ‹a›} and tail of attack list @{text ‹l›} such that
     @{text ‹a›} is a valid attack with pre-state identical to the overall 
     pre-state @{text ‹s0›} and the goal of the tail @{text ‹l›} is 
     @{text ‹s1›} the goal of the  overall attack. The pre-state of the
     attack represented by @{text ‹l›} is @{text ‹snd(attack a)›} since this is 
     the post-state set of the first step @{text ‹a›}.
\end{itemize}
 \item An or-attack @{text ‹As  ⊕<span class="hidden">⇩</span><sub>∨</sub>(s0,s1)›} is a valid attack 
  if either of the following cases holds: 
  \begin{itemize}
   \item the empty attack case is identical to the and-attack above: 
       @{text ‹s0 ⊆ s1›};
   \item attack sequence @{text ‹As›} is singleton: in this case, the 
      singleton element attack @{text ‹a›}
      must be a valid attack and 
      its pre-state must include the overall attack pre-state set @{text ‹s0›} 
      (since @{text ‹a›} is singleton in the or) while the post-state of 
      @{text ‹a›} needs to be included in the global attack goal @{text ‹s1›};
   \item otherwise, @{text ‹As›} must be a list  @{text ‹a # l›} for
     an attack @{text ‹a›} and a list @{text ‹l›} of alternative attacks.
     The pre-states can be just a subset of @{text ‹s0›} (since there are
     other attacks in @{text ‹l›} that can cover the rest) and the goal
     states @{text ‹snd(attack a)›} need to lie all in the overall goal
     state @{text ‹set s1›}. The other or-attacks in @{text ‹l›} need
     to cover only the pre-states @{text ‹fst s - fst(attack a)›}
     (where @{text ‹-›} is set difference) and have the same goal @{text ‹snd s›}.
   \end{itemize}
\end{itemize}
The proof calculus is thus completely described by one recursive function. ›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>is_attack_tree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[('s :: state) attree] ⇒ bool"</span></span></span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⊢_"</span></span></span><span> </span><span class="delimiter">[</span><span>40</span><span class="delimiter">]</span><span> </span><span>40</span><span class="delimiter">)</span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>att_base</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(⊢ 𝒩<span class="hidden">⇘</span><sub>s<span class="hidden">⇙</span></sub>) = ( (∀ x ∈ (fst s). (∃ y ∈ (snd s). x  →<span class="hidden">⇩</span><sub>i</sub> y )))"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>att_and</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊢(As ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>s<span class="hidden">⇖</span></sup>)) = 
               (case As of
                  [] ⇒ (fst s ⊆ snd s)
                | [a] ⇒ ( ⊢ a ∧ attack a = s) 
                | (a # l) ⇒ (( ⊢ a) ∧ (fst(attack a) = fst s) ∧ 
                            (⊢(l ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>(snd(attack a),snd(s))<span class="hidden">⇖</span></sup>))))"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>att_or</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊢(As ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>s<span class="hidden">⇖</span></sup>)) = 
               (case As of 
                  [] ⇒ (fst s ⊆ snd s) 
                | [a] ⇒ ( ⊢ a ∧ (fst(attack a) ⊇ fst s) ∧ (snd(attack a) ⊆ snd s)) 
                | (a # l) ⇒ (( ⊢ a) ∧ fst(attack a) ⊆ fst s ∧ 
                              snd(attack a) ⊆ snd s ∧
                       ( ⊢(l ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>(fst s - fst(attack a), snd s)<span class="hidden">⇖</span></sup>))))"</span></span></span><span> 
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Since the definition is constructive, code can be generated directly from it, here
into the programming language Scala.›</span></span></span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>is_attack_tree</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Scala</span><span>    
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Lemmas for Attack Tree validity"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>att_and_one</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊢ a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"attack a = s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"⊢([a] ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>s<span class="hidden">⇖</span></sup>)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" ⊢([a] ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>s<span class="hidden">⇖</span></sup>)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>att_and</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>att_and</span><span> </span><span>att_or</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>is_attack_tree.simps</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>att_and_empty</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" ⊢([] ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>(s', s'')<span class="hidden">⇖</span></sup>) ⟶ s' ⊆ s''"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_attack_tree.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>att_and_empty2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" ⊢([] ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>(s, s)<span class="hidden">⇖</span></sup>)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_attack_tree.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>att_or_empty</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" ⊢([] ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>(s', s'')<span class="hidden">⇖</span></sup>) ⟶ s' ⊆ s''"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_attack_tree.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>att_or_empty_back</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" s' ⊆ s'' ⟶  ⊢([] ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>(s', s'')<span class="hidden">⇖</span></sup>)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_attack_tree.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>att_or_empty_rev</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊢(l ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>(s, s')<span class="hidden">⇖</span></sup>)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(s ⊆ s')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l ≠ []"</span></span></span><span>    
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>att_or_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>att_or_empty2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⊢([] ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>(s, s)<span class="hidden">⇖</span></sup>)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>att_or_empty_back</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>att_andD1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" ⊢(x1 # x2 ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>s<span class="hidden">⇖</span></sup>) ⟹ ⊢ x1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>is_attack_tree.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>list.exhaust</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>att_and_nonemptyD2</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>       </span><span class="string"><span class="delete"><span class="delete">"(x2 ≠ [] ⟶ ⊢(x1 # x2 ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>s<span class="hidden">⇖</span></sup>) ⟶ ⊢ (x2 ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>(snd(attack x1),snd s)<span class="hidden">⇖</span></sup>))"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>is_attack_tree.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>list.exhaust</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>att_andD2</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" ⊢(x1 # x2 ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>s<span class="hidden">⇖</span></sup>) ⟹ ⊢ (x2 ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>(snd(attack x1),snd s)<span class="hidden">⇖</span></sup>)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>att_and_empty2</span><span> </span><span>att_and_nonemptyD2</span><span> </span><span>is_attack_tree.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>att_and_fst_lem</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"⊢(x1 # x2a ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>x<span class="hidden">⇖</span></sup>) ⟶ xa ∈ fst (attack (x1 # x2a ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>x<span class="hidden">⇖</span></sup>))
                     ⟶ xa ∈ fst (attack x1)"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>x2a</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>att_and</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>att_orD1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" ⊢(x1 # x2 ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>x<span class="hidden">⇖</span></sup>) ⟹ ⊢ x1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>x2</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>att_or</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>att_or_snd_hd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" ⊢(a # list ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>(aa, b)<span class="hidden">⇖</span></sup>) ⟹ snd(attack a) ⊆ b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>list</span><span class="delimiter">,</span><span>  </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>att_or</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>att_or_singleton</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>   </span><span class="string"><span class="delete"><span class="delete">" ⊢([x1] ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>x<span class="hidden">⇖</span></sup>) ⟶ ⊢([] ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>(fst x - fst (attack x1), snd x)<span class="hidden">⇖</span></sup>)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>att_or</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>impI</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>att_or_empty_back</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>att_orD2</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>     </span><span class="string"><span class="delete"><span class="delete">" ⊢(x1 # x2 ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>x<span class="hidden">⇖</span></sup>) ⟶  ⊢ (x2 ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>(fst x - fst(attack x1), snd x)<span class="hidden">⇖</span></sup>)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>x2</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>att_or_singleton</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>att_or</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>att_or_snd_att</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ x. ⊢ (x2 ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>x<span class="hidden">⇖</span></sup>) ⟶ (∀ a ∈ (set x2). snd(attack a) ⊆ snd x )"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>x2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>att_or</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>x2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>att_orD2</span><span> </span><span>att_or_snd_hd</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>singleton_or_lem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" ⊢([x1] ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>x<span class="hidden">⇖</span></sup>)  ⟹ fst x ⊆ fst(attack x1)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>att_or</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>or_att_fst_sup0</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x2 ≠ [] ⟶ (∀ x. (⊢ ((x2 ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>x<span class="hidden">⇖</span></sup>):: ('s :: state) attree)) ⟶
                      ((⋃ y::'s attree∈ set x2. fst (attack y)) ⊇ fst(x))) "</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>x2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>x2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>att_orD2</span><span> </span><span>singleton_or_lem</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>or_att_fst_sup</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊢ ((x1 # x2 ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>x<span class="hidden">⇖</span></sup>):: ('s :: state) attree))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"((⋃ y::'s attree∈ set (x1 # x2). fst (attack y)) ⊇ fst(x))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>or_att_fst_sup0</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The lemma @{text ‹att_elem_seq›} is the main lemma for Correctness.
  It shows that for a given attack tree x1, for each element in the set of start sets 
  of the first attack, we can reach in zero or more steps a state in the states in which 
  the attack is successful (the final attack state @{text ‹snd(attack x1)›}).
  This proof is a big alternative to an earlier version of the proof with
  @{text ‹first_step›} etc that mapped first on a sequence of sets of states.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>att_elem_seq</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⊢ x1 ⟶ (∀ x ∈ fst(attack x1).
                     (∃ y. y ∈ snd(attack x1) ∧ x →<span class="hidden">⇩</span><sub>i</sub>* y))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹First attack tree induction›</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>x1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>BaseAttack</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>AT.att_base</span><span> </span><span>EF_step</span><span> </span><span>EF_step_star_rev</span><span> </span><span>attack.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>AndAttack</span><span> </span><span>x1a</span><span> </span><span>x2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>x2</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀ x1aa::'a attree.
                              x1aa ∈ set x1a ⟶
                               ⊢x1aa ⟶
                               (∀x::'a∈fst (attack x1aa). ∃y::'a. y ∈ snd (attack x1aa) ∧ x →<span class="hidden">⇩</span><sub>i</sub>* y))"</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rotate_tac</span><span> </span><span>-</span><span>1</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Induction for @{text ‹∧›}: the manual instantiation seems tedious but in the @{text ‹∧›} 
            case necessary to get the right induction hypothesis.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>list</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"x1a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>list.induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The @{text ‹∧›} induction empty case›</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀x1aa::'a attree.
           x1aa ∈ set [] ⟶
           ⊢x1aa ⟶ (∀x::'a∈fst (attack x1aa). ∃y::'a. y ∈ snd (attack x1aa) ∧ x →<span class="hidden">⇩</span><sub>i</sub>* y)) ⟶
       (∀x::'a set × 'a set.
           ⊢([] ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>x<span class="hidden">⇖</span></sup>) ⟶
           (∀xa::'a∈fst (attack ([] ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>x<span class="hidden">⇖</span></sup>)). ∃y::'a. y ∈ snd (attack ([] ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>x<span class="hidden">⇖</span></sup>)) ∧ xa →<span class="hidden">⇩</span><sub>i</sub>* y))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>att_and_empty</span><span> </span><span>state_transition_refl_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The @{text ‹∧›} induction case nonempty›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀(x1a::'a attree list) (x2::'a set × 'a set) (x1::'a attree) (x2a::'a attree list).
       (⋀x1aa::'a attree.
           (x1aa ∈ set x1a) ⟹
           ((⊢x1aa) ⟶ (∀x::'a∈fst (attack x1aa). ∃y::'a. y ∈ snd (attack x1aa) ∧ x →<span class="hidden">⇩</span><sub>i</sub>* y))) ⟹
       ∀x1aa::'a attree.
          (x1aa ∈ set x1a) ⟶
          (⊢x1aa) ⟶ ((∀x::'a∈fst (attack x1aa). ∃y::'a. y ∈ snd (attack x1aa) ∧ x →<span class="hidden">⇩</span><sub>i</sub>* y)) ⟹
       (∀x1aa::'a attree.
           (x1aa ∈ set x2a) ⟶
           (⊢x1aa) ⟶ (∀x::'a∈fst (attack x1aa). ∃y::'a. y ∈ snd (attack x1aa) ∧ x →<span class="hidden">⇩</span><sub>i</sub>* y)) ⟶
       (∀x::'a set × 'a set.
           (⊢(x2a ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>x<span class="hidden">⇖</span></sup>)) ⟶
           ((∀xa::'a∈fst (attack (x2a ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>x<span class="hidden">⇖</span></sup>)). ∃y::'a. y ∈ snd (attack (x2a ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>x<span class="hidden">⇖</span></sup>)) ∧ xa →<span class="hidden">⇩</span><sub>i</sub>* y))) ⟹
       ((∀x1aa::'a attree.
           (x1aa ∈ set (x1 # x2a)) ⟶
           (⊢x1aa) ⟶ ((∀x::'a∈fst (attack x1aa). ∃y::'a. y ∈ snd (attack x1aa) ∧ x →<span class="hidden">⇩</span><sub>i</sub>* y))) ⟶
       (∀x::'a set × 'a set.
          ( ⊢(x1 # x2a ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>x<span class="hidden">⇖</span></sup>)) ⟶
           (∀xa::'a∈fst (attack (x1 # x2a ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>x<span class="hidden">⇖</span></sup>)).
               (∃y::'a. y ∈ snd (attack (x1 # x2a ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>x<span class="hidden">⇖</span></sup>)) ∧ (xa →<span class="hidden">⇩</span><sub>i</sub>* y)))))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>impI</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>allI</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Set free the Induction Hypothesis: this is necessary to provide the grounds for specific 
              instantiations in the step.›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀x::'a set × 'a set.
                             ⊢(x2a ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>x<span class="hidden">⇖</span></sup>) ⟶
                             (∀xa::'a∈fst (attack (x2a ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>x<span class="hidden">⇖</span></sup>)).
                              ∃y::'a. y ∈ snd (attack (x2a ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>x<span class="hidden">⇖</span></sup>)) ∧ xa →<span class="hidden">⇩</span><sub>i</sub>* y))"</span></span></span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The following induction step for @{text ‹∧›} needs a number of manual instantiations 
              so that the proof is not found automatically. In the subsequent case for @{text ‹∨›}, 
              sledgehammer finds the proof.›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀(x1a::'a attree list) (x2::'a set × 'a set) (x1::'a attree) (x2a::'a attree list) x::'a set × 'a set.
       ∀x1aa::'a attree.
          x1aa ∈ set (x1 # x2a) ⟶
          ⊢x1aa ⟶ (∀x::'a∈fst (attack x1aa). ∃y::'a. y ∈ snd (attack x1aa) ∧ x →<span class="hidden">⇩</span><sub>i</sub>* y) ⟹
       ⊢(x1 # x2a ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>x<span class="hidden">⇖</span></sup>) ⟹
       ∀x::'a set × 'a set.
          ⊢(x2a ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>x<span class="hidden">⇖</span></sup>) ⟶
          (∀xa::'a∈fst (attack (x2a ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>x<span class="hidden">⇖</span></sup>)). ∃y::'a. y ∈ snd (attack (x2a ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>x<span class="hidden">⇖</span></sup>)) ∧ xa →<span class="hidden">⇩</span><sub>i</sub>* y) ⟹
       ∀xa::'a∈fst (attack (x1 # x2a ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>x<span class="hidden">⇖</span></sup>)). ∃y::'a. y ∈ snd (attack (x1 # x2a ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>x<span class="hidden">⇖</span></sup>)) ∧ xa →<span class="hidden">⇩</span><sub>i</sub>* y"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ballI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>xa</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Prepare the steps›</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(snd(attack x1), snd x)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rotate_tac</span><span> </span><span>-</span><span>1</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>impE</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>att_andD2</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Premise for x1›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>x1</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>att_andD1</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Instantiate first step for xa›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rotate_tac</span><span> </span><span>-</span><span>1</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>xa</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>bspec</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>att_and_fst_lem</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>exE</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>conjE</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Take this y and put it as first into the second part›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>bspec</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>exE</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>conjE</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Bind the first @{text ‹xa →<span class="hidden">⇩</span><sub>i</sub>* y›} and second @{text ‹y →<span class="hidden">⇩</span><sub>i</sub>* ya›} together for solution›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>ya</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>state_transition_refl_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>OrAttack</span><span> </span><span>x1a</span><span> </span><span>x2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>x1a</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>x2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>EF_lem2a</span><span> </span><span>EF_step_star_rev</span><span> </span><span>att_or_empty</span><span> </span><span>attack.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>subsetD</span><span> </span><span>surjective_pairing</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>x1a</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>DiffI</span><span> </span><span>att_orD1</span><span> </span><span>att_orD2</span><span> </span><span>att_or_snd_att</span><span> </span><span>attack.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>insert_iff</span><span> </span><span>list.set</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>prod.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>snd_conv</span><span> </span><span>subset_iff</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>att_elem_seq0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⊢ x1 ⟹ (∀ x ∈ fst(attack x1).
                     (∃ y. y ∈ snd(attack x1) ∧ x →<span class="hidden">⇩</span><sub>i</sub>* y))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>att_elem_seq</span><span class="delimiter">)</span><span>
</span><span>          
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Valid refinements›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>valid_ref</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[('s :: state) attree, 's attree] ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ⊑<span class="hidden">⇩</span><sub>V</sub> _"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"A ⊑<span class="hidden">⇩</span><sub>V</sub> A' ≡  ( (A ⊑ A') ∧  ⊢ A')"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ref_validity</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[('s :: state) attree] ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⊢<span class="hidden">⇩</span><sub>V</sub> _"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"⊢<span class="hidden">⇩</span><sub>V</sub> A  ≡  (∃ A'. (A ⊑<span class="hidden">⇩</span><sub>V</sub> A'))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ref_valI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" A ⊑ A'⟹  ⊢ A' ⟹ ⊢<span class="hidden">⇩</span><sub>V</sub> A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ref_validity_def</span><span> </span><span>valid_ref_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Correctness and Completeness"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This section presents the main theorems of Correctness and Completeness
      between AT and Kripke, essentially: 

@{text ‹⊢ (init K, p) ≡  K ⊢ EF p›}.

First, we proof a number of lemmas needed for both directions before we 
show the Correctness theorem followed by the Completeness theorem.
›</span></span></span><span>    
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lemma for Correctness and Completeness›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nth_app_eq</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"∀ sl x. sl ≠ [] ⟶ sl ! (length sl - Suc (0)) = x
              ⟶ (l @ sl) ! (length l + length sl - Suc (0)) = x"</span></span></span><span>    
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>l</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nth_app_eq1</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length sla ⟹ (sla @ sl) ! i = sla ! i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nth_append</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nth_app_eq1_rev</span><span class="delimiter">:</span><span>   </span><span class="string"><span class="delete"><span class="delete">"i &lt; length sla ⟹  sla ! i = (sla @ sl) ! i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nth_append</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nth_app_eq2</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ sl i. length sla ≤ i ∧ i &lt; length (sla @ sl)
                     ⟶ (sla @ sl) ! i = sl ! (i - (length sla))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nth_append</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tl_ne_ex</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l ≠ [] ⟶ (? x . l = x # (tl l))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>l</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tl_nempty_lngth</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tl sl ≠ [] ⟶ 2 ≤ length(sl)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_less</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_app_one_length</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length l = n ⟹ (l @ [s]) ! n = s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>subst</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tl_lem1</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l ≠ [] ⟶ tl l = [] ⟶ length l = 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>l</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nth_tl_length</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tl sl ≠ [] ⟶
      tl sl ! (length (tl sl) - Suc (0)) = sl ! (length sl - Suc (0))"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>sl</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nth_tl_length1</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tl sl ≠ [] ⟶
      tl sl ! n = sl ! (n + 1)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>sl</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>   
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ineq1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length sla - n  ⟹
       (0) ≤ n ⟹ i &lt; length sla"</span></span></span><span>  
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ineq2</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length sla ≤ i ⟶ i + (1) - length sla = i - length sla + 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ineq3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tl sl ≠ []  ⟹ length sla ≤ i ⟹ i &lt; length (sla @ tl sl) - (1)
              ⟹ i - length sla + (1) &lt; length sl - (1)"</span></span></span><span>    
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tl_eq1</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sl ≠ [] ⟶ tl sl ! (0) = sl ! Suc (0)"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>sl</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tl_eq2</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tl sl = [] ⟶ sl ! (0) = sl ! (length sl - (1))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>sl</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tl_eq3</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tl sl ≠ [] ⟶
    tl sl ! (length sl - Suc (Suc (0))) = sl ! (length sl - Suc (0))"</span></span></span><span>    
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>sl</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nth_app_eq3</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tl sl ≠ []"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(sla @ tl sl) ! (length (sla @ tl sl) - (1)) = sl ! (length sl - (1))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>nth_app_eq</span><span> </span><span>nth_tl_length</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_empty_ex</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ≠ {} ⟹ ? x. x ∈ A"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fst_att_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(fst x # sl) ! (0) = fst (attack (al ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>x<span class="hidden">⇖</span></sup>))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_eq1</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sl ≠ [] ⟶
     (fst x # sl) ! (length (fst x # sl) - (1)) = sl ! (length sl - (1))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>sl</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>attack_eq1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (attack (x1 # x2a ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>x<span class="hidden">⇖</span></sup>)) = snd (attack (x2a ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>(snd (attack x1), snd x)<span class="hidden">⇖</span></sup>))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fst_lem1</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ (a:: 's set) b (c :: 's set) d. (a, c) = (b, d) ⟶ a = b"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fst_eq1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(sla ! (0), y) = attack x1 ⟹
       sla ! (0) = fst (attack x1)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>c</span><span> </span><span class="delimiter">=</span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>d</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd(attack  x1)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>fst_lem1</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>base_att_lem1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" y0 ⊆ y1 ⟹ ⊢ 𝒩<span class="hidden">⇘</span><sub>(y1, y)<span class="hidden">⇙</span></sub> ⟹⊢ 𝒩<span class="hidden">⇘</span><sub>(y0, y)<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>att_base</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ref_pres_att</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ⊑ A' ⟹ attack A = attack A'"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>refines_to.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀(A::'a attree) (l::'a attree list) (si'::'a set) (si''::'a set) (l''::'a attree list) (si::'a set)
       (si'''::'a set) (A'::'a attree) (l'::'a attree list) A''::'a attree.
       A = (l @ [𝒩<span class="hidden">⇘</span><sub>(si', si'')<span class="hidden">⇙</span></sub>] @ l'' ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>(si, si''')<span class="hidden">⇖</span></sup>) ⟹
       A' = (l' ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>(si', si'')<span class="hidden">⇖</span></sup>) ⟹ A'' = (l @ l' @ l'' ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>(si, si''')<span class="hidden">⇖</span></sup>) ⟹ attack A = attack A''"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀(as::'a attree list) (A::'a attree) (s::'a set × 'a set).
       as ≠ [] ⟹
       (∀A'::'a attree∈ (set as). ((A ⊑ A') ∧ (attack A = attack A')) ∧ attack A = s) ⟹
       attack A = attack (as ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>s<span class="hidden">⇖</span></sup>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>last_in_set</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀(A::'a attree) (A'::'a attree) A''::'a attree.
       A ⊑ A' ⟹ attack A = attack A' ⟹ A' ⊑ A'' ⟹ attack A' = attack A'' ⟹ attack A = attack A''"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀A::'a attree. attack A = attack A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>  </span><span>base_subset</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xa ⊆ xc"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"⊢𝒩<span class="hidden">⇘</span><sub>(x, xa)<span class="hidden">⇙</span></sub> ⟹ ⊢𝒩<span class="hidden">⇘</span><sub>(x, xc)<span class="hidden">⇙</span></sub>"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>att_base</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" ∀x::'a∈x. ∃xa::'a∈xa. x →<span class="hidden">⇩</span><sub>i</sub> xa ⟹ ∀x::'a∈x. ∃xa::'a∈xc. x →<span class="hidden">⇩</span><sub>i</sub> xa"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>assms</span><span> </span><span>in_mono</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Correctness Theorem"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Proof with induction over the definition of EF using the main 
lemma @{text ‹att_elem_seq0›}. 

There is also a second version of Correctness for valid refinements.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>AT_EF</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" ⊢ (A :: ('s :: state) attree)"</span></span></span><span>
</span><span>               </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"attack A = (I,s)"</span></span></span><span>
</span><span>               </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Kripke {s :: ('s :: state). ∃ i ∈ I. (i →<span class="hidden">⇩</span><sub>i</sub>* s)} (I :: ('s :: state)set)  ⊢ EF s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>check_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I ⊆ {sa::('s :: state). (∃i::'s∈I. i →<span class="hidden">⇩</span><sub>i</sub>* sa) ∧ sa ∈ EF s}"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subsetI</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>CollectI</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>state_transition_refl_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x::'s. x ∈ I ⟹ ∃i::'s∈I. (i, x) ∈ {(x::'s, y::'s). x →<span class="hidden">⇩</span><sub>i</sub> y}<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>bexI</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x::'s. x ∈ I ⟹ x ∈ EF s"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ x ∈ I. ∃ y ∈ s. x →<span class="hidden">⇩</span><sub>i</sub>* y"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x::'s∈fst (attack A). ∃y::'s. y ∈ snd (attack A) ∧ x →<span class="hidden">⇩</span><sub>i</sub>* y"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>att_elem_seq0</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" ∀x::'s∈I. ∃y::'s∈s. x →<span class="hidden">⇩</span><sub>i</sub>* y"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x::'s. x ∈ I ⟹ x ∈ EF s"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ I"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃y::'s∈s::('s :: state) set. x →<span class="hidden">⇩</span><sub>i</sub>* y"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>A</span><span> </span><span class="delimiter">=</span><span> </span><span>I</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>bspec</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>a</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x →<span class="hidden">⇩</span><sub>i</sub>* y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>bexE</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ EF s"</span></span></span><span> 
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>f</span><span> </span><span class="delimiter">=</span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>EF_step_star</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>ATV_EF</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ ⊢<span class="hidden">⇩</span><sub>V</sub> A; (I,s) = attack A ⟧ ⟹
 (Kripke {s. ∃ i ∈ I. (i →<span class="hidden">⇩</span><sub>i</sub>* s) } I  ⊢ EF s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>AT_EF</span><span> </span><span>ref_pres_att</span><span> </span><span>ref_validity_def</span><span> </span><span>valid_ref_def</span><span class="delimiter">)</span><span> 
</span><span>    
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Completeness Theorem"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This section contains the completeness direction, informally:

@{text ‹⊢ EF s ⟹ ∃ A. ⊢ A ∧ attack A = (I,s)›}.

The main theorem is presented last since its
proof just summarises a number of main lemmas @{text ‹Compl_step1, Compl_step2,
Compl_step3, Compl_step4›} which are presented first together with other
auxiliary lemmas.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Lemma @{text ‹Compl_step1›}"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Compl_step1</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">"Kripke {s :: ('s :: state). ∃ i ∈ I. (i →<span class="hidden">⇩</span><sub>i</sub>* s)} I  ⊢ EF s 
⟹ ∀ x ∈ I. ∃ y ∈ s. x →<span class="hidden">⇩</span><sub>i</sub>* y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>EF_step_star_rev</span><span> </span><span>valEF_E</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Lemma @{text ‹Compl_step2›}"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹First, we prove some auxiliary lemmas.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtrancl_imp_singleton_seq2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x →<span class="hidden">⇩</span><sub>i</sub>* y ⟹ 
          x = y ∨ (∃ s. s ≠ [] ∧ (tl s ≠ []) ∧ s ! 0 = x ∧ s ! (length s - 1) = y ∧ 
               (∀ i &lt; (length s - 1). (s ! i) →<span class="hidden">⇩</span><sub>i</sub> (s ! (Suc i))))"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>state_transition_refl_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtrancl_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>base</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step</span><span> </span><span>y</span><span> </span><span>z</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step.IH</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span> </span><span>exE</span><span> </span><span>conjE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x=y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>step.hyps</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"[y,z]"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀s. ⟦s ≠ []; tl s ≠ []; s ! 0 = x;
          s ! (length s - 1) = y;
          ∀i&lt;length s - 1.
             s ! i →<span class="hidden">⇩</span><sub>i</sub> s ! Suc i⟧
         ⟹ x = z ∨
             (∃s. s ≠ [] ∧
                  tl s ≠ [] ∧ s ! 0 = x ∧
                  s ! (length s - 1) = z ∧
                  (∀i&lt;length s - 1. s ! i →<span class="hidden">⇩</span><sub>i</sub> s ! Suc i))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjI2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"s @ [z]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nth_append</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_lessI</span><span> </span><span>diff_Suc_1</span><span> </span><span>mem_Collect_eq</span><span> </span><span>old.prod.case</span><span> </span><span>step.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tl_nempty_length</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≠ [] ⟶ tl s ≠ [] ⟶ 0 &lt; length s - 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>s</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tl_nempty_length2</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≠ [] ⟶ tl s ≠ [] ⟶ Suc 0 &lt; length s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>s</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_last</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(l @ [x]) ! (length (l @ [x]) - 1) = x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>l</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Compl_step2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ x ∈ I. ∃ y ∈ s. x →<span class="hidden">⇩</span><sub>i</sub>* y ⟹ 
                   ( ∀ x ∈ I.  x ∈ s ∨ (∃ (sl :: ((('s :: state) set)list)). 
                  (sl ≠ []) ∧ (tl sl ≠ []) ∧
                 (sl ! 0, sl ! (length sl - 1)) = ({x},s) ∧
                 (∀ i &lt; (length sl - 1).  ⊢ 𝒩<span class="hidden">⇘</span><sub>(sl ! i,sl ! (i+1) )<span class="hidden">⇙</span></sub>
                         )))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ballI</span><span class="delimiter">,</span><span> </span><span>drule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>bspec</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>bexE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ I"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x →<span class="hidden">⇩</span><sub>i</sub>* y"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ s ∨
       (∃sl::'s set list.
           sl ≠ [] ∧
           tl sl ≠ [] ∧
           (sl ! (0), sl ! (length sl - (1))) = ({x}, s) ∧
           (∀i&lt;length sl - (1). ⊢𝒩<span class="hidden">⇘</span><sub>(sl ! i, sl ! (i + (1)))<span class="hidden">⇙</span></sub>))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>d</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x = y ∨
       (∃s'. s' ≠ [] ∧
           tl s' ≠ [] ∧
           s' ! (0) = x ∧
           s' ! (length s' - (1)) = y ∧ (∀i&lt;length s' - (1). s' ! i →<span class="hidden">⇩</span><sub>i</sub> s' ! Suc i))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c</span><span> </span><span>rtrancl_imp_singleton_seq2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ s ∨
       (∃sl::'s set list.
           sl ≠ [] ∧
           tl sl ≠ [] ∧
           (sl ! (0), sl ! (length sl - (1))) = ({x}, s) ∧
           (∀i&lt;length sl - (1). ⊢𝒩<span class="hidden">⇘</span><sub>(sl ! i, sl ! (i + (1)))<span class="hidden">⇙</span></sub>))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjI2</span><span class="delimiter">,</span><span> </span><span>elim</span><span> </span><span>conjE</span><span> </span><span>exE</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"[{s' ! j}. j ← [0..&lt;(length s' - 1)]] @ [s]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nth_append</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>AT.att_base</span><span> </span><span>Suc_lessD</span><span> </span><span>fst_conv</span><span> </span><span>prod.sel</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>singletonD</span><span> </span><span>singletonI</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>AT.att_base</span><span> </span><span>Suc_lessI</span><span> </span><span>b</span><span> </span><span>fst_conv</span><span> </span><span>prod.sel</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>singletonD</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tl_nempty_length2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Lemma @{text ‹Compl_step3›}"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹First, we need a few lemmas.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_hd_lem</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n &gt; 0 ⟶ (f 0 #  map (λi. f i) [1..&lt;n]) = map  (λi. f i) [0..&lt;n]"</span></span></span><span>    
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span> </span><span class="delimiter">:</span><span> </span><span>hd_map</span><span> </span><span>upt_rec</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_Suc_lem</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n &gt; 0 ⟶ map (λ i:: nat. f i)[1..&lt;n] =
                                  map (λ i:: nat. f(Suc i))[0..&lt;(n - 1)]"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(f 0 # map (λn. f (Suc n)) [0..&lt;n - 1] = f 0 # map f [1..&lt;n]) = (map (λn. f (Suc n)) [0..&lt;n - 1] = map f [1..&lt;n])"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_pred'</span><span> </span><span>map_hd_lem</span><span> </span><span>map_upt_Suc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>forall_ex_fun</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite S ⟹ (∀ x ∈ S. (∃ y. P y x)) ⟶ (∃ f. ∀ x ∈ S. P (f x) x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>finite.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>emptyI</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>insertI</span><span> </span><span>F</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>d</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀x::'a∈insert x F. ∃y::'b. P y x)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀x::'a∈F. ∃y::'b. P y x)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>d</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x::'a∈F. P (f x) x"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>insertI.IH</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>d</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P y x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃f::'a ⇒ 'b. ∀x::'a∈insert x F. P (f x) x)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ z. if z = x then y else f z"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>nodup</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"['a, 'a list] ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span>nodup_nil</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nodup a [] = True"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span>nodup_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nodup a (x # ls) = (if x = a then (a ∉ (set ls)) else nodup a ls)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>nodup_all</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"nodup_all l ≡ ∀ x ∈ set l. nodup x l"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nodup_all_lem</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nodup_all (x1 # a # l) ⟶ (insert x1 (insert a (set l)) - {x1}) = insert a (set l)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>l</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nodup_all_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nodup_all_tl</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nodup_all (x # l) ⟶ nodup_all l"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>l</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nodup_all_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_nodup</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite I ⟹ ∃ l. set l = I ∧ nodup_all l"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>finite.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>emptyI</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nodup_all_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>insertI</span><span> </span><span>A</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>insertE</span><span> </span><span>insert_absorb</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>15</span><span class="delimiter">)</span><span> </span><span>nodup_all_def</span><span> </span><span>nodup_step</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Compl_step3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"I ≠ {} ⟹ finite I ⟹
     ( ∀ x ∈ I.  x ∈ s ∨ (∃ (sl :: ((('s :: state) set)list)). 
                  (sl ≠ []) ∧ (tl sl ≠ []) ∧
                 (sl ! 0, sl ! (length sl - 1)) = ({x},s) ∧
                 (∀ i &lt; (length sl - 1).  ⊢ 𝒩<span class="hidden">⇘</span><sub>(sl ! i,sl ! (i+1) )<span class="hidden">⇙</span></sub>
                         )) ⟹ 
     (∃ lI. set lI = {x :: 's :: state. x ∈ I ∧ x ∉ s} ∧ (∃ Sj :: ((('s :: state) set)list) list. 
               length Sj = length lI ∧ nodup_all lI ∧
            (∀ j &lt; length Sj. (((Sj ! j)  ≠ []) ∧ (tl (Sj ! j) ≠ []) ∧
                 ((Sj ! j) ! 0, (Sj ! j) ! (length (Sj ! j) - 1)) = ({lI ! j},s) ∧
                 (∀ i &lt; (length (Sj ! j) - 1).  ⊢ 𝒩<span class="hidden">⇘</span><sub>((Sj ! j) ! i, (Sj ! j) ! (i+1) )<span class="hidden">⇙</span></sub>
                         ))))))"</span></span></span><span>  
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"I ≠ {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite I"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>fa</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x::'s∈I.
       x ∈ s ∨
       (∃sl::'s set list.
           sl ≠ [] ∧
           tl sl ≠ [] ∧
           (sl ! (0), sl ! (length sl - (1))) = ({x}, s) ∧
           (∀i&lt;length sl - (1). ⊢𝒩<span class="hidden">⇘</span><sub>(sl ! i, sl ! (i + (1)))<span class="hidden">⇙</span></sub>))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ lI. set lI = {x::'s ∈ I. x ∉ s} ∧ nodup_all lI"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>f</span><span> </span><span>finite_nodup</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>lI</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set lI = {x::'s ∈ I. x ∉ s} ∧ nodup_all lI"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>exE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃lI::'s list.
       set lI = {x::'s ∈ I. x ∉ s} ∧
       (∃Sj::'s set list list.
           length Sj = length lI ∧
           nodup_all lI ∧
           (∀j&lt;length Sj.
               Sj ! j ≠ [] ∧
               tl (Sj ! j) ≠ [] ∧
               (Sj ! j ! (0), Sj ! j ! (length (Sj ! j) - (1))) = ({lI ! j}, s) ∧
               (∀i&lt;length (Sj ! j) - (1). ⊢𝒩<span class="hidden">⇘</span><sub>(Sj ! j ! i, Sj ! j ! (i + (1)))<span class="hidden">⇙</span></sub>)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>lI</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>conjE</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀ x ∈ set(lI). (∃ sl::'s set list.
              sl ≠ [] ∧
              tl sl ≠ [] ∧
              (sl ! (0), sl ! (length sl - (1))) = ({x}, s) ∧
              (∀i&lt;length sl - (1). ⊢𝒩<span class="hidden">⇘</span><sub>(sl ! i, sl ! (i + (1)))<span class="hidden">⇙</span></sub>))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b</span><span> </span><span>fa</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃Sj::'s set list list.
       length Sj = length lI ∧
       nodup_all lI ∧
       (∀j&lt;length Sj.
           Sj ! j ≠ [] ∧
           tl (Sj ! j) ≠ [] ∧
           (Sj ! j ! (0), Sj ! j ! (length (Sj ! j) - (1))) = ({lI ! j}, s) ∧
           (∀i&lt;length (Sj ! j) - (1). ⊢𝒩<span class="hidden">⇘</span><sub>(Sj ! j ! i, Sj ! j ! (i + (1)))<span class="hidden">⇙</span></sub>))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (set lI)"</span></span></span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rotate_tac</span><span> </span><span>-</span><span>1</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>forall_ex_fun</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>exE</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"[f (lI ! j). j ← [0..&lt;(length lI)]]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>conjE</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>A</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"set lI"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>B</span><span> </span><span class="delimiter">=</span><span> </span><span>I</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>finite_subset</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lemma @{text ‹Compl_step4›}›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Again, we need some additional lemmas first.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_one_tl_empty</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length l = Suc (0 :: nat) ⟶ tl l = []"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>l</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_two_tl_not_empty</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ list. length l = Suc (Suc (length list)) ⟶ tl l ≠ []"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>l</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>or_empty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⊢([] ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>({}, s)<span class="hidden">⇖</span></sup>)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>att_or</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Note, this is not valid for any l, i.e., @{text ‹⊢ l ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>({}, s)<span class="hidden">⇖</span></sup>›} is not a theorem.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_or_upt</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ l . lI ≠ [] ⟶ length l = length lI ⟶ nodup_all lI ⟶
  (∀ i &lt; length lI. (⊢ (l ! i)) ∧ (attack (l ! i) = ({lI ! i}, s))) 
                ⟶ ( ⊢ (l ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>(set lI, s)<span class="hidden">⇖</span></sup>))"</span></span></span><span>     
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>lI</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x1</span><span> </span><span>x2</span><span> </span><span>l</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀l::'a attree list.
          x2 ≠ [] ⟶
          length l = length x2 ⟶
          nodup_all x2 ⟶
          (∀i&lt;length x2. ⊢(l ! i) ∧ attack (l ! i) = ({x2 ! i}, s)) ⟶ ⊢(l ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>(set x2, s)<span class="hidden">⇖</span></sup>) ⟹
       x1 # x2 ≠ [] ⟹
       length l = length (x1 # x2) ⟹
       nodup_all (x1 # x2) ⟹
       ∀i&lt;length (x1 # x2). ⊢(l ! i) ∧ attack (l ! i) = ({(x1 # x2) ! i}, s) ⟹ ⊢(l ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>(set (x1 # x2), s)<span class="hidden">⇖</span></sup>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>x2</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>att_or</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span>l</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Case @{text ‹∀i&lt;Suc (Suc (length list)). ⊢l ! i ∧ attack (l ! i) = ({(x1 # a # list) ! i}, s) ⟹
       x2 = a # list ⟹  ⊢l ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>(insert x1 (insert a (set list)), s)<span class="hidden">⇖</span></sup>›}›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>att_or</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span>l</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>rename_tac</span><span> </span><span>lista</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span>lista</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Remaining conjunct of three conditions: @{text ‹ ⊢aa ∧
       fst (attack aa) ⊆ insert x1 (insert a (set list)) ∧
       snd (attack aa) ⊆ s ∧ ⊢ab # listb ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>(insert x1 (insert a (set list)) - fst (attack aa), s)<span class="hidden">⇖</span></sup>›}›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹First condition @{text ‹ ⊢aa›}›</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>0</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">,</span><span> </span><span>drule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>conjE</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Second condition @{text ‹fst (attack aa) ⊆ insert x1 (insert a (set list))›}›</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>0</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">,</span><span> </span><span>drule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>conjE</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The remaining conditions 

          @{text ‹snd (attack aa) ⊆ s ∧ ⊢ab # listb ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>(insert x1 (insert a (set list)) - fst (attack aa), s)<span class="hidden">⇖</span></sup>›}
 
          are solved automatically!›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_mono</span><span> </span><span>add.right_neutral</span><span> </span><span>add_Suc_right</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>nodup_all_lem</span><span> </span><span>nodup_all_tl</span><span> </span><span>nth_Cons_0</span><span> </span><span>nth_Cons_Suc</span><span> </span><span>order_refl</span><span> </span><span>prod.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>prod.sel</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>zero_less_Suc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>app_tl_empty_hd</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tl (l @ [a]) = [] ⟶ hd (l @ [a]) = a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>l</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>       
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tl_hd_empty</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tl (l @ [a]) = [] ⟶ l = []"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>l</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tl_hd_not_empty</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tl (l @ [a]) ≠ [] ⟶ l ≠ []"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>l</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>app_tl_empty_length</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tl (map f [0..&lt;length l] @ [a]) = []  
                                        ⟹ l = []"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>tl_hd_empty</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_empty_hd_fst</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l ≠ [] ⟶ hd(l @ [a]) = l ! 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>l</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>app_tl_hd_list</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tl (map f [0..&lt;length l] @ [a]) ≠ []  
                             ⟹ hd(map f [0..&lt;length l] @ [a]) = (map f [0..&lt;length l]) ! 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>tl_hd_not_empty</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>not_empty_hd_fst</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tl_app_in</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l ≠ [] ⟶
   map f [0..&lt;(length l - (Suc 0:: nat))] @ [f(length l - (Suc 0 :: nat))] = map f [0..&lt;length l]"</span></span></span><span>    
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>l</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_fst</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n &gt; 0 ⟶ map f [0..&lt;n] = f 0 # (map f [1..&lt;n])"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_lem</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"l ≠ [] ⟹
       tl (map (λ i. f((x1 # a # l) ! i)((a # l) ! i)) [0..&lt;length l]) =
       map (λi. f((a # l) ! i)(l ! i)) [0..&lt;length l - (1)]"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l ≠ []"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"map (λi. f ((x1 # a # l) ! i) ((a # l) ! i)) [0..&lt;length l] =
                 (f(x1)(a) # (map (λi. f ((a # l) ! i) (l ! i)) [0..&lt;(length l - 1)]))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"map (λi. f ((x1 # a # l) ! i) ((a # l) ! i)) [0..&lt;length l] =
                     f ((x1 # a # l) ! 0) ((a # l) ! 0) # 
                     (map (λi. f ((x1 # a # l) ! i) ((a # l) ! i)) [1..&lt;length l])"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>map_fst</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>l</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"map (λi. f ((x1 # a # l) ! i) ((a # l) ! i)) [Suc (0)..&lt;length l] =
                map (λi. f ((x1 # a # l) ! Suc i) ((a # l) ! Suc i)) [(0)..&lt;(length l - 1)]"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"[Suc (0)..&lt;length l] = map Suc [0..&lt;(length l - 1)]"</span></span></span><span class="delimiter">,</span><span> 
</span><span>             </span><span>simp</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>map_Suc_upt</span><span> </span><span>l</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map (λi. f ((x1 # a # l) ! i) ((a # l) ! i)) [0..&lt;length l] =
             f x1 a # map (λi. f ((a # l) ! i) (l ! i)) [0..&lt;length l - (1)]"</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>b</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l ≠ [] ⟹
    tl (map (λi. f ((x1 # a # l) ! i) ((a # l) ! i)) [0..&lt;length l]) =
    map (λi. f ((a # l) ! i) (l ! i)) [0..&lt;length l - Suc (0)]"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>a</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_lem2a</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; length list ⟹ map (λi. 𝒩<span class="hidden">⇘</span><sub>((x1 # a # list) ! i, (a # list) ! i)<span class="hidden">⇙</span></sub>)
        [0..&lt;length list] @
       [𝒩<span class="hidden">⇘</span><sub>((x1 # a # list) ! length list, (a # list) ! length list)<span class="hidden">⇙</span></sub>] =
       aa # listb ⟶ 𝒩<span class="hidden">⇘</span><sub>((x1, a))<span class="hidden">⇙</span></sub> = aa"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>map_fst</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_lem2b</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 = length list ⟹ map (λi. 𝒩<span class="hidden">⇘</span><sub>((x1 # a # list) ! i, (a # list) ! i)<span class="hidden">⇙</span></sub>)
        [0..&lt;length list] @
       [𝒩<span class="hidden">⇘</span><sub>((x1 # a # list) ! length list, (a # list) ! length list)<span class="hidden">⇙</span></sub>] =
       aa # listb ⟶ 𝒩<span class="hidden">⇘</span><sub>((x1, a))<span class="hidden">⇙</span></sub> = aa"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_lem2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"map (λi. 𝒩<span class="hidden">⇘</span><sub>((x1 # a # list) ! i, (a # list) ! i)<span class="hidden">⇙</span></sub>)
        [0..&lt;length list] @
       [𝒩<span class="hidden">⇘</span><sub>((x1 # a # list) ! length list, (a # list) ! length list)<span class="hidden">⇙</span></sub>] =
       aa # listb ⟹ 𝒩<span class="hidden">⇘</span><sub>((x1, a))<span class="hidden">⇙</span></sub> = aa"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"length list"</span></span></span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>step_lem2b</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>sym</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀nat.
       map (λi. 𝒩<span class="hidden">⇘</span><sub>((x1 # a # list) ! i, (a # list) ! i)<span class="hidden">⇙</span></sub>) [0..&lt;length list] @
       [𝒩<span class="hidden">⇘</span><sub>((x1 # a # list) ! length list, (a # list) ! length list)<span class="hidden">⇙</span></sub>] =
       aa # listb ⟹
       length list = Suc nat ⟹ 𝒩<span class="hidden">⇘</span><sub>(x1, a)<span class="hidden">⇙</span></sub> = aa"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>list</span><span> </span><span class="delimiter">=</span><span> </span><span>list</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>step_lem2a</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>base_list_and</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Sji ≠ [] ⟶ tl Sji ≠ [] ⟶
         (∀ li.  Sji ! (0) = li ⟶
        Sji! (length (Sji) - 1) = s ⟶
       (∀i&lt;length (Sji) - 1. ⊢𝒩<span class="hidden">⇘</span><sub>(Sji ! i, Sji ! Suc i)<span class="hidden">⇙</span></sub>) ⟶
       ⊢ (map (λi. 𝒩<span class="hidden">⇘</span><sub>(Sji ! i, Sji ! Suc i)<span class="hidden">⇙</span></sub>)
          [0..&lt;length (Sji) - Suc (0)] ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>(li, s)<span class="hidden">⇖</span></sup>))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>Sji</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>Sji</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>att_and</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span>Sji</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>impI</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>aa</span><span> </span><span>list</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"list ≠ [] ⟶
       list ! (length list - Suc 0) = s ⟶
       (∀i&lt;length list. ⊢𝒩<span class="hidden">⇘</span><sub>((aa # list) ! i, list ! i)<span class="hidden">⇙</span></sub>) ⟶
       ⊢(map (λi. 𝒩<span class="hidden">⇘</span><sub>((aa # list) ! i, list ! i)<span class="hidden">⇙</span></sub>) [0..&lt;length list] ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>(aa, s)<span class="hidden">⇖</span></sup>) ⟹
       Sji = aa # list ⟹
       (aa # list) ! length list = s ⟹
       ∀i&lt;Suc (length list). ⊢𝒩<span class="hidden">⇘</span><sub>((a # aa # list) ! i, (aa # list) ! i)<span class="hidden">⇙</span></sub> ⟹
       case map (λi. 𝒩<span class="hidden">⇘</span><sub>((a # aa # list) ! i, (aa # list) ! i)<span class="hidden">⇙</span></sub>) [0..&lt;length list] @
            [𝒩<span class="hidden">⇘</span><sub>((a # aa # list) ! length list, s)<span class="hidden">⇙</span></sub>] of
       [] ⇒ fst (a, s) ⊆ snd (a, s) | [aa] ⇒ ⊢aa ∧ attack aa = (a, s)
       | aa # ab # list ⇒
           ⊢aa ∧ fst (attack aa) = fst (a, s) ∧ ⊢(ab # list ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>(snd (attack aa), snd (a, s))<span class="hidden">⇖</span></sup>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"map (λi. 𝒩<span class="hidden">⇘</span><sub>((a # aa # list) ! i, (aa # list) ! i)<span class="hidden">⇙</span></sub>) [0..&lt;length list] @
            [𝒩<span class="hidden">⇘</span><sub>((a # aa # list) ! length list, s)<span class="hidden">⇙</span></sub>]"</span></span></span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>ab</span><span> </span><span>lista</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tl (map (λi. 𝒩<span class="hidden">⇘</span><sub>((a # aa # list) ! i, (aa # list) ! i)<span class="hidden">⇙</span></sub>) [0..&lt;length list])
                    =  (map (λi. 𝒩<span class="hidden">⇘</span><sub>((aa # list) ! i, (list) ! i)<span class="hidden">⇙</span></sub>) [0..&lt;(length list - 1)])"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"list ≠ []"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"tl (map (λi. 𝒩<span class="hidden">⇘</span><sub>((a # aa # list) ! i, (aa # list) ! i)<span class="hidden">⇙</span></sub>) [0..&lt;length list])
                    =  (map (λi. 𝒩<span class="hidden">⇘</span><sub>((aa # list) ! i, (list) ! i)<span class="hidden">⇙</span></sub>) [0..&lt;(length list - 1)])"</span></span></span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>step_lem</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>that</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"list ≠ [] ⟶
       (∀i&lt;length list. ⊢𝒩<span class="hidden">⇘</span><sub>((aa # list) ! i, list ! i)<span class="hidden">⇙</span></sub>) ⟶
       ⊢(map (λi. 𝒩<span class="hidden">⇘</span><sub>((aa # list) ! i, list ! i)<span class="hidden">⇙</span></sub>)
          [0..&lt;length list] ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>(aa, list ! (length list - Suc 0))<span class="hidden">⇖</span></sup>) ⟹
       Sji = aa # list ⟹
       ∀i&lt;Suc (length list). ⊢𝒩<span class="hidden">⇘</span><sub>((a # aa # list) ! i, (aa # list) ! i)<span class="hidden">⇙</span></sub> ⟹
       map (λi. 𝒩<span class="hidden">⇘</span><sub>((a # aa # list) ! i, (aa # list) ! i)<span class="hidden">⇙</span></sub>) [0..&lt;length list] @
       [𝒩<span class="hidden">⇘</span><sub>((a # aa # list) ! length list, (aa # list) ! length list)<span class="hidden">⇙</span></sub>] =
       ab # lista ⟹
       s = (aa # list) ! length list ⟹
       case lista of [] ⇒ ⊢ab ∧ attack ab = (a, (aa # list) ! length list)
       | aba # lista ⇒
           ⊢ab ∧ fst (attack ab) = a ∧ ⊢(aba # lista ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>(snd (attack ab), (aa # list) ! length list)<span class="hidden">⇖</span></sup>)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.split</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>app_tl_hd_list</span><span> </span><span>length_greater_0_conv</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>map_fst</span><span> </span><span>nth_Cons_0</span><span> </span><span>self_append_conv2</span><span> </span><span>upt_0</span><span> </span><span>zero_less_Suc</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>app_tl_hd_list</span><span> </span><span>attack.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>fst_conv</span><span> </span><span>length_greater_0_conv</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>map_fst</span><span> </span><span>nth_Cons_0</span><span> </span><span>self_append_conv2</span><span> </span><span>upt_0</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>app_tl_hd_list</span><span> </span><span>attack.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>fst_conv</span><span> </span><span>length_greater_0_conv</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>map_fst</span><span> </span><span>nth_Cons_0</span><span> </span><span>self_append_conv2</span><span> </span><span>upt_0</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>*</span><span> </span><span>One_nat_def</span><span> </span><span>app_tl_hd_list</span><span> </span><span>attack.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>length_greater_0_conv</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>map_fst</span><span> </span><span>nth_Cons_0</span><span> </span><span>nth_Cons_pos</span><span> </span><span>self_append_conv2</span><span> </span><span>snd_conv</span><span> </span><span>tl_app_in</span><span> </span><span>tl_append2</span><span> </span><span>upt_0</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Compl_step4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"I ≠ {} ⟹ finite I ⟹ ¬ I ⊆ s ⟹
(∃ lI. set lI = {x. x ∈ I ∧ x ∉ s} ∧ (∃ Sj :: ((('s :: state) set)list) list. 
               length Sj = length lI ∧ nodup_all lI ∧
            (∀ j &lt; length Sj. (((Sj ! j)  ≠ []) ∧ (tl (Sj ! j) ≠ []) ∧
                 ((Sj ! j) ! 0, (Sj ! j) ! (length (Sj ! j) - 1)) = ({lI ! j},s) ∧
                 (∀ i &lt; (length (Sj ! j) - 1).  ⊢ 𝒩<span class="hidden">⇘</span><sub>((Sj ! j) ! i, (Sj ! j) ! (i+1) )<span class="hidden">⇙</span></sub>
                         )))))
 ⟹  ∃ (A :: ('s :: state) attree).  ⊢ A ∧ attack A = (I,s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>exE</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>conjE</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>exE</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>conjE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>lI</span><span> </span><span>Sj</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span>  </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"I ≠ {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite I"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ I ⊆ s"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>d</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set lI = {x::'s ∈ I. x ∉ s}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length Sj = length lI"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nodup_all lI ∧ 
              (∀j&lt;length Sj. Sj ! j ≠ [] ∧
                             tl (Sj ! j) ≠ [] ∧
           (Sj ! j ! (0), Sj ! j ! (length (Sj ! j) - (1))) = ({lI ! j}, s) ∧
           (∀i&lt;length (Sj ! j) - (1). ⊢𝒩<span class="hidden">⇘</span><sub>(Sj ! j ! i, Sj ! j ! (i + (1)))<span class="hidden">⇙</span></sub>))"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">"∃A::'s attree. ⊢A ∧ attack A = (I, s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"[([] ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>({x. x ∈ I ∧ x ∈ s}, s)<span class="hidden">⇖</span></sup>),
    ([[ 𝒩<span class="hidden">⇘</span><sub>((Sj ! j) ! i, (Sj ! j) ! (i + (1)))<span class="hidden">⇙</span></sub>. 
      i ← [0..&lt;(length (Sj ! j)-(1))]] ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>(({lI ! j},s))<span class="hidden">⇖</span></sup>. j ← [0..&lt;(length Sj)]]
     ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>({x. x ∈ I ∧ x ∉ s},s)<span class="hidden">⇖</span></sup>)] ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>(I, s)<span class="hidden">⇖</span></sup>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"⊢([[] ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>({x::'s ∈ I. x ∈ s}, s)<span class="hidden">⇖</span></sup>,
       map (λj.
               ((map (λi. 𝒩<span class="hidden">⇘</span><sub>(Sj ! j ! i, Sj ! j ! (i + (1)))<span class="hidden">⇙</span></sub>)
                [0..&lt;length (Sj ! j) - (1)]) ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>({lI ! j}, s)<span class="hidden">⇖</span></sup>))
       [0..&lt;length Sj] ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>({x::'s ∈ I. x ∉ s}, s)<span class="hidden">⇖</span></sup>] ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>(I, s)<span class="hidden">⇖</span></sup>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>g</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"I - {x::'s ∈ I. x ∈ s} = {x::'s ∈ I. x ∉ s}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊢([[] ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>({x::'s ∈ I. x ∈ s}, s)<span class="hidden">⇖</span></sup>,
       (map (λj.
               ((map (λi. 𝒩<span class="hidden">⇘</span><sub>(Sj ! j ! i, Sj ! j ! (i + (1)))<span class="hidden">⇙</span></sub>)
                [0..&lt;length (Sj ! j) - (1)]) ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>({lI ! j}, s)<span class="hidden">⇖</span></sup>))
       [0..&lt;length Sj]) ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>({x::'s ∈ I. x ∉ s}, s)<span class="hidden">⇖</span></sup>] ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>(I, s)<span class="hidden">⇖</span></sup>)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>att_or</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I - {x ∈ I. x ∈ s} = {x ∈ I. x ∉ s} ⟹ ⊢([] ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>({x ∈ I. x ∈ s}, s)<span class="hidden">⇖</span></sup>)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>CollectD</span><span> </span><span>att_or_empty_back</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I - {x ∈ I. x ∈ s} = {x ∈ I. x ∉ s} ⟹
    ⊢([map (λj. ((map (λi. 𝒩<span class="hidden">⇘</span><sub>(Sj ! j ! i, Sj ! j ! Suc i)<span class="hidden">⇙</span></sub>) [0..&lt;length (Sj ! j) - Suc 0]) ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>({lI ! j}, s)<span class="hidden">⇖</span></sup>))
        [0..&lt;length Sj] ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>({x ∈ I. x ∉ s}, s)<span class="hidden">⇖</span></sup>] ⊕<span class="hidden">⇩</span><sub>∨</sub><span class="hidden">⇗</span><sup>({x ∈ I. x ∉ s}, s)<span class="hidden">⇖</span></sup>)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Use lemma @{text ‹list_or_upt›} to distribute attack validity  over list lI›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>ssubst</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>att_or</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>subst</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>d</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>lI</span><span> </span><span class="delimiter">=</span><span> </span><span>lI</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>list_or_upt</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lI ≠ []"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i.
       i &lt; length lI ⟹
       ⊢(map (λj.
                 ((map (λi. 𝒩<span class="hidden">⇘</span><sub>(Sj ! j ! i, Sj ! j ! Suc i)<span class="hidden">⇙</span></sub>)
                  [0..&lt;length (Sj ! j) - Suc (0)]) ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>({lI ! j}, s)<span class="hidden">⇖</span></sup>))
          [0..&lt;length Sj] !
         i) ∧
       (attack
        (map (λj.
                 ((map (λi. 𝒩<span class="hidden">⇘</span><sub>(Sj ! j ! i, Sj ! j ! Suc i)<span class="hidden">⇙</span></sub>)
                  [0..&lt;length (Sj ! j) - Suc (0)]) ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>({lI ! j}, s)<span class="hidden">⇖</span></sup>))
          [0..&lt;length Sj] !
         i) =
       ({lI ! i}, s))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span>e</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i.
                i &lt; length lI ⟹
                ⊢(map (λia. 𝒩<span class="hidden">⇘</span><sub>(Sj ! i ! ia, Sj ! i ! Suc ia)<span class="hidden">⇙</span></sub>)
                [0..&lt;length (Sj ! i) - Suc (0)] ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>({lI ! i}, s)<span class="hidden">⇖</span></sup>)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>              </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length lI"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n. ⊢map (λna. 𝒩<span class="hidden">⇘</span><sub>(Sj ! n ! na, Sj ! n ! Suc na)<span class="hidden">⇙</span></sub>) [0..&lt; length (Sj ! n) - 1] ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>(Sj ! n ! 0, Sj ! n ! (length (Sj ! n) - 1))<span class="hidden">⇖</span></sup> ∨ ¬ n &lt; length Sj"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>One_nat_def</span><span> </span><span>add.right_neutral</span><span> </span><span>add_Suc_right</span><span> </span><span>base_list_and</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊢map (λn. 𝒩<span class="hidden">⇘</span><sub>(Sj ! i ! n, Sj ! i ! Suc n)<span class="hidden">⇙</span></sub>) [0..&lt; length (Sj ! i) - Suc 0] ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>({lI ! i}, s)<span class="hidden">⇖</span></sup>"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>One_nat_def</span><span> </span><span>e</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>e</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Main Theorem Completeness›</span></span></span><span> 
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Completeness</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"I ≠ {} ⟹ finite I ⟹ 
Kripke {s :: ('s :: state). ∃ i ∈ I. (i →<span class="hidden">⇩</span><sub>i</sub>* s)} (I :: ('s :: state)set)  ⊢ EF s 
⟹ ∃ (A :: ('s :: state) attree). ⊢ A ∧ attack A = (I,s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"I ⊆ s"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I ≠ {} ⟹ finite I ⟹
    Kripke {s::'s. ∃i::'s∈I. i →<span class="hidden">⇩</span><sub>i</sub>* s} I ⊢ EF s ⟹ I ⊆ s ⟹ ∃A::'s attree. ⊢A ∧ attack A = (I, s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>att_or_empty_back</span><span> </span><span>attack.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I ≠ {} ⟹ finite I ⟹
    Kripke {s::'s. ∃i::'s∈I. i →<span class="hidden">⇩</span><sub>i</sub>* s} I ⊢ EF s ⟹ ¬ I ⊆ s 
   ⟹ ∃A::'s attree. ⊢A ∧ attack A = (I, s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>iprover</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Compl_step1</span><span> </span><span>Compl_step2</span><span> </span><span>Compl_step3</span><span> </span><span>Compl_step4</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Contrapositions of Correctness and Completeness›</span></span></span><span>   
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>contrapos_compl</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"I ≠ {} ⟹ finite I ⟹ 
  (¬ (∃ (A :: ('s :: state) attree). ⊢ A ∧ attack A = (I, - s))) ⟹
¬ (Kripke {s. ∃i∈I. i →<span class="hidden">⇩</span><sub>i</sub>* s} I ⊢ EF (- s))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Completeness</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>contrapos_corr</span><span class="delimiter">:</span><span>   
</span><span class="string"><span class="delete"><span class="delete">"(¬(Kripke {s :: ('s :: state). ∃ i ∈ I. (i →<span class="hidden">⇩</span><sub>i</sub>* s)} I  ⊢ EF s))
⟹ attack A = (I,s) 
⟹ ¬ (⊢ A)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AT_EF</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="Infrastructure">
<div class="head"><h1>Theory Infrastructure</h1>
<span class="command">theory</span> <span class="name">Infrastructure</span><br/>
<span class="keyword">imports</span> <a href="AT.html"><span class="name">AT</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Infrastructures›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The Isabelle Infrastructure framework supports the representation of infrastructures 
as graphs with actors and policies attached to nodes. These infrastructures 
are the {\it states} of the Kripke structure. 
The transition between states is triggered by non-parametrized
actions @{text ‹get, move, eval, put›} executed by actors. 
Actors are given by an abstract type @{text ‹actor›} and a function 
@{text ‹Actor›} that creates elements of that type from identities 
(of type @{text ‹string›}). Policies are given by pairs of predicates 
(conditions) and sets of (enabled) actions.›</span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Actors, actions, and data labels›</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Infrastructure</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>AT</span><span> 
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>action</span><span> </span><span class="delimiter">=</span><span> </span><span>get</span><span> </span><span class="delimiter">|</span><span> </span><span>move</span><span> </span><span class="delimiter">|</span><span> </span><span>eval</span><span> </span><span class="delimiter">|</span><span> </span><span>put</span><span>
</span><span>
</span><span class="keyword1"><span class="command">typedecl</span></span><span> </span><span>actor</span><span> 
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>identity</span><span> </span><span class="delimiter">=</span><span> </span><span>string</span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span> </span><span>Actor</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"string ⇒ actor"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>policy</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"((actor ⇒ bool) * action set)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ID</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[actor, string] ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ID a s ≡ (a = Actor s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The Decentralised Label Model (DLM) \cite{ml:98} introduced the idea to
label data by owners and readers. We pick up this idea and formalize
a new type to encode the owner and the set of readers as a pair.
The first element is the owner of a data item, the second one is the
set of all actors that may access the data item.
This enables the unique security 
labelling of data within the system additionally taking the ownership into 
account.›</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>data</span><span> </span><span class="delimiter">=</span><span> </span><span>nat</span><span>  
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>dlm</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"actor * actor set"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Infrastructure graphs and policies›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Actors are contained in an infrastructure graph. An @{text ‹igraph›} contains
a set of location pairs representing the topology of the infrastructure
as a graph of nodes and a list of actor identities associated to each node 
(location) in the graph.
Also an @{text ‹igraph›} associates actors to a pair of string sets by
a pair-valued function whose first range component is a set describing
the credentials in the possession of an actor and the second component
is a set defining the roles the actor can take on. More importantly in this 
context, an  @{text ‹igraph›} assigns locations to a pair of a string that defines
the state of the component and an element of type @{text ‹(dlm * data) set›}. This
set of labelled data may represent a condition on that data.
Corresponding projection functions for each of these components of an 
@{text ‹igraph›} are provided; they are named @{text ‹gra›} for the actual set of pairs of
locations, @{text ‹agra›} for the actor map, @{text ‹cgra›} for the credentials,
and @{text ‹lgra›} for the state of a location and the data at that location.›</span></span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>location</span><span> </span><span class="delimiter">=</span><span> </span><span>Location</span><span> </span><span>nat</span><span>
</span><span>  </span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>igraph</span><span> </span><span class="delimiter">=</span><span> </span><span>Lgraph</span><span> </span><span class="string"><span class="delete"><span class="delete">"(location * location)set"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ identity set"</span></span></span><span>
</span><span>                           </span><span class="string"><span class="delete"><span class="delete">"actor ⇒ (string set * string set)"</span></span></span><span>  
</span><span>                           </span><span class="string"><span class="delete"><span class="delete">"location ⇒ string * (dlm * data) set"</span></span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>infrastructure</span><span> </span><span class="delimiter">=</span><span> 
</span><span>         </span><span>Infrastructure</span><span> </span><span class="string"><span class="delete"><span class="delete">"igraph"</span></span></span><span> 
</span><span>                        </span><span class="string"><span class="delete"><span class="delete">"[igraph, location] ⇒ policy set"</span></span></span><span> 
</span><span>                       
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>loc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ nat"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"loc(Location n) = n"</span></span></span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>gra</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"igraph ⇒ (location * location)set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"gra(Lgraph g a c l) = g"</span></span></span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>agra</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"igraph ⇒ (location ⇒ identity set)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"agra(Lgraph g a c l) = a"</span></span></span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>cgra</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"igraph ⇒ (actor ⇒ string set * string set)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"cgra(Lgraph g a c l) = c"</span></span></span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>lgra</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"igraph ⇒ (location ⇒ string * (dlm * data) set)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"lgra(Lgraph g a c l) = l"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>nodes</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"igraph ⇒ location set"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nodes g == { x. (? y. ((x,y): gra g) | ((y,x): gra g))}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>actors_graph</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"igraph ⇒ identity set"</span></span></span><span>  
</span><span class="keyword2"><span class="keyword">where</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"actors_graph g == {x. ? y. y : nodes g ∧ x ∈ (agra g y)}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹There are projection functions text{@ ‹graphI›} and text{@ ‹delta›} when applied
to an infrastructure return the graph and the policy, respectively. Other projections
are introduced for the labels, the credential, and roles and to express their meaning.›</span></span></span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>graphI</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"infrastructure ⇒ igraph"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"graphI (Infrastructure g d) = g"</span></span></span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>delta</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[infrastructure, igraph, location] ⇒ policy set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"delta (Infrastructure g d) = d"</span></span></span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>tspace</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[infrastructure, actor ] ⇒ string set * string set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tspace (Infrastructure g d) = cgra g"</span></span></span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>lspace</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[infrastructure, location ] ⇒ string * (dlm * data)set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lspace (Infrastructure g d) = lgra g"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>credentials</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"string set * string set ⇒ string set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"credentials lxl ≡ (fst lxl)"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>has</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[igraph, actor * string] ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"has G ac ≡ snd ac ∈ credentials(cgra G (fst ac))"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>roles</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"string set * string set ⇒ string set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"roles lxl ≡ (snd lxl)"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>role</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[igraph, actor * string] ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"role G ac ≡ snd ac ∈ roles(cgra G (fst ac))"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>isin</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[igraph,location, string] ⇒ bool"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isin G l s ≡ s = fst (lgra G l)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Predicates and projections for the labels to encode their meaning.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>owner</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"dlm * data ⇒ actor"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"owner d ≡ fst(fst d)"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>owns</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[igraph, location, actor, dlm * data] ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"owns G l a d ≡ owner d = a"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>readers</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"dlm * data ⇒ actor set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"readers d ≡ snd (fst d)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The predicate @{text ‹has_access›} is true for owners or readers.›</span></span></span><span> 
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>has_access</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[igraph, location, actor, dlm * data] ⇒ bool"</span></span></span><span>    
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"has_access G l a d ≡ owns G l a d ∨ a ∈ readers d"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
text ‹Actors can delete data.›
definition actor_can_delete ::   "[infrastructure, actor, location] ⇒ bool"
where actor_can_delete_def: "actor_can_delete I h l ≡  
                   (∀ as n. ((h, as), n) ∉ (snd (lgra (graphI I) l)))"
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We define a type of functions that preserves the security labeling and a 
   corresponding function application  operator.›</span></span></span><span>  
</span><span class="keyword1"><span class="command">typedef</span></span><span> </span><span>label_fun</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"{f :: dlm * data ⇒ dlm * data. 
                        ∀ x:: dlm * data. fst x = fst (f x)}"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>secure_process</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"label_fun ⇒ dlm * data ⇒ dlm * data"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⇕"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f  ⇕ d ≡ (Rep_label_fun f) d"</span></span></span><span> 
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* This part is relevant to model Insiders but is not needed for Infrastructures.

datatype psy_states = happy | depressed | disgruntled | angry | stressed
datatype motivations = financial | political | revenge | curious | competitive_advantage | power | peer_recognition

datatype actor_state = Actor_state "psy_states" "motivations set"
primrec motivation :: "actor_state ⇒ motivations set" 
where "motivation  (Actor_state p m) =  m"
primrec psy_state :: "actor_state ⇒ psy_states" 
where "psy_state  (Actor_state p m) = p"

definition tipping_point :: "actor_state ⇒ bool" where
  "tipping_point a ≡ ((motivation a ≠ {}) ∧ (happy ≠ psy_state a))"

consts astate :: "identity ⇒ actor_state"

(* Two versions of an impersonation predicate "a can act as b". 
   The first one is stronger and allows substitution of the insider in any context; 
   the second one is parameterized over a context predicate to describe this.   *)
definition UasI ::  "[identity, identity] ⇒ bool " 
where "UasI a b ≡ (Actor a = Actor b) ∧ (∀ x y. x ≠ a ∧ y ≠ a ∧ Actor x = Actor y ⟶ x = y)"

definition UasI' ::  "[actor =&gt; bool, identity, identity] ⇒ bool " 
where "UasI' P a b ≡ P (Actor b) ⟶ P (Actor a)"

definition Insider :: "[identity, identity set] ⇒ bool" 
where "Insider a C ≡ (tipping_point (astate a) ⟶ (∀ b∈C. UasI a b))"

definition Insider' :: "[actor ⇒ bool, identity, identity set] ⇒ bool" 
where "Insider' P a C ≡ (tipping_point (astate a) ⟶ (∀ b∈C. UasI' P a b ∧ inj_on Actor C))"
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The predicate atI -- mixfix syntax @{text ‹@<span class="hidden">⇘</span><sub>G<span class="hidden">⇙</span></sub>›} -- expresses that an actor (identity) 
      is at a certain location in an igraph.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>atI</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[identity, igraph, location] ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ @<span class="hidden">⇘</span><sub>(_)<span class="hidden">⇙</span></sub> _"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a @<span class="hidden">⇘</span><sub>G<span class="hidden">⇙</span></sub> l ≡ a ∈ (agra G l)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Policies specify the expected behaviour of actors of an infrastructure. 
They are defined by the @{text ‹enables›} predicate:
an actor @{text ‹h›} is enabled to perform an action @{text ‹a›} 
in infrastructure @{text ‹I›}, at location @{text ‹l›}
if there exists a pair @{text ‹(p,e)›} in the local policy of @{text ‹l›}
(@{text ‹delta I l›} projects to the local policy) such that the action 
@{text ‹a›} is a member of the action set @{text ‹e›} and the policy 
predicate @{text ‹p›} holds for actor @{text ‹h›}.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>enables</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[infrastructure, location, actor, action] ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"enables I l a a' ≡  (∃ (p,e) ∈ delta I (graphI I) l. a' ∈ e ∧ p a)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The behaviour is the good behaviour, i.e. everything allowed by the policy of infrastructure I.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>behaviour</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"infrastructure ⇒ (location * actor * action)set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"behaviour I ≡ {(t,a,a'). enables I t a a'}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The misbehaviour is the complement of the behaviour of an infrastructure I.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>misbehaviour</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"infrastructure ⇒ (location * actor * action)set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"misbehaviour I ≡ -(behaviour I)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"State transition on infrastructures"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The state transition defines how actors may act on infrastructures through actions
    within the boundaries of the policy. It is given as an inductive definition over the 
    states which are infrastructures.  This state transition relation is dependent on actions but also on
    enabledness and the current state of the infrastructure.

    First we introduce some auxiliary functions dealing
    with repetitions in lists and actors moving in an igraph.›</span></span></span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>jonce</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"['a, 'a list] ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>jonce_nil</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"jonce a [] = False"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>jonce_cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"jonce a (x#ls) = (if x = a then (a ∉ (set ls)) else jonce a ls)"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
primrec nodup :: "['a, 'a list] ⇒ bool"
  where 
    nodup_nil: "nodup a [] = True" |
    nodup_step: "nodup a (x # ls) = (if x = a then (a ∉ (set ls)) else nodup a ls)"
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>move_graph_a</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[identity, location, location, igraph] ⇒ igraph"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"move_graph_a n l l' g ≡ Lgraph (gra g) 
                    (if n ∈ ((agra g) l) &amp;  n ∉ ((agra g) l') then 
                     ((agra g)(l := (agra g l) - {n}))(l' := (insert n (agra g l')))
                     else (agra g))(cgra g)(lgra g)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>state_transition_in</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[infrastructure, infrastructure] ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(_ →<span class="hidden">⇩</span><sub>n</sub> _)"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>move</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ G = graphI I; a @<span class="hidden">⇘</span><sub>G<span class="hidden">⇙</span></sub> l; l ∈ nodes G; l' ∈ nodes G;
          (a) ∈ actors_graph(graphI I); enables I l' (Actor a) move;
         I' = Infrastructure (move_graph_a a l l' (graphI I))(delta I) ⟧ ⟹ I →<span class="hidden">⇩</span><sub>n</sub> I'"</span></span></span><span> 
</span><span class="delimiter">|</span><span> </span><span>get</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ G = graphI I; a @<span class="hidden">⇘</span><sub>G<span class="hidden">⇙</span></sub> l; a' @<span class="hidden">⇘</span><sub>G<span class="hidden">⇙</span></sub> l; has G (Actor a, z);
        enables I l (Actor a) get;
        I' = Infrastructure 
                   (Lgraph (gra G)(agra G)
                           ((cgra G)(Actor a' := 
                                (insert z (fst(cgra G (Actor a'))), snd(cgra G (Actor a')))))
                           (lgra G))
                   (delta I)
         ⟧ ⟹ I →<span class="hidden">⇩</span><sub>n</sub> I'"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>get_data</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"G = graphI I ⟹ a @<span class="hidden">⇘</span><sub>G<span class="hidden">⇙</span></sub> l ⟹
        enables I l' (Actor a) get ⟹ 
       ((Actor a', as), n) ∈ snd (lgra G l') ⟹ Actor a ∈ as ⟹ 
        I' = Infrastructure 
                   (Lgraph (gra G)(agra G)(cgra G)
                   ((lgra G)(l := (fst (lgra G l), 
                                   snd (lgra G l)  ∪ {((Actor a', as), n)}))))
                   (delta I)
         ⟹ I →<span class="hidden">⇩</span><sub>n</sub> I'"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>process</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"G = graphI I ⟹ a @<span class="hidden">⇘</span><sub>G<span class="hidden">⇙</span></sub> l ⟹
        enables I l (Actor a) eval ⟹ 
       ((Actor a', as), n) ∈ snd (lgra G l) ⟹ Actor a ∈ as ⟹
        I' = Infrastructure 
                   (Lgraph (gra G)(agra G)(cgra G)
                   ((lgra G)(l := (fst (lgra G l), 
                    snd (lgra G l)  - {((Actor a', as), n)}
                    ∪ {(f :: label_fun) ⇕ ((Actor a', as), n)}))))
                   (delta I)
         ⟹ I →<span class="hidden">⇩</span><sub>n</sub> I'"</span></span></span><span>  
</span><span class="delimiter">|</span><span> </span><span>del_data</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"G = graphI I ⟹ a ∈ actors G ⟹ l ∈ nodes G ⟹
       ((Actor a, as), n) ∈ snd (lgra G l) ⟹ 
        I' = Infrastructure 
                   (Lgraph (gra G)(agra G)(cgra G)
                   ((lgra G)(l := (fst (lgra G l), snd (lgra G l) - {((Actor a, as), n)}))))
                   (delta I)
         ⟹ I →<span class="hidden">⇩</span><sub>n</sub> I'"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>put</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"G = graphI I ⟹ a @<span class="hidden">⇘</span><sub>G<span class="hidden">⇙</span></sub> l ⟹ enables I l (Actor a) put ⟹
        I' = Infrastructure 
                  (Lgraph (gra G)(agra G)(cgra G)
                          ((lgra G)(l := (s, snd (lgra G l) ∪ {((Actor a, as), n)}))))
                   (delta I)
          ⟹ I →<span class="hidden">⇩</span><sub>n</sub> I'"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Note that the type infrastructure can now be instantiated to the axiomatic type class 
      @{text‹state›} which enables the use of the underlying Kripke structures and CTL.›</span></span></span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"infrastructure"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span>state</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> 
</span><span>   </span><span>state_transition_infra_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(i →<span class="hidden">⇩</span><sub>i</sub> i') =  (i →<span class="hidden">⇩</span><sub>n</sub> (i' :: infrastructure))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>MC.class.MC.state.of_class.intro</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>state_transition_in_refl</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(_ →<span class="hidden">⇩</span><sub>n</sub>* _)"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s →<span class="hidden">⇩</span><sub>n</sub>* s' ≡ ((s,s') ∈ {(x,y). state_transition_in x y}<span class="hidden">⇧</span><sup>*</sup>)"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>      
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>move_graph_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"move_graph_a a l l g = g"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>move_graph_a_def</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span>g</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span>     
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>  </span></pre>
</div>
</div><div id="GDPRhealthcare">
<div class="head"><h1>Theory GDPRhealthcare</h1>
<span class="command">theory</span> <span class="name">GDPRhealthcare</span><br/>
<span class="keyword">imports</span> <a href="Infrastructure.html"><span class="name">Infrastructure</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Application example from IoT healthcare›</span></span></span><span> 
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The  example of an IoT healthcare systems is taken from the context of the CHIST-ERA project
SUCCESS \cite{suc:16}.  In this system architecture, data is collected by sensors 
in the home or via a smart phone helping to monitor bio markers of the patient. The data 
collection is in a cloud based server to enable hospitals (or scientific institutions) 
to access the data which is controlled via the smart phone.
The identities Patient and Doctor represent patients
and their doctors; double quotes ''s'' indicate strings 
in Isabelle/HOL.
The global policy is `only the patient and the doctor can access the data in the cloud'.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>GDPRhealthcare</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Infrastructure</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Local policies are represented as a function over an @{text ‹igraph G›} 
      that additionally assigns each location of a scenario to its local policy 
      given as a pair of requirements to an actor (first element of the pair) in 
      order to grant him actions in the location (second element of the pair). 
      The predicate @{text ‹@G›} checks whether an actor is at a given location 
       in the @{text ‹igraph G›}.›</span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>scenarioGDPR</span><span> </span><span class="delimiter">=</span><span> 
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>gdpr_actors</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"identity set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>gdpr_actors_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gdpr_actors ≡ {''Patient'', ''Doctor''}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>gdpr_locations</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>gdpr_locations_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gdpr_locations ≡ 
          {Location 0, Location 1, Location 2, Location 3}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>sphone</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>sphone_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sphone ≡ Location 0"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>home</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>home_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"home ≡ Location 1"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>hospital</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>hospital_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hospital ≡ Location 2"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>cloud</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>cloud_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cloud ≡ Location 3"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>global_policy</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[infrastructure, identity] ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>global_policy_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"global_policy I a ≡ a ≠ ''Doctor'' 
                 ⟶ ¬(enables I hospital (Actor a) eval)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>global_policy'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[infrastructure, identity] ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>global_policy'_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"global_policy' I a ≡ a ∉ gdpr_actors 
                 ⟶ ¬(enables I cloud (Actor a) get)"</span></span></span><span>  
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>ex_creds</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"actor ⇒ (string set * string set)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>ex_creds_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ex_creds ≡ (λ x. if x = Actor ''Patient'' then 
                         ({''PIN'',''skey''}, {}) else 
                            (if x = Actor ''Doctor'' then
                                ({''PIN''},{}) else ({},{})))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>ex_locs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ string * (dlm * data) set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ex_locs ≡ (λ x.  if x = cloud then
             (''free'',{((Actor ''Patient'',{Actor ''Doctor''}),42)}) 
             else ('''',{}))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>ex_loc_ass</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"location ⇒ identity set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>ex_loc_ass_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ex_loc_ass ≡
          (λ x.  if x = home then {''Patient''}  
                 else (if x = hospital then {''Doctor'', ''Eve''} 
                       else {}))"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* The nicer representation with case suffers from
   not so nice presentation in the cases (need to unfold the syntax)  
fixes ex_loc_ass_alt :: "location ⇒ identity set"
defines ex_loc_ass_alt_def: "ex_loc_ass_alt ≡
          (λ x.  (case x of 
             Location (Suc 0) ⇒ {''Patient''}  
           | Location (Suc (Suc 0)) ⇒ {''Doctor'', ''Eve''} 
           |  _ ⇒ {}))"
*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>ex_graph</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"igraph"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>ex_graph_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ex_graph ≡ Lgraph 
     {(home, cloud), (sphone, cloud), (cloud,hospital)}
     ex_loc_ass
     ex_creds ex_locs"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>ex_graph'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"igraph"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>ex_graph'_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ex_graph' ≡ Lgraph 
     {(home, cloud), (sphone, cloud), (cloud,hospital)}
       (λ x. if x = cloud then {''Patient''} else 
           (if x = hospital then {''Doctor'',''Eve''} else {})) 
     ex_creds ex_locs"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>ex_graph''</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"igraph"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>ex_graph''_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ex_graph'' ≡ Lgraph 
     {(home, cloud), (sphone, cloud), (cloud,hospital)}
       (λ x. if x = cloud then {''Patient'', ''Eve''} else 
           (if x = hospital then {''Doctor''} else {})) 
     ex_creds ex_locs"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Same as above: the nicer representation with case suffers from
   not so nice presentation in the cases (need to unfold the syntax) 
fixes local_policies_alt :: "[igraph, location] ⇒ policy set"
defines local_policies_alt_def: "local_policies_alt G ≡ 
    (λ x. case x of 
         Location (Suc 0) ⇒ {(λ y. True, {put,get,move,eval})}
       | Location 0 ⇒ {((λ y. has G (y, ''PIN'')), {put,get,move,eval})} 
       | Location (Suc (Suc (Suc 0))) ⇒ {(λ y. True, {put,get,move,eval})}
       | Location (Suc (Suc 0)) ⇒
                {((λ y. (∃ n. (n  @<span class="hidden">⇘</span><sub>G<span class="hidden">⇙</span></sub> hospital) ∧ Actor n = y ∧ 
                           has G (y, ''skey''))), {put,get,move,eval})} 
       | _ ⇒  {})"
*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>local_policies</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[igraph, location] ⇒ policy set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>local_policies_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"local_policies G ≡ 
    (λ x. if x = home then
        {(λ y. True, {put,get,move,eval})}
          else (if x = sphone then 
             {((λ y. has G (y, ''PIN'')), {put,get,move,eval})} 
                else (if x = cloud then
                {(λ y. True, {put,get,move,eval})}
                       else (if x = hospital then
                {((λ y. (∃ n. (n  @<span class="hidden">⇘</span><sub>G<span class="hidden">⇙</span></sub> hospital) ∧ Actor n = y ∧ 
                           has G (y, ''skey''))), {put,get,move,eval})} else {}))))"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* problems with case in locales?
defines local_policies_def: "local_policies G x ≡ 
     (case x of 
       home ⇒ {(λ y. True, {put,get,move,eval})}
     | sphone ⇒ {((λ y. has G (y, ''PIN'')), {put,get,move,eval})} 
     | cloud ⇒ {(λ y. True, {put,get,move,eval})}
     | hospital ⇒ {((λ y. (∃ n. (n  @<span class="hidden">⇘</span><sub>G<span class="hidden">⇙</span></sub> hospital) ∧ Actor n = y ∧ 
                           has G (y, ''skey''))), {put,get,move,eval})} 
     | _ ⇒  {})"
*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>gdpr_scenario</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"infrastructure"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>gdpr_scenario_def</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"gdpr_scenario ≡ Infrastructure ex_graph local_policies"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>Igdpr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"infrastructure set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>Igdpr_def</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Igdpr ≡ {gdpr_scenario}"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* other states of scenario *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* First step: Patient goes onto cloud *)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>gdpr_scenario'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"infrastructure"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>gdpr_scenario'_def</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"gdpr_scenario' ≡ Infrastructure ex_graph' local_policies"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>GDPR'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"infrastructure set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>GDPR'_def</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"GDPR' ≡ {gdpr_scenario'}"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Second step: Eve goes onto cloud from where she'll be able to get the data *)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>gdpr_scenario''</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"infrastructure"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>gdpr_scenario''_def</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"gdpr_scenario'' ≡ Infrastructure ex_graph'' local_policies"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>GDPR''</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"infrastructure set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>GDPR''_def</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"GDPR'' ≡ {gdpr_scenario''}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>gdpr_states</span><span>
</span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>gdpr_states_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gdpr_states ≡ { I. gdpr_scenario →<span class="hidden">⇩</span><sub>i</sub>* I }"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>gdpr_Kripke</span><span>
</span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gdpr_Kripke ≡ Kripke gdpr_states {gdpr_scenario}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>sgdpr</span><span> 
</span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sgdpr ≡ {x. ¬ (global_policy' x ''Eve'')}"</span></span></span><span>  
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Using Attack Tree Calculus›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Since we consider a predicate transformer semantics, we use sets of states 
     to represent properties. For example, the attack property is given by the above
     @{text ‹set sgdpr›}.

The attack we are interested in is to see whether for the scenario

@{text ‹gdpr scenario ≡ Infrastructure ex_graph local_policies›}

from the initial state 

@{text ‹Igdpr ≡{gdpr scenario}›}, 

the critical state
@{text ‹sgdpr›} can be reached, i.e., is there a valid attack @{text ‹(Igdpr,sgdpr)›}?

We first present a number of lemmas showing single and multi-step state transitions
for relevant states reachable from our @{text ‹gdpr_scenario›}.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gdpr_scenario  →<span class="hidden">⇩</span><sub>n</sub> gdpr_scenario'"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>l</span><span> </span><span class="delimiter">=</span><span> </span><span>home</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"''Patient''"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>l'</span><span> </span><span class="delimiter">=</span><span> </span><span>cloud</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>move</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"graphI gdpr_scenario = graphI gdpr_scenario"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"''Patient'' @<span class="hidden">⇘</span><sub>graphI gdpr_scenario<span class="hidden">⇙</span></sub> home"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gdpr_scenario_def</span><span> </span><span>ex_graph_def</span><span> </span><span>ex_loc_ass_def</span><span> </span><span>atI_def</span><span> </span><span>nodes_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"home ∈ nodes (graphI gdpr_scenario)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gdpr_scenario_def</span><span> </span><span>ex_graph_def</span><span> </span><span>ex_loc_ass_def</span><span> </span><span>atI_def</span><span> </span><span>nodes_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cloud ∈ nodes (graphI gdpr_scenario)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gdpr_scenario_def</span><span> </span><span>nodes_def</span><span> </span><span>ex_graph_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"''Patient'' ∈ actors_graph (graphI gdpr_scenario)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>actors_graph_def</span><span> </span><span>gdpr_scenario_def</span><span> </span><span>ex_graph_def</span><span> </span><span>ex_loc_ass_def</span><span> </span><span>nodes_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enables gdpr_scenario cloud (Actor ''Patient'') move"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>enables_def</span><span> </span><span>gdpr_scenario_def</span><span> </span><span>ex_graph_def</span><span> </span><span>local_policies_def</span><span>
</span><span>                    </span><span>ex_creds_def</span><span> </span><span>ex_locs_def</span><span> </span><span>has_def</span><span> </span><span>credentials_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gdpr_scenario' =
    Infrastructure (move_graph_a ''Patient'' home cloud (graphI gdpr_scenario)) (delta gdpr_scenario)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gdpr_scenario'_def</span><span> </span><span>ex_graph'_def</span><span> </span><span>move_graph_a_def</span><span> 
</span><span>                     </span><span>gdpr_scenario_def</span><span> </span><span>ex_graph_def</span><span> </span><span>home_def</span><span> </span><span>cloud_def</span><span> </span><span>hospital_def</span><span>
</span><span>                     </span><span>ex_loc_ass_def</span><span> </span><span>ex_creds_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hospital_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step1r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gdpr_scenario  →<span class="hidden">⇩</span><sub>n</sub>* gdpr_scenario'"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>state_transition_in_refl_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" (gdpr_scenario, gdpr_scenario') ∈ {(x::infrastructure, y::infrastructure). x →<span class="hidden">⇩</span><sub>n</sub> y}<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>step1</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gdpr_scenario'  →<span class="hidden">⇩</span><sub>n</sub> gdpr_scenario''"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>l</span><span> </span><span class="delimiter">=</span><span> </span><span>hospital</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"''Eve''"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>l'</span><span> </span><span class="delimiter">=</span><span> </span><span>cloud</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>move</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"''Eve'' @<span class="hidden">⇘</span><sub>graphI gdpr_scenario'<span class="hidden">⇙</span></sub> hospital"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gdpr_scenario'_def</span><span> </span><span>ex_graph'_def</span><span> </span><span>hospital_def</span><span> </span><span>cloud_def</span><span> </span><span>atI_def</span><span> </span><span>nodes_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hospital ∈ nodes (graphI gdpr_scenario')"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gdpr_scenario'_def</span><span> </span><span>ex_graph'_def</span><span> </span><span>hospital_def</span><span> </span><span>cloud_def</span><span> </span><span>atI_def</span><span> </span><span>nodes_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cloud ∈ nodes (graphI gdpr_scenario')"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gdpr_scenario'_def</span><span> </span><span>nodes_def</span><span> </span><span>ex_graph'_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"''Eve'' ∈ actors_graph (graphI gdpr_scenario')"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>actors_graph_def</span><span> </span><span>gdpr_scenario'_def</span><span> </span><span>ex_graph'_def</span><span> </span><span>nodes_def</span><span>
</span><span>                     </span><span>hospital_def</span><span> </span><span>cloud_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enables gdpr_scenario' cloud (Actor ''Eve'') move"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>enables_def</span><span> </span><span>gdpr_scenario'_def</span><span> </span><span>ex_graph_def</span><span> </span><span>local_policies_def</span><span>
</span><span>                  </span><span>ex_creds_def</span><span> </span><span>ex_locs_def</span><span> </span><span>has_def</span><span> </span><span>credentials_def</span><span> </span><span>cloud_def</span><span> </span><span>sphone_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gdpr_scenario'' =
    Infrastructure (move_graph_a ''Eve'' hospital cloud (graphI gdpr_scenario')) (delta gdpr_scenario')"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gdpr_scenario'_def</span><span> </span><span>ex_graph''_def</span><span> </span><span>move_graph_a_def</span><span> </span><span>gdpr_scenario''_def</span><span> 
</span><span>                     </span><span>ex_graph'_def</span><span> </span><span>home_def</span><span> </span><span>cloud_def</span><span> </span><span>hospital_def</span><span> </span><span>ex_creds_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hospital_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step2r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gdpr_scenario'  →<span class="hidden">⇩</span><sub>n</sub>* gdpr_scenario''"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>state_transition_in_refl_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(gdpr_scenario', gdpr_scenario'') ∈ {(x::infrastructure, y::infrastructure). x →<span class="hidden">⇩</span><sub>n</sub> y}<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>step2</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>     
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Attack example: Eve can get onto cloud and get Patient's data 
   because the policy allows Eve to get on cloud.
   This attack can easily be fixed by disabling Eve to "get"
   in the policy (just change the "True" for cloud to a set with no 
   Eve in it).
   However, it would not prevent Insider attacks (where Eve is 
   impersonating the Doctor, for example). Insider attacks can
   be checked using the UasI predicate.
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹For the Kripke structure

@{text ‹gdpr_Kripke ≡ Kripke { I. gdpr_scenario →<span class="hidden">⇩</span><sub>i</sub>* I } {gdpr_scenario}›}

we first derive a valid and-attack using the attack tree proof calculus.

@{text ‹"⊢[𝒩<span class="hidden">⇘</span><sub>(Igdpr,GDPR')<span class="hidden">⇙</span></sub>, 𝒩<span class="hidden">⇘</span><sub>(GDPR',sgdpr)<span class="hidden">⇙</span></sub>] ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>(Igdpr,sgdpr)<span class="hidden">⇖</span></sup>›}

The set @{text ‹GDPR'›} (see above) is an intermediate state where Eve accesses the cloud.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gdpr_ref</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[𝒩<span class="hidden">⇘</span><sub>(Igdpr,sgdpr)<span class="hidden">⇙</span></sub>] ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>(Igdpr,sgdpr)<span class="hidden">⇖</span></sup> ⊑
                  ([𝒩<span class="hidden">⇘</span><sub>(Igdpr,GDPR')<span class="hidden">⇙</span></sub>, 𝒩<span class="hidden">⇘</span><sub>(GDPR',sgdpr)<span class="hidden">⇙</span></sub>] ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>(Igdpr,sgdpr)<span class="hidden">⇖</span></sup>)"</span></span></span><span>  
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>l</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>l'</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"[𝒩<span class="hidden">⇘</span><sub>(Igdpr,GDPR')<span class="hidden">⇙</span></sub>, 𝒩<span class="hidden">⇘</span><sub>(GDPR',sgdpr)<span class="hidden">⇙</span></sub>]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>                  </span><span>l''</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>si</span><span> </span><span class="delimiter">=</span><span> </span><span>Igdpr</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>si'</span><span> </span><span class="delimiter">=</span><span> </span><span>Igdpr</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>                  </span><span>si''</span><span> </span><span class="delimiter">=</span><span> </span><span>sgdpr</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>si'''</span><span> </span><span class="delimiter">=</span><span> </span><span>sgdpr</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>refI</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"([𝒩<span class="hidden">⇘</span><sub>(Igdpr, GDPR')<span class="hidden">⇙</span></sub>, 𝒩<span class="hidden">⇘</span><sub>(GDPR', sgdpr)<span class="hidden">⇙</span></sub>] ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>(Igdpr, sgdpr)<span class="hidden">⇖</span></sup>) =
    ([] @ [𝒩<span class="hidden">⇘</span><sub>(Igdpr, GDPR')<span class="hidden">⇙</span></sub>, 𝒩<span class="hidden">⇘</span><sub>(GDPR', sgdpr)<span class="hidden">⇙</span></sub>] @ [] ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>(Igdpr, sgdpr)<span class="hidden">⇖</span></sup>)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>att_gdpr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⊢([𝒩<span class="hidden">⇘</span><sub>(Igdpr,GDPR')<span class="hidden">⇙</span></sub>, 𝒩<span class="hidden">⇘</span><sub>(GDPR',sgdpr)<span class="hidden">⇙</span></sub>] ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>(Igdpr,sgdpr)<span class="hidden">⇖</span></sup>)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>att_and</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" ⊢𝒩<span class="hidden">⇘</span><sub>(Igdpr, GDPR')<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Igdpr_def</span><span> </span><span>GDPR'_def</span><span> </span><span>att_base</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>state_transition_infra_def</span><span> </span><span>step1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ global_policy' gdpr_scenario'' ''Eve''"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gdpr_scenario' →<span class="hidden">⇩</span><sub>n</sub> gdpr_scenario''"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step2</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>global_policy'_def</span><span> </span><span>gdpr_scenario''_def</span><span> </span><span>gdpr_actors_def</span><span> 
</span><span>                      </span><span>enables_def</span><span> </span><span>local_policies_def</span><span> </span><span>cloud_def</span><span> </span><span>sphone_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>step2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊢([𝒩<span class="hidden">⇘</span><sub>(GDPR', sgdpr)<span class="hidden">⇙</span></sub>] ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>(GDPR', sgdpr)<span class="hidden">⇖</span></sup>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>att_and</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>GDPR'_def</span><span> </span><span>sgdpr_def</span><span> </span><span>att_base</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>state_transition_infra_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gdpr_abs_att</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⊢<span class="hidden">⇩</span><sub>V</sub>([𝒩<span class="hidden">⇘</span><sub>(Igdpr,sgdpr)<span class="hidden">⇙</span></sub>] ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>(Igdpr,sgdpr)<span class="hidden">⇖</span></sup>)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ref_valI</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>gdpr_ref</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>att_gdpr</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We can then simply apply the Correctness theorem @{text ‹AT EF›} to immediately 
      prove the following CTL statement.

      @{text ‹gdpr_Kripke ⊢ EF sgdpr›}

This application of the meta-theorem of Correctness of attack trees saves us
proving the CTL formula tediously by exploring the state space.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gdpr_att</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gdpr_Kripke ⊢ EF {x. ¬(global_policy' x ''Eve'')}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" ⊢([𝒩<span class="hidden">⇘</span><sub>(Igdpr, GDPR')<span class="hidden">⇙</span></sub>, 𝒩<span class="hidden">⇘</span><sub>(GDPR', sgdpr)<span class="hidden">⇙</span></sub>] ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>(Igdpr, sgdpr)<span class="hidden">⇖</span></sup>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>att_gdpr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Igdpr,sgdpr) = attack ([𝒩<span class="hidden">⇘</span><sub>(Igdpr, GDPR')<span class="hidden">⇙</span></sub>, 𝒩<span class="hidden">⇘</span><sub>(GDPR', sgdpr)<span class="hidden">⇙</span></sub>] ⊕<span class="hidden">⇩</span><sub>∧</sub><span class="hidden">⇗</span><sup>(Igdpr, sgdpr)<span class="hidden">⇖</span></sup>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Kripke {s::infrastructure. ∃i::infrastructure∈Igdpr. i →<span class="hidden">⇩</span><sub>i</sub>* s} Igdpr ⊢ EF sgdpr"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ATV_EF</span><span> </span><span>gdpr_abs_att</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gdpr_Kripke ⊢ EF {x::infrastructure. ¬ global_policy' x ''Eve''}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gdpr_Kripke_def</span><span> </span><span>gdpr_states_def</span><span> </span><span>Igdpr_def</span><span> </span><span>sgdpr_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gdpr_EF</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gdpr_Kripke ⊢ EF sgdpr"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gdpr_att</span><span> </span><span>sgdpr_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Similarly, vice-versa, the CTL statement proved in @{text ‹gdpr_EF›}
    can now be directly translated into Attack Trees using the Completeness 
    Theorem\footnote{This theorem could easily 
    be proved as a direct instance of @{text ‹att_gdpr›} above but we want to illustrate
    an alternative proof method using Completeness here.}.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gdpr_AT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ A. ⊢ A ∧ attack A = (Igdpr,sgdpr)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gdpr_Kripke ⊢ EF sgdpr "</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gdpr_EF</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Igdpr ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Igdpr_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃A::infrastructure attree. ⊢A ∧ attack A = (Igdpr, sgdpr)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Completeness</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Kripke {s. ∃i∈Igdpr. i →<span class="hidden">⇩</span><sub>i</sub>* s} Igdpr ⊢ EF sgdpr"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gdpr_Kripke_def</span><span> </span><span>Igdpr_def</span><span> </span><span>gdpr_states_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Igdpr_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Conversely, since we have an attack given by rule @{text ‹gdpr_AT›}, we can immediately 
   infer @{text ‹EF s›} using Correctness @{text ‹AT_EF›}\footnote{Clearly, this theorem is identical
   to @{text ‹gdpr_EF›} and could thus be inferred from that one but we want to show here an 
   alternative way of proving it using the Correctness theorem @{text ‹AT_EF›}.}.›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>gdpr_EF'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gdpr_Kripke ⊢ EF sgdpr"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gdpr_AT</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>gdpr_Kripke_def</span><span> </span><span>gdpr_states_def</span><span> </span><span>Igdpr_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>AT_EF</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* However, when integrating DLM into the model and hence labeling
   information becomes part of the conditions of the get_data rule this isn't
   possible any more: gdpr_EF is not true any more *)</span></span></span></span></span><span>    
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(** GDPR properties  for the illustration of the DLM labeling **)</span></span></span></span></span><span>    
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Data Protection by Design for GDPR compliance›</span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹General Data Protection Regulation (GDPR)›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Since 26th May 2018, the GDPR has become mandatory within the European Union and hence 
also for any supplier of IT products. Breaches of the regulation will be fined with penalties 
of 20 Million EUR. Despite the relatively large size of the document of 209 pages, the technically 
relevant portion for us is only about 30 pages (Pages 81–111, Chapters I to Chapter III, Section 3). 
In summary, Chapter III specifies that the controller must give the data subject read access (1) 
to any information, communications, and “meta-data” of the data, e.g., retention time and purpose. 
In addition, the system must enable deletion of data (2) and restriction of processing.
An invariant condition for data processing resulting from these Articles is that the system functions 
must preserve any of the access rights of personal data (3).

Using labeled data, we can now express the essence of Article 4 Paragraph (1): 
’personal data’ means any information relating to an identified or identifiable natural 
person (’data subject’).

The labels of data must not be changed by processing: we have identified this  as 
an invariant (3) resulting from the GDPR above. This invariant is formalized in 
our Isabelle model by the type definition of functions on labeled data @{text ‹label_fun›}
(see Section 4.2) that preserve the data labels.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Policy enforcement and privacy preservation›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We can now use the labeled data to encode the privacy constraints of the 
    GDPR in the rules. For example, the get data rule (see Section 4.3) has labelled data 
    @{text ‹((Actor a’, as), n)›} and uses the labeling in the precondition to guarantee 
    that only entitled users can get data.

We can prove that processing preserves ownership as defined in the initial state for all paths 
globally (AG) within the Kripke structure and in all locations of the graph.›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* GDPR three: Processing preserves ownership in any location *)</span></span></span></span></span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gdpr_three</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"h ∈ gdpr_actors ⟹ l ∈ gdpr_locations ⟹
         owns (Igraph gdpr_scenario) l (Actor h) d ⟹
         gdpr_Kripke ⊢ AG {x. ∀ l ∈ gdpr_locations. owns (Igraph x) l (Actor h) d }"</span></span></span><span>  
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gdpr_Kripke_def</span><span> </span><span>check_def</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gdpr_scenario ∈ gdpr_states"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gdpr_states_def</span><span> </span><span>state_transition_refl_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h ∈ gdpr_actors ⟹
    l ∈ gdpr_locations ⟹
    owns (Igraph gdpr_scenario) l (Actor h) d ⟹
    gdpr_scenario ∈ AG {x::infrastructure. ∀l∈gdpr_locations. owns (Igraph x) l (Actor h) d}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>AG_def</span><span> </span><span>gfp_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"{x::infrastructure. ∀l∈gdpr_locations. owns (Igraph x) l (Actor h) d}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>AX_def</span><span> </span><span>gdpr_scenario_def</span><span> </span><span>owns_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The final application example of Correctness contraposition 
   shows that there is no attack to ownership possible.
The proved meta-theory for attack trees can be applied to facilitate the proof. 
The contraposition of the Correctness property grants that if there is no attack on 
@{text ‹(I,¬f)›}, then @{text ‹(EF ¬f)›} does not hold in the Kripke structure. This 
yields the theorem since the @{text ‹AG f›} statement corresponds to @{text ‹¬(EF ¬f)›}.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>no_attack_gdpr_three</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">"h ∈ gdpr_actors ⟹ l ∈ gdpr_locations ⟹ 
 owns (Igraph gdpr_scenario) l (Actor h) d ⟹
attack A = (Igdpr, -{x. ∀ l ∈ gdpr_locations. owns (Igraph x) l (Actor h) d })
⟹ ¬ (⊢ A)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>I</span><span> </span><span class="delimiter">=</span><span> </span><span>Igdpr</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>           </span><span>s</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"-{x::infrastructure. ∀l∈gdpr_locations. owns (Igraph x) l (Actor h) d}"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>contrapos_corr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h ∈ gdpr_actors ⟹
    l ∈ gdpr_locations ⟹
    owns (Igraph gdpr_scenario) l (Actor h) d ⟹
    attack A = (Igdpr, - {x::infrastructure. ∀l∈gdpr_locations. owns (Igraph x) l (Actor h) d}) ⟹
    ¬ (Kripke {s::infrastructure. ∃i::infrastructure∈Igdpr. i →<span class="hidden">⇩</span><sub>i</sub>* s}
        Igdpr ⊢ EF (- {x::infrastructure. ∀l∈gdpr_locations. owns (Igraph x) l (Actor h) d}))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>AG_imp_notnotEF</span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gdpr_Kripke_def</span><span> </span><span>Igdpr_def</span><span> </span><span>gdpr_states_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Igdpr_def</span><span> </span><span>gdpr_Kripke_def</span><span> </span><span>gdpr_states_def</span><span> </span><span>gdpr_three</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div>