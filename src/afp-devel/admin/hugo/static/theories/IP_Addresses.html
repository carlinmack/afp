<div id="NumberWang_IPv4">
<div class="head"><h1>Theory NumberWang_IPv4</h1>
<span class="command">theory</span> <span class="name">NumberWang_IPv4</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL-Word/Word.html"><span class="name">Word</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>NumberWang_IPv4</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Word.Word"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Helper Lemmas for Low-Level Operations on Machine Words›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Needed for IPv4 Syntax›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mod256</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"((d::nat) + 256 * c + 65536 * b + 16777216 * a) mod 256 = d mod 256"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>mod_mult_self2</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"d + 256 * c + 65536 * b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"256"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"65536 * a"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(d + 256 * c + 65536 * b + 256 * 65536 * a) mod 256 = (d + 256 * c + 65536 * b) mod 256"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"…  = (d + 256 * c) mod 256"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mod_mult_self2</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"d + 256 * c"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"256"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"256 * b"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = d mod 256"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mod_mult_self2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>div65536</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a &lt; 256"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b &lt; 256"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c &lt; 256"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d &lt; 256"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ((int d + int (256 * c) + int (65536 * b) + int (16777216 * a)) div 65536 mod 256) = b"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>zdiv_mult_self</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"int d + int (256 * c) + int (65536 * b)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>65536</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"256 * (int a)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(int d + int (256 * c) + int (65536 * b) + int (16777216 * a)) div 65536 =
     ((int d + int (256 * c) + int (65536 * b)) div 65536) + 256 * int a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>zdiv_mult_self</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"int d + int (256 * c)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"65536"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"int b"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"… = (int d + int (256 * c)) div 65536 + int b + 256 * int a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = int b + 256 * int a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>helper</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(int d + int (256 * c) + int (65536 * b) + int (16777216 * a)) div 65536 = int b + 256 * int a"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>div256</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a &lt; 256"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b &lt; 256"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c &lt; 256"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d &lt; 256"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ((int d + int (256 * c) + int (65536 * b) + int (16777216 * a)) div 256 mod 256) = c"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>zdiv_mult_self</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"int d + int (256 * c) + int (65536 * b)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>256</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"65536 * (int a)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(int d + int (256 * c) + int (65536 * b) + int (16777216 * a)) div 256 =
     ((int d + int (256 * c) + int (65536 * b)) div 256) + 65536 * int a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>zdiv_mult_self</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"int d + int (256 * c)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"256"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"256 * int b"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"… = (int d + int (256 * c)) div 256 + 256 * int b + 65536 * int a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>zdiv_mult_self</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"int d"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"256"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"int c"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"… = (int d) div 256 + int c + 256 * int b + 65536 * int a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = int c + 256 * int b + 65536 * int a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>helper1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(int d + int (256 * c) + int (65536 * b) + int (16777216 * a)) div 256 =
                          int c + 256 * int b + 65536 * int a"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>mod_mult_self2</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"int c + 256 * int b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"256 * int a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">=</span><span>256</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(int c + 256 * int b + 65536 * int a) mod 256 = (int c + 256 * int b) mod 256"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = int c mod 256"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mod_mult_self2</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"int c"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">=</span><span>256</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"int b"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = int c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>mod_pos_pos_trivial</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>helper2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(int c + 256 * int b + 65536 * int a) mod 256 = int c"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>helper1</span><span> </span><span>helper2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="NumberWang_IPv6">
<div class="head"><h1>Theory NumberWang_IPv6</h1>
<span class="command">theory</span> <span class="name">NumberWang_IPv6</span><br/>
<span class="keyword">imports</span> <a href="../Word_Lib/Word_Lemmas.html"><span class="name">Word_Lemmas</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>NumberWang_IPv6</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>  </span><span>Word_Lib.Word_Lemmas</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Helper Lemmas for Low-Level Operations on Machine Words›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Needed for IPv6 Syntax›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_drop_bl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length (dropWhile Not (to_bl (of_bl bs))) ≤ length bs"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>length_takeWhile_Not_replicate_False</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"length (takeWhile Not (replicate n False @ ls)) = n + length (takeWhile Not ls)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span> </span><span>ls</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>takeWhile_append2</span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>word_rep_drop</span><span> </span><span>dropWhile_eq_drop</span><span> </span><span>length_takeWhile_Not_replicate_False</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bl_drop_leading_zeros</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(of_bl:: bool list ⇒ 'a::len word) (dropWhile Not bs) =
       (of_bl:: bool list ⇒ 'a::len word) bs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>bs</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bl_length_drop_bound</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (dropWhile Not bs) ≤ n"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (dropWhile Not (to_bl ((of_bl:: bool list ⇒ 'a::len word) bs))) ≤ n"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bl_length_drop_twice</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"length (dropWhile Not (to_bl ((of_bl:: bool list ⇒ 'a::len word) (dropWhile Not bs)))) =
       length (dropWhile Not (to_bl ((of_bl:: bool list ⇒ 'a::len word) bs)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bl_drop_leading_zeros</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>length_drop_bl</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length (dropWhile Not (to_bl ((of_bl:: bool list ⇒ 'a::len word) bs))) ≤ length (dropWhile Not bs)"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>dual_order.trans</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>bl_length_drop_twice</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>order.trans</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>*</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_drop_mask_outer</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>ip</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a::len word"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LENGTH('a) - n' = len ⟹ length (dropWhile Not (to_bl (ip AND (mask n &lt;&lt; n') &gt;&gt; n'))) ≤ len"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Word_Lemmas.word_and_mask_shiftl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Word_Lib.shiftl_shiftr1</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Word_Lib.and_mask</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>word_size</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>length_drop_mask</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_drop_mask_inner</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>ip</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a::len word"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ≤ LENGTH('a) - n' ⟹ length (dropWhile Not (to_bl (ip AND (mask n &lt;&lt; n') &gt;&gt; n'))) ≤ n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Word_Lemmas.word_and_mask_shiftl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Word_Lemmas.shiftl_shiftr3</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>word_size</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Word_Lemmas.mask_twice</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>length_drop_mask</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mask128</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF = mask 128"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mask_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*-------------- things for ipv6 syntax round trip property two ------------------*)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*n small, m large*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>helper_masked_ucast_generic</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>b</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n + 16 ≤ m"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m &lt; 128"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((ucast:: 16 word ⇒ 128 word) b &lt;&lt; n) &amp;&amp; (mask 16 &lt;&lt; m) = 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x &lt; 2 ^ (m - n)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>mnh2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x &lt; 0x10000"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"128 word"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>mnh3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 ≤ m - n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>power_2_16_nat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(16::nat) ≤ n ⟹ (65535::nat) &lt; 2 ^ n"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"16 ≤ n"</span></span></span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>power2_rule</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≤ b ⟹ (2::nat)^a ≤ 2 ^ b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"65536 ≤ 2 ^ n"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Nat.less_eq_Suc_le</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"(65536::nat) = 2^16"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>power2_rule</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹16 ≤ n›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"65536 = unat (65536::128 word)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>mnh2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"unat x &lt;  unat (65536::128 word)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Word.unat_mono</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"unat x &lt; 65536"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>mnh3</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"unat x &lt; 2 ^ (m - n)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>b</span><span class="delimiter">=</span><span>65535</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Orderings.order_class.order.strict_trans1</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>power_2_16_nat</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>word_less_nat_alt</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>mnhelper2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(of_bl::bool list ⇒ 128 word) (to_bl b) &lt; 2 ^ (m - n)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"(of_bl::bool list ⇒ 128 word) (to_bl b) &lt; 2^(LENGTH(16))"</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Word.of_bl_length_less</span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>mnhelper3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(of_bl::bool list ⇒ 128 word) (to_bl b) * 2 ^ n &lt; 2 ^ m"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Word.div_lt_mult</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Word_Lemmas.word_less_two_pow_divI</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mnhelper2</span><span> </span><span>Word_Lib.p2_gt_0</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Word.ucast_bl</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Word.shiftl_of_bl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Word.of_bl_append</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Word_Lemmas.word_and_mask_shiftl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Word_Lib.shiftr_div_2n_w</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>word_size</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Word_Lemmas.word_div_less</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>mnhelper3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unat_of_bl_128_16_less_helper</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>b</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"unat ((of_bl::bool list ⇒ 128 word) (to_bl b)) &lt; 2^16"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Word.word_bl_Rep'</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length (to_bl b) = 16"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"unat ((of_bl::bool list ⇒ 128 word) (to_bl b)) &lt; 2^(length (to_bl b))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fact</span><span> </span><span>Word_Lemmas.unat_of_bl_length</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>1</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unat_of_bl_128_16_le_helper</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"unat ((of_bl:: bool list ⇒ 128 word) (to_bl (b::16 word))) ≤ 65535"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>unat_of_bl_128_16_less_helper</span><span class="delimiter">[</span><span>of</span><span> </span><span>b</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"unat ((of_bl:: bool list ⇒ 128 word) (to_bl b)) &lt; 65536"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Nat.Suc_leI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*reverse*)</span></span></span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>helper_masked_ucast_reverse_generic</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>b</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m + 16 ≤ n"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ≤ 128 - 16"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((ucast:: 16 word ⇒ 128 word) b &lt;&lt; n) &amp;&amp; (mask 16 &lt;&lt; m) = 0"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>power_less_128_helper</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"2 ^ n * unat ((of_bl::bool list ⇒ 128 word) (to_bl b)) &lt; 2 ^ LENGTH(128)"</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n ≤ 128 - 16"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>help_mult</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n ≤ l ⟹ 2 ^ n * x &lt; 2 ^ l ⟷ x &lt; 2 ^ (l - n)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span class="delimiter">::</span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>l</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nat_mult_power_less_eq</span><span> </span><span>semiring_normalization_rules</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>n</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>help_mult</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_less_le_trans</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>unat_of_bl_128_16_less_helper</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Power.power_increasing</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"2 ^ m * (2 ^ (n - m) * unat ((of_bl::bool list ⇒ 128 word) (to_bl b))) = 
            2 ^ n * unat ((of_bl::bool list ⇒ 128 word) (to_bl b))"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"unat ((of_bl::bool list ⇒ 128 word) (to_bl b)) = 0"</span></span></span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>help_mult</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≠ 0 ⟹ b * (c * x) = a * (x::nat)  ⟷ b * c = a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>help_mult</span><span class="delimiter">[</span><span>OF</span><span> </span><span>False</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Power.monoid_mult_class.power_add</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"unat ((2 ^ n)::128 word) * unat ((of_bl::bool list ⇒ 128 word) (to_bl b)) mod 2 ^ LENGTH(128) =
        2 ^ m * (2 ^ (n - m) * unat ((of_bl::bool list ⇒ 128 word) (to_bl b)) mod 2 ^ LENGTH(128))"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>nat_mod_eq'</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Aligned.unat_power_lower</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>power_less_128_helper</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>nat_mod_eq'</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>power_less_128_helper</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Aligned.unat_power_lower</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>*</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ex_k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃k. unat ((2 ^ n)::128 word) * unat ((of_bl::bool list ⇒ 128 word) (to_bl b)) mod 2 ^ LENGTH(128) = 2 ^ m * k"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>aligned</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_aligned ((of_bl::bool list ⇒ 128 word) (to_bl b) &lt;&lt; n) m"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_aligned_def</span><span>
</span><span>     </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dvd_def</span><span>
</span><span>     </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Word.shiftl_t2n</span><span>
</span><span>     </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Word.unat_word_ariths</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>assumption</span><span>
</span><span>
</span><span>   </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>of_bl_to_bl_shift_mask</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"((of_bl::bool list ⇒ 128 word) (to_bl b) &lt;&lt; n) &amp;&amp; mask (16 + m) = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>is_aligned_mask</span><span> </span><span>is_aligned_shiftl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*sledgehammer*)</span></span></span></span></span><span>
</span><span>
</span><span>   </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Word.ucast_bl</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Word_Lemmas.word_and_mask_shiftl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Aligned.aligned_shiftr_mask_shiftl</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>aligned</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>of_bl_to_bl_shift_mask</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>helper_masked_ucast_equal_generic</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>b</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ≤ 128 - 16"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ucast (((ucast:: 16 word ⇒ 128 word) b &lt;&lt; n) &amp;&amp; (mask 16 &lt;&lt; n) &gt;&gt; n) = b"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ucast_mask</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ucast:: 16 word ⇒ 128 word) b &amp;&amp; mask 16 = ucast b"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Word_Lib.and_mask_eq_iff_le_mask</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Word.ucast_bl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mask_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>Word.word_uint_eqI</span><span> </span><span>word_le_nat_alt</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>word_le_nat_alt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unat_of_bl_128_16_le_helper</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ucast (((ucast:: 16 word ⇒ 128 word) b &amp;&amp; mask (128 - n) &amp;&amp; mask 16) &amp;&amp; mask (128 - n)) = b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Word_Lemmas.mask_and_mask</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Word.word_bool_alg.conj.assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Word_Lemmas.mask_and_mask</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ucast_mask</span><span> </span><span>Word_Lemmas.ucast_ucast_mask</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Word.mask_eq_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_less_trans</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Word.uint_lt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span> 
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Word_Lemmas.word_and_mask_shiftl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Word_Lemmas.shiftl_shiftr3</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Word_Lemmas.shiftl_shiftr3</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>word_size</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Word.word_bool_alg.conj.assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="WordInterval">
<div class="head"><h1>Theory WordInterval</h1>
<span class="command">theory</span> <span class="name">WordInterval</span><br/>
<span class="keyword">imports</span> <a href="../Word_Lib/Word_Lemmas.html"><span class="name">Word_Lemmas</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      WordInterval.thy
    Authors:    Julius Michaelis, Cornelius Diekmann
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>WordInterval</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Word_Lib.Word_Lemmas"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹WordInterval: Executable datatype for Machine Word Sets›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Stores ranges of machine words as interval. This has been proven quite efficient for
     IP Addresses.›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*NOTE: All algorithms here use a straight-forward implementation. There is a lot of room for
        improving the computation complexity, for example by making the WordInterval a balanced,
        sorted tree.*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Syntax›</span></span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>typedef_overloaded</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a</span><span class="delimiter">::</span><span>len0</span><span class="delimiter">)</span><span> </span><span>wordinterval</span><span> </span><span class="delimiter">=</span><span> </span><span>WordInterval</span><span>
</span><span>                                        </span><span class="string"><span class="delete"><span class="delete">"('a::len0) word"</span></span></span><span> </span><span class="comment">― ‹start (inclusive)›</span><span>
</span><span>                                        </span><span class="string"><span class="delete"><span class="delete">"('a::len0) word"</span></span></span><span> </span><span class="comment">― ‹end (inclusive)›</span><span>
</span><span>                                  </span><span class="delimiter">|</span><span> </span><span>RangeUnion</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a wordinterval"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"'a wordinterval"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Semantics›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wordinterval_to_set</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::len0 wordinterval ⇒ ('a::len0 word) set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set (WordInterval start end) =
        {start .. end}"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set (RangeUnion r1 r2) =
        wordinterval_to_set r1 ∪ wordinterval_to_set r2"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Note: The runtime of all the operations could be improved, for example by keeping the tree sorted
  and balanced.*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Basic operations›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹‹∈››</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wordinterval_element</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::len0 word ⇒ 'a::len0 wordinterval ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_element el (WordInterval s e) ⟷ s ≤ el ∧ el ≤ e"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_element el (RangeUnion r1 r2) ⟷
                                            wordinterval_element el r1 ∨ wordinterval_element el r2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_element_set_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_element el rg = (el ∈ wordinterval_to_set rg)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>rg</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wordinterval_element.induct</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>wordinterval_union</span><span>
</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::len0 wordinterval ⇒ 'a::len0 wordinterval ⇒ 'a::len0 wordinterval"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_union r1 r2 = RangeUnion r1 r2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_union_set_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set (wordinterval_union r1 r2) = wordinterval_to_set r1 ∪ wordinterval_to_set r2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wordinterval_union_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wordinterval_empty</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::len0 wordinterval ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_empty (WordInterval s e) ⟷ e &lt; s"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_empty (RangeUnion r1 r2) ⟷ wordinterval_empty r1 ∧ wordinterval_empty r2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_empty_set_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_empty r ⟷ wordinterval_to_set r = {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Empty_WordInterval</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::len wordinterval"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Empty_WordInterval ≡ WordInterval 1 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_empty_Empty_WordInterval</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_empty Empty_WordInterval"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Empty_WordInterval_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Empty_WordInterval_set_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set Empty_WordInterval = {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Empty_WordInterval_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹WordInterval and Lists›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹A list of ‹(start, end)› tuples.›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹wordinterval to list›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wi2l</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::len0 wordinterval ⇒ ('a::len0 word × 'a::len0 word) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wi2l (RangeUnion r1 r2) = wi2l r1 @ wi2l r2"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wi2l (WordInterval s e) = (if e &lt; s then [] else [(s,e)])"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹list to wordinterval›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>l2wi</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::len word × 'a word) list ⇒ 'a wordinterval"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"l2wi [] = Empty_WordInterval"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"l2wi [(s,e)] = (WordInterval s e)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"l2wi ((s,e)#rs) = (RangeUnion (WordInterval s e) (l2wi rs))"</span></span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>l2wi_append</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set (l2wi (l1@l2)) =
                      wordinterval_to_set (l2wi l1) ∪ wordinterval_to_set (l2wi l2)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>l1</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>l2</span><span> </span><span>rule</span><span class="delimiter">:</span><span>l2wi.induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>s</span><span> </span><span>e</span><span> </span><span>l2</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>l2</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>3</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>l2wi_wi2l</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set (l2wi (wi2l r)) = wordinterval_to_set r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>l2wi_append</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>l2wi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set (l2wi l) = (⋃ (i,j) ∈ set l. {i .. j})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>l</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>l2wi.induct</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wi2l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋃(i,j)∈set (wi2l r). {i .. j}) = wordinterval_to_set r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>r</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wi2l.induct</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>l2wi_remdups</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set (l2wi (remdups ls)) = wordinterval_to_set (l2wi ls)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>l2wi</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wi2l_empty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wi2l Empty_WordInterval = []"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Empty_WordInterval_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Optimizing and minimizing @{typ "('a::len) wordinterval"}s›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Removing empty intervals›</span></span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wordinterval_optimize_empty</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::len0 wordinterval ⇒ 'a wordinterval"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_optimize_empty (RangeUnion r1 r2) = (let r1o = wordinterval_optimize_empty r1;
                                                           r2o = wordinterval_optimize_empty r2
      in if
        wordinterval_empty r1o
      then
        r2o
      else if
        wordinterval_empty r2o
      then
        r1o
      else
        RangeUnion r1o r2o)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_optimize_empty r = r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_optimize_empty_set_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set (wordinterval_optimize_empty r) = wordinterval_to_set r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_optimize_empty_double</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_optimize_empty (wordinterval_optimize_empty r) = wordinterval_optimize_empty r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wordinterval_empty_shallow</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::len0 wordinterval ⇒ bool"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_empty_shallow (WordInterval s e) ⟷ e &lt; s"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_empty_shallow (RangeUnion _ _) ⟷ False"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>helper_optimize_shallow</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_empty_shallow (wordinterval_optimize_empty r) =
      wordinterval_empty (wordinterval_optimize_empty r)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wordinterval_optimize_empty2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_optimize_empty2 (RangeUnion r1 r2) = (let r1o = wordinterval_optimize_empty r1;
                                                            r2o = wordinterval_optimize_empty r2
      in if
        wordinterval_empty_shallow r1o
      then
        r2o
      else if
        wordinterval_empty_shallow r2o
      then
        r1o
      else
        RangeUnion r1o r2o)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_optimize_empty2 r = r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_optimize_empty_code</span><span class="delimiter">[</span><span>code_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_optimize_empty = wordinterval_optimize_empty2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>fun_eq_iff</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">,</span><span> </span><span>rename_tac</span><span> </span><span>r</span><span class="delimiter">,</span><span> </span><span>induct_tac</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>wordinterval_optimize_empty.simps</span><span> </span><span>wordinterval_optimize_empty2.simps</span><span>
</span><span>               </span><span>Let_def</span><span> </span><span>helper_optimize_shallow</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Merging overlapping intervals›</span></span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>disjoint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set ⇒ 'a set ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"disjoint A B ≡ A ∩ B = {}"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>interval_of</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::len0) word × 'a word ⇒ 'a word set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"interval_of (s,e) = {s .. e}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>interval_of.simps</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>disjoint_intervals</span><span>
</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('a::len0) word × ('a::len0) word) ⇒ ('a word × 'a word) ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"disjoint_intervals A B ≡ disjoint (interval_of A) (interval_of B)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>not_disjoint_intervals</span><span>
</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('a::len0) word × ('a::len0) word) ⇒ ('a word × 'a word) ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"not_disjoint_intervals A B ≡ ¬ disjoint (interval_of A) (interval_of B)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"not_disjoint_intervals A B =
      (case A of (s,e) ⇒ case B of (s',e') ⇒ s ≤ e' ∧ s' ≤ e ∧ s ≤ e ∧ s' ≤ e')"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>A</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>B</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>not_disjoint_intervals_def</span><span> </span><span>interval_of.simps</span><span> </span><span>disjoint_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"disjoint_intervals A B =
      (case A of (s,e) ⇒ case B of (s',e') ⇒ s &gt; e' ∨ s' &gt; e ∨ s &gt; e ∨ s' &gt; e')"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>A</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>B</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>disjoint_intervals_def</span><span> </span><span>interval_of.simps</span><span> </span><span>disjoint_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹BEGIN merging overlapping intervals›</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*result has no empty intervals and all are disjoint.
    merging things such as [1,7] [8,10] would still be possible*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>merge_overlap</span><span>
</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('a::len0) word × ('a::len0) word) ⇒ ('a word × 'a word) list ⇒ ('a word × 'a word) list"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"merge_overlap s [] = [s]"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"merge_overlap (s,e) ((s',e')#ss) = (
       if not_disjoint_intervals (s,e) (s',e')
       then (min s s', max e e')#ss
       else (s',e')#merge_overlap (s,e) ss)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_disjoint_union</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>s</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::len0) word"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ disjoint {s..e} {s'..e'} ⟹ {s..e} ∪ {s'..e'} = {min s s' .. max e e'}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>disjoint_def</span><span> </span><span>min_def</span><span> </span><span>max_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>disjoint_subset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"disjoint A B ⟹ A ⊆ B ∪ C ⟹ A ⊆ C"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>disjoint_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_overlap_helper1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"interval_of A ⊆ (⋃s ∈ set ss. interval_of s) ⟹
      (⋃s ∈ set (merge_overlap A ss). interval_of s) = (⋃s ∈ set ss. interval_of s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>ss</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>A</span><span class="delimiter">,</span><span> </span><span>rename_tac</span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>not_disjoint_intervals_def</span><span> </span><span>interval_of.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>impI</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule</span><span> </span><span>not_disjoint_union</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>C</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"(⋃x∈set xs. interval_of x)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>disjoint_subset</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_overlap_helper2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃s'∈set ss. ¬ disjoint (interval_of A) (interval_of s') ⟹
          interval_of A ∪ (⋃s ∈ set ss. interval_of s) = (⋃s ∈ set (merge_overlap A ss). interval_of s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>ss</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>A</span><span class="delimiter">,</span><span> </span><span>rename_tac</span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>not_disjoint_intervals_def</span><span> </span><span>interval_of.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>impI</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule</span><span> </span><span>not_disjoint_union</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_overlap_length</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∃s' ∈ set ss. ¬ disjoint (interval_of A) (interval_of s') ⟹
      length (merge_overlap A ss) = length ss"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>ss</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>A</span><span class="delimiter">,</span><span> </span><span>rename_tac</span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>not_disjoint_intervals_def</span><span> </span><span>interval_of.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_overlap (1:: 16 word,2) [(1, 7)] = [(1, 7)]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_overlap (1:: 16 word,2) [(2, 7)] = [(1, 7)]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_overlap (1:: 16 word,2) [(3, 7)] = [(3, 7), (1,2)]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">function</span></span><span> </span><span>listwordinterval_compress</span><span>
</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('a::len0) word × ('a::len0) word) list ⇒ ('a word × 'a word) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"listwordinterval_compress [] = []"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"listwordinterval_compress (s#ss) = (
            if ∀s' ∈ set ss. disjoint_intervals s s'
            then s#listwordinterval_compress ss
            else listwordinterval_compress (merge_overlap s ss))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>pat_completeness</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">termination</span></span><span> </span><span>listwordinterval_compress</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>relation</span><span> </span><span class="string"><span class="delete"><span class="delete">"measure length"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_measure</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>disjoint_intervals_def</span><span> </span><span>merge_overlap_length</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>listwordinterval_compress</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(⋃s ∈ set (listwordinterval_compress ss). interval_of s) = (⋃s ∈ set ss. interval_of s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>ss</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>listwordinterval_compress.induct</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>disjoint_intervals_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule</span><span> </span><span>merge_overlap_helper2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"listwordinterval_compress [(1::32 word,3), (8,10), (2,5), (3,7)] = [(8, 10), (1, 7)]"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>A_in_listwordinterval_compress</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∈ set (listwordinterval_compress ss) ⟹
    interval_of A ⊆ (⋃s ∈ set ss. interval_of s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>listwordinterval_compress</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>listwordinterval_compress_disjoint</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"A ∈ set (listwordinterval_compress ss) ⟹ B ∈ set (listwordinterval_compress ss) ⟹
      A ≠ B ⟹ disjoint (interval_of A) (interval_of B)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>ss</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>listwordinterval_compress.induct</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>disjoint_intervals_def</span><span> </span><span>disjoint_def</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>thin_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"False ⟹ _ ⟹ _ ⟹ _"</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>A_in_listwordinterval_compress</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹END merging overlapping intervals›</span></span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹BEGIN merging adjacent intervals›</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>merge_adjacent</span><span>
</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('a::len) word × ('a::len) word) ⇒ ('a word × 'a word) list ⇒ ('a word × 'a word) list"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"merge_adjacent s [] = [s]"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"merge_adjacent (s,e) ((s',e')#ss) = (
       if s ≤e ∧ s' ≤ e' ∧ word_next e = s'
       then (s, e')#ss
       else if s ≤e ∧ s' ≤ e' ∧ word_next e' = s
       then (s', e)#ss
       else (s',e')#merge_adjacent (s,e) ss)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_adjacent_helper</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"interval_of A ∪ (⋃s ∈ set ss. interval_of s) = (⋃s ∈ set (merge_adjacent A ss). interval_of s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>ss</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>A</span><span class="delimiter">,</span><span> </span><span>rename_tac</span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>  </span><span>interval_of.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>impI</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_assoc</span><span> </span><span>word_adjacent_union</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>elim</span><span> </span><span>conjE</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>word_adjacent_union</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>word_adjacent_union</span><span> </span><span>Un_assoc</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_adjacent_length</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∃(s', e')∈set ss. s ≤ e ∧ s' ≤ e' ∧ (word_next e = s' ∨ word_next e' = s)
     ⟹ length (merge_adjacent (s,e) ss) = length ss"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>ss</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">function</span></span><span> </span><span>listwordinterval_adjacent</span><span>
</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('a::len) word × ('a::len) word) list ⇒ ('a word × 'a word) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"listwordinterval_adjacent [] = []"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"listwordinterval_adjacent ((s,e)#ss) = (
            if ∀(s',e') ∈ set ss. ¬ (s ≤e ∧ s' ≤ e' ∧ (word_next e = s' ∨ word_next e' = s))
            then (s,e)#listwordinterval_adjacent ss
            else listwordinterval_adjacent (merge_adjacent (s,e) ss))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>pat_completeness</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">termination</span></span><span> </span><span>listwordinterval_adjacent</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>relation</span><span> </span><span class="string"><span class="delete"><span class="delete">"measure length"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_measure</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>merge_adjacent_length</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>listwordinterval_adjacent</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(⋃s ∈ set (listwordinterval_adjacent ss). interval_of s) = (⋃s ∈ set ss. interval_of s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>ss</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>listwordinterval_adjacent.induct</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>merge_adjacent_helper</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"listwordinterval_adjacent [(1::16 word, 3), (5, 10), (10,10), (4,4)] = [(10, 10), (1, 10)]"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹END merging adjacent intervals›</span></span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>wordinterval_compress</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::len) wordinterval ⇒ 'a wordinterval"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_compress r ≡
      l2wi (remdups (listwordinterval_adjacent (listwordinterval_compress
        (wi2l (wordinterval_optimize_empty r)))))"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness: Compression preserves semantics›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_compress</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set (wordinterval_compress r) = wordinterval_to_set r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wordinterval_compress_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>interval_of'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"interval_of s = (case s of (s,e) ⇒ {s .. e})"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>interval_of.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set (l2wi (remdups (listwordinterval_adjacent
              (listwordinterval_compress (wi2l (wordinterval_optimize_empty r)))))) =
            (⋃x∈set (listwordinterval_adjacent (listwordinterval_compress
                (wi2l (wordinterval_optimize_empty r)))). interval_of x)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>interval_of'</span><span> </span><span>l2wi</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… =  (⋃s∈set (wi2l (wordinterval_optimize_empty r)). interval_of s)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>listwordinterval_compress</span><span> </span><span>listwordinterval_adjacent</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (⋃(i, j)∈set (wi2l (wordinterval_optimize_empty r)). {i..j})"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>interval_of'</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = wordinterval_to_set r"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wi2l</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set
        (l2wi (remdups (listwordinterval_adjacent (listwordinterval_compress
            (wi2l (wordinterval_optimize_empty r))))))
          = wordinterval_to_set r"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Example›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(wi2l ∘ (wordinterval_compress :: 32 wordinterval ⇒ 32 wordinterval) ∘ l2wi)
          [(70, 80001), (0,0), (150, 8000), (1,3), (42,41), (3,7), (56, 200), (8,10)] =
          [(56, 80001), (0, 10)]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_compress (RangeUnion (RangeUnion (WordInterval (1::32 word) 5)
                                                        (WordInterval 8 10)) (WordInterval 3 7)) =
       WordInterval 1 10"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Further operations›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹‹⋃››</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>wordinterval_Union</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::len) wordinterval list ⇒ 'a wordinterval"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_Union ws = wordinterval_compress (foldr wordinterval_union ws Empty_WordInterval)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_Union</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set (wordinterval_Union ws) = (⋃ w ∈ (set ws). wordinterval_to_set w)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>ws</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wordinterval_compress</span><span> </span><span>wordinterval_Union_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wordinterval_setminus'</span><span>
</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::len wordinterval ⇒ 'a wordinterval ⇒ 'a wordinterval"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_setminus' (WordInterval s e) (WordInterval ms me) = (
      if s &gt; e ∨ ms &gt; me then WordInterval s e else
      if me ≥ e
        then
          WordInterval (if ms = 0 then 1 else s) (min e (word_prev ms))
        else if ms ≤ s
        then
          WordInterval (max s (word_next me)) (if me = max_word then 0 else e)
        else
          RangeUnion (WordInterval (if ms = 0 then 1 else s) (word_prev ms))
                     (WordInterval (word_next me) (if me = max_word then 0 else e))
        )"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"wordinterval_setminus' (RangeUnion r1 r2) t =
        RangeUnion (wordinterval_setminus' r1 t) (wordinterval_setminus' r2 t)"</span></span></span><span class="delimiter">|</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"wordinterval_setminus' t (RangeUnion r1 r2) =
        wordinterval_setminus' (wordinterval_setminus' t r1) r2"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_setminus'_rr_set_eq</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set(wordinterval_setminus' (WordInterval s e) (WordInterval ms me)) =
    wordinterval_to_set (WordInterval s e) - wordinterval_to_set (WordInterval ms me)"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>wordinterval_setminus'.simps</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"e &lt; s"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"me &lt; ms"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"e ≤ me"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"ms = 0"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"ms ≤ s"</span></span></span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"me = max_word"</span></span></span><span class="delimiter">)</span><span>
</span><span>                    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>word_prev_def</span><span> </span><span>word_next_def</span><span> </span><span>min_def</span><span> </span><span>max_def</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>safe</span><span class="delimiter">)</span><span>
</span><span>                                  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>                          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>uint_arith</span><span class="delimiter">)</span><span>
</span><span>                         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>uint_arith</span><span class="delimiter">)</span><span>
</span><span>                        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>uint_arith</span><span class="delimiter">)</span><span>
</span><span>                       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>uint_arith</span><span class="delimiter">)</span><span>
</span><span>                      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>uint_arith</span><span class="delimiter">)</span><span>
</span><span>                     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>uint_arith</span><span class="delimiter">)</span><span>
</span><span>                    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>uint_arith</span><span class="delimiter">)</span><span>
</span><span>                   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>uint_arith</span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>uint_arith</span><span class="delimiter">)</span><span>
</span><span>                 </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>uint_arith</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>uint_arith</span><span class="delimiter">)</span><span>
</span><span>               </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>uint_arith</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>uint_arith</span><span class="delimiter">)</span><span>
</span><span>             </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>uint_arith</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>uint_arith</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>uint_arith</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>uint_arith</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>uint_arith</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>uint_arith</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>uint_arith</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>uint_arith</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>uint_arith</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_setminus'_set_eq</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set (wordinterval_setminus' r1 r2) =
      wordinterval_to_set r1 - wordinterval_to_set r2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wordinterval_setminus'.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wordinterval_setminus'_rr_set_eq</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_setminus'_empty_struct</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_empty r2 ⟹ wordinterval_setminus' r1 r2 = r1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>r1</span><span> </span><span>r2</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wordinterval_setminus'.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>wordinterval_setminus</span><span>
</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::len wordinterval ⇒ 'a::len wordinterval ⇒ 'a::len wordinterval"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_setminus r1 r2 = wordinterval_compress (wordinterval_setminus' r1 r2)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_setminus_set_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set (wordinterval_setminus r1 r2) =
    wordinterval_to_set r1 - wordinterval_to_set r2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wordinterval_setminus_def</span><span> </span><span>wordinterval_compress</span><span> </span><span>wordinterval_setminus'_set_eq</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>wordinterval_UNIV</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::len wordinterval"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wordinterval_UNIV ≡ WordInterval 0 max_word"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_UNIV_set_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set wordinterval_UNIV = UNIV"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wordinterval_UNIV_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>max_word_max</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wordinterval_invert</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::len wordinterval ⇒ 'a::len wordinterval"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wordinterval_invert r = wordinterval_setminus wordinterval_UNIV r"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_invert_set_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set (wordinterval_invert r) = UNIV - wordinterval_to_set r"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_invert_UNIV_empty</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wordinterval_empty (wordinterval_invert wordinterval_UNIV)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wi2l_univ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wi2l wordinterval_UNIV = [(0, max_word)]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wordinterval_UNIV_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹‹∩››</span></span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{(s::nat) .. e} ∩ {s' .. e'} = {} ⟷ s &gt; e' ∨ s' &gt; e ∨ s &gt; e ∨ s' &gt; e'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wordinterval_intersection'</span><span>
</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::len wordinterval ⇒ 'a::len wordinterval ⇒ 'a::len wordinterval"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_intersection' (WordInterval s e) (WordInterval s' e') = (
        if s &gt; e ∨ s' &gt; e' ∨ s &gt; e' ∨ s' &gt; e ∨ s &gt; e ∨ s' &gt; e'
        then
          Empty_WordInterval
        else
          WordInterval (max s s') (min e e')
        )"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_intersection' (RangeUnion r1 r2) t =
        RangeUnion (wordinterval_intersection' r1 t) (wordinterval_intersection' r2 t)"</span></span></span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_intersection' t (RangeUnion r1 r2) =
        RangeUnion (wordinterval_intersection' t r1) (wordinterval_intersection' t r2)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_intersection'_set_eq</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set (wordinterval_intersection' r1 r2) =
      wordinterval_to_set r1 ∩ wordinterval_to_set r2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>r1</span><span> </span><span>r2</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wordinterval_intersection'.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_intersection'
          (RangeUnion (RangeUnion (WordInterval (1::32 word) 3) (WordInterval 8 10))
                      (WordInterval 1 3)) (WordInterval 1 3) =
          RangeUnion (RangeUnion (WordInterval 1 3) (WordInterval 1 0)) (WordInterval 1 3)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>wordinterval_intersection</span><span>
</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::len wordinterval ⇒ 'a::len wordinterval ⇒ 'a::len wordinterval"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_intersection r1 r2 ≡ wordinterval_compress (wordinterval_intersection' r1 r2)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_intersection_set_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set (wordinterval_intersection r1 r2) =
      wordinterval_to_set r1 ∩ wordinterval_to_set r2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wordinterval_intersection_def</span><span>
</span><span>                 </span><span>wordinterval_compress</span><span> </span><span>wordinterval_intersection'_set_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_intersection
          (RangeUnion (RangeUnion (WordInterval (1::32 word) 3) (WordInterval 8 10))
                      (WordInterval 1 3)) (WordInterval 1 3) =
          WordInterval 1 3"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>wordinterval_subset</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::len wordinterval ⇒ 'a::len wordinterval ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wordinterval_subset r1 r2 ≡ wordinterval_empty (wordinterval_setminus r1 r2)"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_subset_set_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wordinterval_subset r1 r2 = (wordinterval_to_set r1 ⊆ wordinterval_to_set r2)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wordinterval_subset_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>wordinterval_eq</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::len wordinterval ⇒ 'a::len wordinterval ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wordinterval_eq r1 r2 = (wordinterval_subset r1 r2 ∧ wordinterval_subset r2 r1)"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_eq_set_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wordinterval_eq r1 r2 ⟷ wordinterval_to_set r1 = wordinterval_to_set r2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wordinterval_eq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>iffD1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wordinterval_eq_set_eq</span><span class="delimiter">]</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*declare iffD1[OF wordinterval_eq_set_eq, simp]*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_eq_comm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_eq r1 r2 ⟷ wordinterval_eq r2 r1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wordinterval_eq_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_to_set_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set r = {x. wordinterval_element x r}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wordinterval_element_set_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_un_empty</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wordinterval_empty r1 ⟹ wordinterval_eq (wordinterval_union r1 r2) r2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>wordinterval_eq_set_eq</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_un_emty_b</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wordinterval_empty r2 ⟹ wordinterval_eq (wordinterval_union r1 r2) r1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>wordinterval_eq_set_eq</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_Diff_triv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wordinterval_empty (wordinterval_intersection a b) ⟹ wordinterval_eq (wordinterval_setminus a b) a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wordinterval_eq_set_eq</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹A size of the datatype, does not correspond to the cardinality of the corresponding set›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wordinterval_size</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::len) wordinterval ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wordinterval_size (RangeUnion a b) = wordinterval_size a + wordinterval_size b"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wordinterval_size (WordInterval s e) = (if s ≤ e then 1 else 0)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_size_length</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_size r = length (wi2l r)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ex_wordinterval_nonempty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x::('a::len wordinterval). y ∈ wordinterval_to_set x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ wordinterval_to_set wordinterval_UNIV"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_eq_reflp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"reflp wordinterval_eq"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>reflpI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>wordinterval_eq_set_eq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordintervalt_eq_symp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"symp wordinterval_eq"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>sympI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wordinterval_eq_comm</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_eq_transp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"transp wordinterval_eq"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>transpI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>wordinterval_eq_set_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_eq_equivp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"equivp wordinterval_eq"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>equivpI</span><span> </span><span>wordinterval_eq_reflp</span><span> </span><span>wordintervalt_eq_symp</span><span> </span><span>wordinterval_eq_transp</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The smallest element in the interval›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_lowest_element</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::ord ⇒ 'a set ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"is_lowest_element x S = (x ∈ S ∧ (∀y∈S. y ≤ x ⟶ y = x))"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  	</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a :: complete_lattice"</span></span></span><span>
</span><span>  	</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ S"</span></span></span><span>
</span><span>  	</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" x = Inf S ⟹ is_lowest_element x S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_lowest_element_def</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Inf_lower</span><span> </span><span>eq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  	</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a :: linorder"</span></span></span><span>
</span><span>  	</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ S"</span></span></span><span>
</span><span>  	</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_lowest_element x S ⟷ x = Min S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_lowest_element_def</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Min_eqI</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Min.coboundedI</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>dual_order.antisym</span><span> </span><span>is_lowest_element_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Smallest element in the interval›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wordinterval_lowest_element</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::len0 wordinterval ⇒ 'a word option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_lowest_element (WordInterval s e) = (if s ≤ e then Some s else None)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_lowest_element (RangeUnion A B) =
      (case (wordinterval_lowest_element A, wordinterval_lowest_element B) of
          (Some a, Some b) ⇒ Some (if a &lt; b then a else b) |
          (None, Some b) ⇒ Some b |
          (Some a, None) ⇒ Some a |
          (None, None) ⇒ None)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_lowest_none_empty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_lowest_element r = None ⟷ wordinterval_empty r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>WordInterval</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>RangeUnion</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_lowest_element_correct_A</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_lowest_element r = Some x ⟹ is_lowest_element x (wordinterval_to_set r)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_lowest_element_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>r</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wordinterval_lowest_element.induct</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>rs</span><span> </span><span>re</span><span> </span><span>x</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"rs ≤ re"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>wordinterval_lowest_element.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span>     </span><span class="string"><span class="delete"><span class="delete">"wordinterval_lowest_element B"</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_lowest_element A"</span></span></span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wordinterval_lowest_none_empty</span><span class="delimiter">)</span><span class="delimiter">[</span><span>3</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_lowest_element_set_eq</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ wordinterval_empty r"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(wordinterval_lowest_element r = Some x) = (is_lowest_element x (wordinterval_to_set r))"</span></span></span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*unfolding is_lowest_element_def*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_lowest_element r = Some x"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_lowest_element x (wordinterval_to_set r)"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wordinterval_lowest_element_correct_A</span><span> </span><span>wordinterval_lowest_none_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_lowest_element x (wordinterval_to_set r)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(wordinterval_lowest_element r = Some x)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>r</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wordinterval_lowest_element.induct</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_lowest_element_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>is_lowest_RangeUnion</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_lowest_element x (wordinterval_to_set A ∪ wordinterval_to_set B) ⟹
          is_lowest_element x (wordinterval_to_set A) ∨ is_lowest_element x (wordinterval_to_set B)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_lowest_element_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>         </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*why ⋀ A B?*)</span></span></span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wordinterval_lowest_element_RangeUnion</span><span class="delimiter">:</span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"⋀a b A B. wordinterval_lowest_element A = Some a ⟹
                  wordinterval_lowest_element B = Some b ⟹
                  wordinterval_lowest_element (RangeUnion A B) = Some (min a b)"</span></span></span><span>
</span><span>           </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>wordinterval_lowest_element_correct_A</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_lowest_element_def</span><span> </span><span>min_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span>     </span><span class="string"><span class="delete"><span class="delete">"wordinterval_lowest_element B"</span></span></span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_lowest_element A"</span></span></span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_lowest_element_def</span><span class="delimiter">)</span><span class="delimiter">[</span><span>3</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ wordinterval_empty A ∧ ¬ wordinterval_empty B"</span></span></span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span> </span><span class="delimiter">=</span><span> </span><span>Not</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>wordinterval_lowest_none_empty</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>wordinterval_lowest_element_RangeUnion</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split_asm</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>min_def</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule</span><span> </span><span>is_lowest_RangeUnion</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_lowest_element_def</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wordinterval_lowest_none_empty</span><span class="delimiter">)</span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_lowest_element_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wordinterval_lowest_none_empty</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wordinterval_lowest_element_correct_A</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>is_lowest_element_def</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_iff</span><span> </span><span>not_le</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Cardinality approximation for @{typ "('a::len) wordinterval"}s›</span></span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>card_atLeastAtMost_word</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>s</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('a::len) word"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card {s..e} = Suc (unat e) - (unat s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"s &gt; e"</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>Word.word_less_nat_alt</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Word_Lemmas.upto_enum_set_conv2</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>List.card_set</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>remdups_enum_upto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wordinterval_card</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::len) wordinterval ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_card (WordInterval s e) = Suc (unat e) - (unat s)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_card (RangeUnion a b) = wordinterval_card a + wordinterval_card b"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_card</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_card r ≥ card (wordinterval_to_set r)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>WordInterval</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>card_atLeastAtMost_word</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>RangeUnion</span><span> </span><span>r1</span><span> </span><span>r2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (wordinterval_to_set r1 ∪ wordinterval_to_set r2) ≤
              card (wordinterval_to_set r1) + card (wordinterval_to_set r2)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Finite_Set.card_Un_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>RangeUnion</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹With @{thm wordinterval_compress} it should be possible to get the exact cardinality›</span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Hs_Compat">
<div class="head"><h1>Theory Hs_Compat</h1>
<span class="command">theory</span> <span class="name">Hs_Compat</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Hs_Compat</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Definitions inspired by the Haskell World.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>uncurry</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('b ⇒ 'c ⇒ 'a) ⇒ 'b × 'c ⇒ 'a"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"uncurry f a ≡ (case a of (x,y) ⇒ f x y)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uncurry_simp</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"uncurry f (a,b) = f a b"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>uncurry_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uncurry_curry_id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"uncurry ∘ curry = id"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"curry ∘ uncurry = id"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uncurry_split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P (uncurry f p) ⟷ (∀x1 x2. p = (x1, x2) ⟶ P (f x1 x2))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>p</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uncurry_split_asm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P (uncurry f a) ⟷ ¬(∃x y. a = (x,y) ∧ ¬P (f x y))"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>uncurry_split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>uncurry_splits</span><span> </span><span class="delimiter">=</span><span> </span><span>uncurry_split</span><span> </span><span>uncurry_split_asm</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uncurry_case_stmt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(case x of (a, b) ⇒ f a b) = uncurry f x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="IP_Address">
<div class="head"><h1>Theory IP_Address</h1>
<span class="command">theory</span> <span class="name">IP_Address</span><br/>
<span class="keyword">imports</span> <a href="Hs_Compat.html"><span class="name">Hs_Compat</span></a> <a href="WordInterval.html"><span class="name">WordInterval</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      IP_Address.thy
    Authors:    Cornelius Diekmann
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>IP_Address</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Word_Lib.Word_Lemmas"</span></span></span><span>
</span><span>        </span><span>Hs_Compat</span><span>
</span><span>        </span><span>WordInterval</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Modelling IP Adresses›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹An IP address is basically an unsigned integer.
    We model IP addresses of arbitrary lengths.

    We will write @{typ "'i::len word"} for IP addresses of length @{term "LENGTH('i::len)"}.
    We use the convention to write @{typ 'i} whenever we mean IP addresses instead of generic words.
    When we will later have theorems with several polymorphic types in it (e.g. arbitrarily
    extensible packets), this notation makes it easier to spot that type @{typ 'i} is for
    IP addresses.

    The files @{file ‹IPv4.thy›} @{file ‹IPv6.thy›} concrete this for IPv4 and IPv6.›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The maximum IP address›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>max_ip_addr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'i::len word"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"max_ip_addr ≡ of_nat ((2^(len_of(TYPE('i)))) - 1)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>max_ip_addr_max_word</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"max_ip_addr = max_word"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>max_ip_addr_def</span><span> </span><span>max_word_def</span><span> </span><span>word_of_int_minus</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>max_ip_addr_max</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a. a ≤ max_ip_addr"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>max_ip_addr_max_word</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>range_0_max_UNIV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"UNIV = {0 .. max_ip_addr}"</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*not in the simp set, for a reason*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>max_ip_addr_max_word</span><span class="delimiter">)</span><span> </span><span>fastforce</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"size (x::'i::len word) = len_of(TYPE('i))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>word_size</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Sets of IP Addresses›</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Warning, not executable!*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Specifying sets with network masks: 192.168.0.0 255.255.255.0›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ipset_from_netmask</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'i::len word ⇒ 'i::len word ⇒ 'i::len word set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ipset_from_netmask addr netmask ≡
      let
        network_prefix = (addr AND netmask)
      in
        {network_prefix .. network_prefix OR (NOT netmask)}"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Example (pseudo syntax):
    @{const ipset_from_netmask} ‹192.168.1.129  255.255.255.0› =
        ‹{192.168.1.0 .. 192.168.1.255}››</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹A network mask of all ones (i.e. @{term "(- 1)::'i::len word"}).›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipset_from_netmask_minusone</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ipset_from_netmask ip (- 1) = {ip}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipset_from_netmask_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipset_from_netmask_maxword</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ipset_from_netmask ip max_word = {ip}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipset_from_netmask_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipset_from_netmask_zero</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ipset_from_netmask ip 0 = UNIV"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipset_from_netmask_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Specifying sets in Classless Inter-domain Routing (CIDR) notation: 192.168.0.0/24›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ipset_from_cidr</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'i::len word ⇒ nat ⇒ 'i::len word set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ipset_from_cidr addr pflength ≡
       ipset_from_netmask addr ((mask pflength) &lt;&lt; (len_of(TYPE('i)) - pflength))"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Example (pseudo syntax):
    @{const ipset_from_cidr} ‹192.168.1.129 24› = ‹{192.168.1.0 .. 192.168.1.255}››</span></span></span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*does this simplify stuff?*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(case ipcidr of (base, len) ⇒ ipset_from_cidr base len) = uncurry ipset_from_cidr ipcidr"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>uncurry_case_stmt</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipset_from_cidr_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipset_from_cidr ip 0 = UNIV"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipset_from_cidr_def</span><span> </span><span>ipset_from_netmask_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹A prefix length of word size gives back the singleton set with the IP address.
       Example: ‹192.168.1.2/32 = {192.168.1.2}››</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipset_from_cidr_wordlength</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>ip</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'i::len word"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipset_from_cidr ip (LENGTH('i)) = {ip}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipset_from_cidr_def</span><span> </span><span>ipset_from_netmask_def</span><span> </span><span>Let_def</span><span> </span><span>mask_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Alternative definition: Considering words as bit lists:›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipset_from_cidr_bl</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>addr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'i::len word"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipset_from_cidr addr pflength ≡
            ipset_from_netmask addr (of_bl ((replicate pflength True) @
                                            (replicate ((len_of(TYPE('i))) - pflength)) False))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipset_from_cidr_def</span><span> </span><span>mask_bl</span><span> </span><span>Word.shiftl_of_bl</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipset_from_cidr_alt</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>pre</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'i::len word"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipset_from_cidr pre len =
            {pre AND (mask len &lt;&lt; LENGTH('i) - len)
             ..
             pre OR mask (LENGTH('i) - len)}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipset_from_cidr_def</span><span> </span><span>ipset_from_netmask_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Word.word_oa_dist</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>NOT_mask_shifted_lenword</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipset_from_cidr_alt2</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>base</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'i::len word"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipset_from_cidr base len =
           ipset_from_netmask base (NOT (mask (LENGTH('i) - len)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipset_from_cidr_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NOT_mask_shifted_lenword</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>metis</span><span> </span><span>word_not_not</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹In CIDR notation, we cannot express the empty set.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipset_from_cidr_not_empty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipset_from_cidr base len ≠ {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipset_from_cidr_alt</span><span> </span><span>bitmagic_zeroLast_leq_or1Last</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Though we can write 192.168.1.2/24, we say that 192.168.0.0/24 is well-formed.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipset_from_cidr_base_wellforemd</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>base</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'i::len word"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mask (LENGTH('i) - l) AND base = 0"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipset_from_cidr base l = {base .. base OR mask (LENGTH('i) - l)}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>maskshift_eq_not_mask_generic</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"((mask l &lt;&lt; LENGTH('i) - l) :: 'i::len word) = NOT (mask (LENGTH('i) - l))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NOT_mask_shifted_lenword</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>word_not_not</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"base AND NOT (mask (LENGTH('i) - l)) = base"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mask_eq_0_eq_x</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>word_bw_comms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>base</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>**</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"base AND NOT (mask (LENGTH('i) - l)) OR mask (LENGTH('i) - l) =
                base OR mask (LENGTH('i) - l)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipset_from_netmask base (NOT (mask (LENGTH('i) - l))) =
            {base .. base || mask (LENGTH('i) - l)}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipset_from_netmask_def</span><span> </span><span>Let_def</span><span> </span><span>**</span><span> </span><span>*</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipset_from_cidr_def</span><span> </span><span>maskshift_eq_not_mask_generic</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipset_from_cidr_large_pfxlen</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>ip</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'i::len word"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ≥ LENGTH('i)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipset_from_cidr ip n = {ip}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>obviously</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mask (LENGTH('i) - n) = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>ipset_from_cidr_base_wellforemd</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>obviously</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipset_from_netmask_base_mask_consume</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>base</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'i::len word"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipset_from_netmask (base AND NOT (mask (LENGTH('i) - m)))
                              (NOT (mask (LENGTH('i) - m)))
            =
             ipset_from_netmask base (NOT (mask (LENGTH('i) - m)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ipset_from_netmask_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Another definition of CIDR notation:
       All IP address which are equal on the first @{term "len - n"} bits›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ip_cidr_set</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'i::len word ⇒ nat ⇒ 'i word set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ip_cidr_set i r ≡
      {j . i AND NOT (mask (LENGTH('i) - r)) = j AND NOT (mask (LENGTH('i) - r))}"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The definitions are equal›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipset_from_cidr_eq_ip_cidr_set</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>base</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'i::len word"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipset_from_cidr base len = ip_cidr_set base len"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>maskshift_eq_not_mask_generic</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"((mask len &lt;&lt; LENGTH('a) - len) :: 'a::len word) = NOT (mask (LENGTH('a) - len))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NOT_mask_shifted_lenword</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>word_not_not</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mask (len - m) AND base AND NOT (mask (len - m)) = 0"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>len</span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>base</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'i::len word"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>word_bw_lcs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mask (LENGTH('i) - len) AND pfxm_p = 0 ⟹
           (a ∈ ipset_from_netmask pfxm_p (NOT (mask (LENGTH('i) - len)))) ⟷
           (pfxm_p = NOT (mask (LENGTH('i) - len)) AND a)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'i::len word"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pfxm_p</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>ipset_from_cidr_alt2</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>zero_base_lsb_imp_set_eq_as_bit_operation</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>ipset_from_cidr_base_wellforemd</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>base</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(x ∈ ipset_from_netmask base (~~ (mask (LENGTH('i) - len)))) ⟷
       (base &amp;&amp; ~~ (mask (LENGTH('i) - len)) = x &amp;&amp; ~~ (mask (LENGTH('i) - len)))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipset_from_netmask_base_mask_consume</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>word_bw_comms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">" ~~ (mask (LENGTH('i) - len))"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ip_cidr_set_def</span><span> </span><span>ipset_from_cidr_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>  </span><span>maskshift_eq_not_mask_generic</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ip_cidr_set_change_base</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j ∈ ip_cidr_set i r ⟹ ip_cidr_set j r = ip_cidr_set i r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ip_cidr_set_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹IP Addresses as WordIntervals›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The nice thing is: @{typ "'i wordinterval"}s are executable.›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>iprange_single</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'i::len word ⇒ 'i wordinterval"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"iprange_single ip ≡ WordInterval ip ip"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>iprange_interval</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('i::len word × 'i::len word) ⇒ 'i wordinterval"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"iprange_interval (ip_start, ip_end) = WordInterval ip_start ip_end"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>iprange_interval.simps</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iprange_interval_uncurry</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"iprange_interval ipcidr = uncurry WordInterval ipcidr"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>ipcidr</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>iprange_interval.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set (iprange_single ip) = {ip}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>iprange_single_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set (iprange_interval (ip1, ip2)) = {ip1 .. ip2}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>iprange_interval.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Now we can use the set operations on @{typ "'i::len wordinterval"}s›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">term</span></span><span> </span><span>wordinterval_to_set</span><span>
</span><span>  </span><span class="keyword1"><span class="command">term</span></span><span> </span><span>wordinterval_element</span><span>
</span><span>  </span><span class="keyword1"><span class="command">term</span></span><span> </span><span>wordinterval_union</span><span>
</span><span>  </span><span class="keyword1"><span class="command">term</span></span><span> </span><span>wordinterval_empty</span><span>
</span><span>  </span><span class="keyword1"><span class="command">term</span></span><span> </span><span>wordinterval_setminus</span><span>
</span><span>  </span><span class="keyword1"><span class="command">term</span></span><span> </span><span>wordinterval_UNIV</span><span>
</span><span>  </span><span class="keyword1"><span class="command">term</span></span><span> </span><span>wordinterval_invert</span><span>
</span><span>  </span><span class="keyword1"><span class="command">term</span></span><span> </span><span>wordinterval_intersection</span><span>
</span><span>  </span><span class="keyword1"><span class="command">term</span></span><span> </span><span>wordinterval_subset</span><span>
</span><span>  </span><span class="keyword1"><span class="command">term</span></span><span> </span><span>wordinterval_eq</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹IP Addresses in CIDR Notation›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹We want to convert IP addresses in CIDR notation to intervals.
    We already have @{const ipset_from_cidr}, which gives back a non-executable set.
    We want to convert to something we can store in an @{typ "'i wordinterval"}.›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>ipcidr_to_interval_start</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('i::len word × nat) ⇒ 'i::len word"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ipcidr_to_interval_start (pre, len) = (
      let netmask = (mask len) &lt;&lt; (LENGTH('i) - len);
          network_prefix = (pre AND netmask)
      in network_prefix)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>ipcidr_to_interval_end</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('i::len word × nat) ⇒ 'i::len word"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ipcidr_to_interval_end (pre, len) = (
      let netmask = (mask len) &lt;&lt; (LENGTH('i) - len);
          network_prefix = (pre AND netmask)
      in network_prefix OR (NOT netmask))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ipcidr_to_interval</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('i::len word × nat) ⇒ ('i word × 'i word)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ipcidr_to_interval cidr ≡ (ipcidr_to_interval_start cidr, ipcidr_to_interval_end cidr)"</span></span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipset_from_cidr_ipcidr_to_interval</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ipset_from_cidr base len =
      {ipcidr_to_interval_start (base,len) .. ipcidr_to_interval_end (base,len)}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>ipcidr_to_interval_def</span><span> </span><span>ipset_from_cidr_def</span><span> </span><span>ipset_from_netmask_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>ipcidr_to_interval_start.simps</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span> </span><span>ipcidr_to_interval_end.simps</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipcidr_to_interval</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ipcidr_to_interval (base, len) = (s,e) ⟹ ipset_from_cidr base len = {s .. e}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipcidr_to_interval_def</span><span> </span><span>ipset_from_cidr_ipcidr_to_interval</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ipcidr_tuple_to_wordinterval</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('i::len word × nat) ⇒ 'i wordinterval"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ipcidr_tuple_to_wordinterval iprng ≡ iprange_interval (ipcidr_to_interval iprng)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_to_set_ipcidr_tuple_to_wordinterval</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set (ipcidr_tuple_to_wordinterval (b, m)) = ipset_from_cidr b m"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ipcidr_tuple_to_wordinterval_def</span><span> </span><span>ipset_from_cidr_ipcidr_to_interval</span><span>
</span><span>              </span><span>ipcidr_to_interval_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>iprange_interval.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_to_set_ipcidr_tuple_to_wordinterval_uncurry</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set (ipcidr_tuple_to_wordinterval ipcidr) = uncurry ipset_from_cidr ipcidr"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>ipcidr</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wordinterval_to_set_ipcidr_tuple_to_wordinterval</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ipcidr_union_set</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('i::len word × nat) set ⇒ ('i word) set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ipcidr_union_set ips ≡ ⋃(base, len) ∈ ips. ipset_from_cidr base len"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipcidr_union_set_uncurry</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ipcidr_union_set ips = (⋃ ipcidr ∈ ips. uncurry ipset_from_cidr ipcidr)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipcidr_union_set_def</span><span> </span><span>uncurry_case_stmt</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Clever Operations on IP Addresses in CIDR Notation›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Intersecting two intervals may result in a new interval.
    Example: ‹{1..10} ∩ {5..20} = {5..10}›

    Intersecting two IP address ranges represented as CIDR ranges results either in the empty set
    or the smaller of the two ranges. It will never create a new range.
    ›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*contributed by Lars Noschinski*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>less_and_not_mask_eq</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>i</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a :: len) word"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r2 ≤ r1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &amp;&amp; ~~ (mask r2) = x &amp;&amp; ~~ (mask r2)"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &amp;&amp; ~~ (mask r1) = x &amp;&amp; ~~ (mask r1)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i AND NOT (mask r1) = (i &amp;&amp; ~~ (mask r2)) &amp;&amp; ~~ (mask r1)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ = ?w &amp;&amp; _"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹r2 ≤ r1›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>and_not_mask_twice</span><span> </span><span>max_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?w = x &amp;&amp; ~~ (mask r2)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… &amp;&amp; ~~ (mask r1) = x &amp;&amp; ~~ (mask r1)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹r2 ≤ r1›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>and_not_mask_twice</span><span> </span><span>max_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ip_cidr_set_less</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>i</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'i::len word"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r1 ≤ r2 ⟹ ip_cidr_set i r2 ⊆ ip_cidr_set i r1"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ip_cidr_set_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>less_and_not_mask_eq</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="var">?r2.0</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"LENGTH('i) - r2"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ip_cidr_set_intersect_subset_helper</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>i1</span><span> </span><span>r1</span><span> </span><span>i2</span><span> </span><span>r2</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>disj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ip_cidr_set i1 r1 ∩ ip_cidr_set i2 r2 ≠ {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"r1 ≤ r2"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ip_cidr_set i2 r2 ⊆ ip_cidr_set i1 r1"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>disj</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>j</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ∈ ip_cidr_set i1 r1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ∈ ip_cidr_set i2 r2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹r1 ≤ r2›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ∈ ip_cidr_set j r1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ∈ ip_cidr_set j r1"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ip_cidr_set_change_base</span><span> </span><span>ip_cidr_set_less</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ip_cidr_set i2 r2 ⊆ ip_cidr_set i1 r1"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ ip_cidr_set i2 r2"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹j ∈ ip_cidr_set i2 r2›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ ip_cidr_set j r2"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ip_cidr_set_change_base</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ip_cidr_set j r2 ⊆ ip_cidr_set j r1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹r1 ≤ r2›</span></span></span><span> </span><span>ip_cidr_set_less</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = ip_cidr_set i1 r1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹j ∈ ip_cidr_set i1 r1›</span></span></span><span> </span><span>ip_cidr_set_change_base</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∈ ip_cidr_set i1 r1"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ip_cidr_set_notsubset_empty_inter</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"¬ ip_cidr_set i1 r1 ⊆ ip_cidr_set i2 r2 ⟹
       ¬ ip_cidr_set i2 r2 ⊆ ip_cidr_set i1 r1 ⟹
       ip_cidr_set i1 r1 ∩ ip_cidr_set i2 r2 = {}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"r1 ≤ r2"</span></span></span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ip_cidr_set_intersect_subset_helper</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"r2 ≤ r1"</span></span></span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ip_cidr_set_intersect_subset_helper</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ip_cidr_intersect</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"¬ ipset_from_cidr b2 m2 ⊆ ipset_from_cidr b1 m1 ⟹
      ¬ ipset_from_cidr b1 m1 ⊆ ipset_from_cidr b2 m2 ⟹
      ipset_from_cidr b1 m1 ∩ ipset_from_cidr b2 m2 = {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipset_from_cidr_eq_ip_cidr_set</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ip_cidr_set_notsubset_empty_inter</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Computing the intersection of two IP address ranges in CIDR notation›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>ipcidr_conjunct</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('i::len word × nat) ⇒ ('i word × nat) ⇒ ('i word × nat) option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ipcidr_conjunct (base1, m1) (base2, m2) = (
       if
         ipset_from_cidr base1 m1 ∩ ipset_from_cidr base2 m2 = {}
       then
         None
       else if
         ipset_from_cidr base1 m1 ⊆ ipset_from_cidr base2 m2
       then
         Some (base1, m1)
       else
         Some (base2, m2)
      )"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Intersecting with an address with prefix length zero always yields a non-empty result.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipcidr_conjunct_any</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipcidr_conjunct a (x,0) ≠ None"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipcidr_conjunct (y,0) b ≠ None"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipset_from_cidr_0</span><span> </span><span>ipset_from_cidr_not_empty</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipset_from_cidr_0</span><span> </span><span>ipset_from_cidr_not_empty</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipcidr_conjunct_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(case ipcidr_conjunct (b1, m1) (b2, m2)
                                          of Some (bx, mx) ⇒ ipset_from_cidr bx mx
                                          |  None ⇒ {}) =
                                   (ipset_from_cidr b1 m1) ∩ (ipset_from_cidr b2 m2)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ip_cidr_intersect</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>ipcidr_conjunct.simps</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Code Equations›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Executable definition using word intervals›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipcidr_conjunct_word</span><span class="delimiter">[</span><span>code_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ipcidr_conjunct ips1 ips2 = (
     if
      wordinterval_empty (wordinterval_intersection
                            (ipcidr_tuple_to_wordinterval ips1) (ipcidr_tuple_to_wordinterval ips2))
     then
       None
     else if
       wordinterval_subset (ipcidr_tuple_to_wordinterval ips1) (ipcidr_tuple_to_wordinterval ips2)
     then
       Some ips1
     else
       Some ips2
     )"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>ips1</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>ips2</span><span class="delimiter">,</span><span> </span><span>rename_tac</span><span> </span><span>b1</span><span> </span><span>m1</span><span> </span><span>b2</span><span> </span><span>m2</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wordinterval_to_set_ipcidr_tuple_to_wordinterval</span><span> </span><span>ipcidr_conjunct.simps</span><span>
</span><span>             </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*with the code_unfold lemma before, this works!*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipcidr_conjunct (0::32 word,0) (8,1) = Some (8, 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>  </span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>ipcidr_conjunct</span><span> </span><span class="keyword2"><span class="keyword">checking</span></span><span> </span><span>SML</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹making element check executable›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>addr_in_ipset_from_netmask_code</span><span class="delimiter">[</span><span>code_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"addr ∈ (ipset_from_netmask base netmask) ⟷
      (base AND netmask) ≤ addr ∧ addr ≤ (base AND netmask) OR (NOT netmask)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipset_from_netmask_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>addr_in_ipset_from_cidr_code</span><span class="delimiter">[</span><span>code_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(addr::'i::len word) ∈ (ipset_from_cidr pre len) ⟷
       (pre AND ((mask len) &lt;&lt; (LENGTH('i) - len))) ≤ addr ∧
        addr ≤ pre OR (mask (LENGTH('i) - len))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ipset_from_cidr_alt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="IPv4">
<div class="head"><h1>Theory IPv4</h1>
<span class="command">theory</span> <span class="name">IPv4</span><br/>
<span class="keyword">imports</span> <a href="IP_Address.html"><span class="name">IP_Address</span></a> <a href="NumberWang_IPv4.html"><span class="name">NumberWang_IPv4</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      IPv4.thy
    Authors:    Cornelius Diekmann, Julius Michaelis
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>IPv4</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>IP_Address</span><span>
</span><span>        </span><span>NumberWang_IPv4</span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* include "HOL-Library.Code_Target_Nat" if you need to work with actual numbers.*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹IPv4 Adresses›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹An IPv4 address is basically a 32 bit unsigned integer.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>ipv4addr</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"32 word"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Conversion between natural numbers and IPv4 adresses›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>nat_of_ipv4addr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv4addr ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"nat_of_ipv4addr a = unat a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ipv4addr_of_nat</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ ipv4addr"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ipv4addr_of_nat n =  of_nat n"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The maximum IPv4 addres›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>max_ipv4_addr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv4addr"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"max_ipv4_addr ≡ ipv4addr_of_nat ((2^32) - 1)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>max_ipv4_addr_number</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"max_ipv4_addr = 4294967295"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>max_ipv4_addr_def</span><span> </span><span>ipv4addr_of_nat_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"max_ipv4_addr = 0b11111111111111111111111111111111"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fact</span><span> </span><span>max_ipv4_addr_number</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>max_ipv4_addr_max_word</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"max_ipv4_addr = max_word"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>max_ipv4_addr_number</span><span> </span><span>max_word_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>max_ipv4_addr_max</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a. a ≤ max_ipv4_addr"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>max_ipv4_addr_max_word</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>UNIV_ipv4addrset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"UNIV = {0 .. max_ipv4_addr}"</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*not in the simp set, for a reason*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>max_ipv4_addr_max_word</span><span class="delimiter">)</span><span> </span><span>fastforce</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹identity functions›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nat_of_ipv4addr_ipv4addr_of_nat</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⟦ n ≤ nat_of_ipv4addr max_ipv4_addr ⟧ ⟹ nat_of_ipv4addr (ipv4addr_of_nat n) = n"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv4addr_of_nat_def</span><span> </span><span>le_unat_uoi</span><span> </span><span>nat_of_ipv4addr_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nat_of_ipv4addr_ipv4addr_of_nat_mod</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat_of_ipv4addr (ipv4addr_of_nat n) = n mod 2^32"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv4addr_of_nat_def</span><span> </span><span>nat_of_ipv4addr_def</span><span> </span><span>unat_of_nat</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipv4addr_of_nat_nat_of_ipv4addr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv4addr_of_nat (nat_of_ipv4addr addr) = addr"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv4addr_of_nat_def</span><span> </span><span>nat_of_ipv4addr_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Representing IPv4 Adresses (Syntax)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>ipv4addr_of_dotdecimal</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat × nat × nat × nat ⇒ ipv4addr"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ipv4addr_of_dotdecimal (a,b,c,d) = ipv4addr_of_nat (d + 256 * c + 65536 * b + 16777216 * a )"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>dotdecimal_of_ipv4addr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv4addr ⇒ nat × nat × nat × nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"dotdecimal_of_ipv4addr a = (nat_of_ipv4addr ((a &gt;&gt; 24) AND 0xFF),
                                    nat_of_ipv4addr ((a &gt;&gt; 16) AND 0xFF),
                                    nat_of_ipv4addr ((a &gt;&gt; 8) AND 0xFF),
                                    nat_of_ipv4addr (a AND 0xff))"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>ipv4addr_of_dotdecimal.simps</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>dotdecimal_of_ipv4addr.simps</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Examples:›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv4addr_of_dotdecimal (192, 168, 0, 1) = 3232235521"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv4addr_of_dotdecimal.simps</span><span> </span><span>ipv4addr_of_nat_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*could be solved by eval, but needs "HOL-Library.Code_Target_Nat"*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dotdecimal_of_ipv4addr 3232235521 = (192, 168, 0, 1)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dotdecimal_of_ipv4addr.simps</span><span> </span><span>nat_of_ipv4addr_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹a different notation for @{term ipv4addr_of_dotdecimal}›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipv4addr_of_dotdecimal_bit</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ipv4addr_of_dotdecimal (a,b,c,d) =
      (ipv4addr_of_nat a &lt;&lt; 24) + (ipv4addr_of_nat b &lt;&lt; 16) +
       (ipv4addr_of_nat c &lt;&lt; 8) + ipv4addr_of_nat d"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ipv4addr_of_nat a) &lt;&lt; 24 = ipv4addr_of_nat (a * 16777216)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv4addr_of_nat_def</span><span> </span><span>shiftl_t2n</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ipv4addr_of_nat b) &lt;&lt; 16 = ipv4addr_of_nat (b * 65536)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv4addr_of_nat_def</span><span> </span><span>shiftl_t2n</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ipv4addr_of_nat c) &lt;&lt; 8 = ipv4addr_of_nat (c * 256)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv4addr_of_nat_def</span><span> </span><span>shiftl_t2n</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ipv4addr_of_nat_suc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. ipv4addr_of_nat (Suc x) = word_succ (ipv4addr_of_nat (x))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv4addr_of_nat_def</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>Abs_fnat_hom_Suc</span><span> </span><span>of_nat_Suc</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv4addr_of_nat x + ipv4addr_of_nat y = ipv4addr_of_nat (x+y)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>x</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv4addr_of_nat_def</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv4addr_of_nat_suc</span><span> </span><span>word_succ_p1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv4addr_of_dotdecimal.simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span>ipv4addr_of_nat</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>thin_tac</span><span> </span><span>_</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>size_ipv4addr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"size (x::ipv4addr) = 32"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>word_size</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dotdecimal_of_ipv4addr_ipv4addr_of_dotdecimal</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ a &lt; 256; b &lt; 256; c &lt; 256; d &lt; 256 ⟧ ⟹
    dotdecimal_of_ipv4addr (ipv4addr_of_dotdecimal (a,b,c,d)) = (a,b,c,d)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"a &lt; 256"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b &lt; 256"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c &lt; 256"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d &lt; 256"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>assms</span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a &lt; 256›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹b &lt; 256›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹c &lt; 256›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹d &lt; 256›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>a</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nat_of_ipv4addr ((ipv4addr_of_nat (d + 256 * c + 65536 * b + 16777216 * a) &gt;&gt; 24) AND mask 8) = a"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv4addr_of_nat_def</span><span> </span><span>word_of_nat</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nat_of_ipv4addr_def</span><span> </span><span>unat_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>and_mask_mod_2p</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>shiftr_div_2n</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>uint_word_of_int</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ipv4addr_of_nat_AND_mask8</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ipv4addr_of_nat a) AND mask 8 = (ipv4addr_of_nat (a mod 256))"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv4addr_of_nat_def</span><span> </span><span>and_mask_mod_2p</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>word_of_nat</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*use this to get rid of of_nat. All thm are with word_of_int*)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>uint_word_of_int</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>mod_mod_cancel</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>zmod_int</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"nat_of_ipv4addr ((ipv4addr_of_nat (d + 256 * c + 65536 * b + 16777216 * a) &gt;&gt; 16) AND mask 8) = b"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv4addr_of_nat_def</span><span> </span><span>word_of_nat</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nat_of_ipv4addr_def</span><span> </span><span>unat_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>and_mask_mod_2p</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>shiftr_div_2n</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>uint_word_of_int</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>NumberWang_IPv4.div65536</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*The [simplified] is needed because Word_Lib adds some additional simp rules*)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="comment">― ‹When @{file ‹../Word_Lib/Word_Lemmas.thy›} is imported,
         some @{file ‹NumberWang_IPv4.thy›} lemmas need the
         [simplified] attribute because @{text Word_Lib} adds some simp rules.
         This theory should also work without @{file ‹../Word_Lib/Word_Lemmas.thy›}›</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"nat_of_ipv4addr ((ipv4addr_of_nat (d + 256 * c + 65536 * b + 16777216 * a) &gt;&gt; 8) AND mask 8) = c"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv4addr_of_nat_def</span><span> </span><span>word_of_nat</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nat_of_ipv4addr_def</span><span> </span><span>unat_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>and_mask_mod_2p</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>shiftr_div_2n</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>uint_word_of_int</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>NumberWang_IPv4.div256</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹d &lt; 256›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>d</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat_of_ipv4addr (ipv4addr_of_nat (d + 256 * c + 65536 * b + 16777216 * a) AND mask 8) = d"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv4addr_of_nat_AND_mask8</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv4addr_of_nat_def</span><span> </span><span>word_of_nat</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nat_of_ipv4addr_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"(d + 256 * c + 65536 * b + 16777216 * a) mod 256 = d"</span></span></span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>unat_def</span><span> </span><span>uint_word_of_int</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>NumberWang_IPv4.mod256</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv4addr_of_dotdecimal.simps</span><span> </span><span>dotdecimal_of_ipv4addr.simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mask_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipv4addr_of_dotdecimal_dotdecimal_of_ipv4addr</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(ipv4addr_of_dotdecimal (dotdecimal_of_ipv4addr ip)) = ip"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ip_and_mask8_bl_drop24</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ip::ipv4addr) AND mask 8 = of_bl (drop 24 (to_bl ip))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Word_Lemmas.of_drop_to_bl</span><span> </span><span>size_ipv4addr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>List_rev_drop_geqn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length x ≥ n ⟹ (take n (rev x)) = rev (drop (length x - n) x)"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>List.rev_drop</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>and_mask_bl_take</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length x ≥ n ⟹ ((of_bl x) AND mask n) = (of_bl (rev (take n (rev (x)))))"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>n</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>List_rev_drop_geqn</span><span> </span><span>of_bl_drop</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ipv4addr_and_255</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x AND 255 = x AND mask 8"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span>ipv4addr</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mask_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bit_equality</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"((ip &gt;&gt; 24) AND 0xFF &lt;&lt; 24) + ((ip &gt;&gt; 16) AND 0xFF &lt;&lt; 16) + ((ip &gt;&gt; 8) AND 0xFF &lt;&lt; 8) + (ip AND 0xFF) =
       of_bl (take 8 (to_bl ip) @ take 8 (drop 8 (to_bl ip)) @ take 8 (drop 16 (to_bl ip)) @ drop 24 (to_bl ip))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv4addr_and_255</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>shiftr_slice</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Word.slice_take'</span><span> </span><span>size_ipv4addr</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>and_mask_bl_take</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>List_rev_drop_geqn</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>drop_take</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Word.shiftl_of_bl</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>of_bl_append</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ip_and_mask8_bl_drop24</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>blip_split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ blip. length blip = 32 ⟹
      blip = (take 8 blip) @ (take 8 (drop 8 blip)) @ (take 8 (drop 16 blip)) @ (take 8 (drop 24 blip))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>blip</span><span class="delimiter">,</span><span>case_tac</span><span> </span><span>blip</span><span class="delimiter">,</span><span>simp_all</span><span class="delimiter">)</span><span class="delimiter">+</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*I'm so sorry for this ...*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv4addr_of_dotdecimal (dotdecimal_of_ipv4addr ip) = of_bl (to_bl ip)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>blip_split</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv4addr_of_dotdecimal_bit</span><span> </span><span>dotdecimal_of_ipv4addr.simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv4addr_of_nat_nat_of_ipv4addr</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bit_equality</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Word.word_bl.Rep_inverse</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipv4addr_of_dotdecimal_eqE</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⟦ ipv4addr_of_dotdecimal (a,b,c,d) = ipv4addr_of_dotdecimal (e,f,g,h);
       a &lt; 256; b &lt; 256; c &lt; 256; d &lt; 256; e &lt; 256; f &lt; 256; g &lt; 256; h &lt; 256 ⟧ ⟹
         a = e ∧ b = f ∧ c = g ∧ d = h"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Pair_inject</span><span> </span><span>dotdecimal_of_ipv4addr_ipv4addr_of_dotdecimal</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹IP Ranges: Examples›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(UNIV :: ipv4addr set) = {0 .. max_ipv4_addr}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>UNIV_ipv4addrset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(42::ipv4addr) ∈ UNIV"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Warning, not executable!*)</span></span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipset_from_netmask (ipv4addr_of_dotdecimal (192,168,0,42)) (ipv4addr_of_dotdecimal (255,255,0,0)) =
          {ipv4addr_of_dotdecimal (192,168,0,0) .. ipv4addr_of_dotdecimal (192,168,255,255)}"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipset_from_netmask_def</span><span> </span><span>ipv4addr_of_dotdecimal.simps</span><span> </span><span>ipv4addr_of_nat_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipset_from_netmask (ipv4addr_of_dotdecimal (192,168,0,42)) (ipv4addr_of_dotdecimal (0,0,0,0)) = UNIV"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>UNIV_ipv4addrset</span><span> </span><span>ipset_from_netmask_def</span><span> </span><span>ipv4addr_of_dotdecimal.simps</span><span>
</span><span>                 </span><span>ipv4addr_of_nat_def</span><span> </span><span>max_ipv4_addr_max_word</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹192.168.0.0/24›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>addr</span><span> </span><span class="delimiter">::</span><span> </span><span>ipv4addr</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipset_from_cidr addr pflength =
            ipset_from_netmask addr ((mask pflength) &lt;&lt; (32 - pflength))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipset_from_cidr_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipset_from_cidr (ipv4addr_of_dotdecimal (192,168,0,42)) 16 =
          {ipv4addr_of_dotdecimal (192,168,0,0) .. ipv4addr_of_dotdecimal (192,168,255,255)}"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipset_from_cidr_alt</span><span> </span><span>mask_def</span><span>  </span><span>ipv4addr_of_dotdecimal.simps</span><span> </span><span>ipv4addr_of_nat_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ip ∈ (ipset_from_cidr (ipv4addr_of_dotdecimal (0, 0, 0, 0)) 0)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipset_from_cidr_0</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipv4set_from_cidr_32</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>addr</span><span> </span><span class="delimiter">::</span><span> </span><span>ipv4addr</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipset_from_cidr addr 32 = {addr}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipset_from_cidr_alt</span><span> </span><span>mask_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>pre</span><span> </span><span class="delimiter">::</span><span> </span><span>ipv4addr</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipset_from_cidr pre len = {(pre AND ((mask len) &lt;&lt; (32 - len))) .. pre OR (mask (32 - len))}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipset_from_cidr_alt</span><span> </span><span>ipset_from_cidr_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹making element check executable›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>addr_in_ipv4set_from_netmask_code</span><span class="delimiter">[</span><span>code_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>addr</span><span> </span><span class="delimiter">::</span><span> </span><span>ipv4addr</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"addr ∈ (ipset_from_netmask base netmask) ⟷
            (base AND netmask) ≤ addr ∧ addr ≤ (base AND netmask) OR (NOT netmask)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>addr_in_ipset_from_netmask_code</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>addr_in_ipv4set_from_cidr_code</span><span class="delimiter">[</span><span>code_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>addr</span><span> </span><span class="delimiter">::</span><span> </span><span>ipv4addr</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"addr ∈ (ipset_from_cidr pre len) ⟷
              (pre AND ((mask len) &lt;&lt; (32 - len))) ≤ addr ∧ addr ≤ pre OR (mask (32 - len))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>addr_in_ipset_from_cidr_code</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*small numbers because we didn't load Code_Target_Nat. Should work by eval*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv4addr_of_dotdecimal (192,168,42,8) ∈ (ipset_from_cidr (ipv4addr_of_dotdecimal (192,168,0,0)) 16)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv4addr_of_dotdecimal.simps</span><span> </span><span>ipv4addr_of_nat_def</span><span> </span><span>ipset_from_cidr_def</span><span>
</span><span>                    </span><span>ipset_from_netmask_def</span><span> </span><span>mask_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ipv4range_UNIV</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"32 wordinterval"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv4range_UNIV ≡ wordinterval_UNIV"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipv4range_UNIV_set_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set ipv4range_UNIV = UNIV"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>ipv4range_UNIV_def</span><span> </span><span>wordinterval_UNIV_set_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>iffD1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wordinterval_eq_set_eq</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*TODO: probably the following is a good idea?*)</span></span></span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  declare iffD1[OF wordinterval_eq_set_eq, cong]
  *)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹This ‹LENGTH('a)› is 32 for IPv4 addresses.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipv4cidr_to_interval_simps</span><span class="delimiter">[</span><span>code_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipcidr_to_interval ((pre::ipv4addr), len) = (
      let netmask = (mask len) &lt;&lt; (32 - len);
          network_prefix = (pre AND netmask)
      in (network_prefix, network_prefix OR (NOT netmask)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipcidr_to_interval_def</span><span> </span><span>Let_def</span><span> </span><span>ipcidr_to_interval_start.simps</span><span> </span><span>ipcidr_to_interval_end.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="IPv6">
<div class="head"><h1>Theory IPv6</h1>
<span class="command">theory</span> <span class="name">IPv6</span><br/>
<span class="keyword">imports</span> <a href="IP_Address.html"><span class="name">IP_Address</span></a> <a href="NumberWang_IPv6.html"><span class="name">NumberWang_IPv6</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      IPv6.thy
    Authors:    Cornelius Diekmann
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>IPv6</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>IP_Address</span><span>
</span><span>        </span><span>NumberWang_IPv6</span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* include "HOL-Library.Code_Target_Nat" if you need to work with actual numbers.*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹IPv6 Addresses›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹An IPv6 address is basically a 128 bit unsigned integer. RFC 4291, Section 2.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>ipv6addr</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"128 word"</span></span></span><span>
</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Conversion between natural numbers and IPv6 adresses›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>nat_of_ipv6addr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"nat_of_ipv6addr a = unat a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ipv6addr_of_nat</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ ipv6addr"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_of_nat n =  of_nat n"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_of_nat n = word_of_int (int n)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv6addr_of_nat_def</span><span> </span><span>word_of_nat</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The maximum IPv6 address›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>max_ipv6_addr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"max_ipv6_addr ≡ ipv6addr_of_nat ((2^128) - 1)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>max_ipv6_addr_number</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"max_ipv6_addr = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>max_ipv6_addr_def</span><span> </span><span>ipv6addr_of_nat_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"max_ipv6_addr = 340282366920938463463374607431768211455"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fact</span><span> </span><span>max_ipv6_addr_number</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>max_ipv6_addr_max_word</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"max_ipv6_addr = max_word"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>max_ipv6_addr_number</span><span> </span><span>max_word_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>max_ipv6_addr_max</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a. a ≤ max_ipv6_addr"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>max_ipv6_addr_max_word</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>UNIV_ipv6addrset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"UNIV = {0 .. max_ipv6_addr}"</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*not in the simp set, for a reason*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>max_ipv6_addr_max_word</span><span class="delimiter">)</span><span> </span><span>fastforce</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹identity functions›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nat_of_ipv6addr_ipv6addr_of_nat</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"n ≤ nat_of_ipv6addr max_ipv6_addr ⟹ nat_of_ipv6addr (ipv6addr_of_nat n) = n"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nat_of_ipv6addr_def</span><span> </span><span>ipv6addr_of_nat_def</span><span> </span><span>le_unat_uoi</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nat_of_ipv6addr_ipv6addr_of_nat_mod</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat_of_ipv6addr (ipv6addr_of_nat n) = n mod 2^128"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv6addr_of_nat_def</span><span> </span><span>nat_of_ipv6addr_def</span><span> </span><span>unat_of_nat</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipv6addr_of_nat_nat_of_ipv6addr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_of_nat (nat_of_ipv6addr addr) = addr"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv6addr_of_nat_def</span><span> </span><span>nat_of_ipv6addr_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Syntax of IPv6 Adresses›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹RFC 4291, Section 2.2.: Text Representation of Addresses›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Quoting the RFC (note: errata exists):›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text_raw</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
  \begin{verbatim}
   1. The preferred form is x:x:x:x:x:x:x:x, where the 'x's are one to
      four hexadecimal digits of the eight 16-bit pieces of the address.
      Examples:
         ABCD:EF01:2345:6789:ABCD:EF01:2345:6789
         2001:DB8:0:0:8:800:200C:417A
  \end{verbatim}
›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>ipv6addr_syntax</span><span> </span><span class="delimiter">=</span><span> 
</span><span>    </span><span>IPv6AddrPreferred</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text_raw</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
  \begin{verbatim}
   2. [...] In order to make writing addresses containing zero
      bits easier, a special syntax is available to compress the zeros.
      The use of "::" indicates one or more groups of 16 bits of zeros.
      The "::" can only appear once in an address.  The "::" can also be
      used to compress leading or trailing zeros in an address.

      For example, the following addresses
         2001:DB8:0:0:8:800:200C:417A   a unicast address
         FF01:0:0:0:0:0:0:101           a multicast address
         0:0:0:0:0:0:0:1                the loopback address
         0:0:0:0:0:0:0:0                the unspecified address

      may be represented as
         2001:DB8::8:800:200C:417A      a unicast address
         FF01::101                      a multicast address
         ::1                            the loopback address
         ::                             the unspecified address
  \end{verbatim}
›</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*datatype may take some minutes to load*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>ipv6addr_syntax_compressed</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="comment">― ‹using @{typ unit} for the omission @{text "::"}. 

     Naming convention of the datatype: 
      The first number is the position where the omission occurs.
      The second number is the length of the specified address pieces.
        I.e. `8 minus the second number' pieces are omitted.›</span><span>
</span><span>    </span><span>IPv6AddrCompressed1_0</span><span> </span><span>unit</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed1_1</span><span> </span><span>unit</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed1_2</span><span> </span><span>unit</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed1_3</span><span> </span><span>unit</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed1_4</span><span> </span><span>unit</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> 
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed1_5</span><span> </span><span>unit</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed1_6</span><span> </span><span>unit</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed1_7</span><span> </span><span>unit</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span>
</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed2_1</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span>unit</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed2_2</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span>unit</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed2_3</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span>unit</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed2_4</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span>unit</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed2_5</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span>unit</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed2_6</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span>unit</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed2_7</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span>unit</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span>
</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed3_2</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span>unit</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed3_3</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span>unit</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed3_4</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span>unit</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed3_5</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span>unit</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed3_6</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span>unit</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed3_7</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span>unit</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span>
</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed4_3</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span>unit</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed4_4</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span>unit</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed4_5</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span>unit</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed4_6</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span>unit</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed4_7</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span>unit</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span>
</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed5_4</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span>unit</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed5_5</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span>unit</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed5_6</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span>unit</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed5_7</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span>unit</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span>
</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed6_5</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span>unit</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed6_6</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span>unit</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed6_7</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span>unit</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span>
</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed7_6</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span>unit</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed7_7</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span>unit</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span>
</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>IPv6AddrCompressed8_7</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word"</span></span></span><span> </span><span>unit</span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*RFC 5952:
    """
    4.  A Recommendation for IPv6 Text Representation
    4.2.2.  Handling One 16-Bit 0 Field
       The symbol "::" MUST NOT be used to shorten just one 16-bit 0 field.
       For example, the representation 2001:db8:0:1:1:1:1:1 is correct, but
       2001:db8::1:1:1:1:1 is not correct.
    """

    So we could remove all IPv6AddrCompressed*_7 constructors.
    But these are `recommendations', we might still see these non-recommended definitions.
    "[...] all implementations must accept and be able to handle any legitimate RFC 4291 format."
  *)</span></span></span></span></span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*More convenient parser helper function for compressed IPv6 addresses:
    Input list (from parser):
      Some 16word ⟶ address piece
      None ⟶ omission '::'
    
  
   Basically, the parser must only do the following (python syntax):
     split the string which is an ipv6 address at ':'
     map empty string to None
     map everything else to Some (string_to_16word str)
     sanitize empty strings at the start and the end (see toString and parser theories)
   Example:
     "1:2:3".split(":")  = ['1', '2', '3']
     ":2:3:4".split(":") = ['', '2', '3', '4']
     ":2::3".split(":")  = ['', '2', '', '3']
     "1:2:3:".split(":") = ['1', '2', '3', '']
  *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>parse_ipv6_address_compressed</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"((16 word) option) list ⇒ ipv6addr_syntax_compressed option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"parse_ipv6_address_compressed as = (case as of 
      [None] ⇒ Some (IPv6AddrCompressed1_0 ())
    | [None, Some a] ⇒ Some (IPv6AddrCompressed1_1 () a)
    | [None, Some a, Some b] ⇒ Some (IPv6AddrCompressed1_2 () a b)
    | [None, Some a, Some b, Some c] ⇒ Some (IPv6AddrCompressed1_3 () a b c)
    | [None, Some a, Some b, Some c, Some d] ⇒ Some (IPv6AddrCompressed1_4 () a b c d)
    | [None, Some a, Some b, Some c, Some d, Some e] ⇒ Some (IPv6AddrCompressed1_5 () a b c d e)
    | [None, Some a, Some b, Some c, Some d, Some e, Some f] ⇒ Some (IPv6AddrCompressed1_6 () a b c d e f)
    | [None, Some a, Some b, Some c, Some d, Some e, Some f, Some g] ⇒ Some (IPv6AddrCompressed1_7 () a b c d e f g)
  
    | [Some a, None] ⇒ Some (IPv6AddrCompressed2_1 a ())
    | [Some a, None, Some b] ⇒ Some (IPv6AddrCompressed2_2 a () b)
    | [Some a, None, Some b, Some c] ⇒ Some (IPv6AddrCompressed2_3 a () b c)
    | [Some a, None, Some b, Some c, Some d] ⇒ Some (IPv6AddrCompressed2_4 a () b c d)
    | [Some a, None, Some b, Some c, Some d, Some e] ⇒ Some (IPv6AddrCompressed2_5 a () b c d e)
    | [Some a, None, Some b, Some c, Some d, Some e, Some f] ⇒ Some (IPv6AddrCompressed2_6 a () b c d e f)
    | [Some a, None, Some b, Some c, Some d, Some e, Some f, Some g] ⇒ Some (IPv6AddrCompressed2_7 a () b c d e f g)
  
    | [Some a, Some b, None] ⇒ Some (IPv6AddrCompressed3_2 a b ())
    | [Some a, Some b, None, Some c] ⇒ Some (IPv6AddrCompressed3_3 a b () c)
    | [Some a, Some b, None, Some c, Some d] ⇒ Some (IPv6AddrCompressed3_4 a b () c d)
    | [Some a, Some b, None, Some c, Some d, Some e] ⇒ Some (IPv6AddrCompressed3_5 a b () c d e)
    | [Some a, Some b, None, Some c, Some d, Some e, Some f] ⇒ Some (IPv6AddrCompressed3_6 a b () c d e f)
    | [Some a, Some b, None, Some c, Some d, Some e, Some f, Some g] ⇒ Some (IPv6AddrCompressed3_7 a b () c d e f g)
  
    | [Some a, Some b, Some c, None] ⇒ Some (IPv6AddrCompressed4_3 a b c ())
    | [Some a, Some b, Some c, None, Some d] ⇒ Some (IPv6AddrCompressed4_4 a b c () d)
    | [Some a, Some b, Some c, None, Some d, Some e] ⇒ Some (IPv6AddrCompressed4_5 a b c () d e)
    | [Some a, Some b, Some c, None, Some d, Some e, Some f] ⇒ Some (IPv6AddrCompressed4_6 a b c () d e f)
    | [Some a, Some b, Some c, None, Some d, Some e, Some f, Some g] ⇒ Some (IPv6AddrCompressed4_7 a b c () d e f g)
  
    | [Some a, Some b, Some c, Some d, None] ⇒ Some (IPv6AddrCompressed5_4 a b c d ())
    | [Some a, Some b, Some c, Some d, None, Some e] ⇒ Some (IPv6AddrCompressed5_5 a b c d () e)
    | [Some a, Some b, Some c, Some d, None, Some e, Some f] ⇒ Some (IPv6AddrCompressed5_6 a b c d () e f)
    | [Some a, Some b, Some c, Some d, None, Some e, Some f, Some g] ⇒ Some (IPv6AddrCompressed5_7 a b c d () e f g)
  
    | [Some a, Some b, Some c, Some d, Some e, None] ⇒ Some (IPv6AddrCompressed6_5 a b c d e ())
    | [Some a, Some b, Some c, Some d, Some e, None, Some f] ⇒ Some (IPv6AddrCompressed6_6 a b c d e () f)
    | [Some a, Some b, Some c, Some d, Some e, None, Some f, Some g] ⇒ Some (IPv6AddrCompressed6_7 a b c d e () f g)
  
    | [Some a, Some b, Some c, Some d, Some e, Some f, None] ⇒ Some (IPv6AddrCompressed7_6 a b c d e f ())
    | [Some a, Some b, Some c, Some d, Some e, Some f, None, Some g] ⇒ Some (IPv6AddrCompressed7_7 a b c d e f () g)

    | [Some a, Some b, Some c, Some d, Some e, Some f, Some g, None] ⇒ Some (IPv6AddrCompressed8_7 a b c d e f g ())
    | _ ⇒ None ― ‹invalid ipv6 copressed address.›
)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>ipv6addr_syntax_compressed_to_list</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed ⇒ ((16 word) option) list"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed1_0 _) =
                                     [None]"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed1_1 () a) =
                                     [None, Some a]"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed1_2 () a b) =
                                     [None, Some a, Some b]"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed1_3 () a b c) =
                                     [None, Some a, Some b, Some c]"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed1_4 () a b c d) =
                                     [None, Some a, Some b, Some c, Some d]"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed1_5 () a b c d e) =
                                     [None, Some a, Some b, Some c, Some d, Some e]"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed1_6 () a b c d e f) =
                                     [None, Some a, Some b, Some c, Some d, Some e, Some f]"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed1_7 () a b c d e f g) =
                                     [None, Some a, Some b, Some c, Some d, Some e, Some f, Some g]"</span></span></span><span>
</span><span>  
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed2_1 a ()) =
                                     [Some a, None]"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed2_2 a () b) =
                                     [Some a, None, Some b]"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed2_3 a () b c) =
                                     [Some a, None, Some b, Some c]"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed2_4 a () b c d) =
                                     [Some a, None, Some b, Some c, Some d]"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed2_5 a () b c d e) =
                                     [Some a, None, Some b, Some c, Some d, Some e]"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed2_6 a () b c d e f) =
                                     [Some a, None, Some b, Some c, Some d, Some e, Some f]"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed2_7 a () b c d e f g) =
                                     [Some a, None, Some b, Some c, Some d, Some e, Some f, Some g]"</span></span></span><span>
</span><span>  
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed3_2 a b ()) = [Some a, Some b, None]"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed3_3 a b () c) =
                                     [Some a, Some b, None, Some c]"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed3_4 a b () c d) =
                                     [Some a, Some b, None, Some c, Some d]"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed3_5 a b () c d e) =
                                     [Some a, Some b, None, Some c, Some d, Some e]"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed3_6 a b () c d e f) =
                                     [Some a, Some b, None, Some c, Some d, Some e, Some f]"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed3_7 a b () c d e f g) =
                                     [Some a, Some b, None, Some c, Some d, Some e, Some f, Some g]"</span></span></span><span>
</span><span>  
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed4_3 a b c ()) =
                                     [Some a, Some b, Some c, None]"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed4_4 a b c () d) =
                                     [Some a, Some b, Some c, None, Some d]"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed4_5 a b c () d e) =
                                     [Some a, Some b, Some c, None, Some d, Some e]"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed4_6 a b c () d e f) =
                                     [Some a, Some b, Some c, None, Some d, Some e, Some f]"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed4_7 a b c () d e f g) =
                                     [Some a, Some b, Some c, None, Some d, Some e, Some f, Some g]"</span></span></span><span>
</span><span>  
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed5_4 a b c d ()) =
                                     [Some a, Some b, Some c, Some d, None]"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed5_5 a b c d () e) =
                                     [Some a, Some b, Some c, Some d, None, Some e]"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed5_6 a b c d () e f) =
                                     [Some a, Some b, Some c, Some d, None, Some e, Some f]"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed5_7 a b c d () e f g) =
                                     [Some a, Some b, Some c, Some d, None, Some e, Some f, Some g]"</span></span></span><span>
</span><span>  
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed6_5 a b c d e ()) =
                                     [Some a, Some b, Some c, Some d, Some e, None]"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed6_6 a b c d e () f) =
                                     [Some a, Some b, Some c, Some d, Some e, None, Some f]"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed6_7 a b c d e () f g) =
                                     [Some a, Some b, Some c, Some d, Some e, None, Some f, Some g]"</span></span></span><span>
</span><span>  
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed7_6 a b c d e f ()) =
                                     [Some a, Some b, Some c, Some d, Some e, Some f, None]"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed7_7 a b c d e f () g) =
                                     [Some a, Some b, Some c, Some d, Some e, Some f, None, Some g]"</span></span></span><span>
</span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list (IPv6AddrCompressed8_7 a b c d e f g ()) =
                                     [Some a, Some b, Some c, Some d, Some e, Some f, Some g, None]"</span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*for all ipv6_syntax, there is a corresponding list representation*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parse_ipv6_address_compressed_exists</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>ss</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"parse_ipv6_address_compressed ss = Some ipv6_syntax"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ss</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ss = ipv6addr_syntax_compressed_to_list ipv6_syntax"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"parse_ipv6_address_compressed ss = Some ipv6_syntax"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ipv6_syntax</span><span class="delimiter">;</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>parse_ipv6_address_compressed_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parse_ipv6_address_compressed_identity</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"parse_ipv6_address_compressed (ipv6addr_syntax_compressed_to_list (ipv6_syntax)) = Some ipv6_syntax"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>ipv6_syntax</span><span class="delimiter">;</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>parse_ipv6_address_compressed_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parse_ipv6_address_compressed_someE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"parse_ipv6_address_compressed as = Some ipv6"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"as = [None]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed1_0 ())"</span></span></span><span>  </span><span class="delimiter">|</span><span>
</span><span>    </span><span>a</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [None, Some a]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed1_1 () a)"</span></span></span><span>  </span><span class="delimiter">|</span><span>
</span><span>    </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [None, Some a, Some b]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed1_2 () a b)"</span></span></span><span>  </span><span class="delimiter">|</span><span>
</span><span>    </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [None, Some a, Some b, Some c]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed1_3 () a b c)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [None, Some a, Some b, Some c, Some d]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed1_4 () a b c d)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span>e</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [None, Some a, Some b, Some c, Some d, Some e]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed1_5 () a b c d e)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span>e</span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [None, Some a, Some b, Some c, Some d, Some e, Some f]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed1_6 () a b c d e f)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span>e</span><span> </span><span>f</span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [None, Some a, Some b, Some c, Some d, Some e, Some f, Some g]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed1_7 () a b c d e f g)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  
</span><span>    </span><span>a</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [Some a, None]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed2_1 a ())"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [Some a, None, Some b]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed2_2 a () b)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [Some a, None, Some b, Some c]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed2_3 a () b c)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [Some a, None, Some b, Some c, Some d]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed2_4 a () b c d)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span>e</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [Some a, None, Some b, Some c, Some d, Some e]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed2_5 a () b c d e)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span>e</span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [Some a, None, Some b, Some c, Some d, Some e, Some f]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed2_6 a () b c d e f)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span>e</span><span> </span><span>f</span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [Some a, None, Some b, Some c, Some d, Some e, Some f, Some g]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed2_7 a () b c d e f g)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  
</span><span>    </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [Some a, Some b, None]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed3_2 a b ())"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [Some a, Some b, None, Some c]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed3_3 a b () c)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [Some a, Some b, None, Some c, Some d]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed3_4 a b () c d)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span>e</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [Some a, Some b, None, Some c, Some d, Some e]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed3_5 a b () c d e)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span>e</span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [Some a, Some b, None, Some c, Some d, Some e, Some f]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed3_6 a b () c d e f)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span>e</span><span> </span><span>f</span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [Some a, Some b, None, Some c, Some d, Some e, Some f, Some g]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed3_7 a b () c d e f g)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  
</span><span>    </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [Some a, Some b, Some c, None]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed4_3 a b c ())"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [Some a, Some b, Some c, None, Some d]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed4_4 a b c () d)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span>e</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [Some a, Some b, Some c, None, Some d, Some e]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed4_5 a b c () d e)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span>e</span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [Some a, Some b, Some c, None, Some d, Some e, Some f]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed4_6 a b c () d e f)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span>e</span><span> </span><span>f</span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [Some a, Some b, Some c, None, Some d, Some e, Some f, Some g]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed4_7 a b c () d e f g)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  
</span><span>    </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [Some a, Some b, Some c, Some d, None]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed5_4 a b c d ())"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span>e</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [Some a, Some b, Some c, Some d, None, Some e]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed5_5 a b c d () e)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span>e</span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [Some a, Some b, Some c, Some d, None, Some e, Some f]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed5_6 a b c d () e f)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span>e</span><span> </span><span>f</span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [Some a, Some b, Some c, Some d, None, Some e, Some f, Some g]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed5_7 a b c d () e f g)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  
</span><span>    </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span>e</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [Some a, Some b, Some c, Some d, Some e, None]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed6_5 a b c d e ())"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span>e</span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [Some a, Some b, Some c, Some d, Some e, None, Some f]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed6_6 a b c d e () f)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span>e</span><span> </span><span>f</span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [Some a, Some b, Some c, Some d, Some e, None, Some f, Some g]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed6_7 a b c d e () f g)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  
</span><span>    </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span>e</span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [Some a, Some b, Some c, Some d, Some e, Some f, None]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed7_6 a b c d e f ())"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span>e</span><span> </span><span>f</span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [Some a, Some b, Some c, Some d, Some e, Some f, None, Some g]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed7_7 a b c d e f () g)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>
</span><span>    </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span>e</span><span> </span><span>f</span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = [Some a, Some b, Some c, Some d, Some e, Some f, Some g, None]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6 = (IPv6AddrCompressed8_7 a b c d e f g ())"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>parse_ipv6_address_compressed_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.split_asm</span><span> </span><span>option.split_asm</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* takes a minute *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parse_ipv6_address_compressed_identity2</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed_to_list ipv6_syntax = ls ⟷
        (parse_ipv6_address_compressed ls) = Some ipv6_syntax"</span></span></span><span>
</span><span>      </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?rhs</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?lhs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>parse_ipv6_address_compressed_someE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?lhs</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?rhs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ipv6_syntax</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>parse_ipv6_address_compressed_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Valid IPv6 compressed notation:
  ▪ at most one omission
  ▪ at most 7 pieces
›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>RFC_4291_format</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"parse_ipv6_address_compressed as ≠ None ⟷
       length (filter (λp. p = None) as) = 1 ∧ length (filter (λp. p ≠ None) as) ≤ 7"</span></span></span><span>
</span><span>       </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?lhs</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>addr</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"parse_ipv6_address_compressed as = Some addr"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?rhs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>parse_ipv6_address_compressed_someE</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?rhs</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?lhs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>parse_ipv6_address_compressed_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span> </span><span>list.split</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text_raw</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
  \begin{verbatim}
  3. An alternative form that is sometimes more convenient when dealing
      with a mixed environment of IPv4 and IPv6 nodes is
      x:x:x:x:x:x:d.d.d.d, where the 'x's are the hexadecimal values of
      the six high-order 16-bit pieces of the address, and the 'd's are
      the decimal values of the four low-order 8-bit pieces of the
      address (standard IPv4 representation).  Examples:

         0:0:0:0:0:0:13.1.68.3
         0:0:0:0:0:FFFF:129.144.52.38

      or in compressed form:

         ::13.1.68.3
         ::FFFF:129.144.52.38
  \end{verbatim}

  This is currently not supported by our library!
›</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*TODO*)</span></span></span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*TODO: oh boy, they can also be compressed*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Semantics›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>ipv6preferred_to_int</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax ⇒ ipv6addr"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ipv6preferred_to_int (IPv6AddrPreferred a b c d e f g h) = (ucast a &lt;&lt; (16 * 7)) OR
                                                                (ucast b &lt;&lt; (16 * 6)) OR
                                                                (ucast c &lt;&lt; (16 * 5)) OR
                                                                (ucast d &lt;&lt; (16 * 4)) OR
                                                                (ucast e &lt;&lt; (16 * 3)) OR
                                                                (ucast f &lt;&lt; (16 * 2)) OR
                                                                (ucast g &lt;&lt; (16 * 1)) OR
                                                                (ucast h &lt;&lt; (16 * 0))"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6preferred_to_int (IPv6AddrPreferred 0x2001 0xDB8 0x0 0x0 0x8 0x800 0x200C 0x417A) = 
          42540766411282592856906245548098208122"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6preferred_to_int (IPv6AddrPreferred 0xFF01 0x0 0x0 0x0 0x0 0x0 0x0 0x101) = 
          338958331222012082418099330867817087233"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>ipv6preferred_to_int.simps</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>int_to_ipv6preferred</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr ⇒ ipv6addr_syntax"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"int_to_ipv6preferred i = IPv6AddrPreferred (ucast ((i AND 0xFFFF0000000000000000000000000000) &gt;&gt; 16*7))
                                                (ucast ((i AND 0xFFFF000000000000000000000000) &gt;&gt; 16*6))
                                                (ucast ((i AND 0xFFFF00000000000000000000) &gt;&gt; 16*5))
                                                (ucast ((i AND 0xFFFF0000000000000000) &gt;&gt; 16*4))
                                                (ucast ((i AND 0xFFFF000000000000) &gt;&gt; 16*3))
                                                (ucast ((i AND 0xFFFF00000000) &gt;&gt; 16*2))
                                                (ucast ((i AND 0xFFFF0000) &gt;&gt; 16*1))
                                                (ucast ((i AND 0xFFFF)))"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"int_to_ipv6preferred 42540766411282592856906245548098208122 =
         IPv6AddrPreferred 0x2001 0xDB8 0x0 0x0 0x8 0x800 0x200C 0x417A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word128_masks_ipv6pieces</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(0xFFFF0000000000000000000000000000::ipv6addr) = (mask 16) &lt;&lt; 112"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(0xFFFF000000000000000000000000::ipv6addr) = (mask 16) &lt;&lt; 96"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(0xFFFF00000000000000000000::ipv6addr) = (mask 16) &lt;&lt; 80"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(0xFFFF0000000000000000::ipv6addr) = (mask 16) &lt;&lt; 64"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(0xFFFF000000000000::ipv6addr) = (mask 16) &lt;&lt; 48"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(0xFFFF00000000::ipv6addr) = (mask 16) &lt;&lt; 32"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(0xFFFF0000::ipv6addr) = (mask 16) &lt;&lt; 16"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(0xFFFF::ipv6addr) = (mask 16)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mask_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness: round trip property one›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipv6preferred_to_int_int_to_ipv6preferred</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ipv6preferred_to_int (int_to_ipv6preferred ip) = ip"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>and_mask_shift_helper</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"w AND (mask m &lt;&lt; n) &gt;&gt; n &lt;&lt; n = w AND (mask m &lt;&lt; n)"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>m</span><span> </span><span>n</span><span class="delimiter">::</span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>w</span><span class="delimiter">::</span><span>ipv6addr</span><span>
</span><span>     </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*sledgehammered for 128 word and concrete values for m and n*)</span></span></span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀w wa wb. ((w::'a::len word) &amp;&amp; wa) &amp;&amp; wb = w &amp;&amp; wb &amp;&amp; wa"</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>word_bool_alg.conj_left_commute</span><span> </span><span>word_bw_comms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀w n wa. ((w::'a::len word) &amp;&amp; ~~ (mask n)) &amp;&amp; (wa &lt;&lt; n) = (w &gt;&gt; n) &amp;&amp; wa &lt;&lt; n"</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>and_not_mask</span><span> </span><span>shiftl_over_and_dist</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_aligned_mask</span><span> </span><span>is_aligned_shiftr_shiftl</span><span> </span><span>word_bool_alg.conj.assoc</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*using f1 by (metis (no_types) and_not_mask word_and_mask_shiftl word_bw_comms(1))*)</span></span></span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ucast_ipv6_piece_rule</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"length (dropWhile Not (to_bl w)) ≤ 16 ⟹ (ucast::16 word ⇒ 128 word) ((ucast::128 word ⇒ 16 word) w) = w"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>w</span><span class="delimiter">::</span><span>ipv6addr</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ucast_short_ucast_long_ingoreLeadingZero</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ucast_ipv6_piece</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 ≤ 128 - n ⟹ 
      (ucast::16 word ⇒ 128 word) ((ucast::128 word ⇒ 16 word) (w AND (mask 16 &lt;&lt; n) &gt;&gt; n)) &lt;&lt; n = w AND (mask 16 &lt;&lt; n)"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>w</span><span class="delimiter">::</span><span>ipv6addr</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">::</span><span>nat</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>ucast_ipv6_piece_rule</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>length_drop_mask_inner</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>and_mask_shift_helper</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ucast16_ucast128_masks_highest_bits</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(ucast ((ucast::ipv6addr ⇒ 16 word) (ip AND 0xFFFF0000000000000000000000000000 &gt;&gt; 112)) &lt;&lt; 112) = 
             (ip AND 0xFFFF0000000000000000000000000000)"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(ucast ((ucast::ipv6addr ⇒ 16 word) (ip AND 0xFFFF000000000000000000000000 &gt;&gt; 96)) &lt;&lt; 96) =
           ip AND 0xFFFF000000000000000000000000"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(ucast ((ucast::ipv6addr ⇒ 16 word) (ip AND 0xFFFF00000000000000000000 &gt;&gt; 80)) &lt;&lt; 80) =
           ip AND 0xFFFF00000000000000000000"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(ucast ((ucast::ipv6addr ⇒ 16 word) (ip AND 0xFFFF0000000000000000 &gt;&gt; 64)) &lt;&lt; 64) =
           ip AND 0xFFFF0000000000000000"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(ucast ((ucast::ipv6addr ⇒ 16 word) (ip AND 0xFFFF000000000000 &gt;&gt; 48)) &lt;&lt; 48) =
           ip AND 0xFFFF000000000000"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(ucast ((ucast::ipv6addr ⇒ 16 word) (ip AND 0xFFFF00000000 &gt;&gt; 32)) &lt;&lt; 32) =
           ip AND 0xFFFF00000000"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(ucast ((ucast::ipv6addr ⇒ 16 word) (ip AND 0xFFFF0000 &gt;&gt; 16)) &lt;&lt; 16) =
           ip AND 0xFFFF0000"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span class="delimiter">(</span><span>subst</span><span> </span><span>word128_masks_ipv6pieces</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>ucast_ipv6_piece</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ucast16_ucast128_masks_highest_bits0</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(ucast ((ucast::ipv6addr ⇒ 16 word) (ip AND 0xFFFF))) = ip AND 0xFFFF"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>word128_masks_ipv6pieces</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>ucast_short_ucast_long_ingoreLeadingZero</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>length_drop_mask</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>mask_len_word</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"n = (LENGTH('a)) ⟹ w AND mask n = w"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>w</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a::len word"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mask_eq_iff</span><span class="delimiter">)</span><span> 
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ipv6addr_16word_pieces_compose_or</span><span class="delimiter">:</span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"ip &amp;&amp; (mask 16 &lt;&lt; 112) ||
             ip &amp;&amp; (mask 16 &lt;&lt; 96) ||
             ip &amp;&amp; (mask 16 &lt;&lt; 80) ||
             ip &amp;&amp; (mask 16 &lt;&lt; 64) ||
             ip &amp;&amp; (mask 16 &lt;&lt; 48) ||
             ip &amp;&amp; (mask 16 &lt;&lt; 32) ||
             ip &amp;&amp; (mask 16 &lt;&lt; 16) ||
             ip &amp;&amp; mask 16 =
             ip"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>word_ao_dist2</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mask_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>mask128</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>mask_len_word</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv6preferred_to_int.simps</span><span> </span><span>int_to_ipv6preferred_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ucast16_ucast128_masks_highest_bits</span><span> </span><span>ucast16_ucast128_masks_highest_bits0</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>word128_masks_ipv6pieces</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ipv6addr_16word_pieces_compose_or</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness: round trip property two›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>int_to_ipv6preferred_ipv6preferred_to_int</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"int_to_ipv6preferred (ipv6preferred_to_int ip) = ip"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ucast_shift_simps</span><span class="delimiter">=</span><span>helper_masked_ucast_generic</span><span> </span><span>helper_masked_ucast_reverse_generic</span><span>
</span><span>                           </span><span>helper_masked_ucast_generic</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>n</span><span class="delimiter">=</span><span>0</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>                           </span><span>helper_masked_ucast_equal_generic</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ucast_simps</span><span class="delimiter">=</span><span>helper_masked_ucast_reverse_generic</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">=</span><span>0</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>                     </span><span>helper_masked_ucast_equal_generic</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>n</span><span class="delimiter">=</span><span>0</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>ip</span><span class="delimiter">,</span><span> </span><span>rename_tac</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span>e</span><span> </span><span>f</span><span> </span><span>g</span><span> </span><span>h</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv6preferred_to_int.simps</span><span> </span><span>int_to_ipv6preferred_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>word128_masks_ipv6pieces</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>word_ao_dist</span><span> </span><span>ucast_shift_simps</span><span> </span><span>ucast_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹compressed to preferred format›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>ipv6addr_c2p</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax_compressed ⇒ ipv6addr_syntax"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed1_0 ()) = IPv6AddrPreferred 0 0 0 0 0 0 0 0"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed1_1 () h) = IPv6AddrPreferred 0 0 0 0 0 0 0 h"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed1_2 () g h) = IPv6AddrPreferred 0 0 0 0 0 0 g h"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed1_3 () f g h) = IPv6AddrPreferred 0 0 0 0 0 f g h"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed1_4 () e f g h) = IPv6AddrPreferred 0 0 0 0 e f g h"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed1_5 () d e f g h) = IPv6AddrPreferred 0 0 0 d e f g h"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed1_6 () c d e f g h) = IPv6AddrPreferred 0 0 c d e f g h"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed1_7 () b c d e f g h) = IPv6AddrPreferred 0 b c d e f g h"</span></span></span><span>
</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed2_1 a ()) = IPv6AddrPreferred a 0 0 0 0 0 0 0"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed2_2 a () h) = IPv6AddrPreferred a 0 0 0 0 0 0 h"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed2_3 a () g h) = IPv6AddrPreferred a 0 0 0 0 0 g h"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed2_4 a () f g h) = IPv6AddrPreferred a 0 0 0 0 f g h"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed2_5 a () e f g h) = IPv6AddrPreferred a 0 0 0 e f g h"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed2_6 a () d e f g h) = IPv6AddrPreferred a 0 0 d e f g h"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed2_7 a () c d e f g h) = IPv6AddrPreferred a 0 c d e f g h"</span></span></span><span>
</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed3_2 a b ()) = IPv6AddrPreferred a b 0 0 0 0 0 0"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed3_3 a b () h) = IPv6AddrPreferred a b 0 0 0 0 0 h"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed3_4 a b () g h) = IPv6AddrPreferred a b 0 0 0 0 g h"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed3_5 a b () f g h) = IPv6AddrPreferred a b 0 0 0 f g h"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed3_6 a b () e f g h) = IPv6AddrPreferred a b 0 0 e f g h"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed3_7 a b () d e f g h) = IPv6AddrPreferred a b 0 d e f g h"</span></span></span><span>
</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed4_3 a b c ()) = IPv6AddrPreferred a b c 0 0 0 0 0"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed4_4 a b c () h) = IPv6AddrPreferred a b c 0 0 0 0 h"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed4_5 a b c () g h) = IPv6AddrPreferred a b c 0 0 0 g h"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed4_6 a b c () f g h) = IPv6AddrPreferred a b c 0 0 f g h"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed4_7 a b c () e f g h) = IPv6AddrPreferred a b c 0 e f g h"</span></span></span><span>
</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed5_4 a b c d ()) = IPv6AddrPreferred a b c d 0 0 0 0"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed5_5 a b c d () h) = IPv6AddrPreferred a b c d 0 0 0 h"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed5_6 a b c d () g h) = IPv6AddrPreferred a b c d 0 0 g h"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed5_7 a b c d () f g h) = IPv6AddrPreferred a b c d 0 f g h"</span></span></span><span>
</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed6_5 a b c d e ()) = IPv6AddrPreferred a b c d e 0 0 0"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed6_6 a b c d e () h) = IPv6AddrPreferred a b c d e 0 0 h"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed6_7 a b c d e () g h) = IPv6AddrPreferred a b c d e 0 g h"</span></span></span><span>
</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed7_6 a b c d e f ()) = IPv6AddrPreferred a b c d e f 0 0"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed7_7 a b c d e f () h) = IPv6AddrPreferred a b c d e f 0 h"</span></span></span><span>
</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_c2p (IPv6AddrCompressed8_7 a b c d e f g ()) = IPv6AddrPreferred a b c d e f g 0"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ipv6_unparsed_compressed_to_preferred</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"((16 word) option) list ⇒ ipv6addr_syntax option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ipv6_unparsed_compressed_to_preferred ls = (
    if
      length (filter (λp. p = None) ls) ≠ 1 ∨ length (filter (λp. p ≠ None) ls) &gt; 7
    then
      None
    else
      let
        before_omission = map the (takeWhile (λx. x ≠ None) ls);
        after_omission = map the (drop 1 (dropWhile (λx. x ≠ None) ls));
        num_omissions = 8 - (length before_omission + length after_omission);
        expanded = before_omission @ (replicate num_omissions 0) @ after_omission
      in
        case expanded of [a,b,c,d,e,f,g,h] ⇒ Some (IPv6AddrPreferred a b c d e f g h)
                         | _               ⇒ None
      )"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6_unparsed_compressed_to_preferred
    [Some 0x2001, Some 0xDB8, None, Some 0x8, Some 0x800, Some 0x200C, Some 0x417A]
      = Some (IPv6AddrPreferred 0x2001 0xDB8 0 0 8 0x800 0x200C 0x417A)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6_unparsed_compressed_to_preferred [None] = Some (IPv6AddrPreferred 0 0 0 0 0 0 0 0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6_unparsed_compressed_to_preferred [] = None"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipv6_unparsed_compressed_to_preferred_identity1</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"ipv6_unparsed_compressed_to_preferred (ipv6addr_syntax_compressed_to_list ipv6compressed) = Some ipv6prferred
    ⟷ ipv6addr_c2p ipv6compressed = ipv6prferred"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>ipv6compressed</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv6_unparsed_compressed_to_preferred_def</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*1s*)</span></span></span></span></span><span>
</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipv6_unparsed_compressed_to_preferred_identity2</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ipv6_unparsed_compressed_to_preferred ls = Some ipv6prferred
     ⟷ (∃ipv6compressed. parse_ipv6_address_compressed ls = Some ipv6compressed ∧
                           ipv6addr_c2p ipv6compressed = ipv6prferred)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"parse_ipv6_address_compressed ls ≠ None"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>RFC_4291_format</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv6_unparsed_compressed_to_preferred_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>exE</span><span class="delimiter">,</span><span> </span><span>rename_tac</span><span> </span><span>ipv6compressed</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"ipv6compressed"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ipv6addr_syntax_compressed_to_list ipv6compressed = ls)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>parse_ipv6_address_compressed_identity2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>presburger</span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ipv6_unparsed_compressed_to_preferred_identity1</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>exE</span><span class="delimiter">,</span><span> </span><span>rename_tac</span><span> </span><span>ipv6compressed</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ipv6addr_syntax_compressed_to_list ipv6compressed = ls)"</span></span></span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>parse_ipv6_address_compressed_identity2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ipv6_unparsed_compressed_to_preferred_identity1</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹IPv6 Pretty Printing (converting to compressed format)›</span></span></span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
RFC5952:
\begin{verbatim}
4.  A Recommendation for IPv6 Text Representation

   A recommendation for a canonical text representation format of IPv6
   addresses is presented in this section.  The recommendation in this
   document is one that complies fully with [RFC4291], is implemented by
   various operating systems, and is human friendly.  The recommendation
   in this section SHOULD be followed by systems when generating an
   address to be represented as text, but all implementations MUST
   accept and be able to handle any legitimate [RFC4291] format.  It is
   advised that humans also follow these recommendations when spelling
   an address.

4.1.  Handling Leading Zeros in a 16-Bit Field

   Leading zeros MUST be suppressed.  For example, 2001:0db8::0001 is
   not acceptable and must be represented as 2001:db8::1.  A single 16-
   bit 0000 field MUST be represented as 0.

4.2.  "::" Usage

4.2.1.  Shorten as Much as Possible

   The use of the symbol "::" MUST be used to its maximum capability.
   For example, 2001:db8:0:0:0:0:2:1 must be shortened to 2001:db8::2:1.
   Likewise, 2001:db8::0:1 is not acceptable, because the symbol "::"
   could have been used to produce a shorter representation 2001:db8::1.

4.2.2.  Handling One 16-Bit 0 Field

   The symbol "::" MUST NOT be used to shorten just one 16-bit 0 field.
   For example, the representation 2001:db8:0:1:1:1:1:1 is correct, but
   2001:db8::1:1:1:1:1 is not correct.

4.2.3.  Choice in Placement of "::"

   When there is an alternative choice in the placement of a "::", the
   longest run of consecutive 16-bit 0 fields MUST be shortened (i.e.,
   the sequence with three consecutive zero fields is shortened in 2001:
   0:0:1:0:0:0:1).  When the length of the consecutive 16-bit 0 fields
   are equal (i.e., 2001:db8:0:0:1:0:0:1), the first sequence of zero
   bits MUST be shortened.  For example, 2001:db8::1:0:0:1 is correct
   representation.

4.3.  Lowercase

   The characters "a", "b", "c", "d", "e", and "f" in an IPv6 address
   MUST be represented in lowercase.
\end{verbatim}
›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹See @{file ‹IP_Address_toString.thy›} for examples and test cases.›</span></span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">function</span></span><span> </span><span>goup_by_zeros</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word list ⇒ 16 word list list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"goup_by_zeros [] = []"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"goup_by_zeros (x#xs) = (
        if x = 0
        then takeWhile (λx. x = 0) (x#xs) # (goup_by_zeros (dropWhile (λx. x = 0) xs))
        else [x]#(goup_by_zeros xs))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>pat_completeness</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">termination</span></span><span> </span><span>goup_by_zeros</span><span>
</span><span>	 </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>relation</span><span> </span><span class="string"><span class="delete"><span class="delete">"measure (λxs. length xs)"</span></span></span><span class="delimiter">)</span><span>
</span><span>	   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>	 </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>le_imp_less_Suc</span><span> </span><span>length_dropWhile_le</span><span class="delimiter">)</span><span>
</span><span>	
</span><span>	</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"goup_by_zeros [0,1,2,3,0,0,0,0,3,4,0,0,0,2,0,0,2,0,3,0] =
	        [[0], [1], [2], [3], [0, 0, 0, 0], [3], [4], [0, 0, 0], [2], [0, 0], [2], [0], [3], [0]]"</span></span></span><span>
</span><span>	</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>	
</span><span>	</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"concat (goup_by_zeros ls) = ls"</span></span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>ls</span><span> </span><span>rule</span><span class="delimiter">:</span><span>goup_by_zeros.induct</span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>	
</span><span>	</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[] ∉ set (goup_by_zeros ls)"</span></span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>ls</span><span> </span><span>rule</span><span class="delimiter">:</span><span>goup_by_zeros.induct</span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>	  
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>List_replace1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a list ⇒ 'a list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"List_replace1 _ _ [] = []"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"List_replace1 a b (x#xs) = (if a = x then b#xs else x#List_replace1 a b xs)"</span></span></span><span>
</span><span>    
</span><span>	</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"List_replace1 a a ls = ls"</span></span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>ls</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>	
</span><span>	</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∉ set ls ⟹ List_replace1 a b ls = ls"</span></span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>ls</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>	
</span><span>	</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ set ls ⟹ b ∈ set (List_replace1 a b ls)"</span></span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>ls</span><span class="delimiter">)</span><span>
</span><span>	   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>	  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>	  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  
</span><span>	</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>List_explode</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list list ⇒ ('a option) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>	  </span><span class="string"><span class="delete"><span class="delete">"List_explode [] = []"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>	  </span><span class="string"><span class="delete"><span class="delete">"List_explode ([]#xs) = None#List_explode xs"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>	  </span><span class="string"><span class="delete"><span class="delete">"List_explode (xs1#xs2) = map Some xs1@List_explode xs2"</span></span></span><span>
</span><span>	  
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"List_explode [[0::int], [2,3], [], [3,4]] = [Some 0, Some 2, Some 3, None, Some 3, Some 4]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>List_explode_def</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"List_explode xss = concat (map (λxs. if xs = [] then [None] else map Some xs) xss)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>xss</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>List_explode.induct</span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>	  
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>List_explode_no_empty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[] ∉ set xss ⟹ List_explode xss = map Some (concat xss)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>xss</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>List_explode.induct</span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>List_explode_replace1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[] ∉ set xss ⟹ foo ∈ set xss ⟹
          List_explode (List_replace1 foo [] xss) =
            map Some (concat (takeWhile (λxs. xs ≠ foo) xss)) @ [None] @
              map Some (concat (tl (dropWhile (λxs. xs ≠ foo) xss)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>xss</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>List_explode.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>List_explode_no_empty</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>ipv6_preferred_to_compressed</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_syntax ⇒ ((16 word) option) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ipv6_preferred_to_compressed (IPv6AddrPreferred a b c d e f g h) = (
    let lss = goup_by_zeros [a,b,c,d,e,f,g,h];
        max_zero_seq = foldr (λxs. max (length xs)) lss 0;
        shortened = if max_zero_seq &gt; 1 then List_replace1 (replicate max_zero_seq 0) [] lss else lss
    in
      List_explode shortened
    )"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>ipv6_preferred_to_compressed.simps</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>foldr_max_length</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"foldr (λxs. max (length xs)) lss n = fold max (map length lss) n"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>List.foldr_fold</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>lss</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>List_explode_goup_by_zeros</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"List_explode (goup_by_zeros xs) = map Some xs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>goup_by_zeros.induct</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>safe</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>map_append</span><span> </span><span>takeWhile_dropWhile_id</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"max_zero_streak xs ≡ foldr (λxs. max (length xs)) (goup_by_zeros xs) 0"</span></span></span><span>    
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>max_zero_streak_def2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"max_zero_streak xs = fold max (map length (goup_by_zeros xs)) 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>max_zero_streak_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>foldr_max_length</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipv6_preferred_to_compressed_pull_out_if</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ipv6_preferred_to_compressed (IPv6AddrPreferred a b c d e f g h) = (
    if max_zero_streak [a,b,c,d,e,f,g,h] &gt; 1 then
      List_explode (List_replace1 (replicate (max_zero_streak [a,b,c,d,e,f,g,h]) 0) [] (goup_by_zeros [a,b,c,d,e,f,g,h]))
    else
      map Some [a,b,c,d,e,f,g,h]
    )"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv6_preferred_to_compressed.simps</span><span> </span><span>max_zero_streak_def</span><span> </span><span>List_explode_goup_by_zeros</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6_preferred_to_compressed (IPv6AddrPreferred 0 0 0 0 0 0 0 0) = [None]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6_preferred_to_compressed (IPv6AddrPreferred 0x2001 0xDB8 0 0 8 0x800 0x200C 0x417A) =
                [Some 0x2001, Some 0xDB8, None,           Some 8, Some 0x800, Some 0x200C, Some 0x417A]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6_preferred_to_compressed (IPv6AddrPreferred 0x2001 0xDB8 0 3 8 0x800 0x200C 0x417A) =
                [Some 0x2001, Some 0xDB8, Some 0, Some 3, Some 8, Some 0x800, Some 0x200C, Some 0x417A]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*the output should even conform to RFC5952, ...*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipv6_preferred_to_compressed_RFC_4291_format</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ipv6_preferred_to_compressed ip = as ⟹ 
          length (filter (λp. p = None) as) = 0 ∧ length as = 8
          ∨
          length (filter (λp. p = None) as) = 1 ∧ length (filter (λp. p ≠ None) as) ≤ 7"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>ip</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv6_preferred_to_compressed_pull_out_if</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span>e</span><span> </span><span>f</span><span> </span><span>g</span><span> </span><span>h</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjI2</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"a=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"b=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"c=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"d=0"</span></span></span><span class="delimiter">,</span><span>
</span><span>         </span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"e=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"f=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"g=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"h=0"</span></span></span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>max_zero_streak_def</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*1min*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjI1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="comment">― ‹Idea for the following proof:›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6_preferred_to_compressed (IPv6AddrPreferred a b c d e f g h) = None#xs ⟹
      xs = map Some (dropWhile (λx. x=0) [a,b,c,d,e,f,g,h])"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"a=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"b=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"c=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"d=0"</span></span></span><span class="delimiter">,</span><span>
</span><span>          </span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"e=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"f=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"g=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"h=0"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv6_preferred_to_compressed_pull_out_if</span><span> </span><span>max_zero_streak_def</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*20s*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipv6_preferred_to_compressed</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6_unparsed_compressed_to_preferred (ipv6_preferred_to_compressed ip) = Some ip'"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ip = ip'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ipv6compressed.
         parse_ipv6_address_compressed (ipv6_preferred_to_compressed ip) = Some ipv6compressed ∧
         ipv6addr_c2p ipv6compressed = ip'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ipv6_unparsed_compressed_to_preferred_identity2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span>e</span><span> </span><span>f</span><span> </span><span>g</span><span> </span><span>h</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ip = IPv6AddrPreferred a b c d e f g h"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>ip</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ipv6_preferred_to_compressed_None1</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"ipv6_preferred_to_compressed (IPv6AddrPreferred a b c d e f g h) = None#xs ⟹
        (map Some (dropWhile (λx. x=0) [a,b,c,d,e,f,g,h]) = xs ⟹ (IPv6AddrPreferred a b c d e f g h) = ip') ⟹
        (IPv6AddrPreferred a b c d e f g h) = ip'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>xs</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"a=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"b=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"c=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"d=0"</span></span></span><span class="delimiter">,</span><span>
</span><span>            </span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"e=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"f=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"g=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"h=0"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv6_preferred_to_compressed_pull_out_if</span><span> </span><span>max_zero_streak_def</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*5s*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ipv6_preferred_to_compressed_None2</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"ipv6_preferred_to_compressed (IPv6AddrPreferred a b c d e f g h) = (Some a')#None#xs ⟹
        (map Some (dropWhile (λx. x=0) [b,c,d,e,f,g,h]) = xs ⟹ (IPv6AddrPreferred a' b c d e f g h) = ip') ⟹
        (IPv6AddrPreferred a b c d e f g h) = ip'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>xs</span><span> </span><span>a'</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"a=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"b=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"c=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"d=0"</span></span></span><span class="delimiter">,</span><span>
</span><span>            </span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"e=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"f=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"g=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"h=0"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv6_preferred_to_compressed_pull_out_if</span><span> </span><span>max_zero_streak_def</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*5s*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ipv6_preferred_to_compressed_None3</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"ipv6_preferred_to_compressed (IPv6AddrPreferred a b c d e f g h) = (Some a')#(Some b')#None#xs ⟹
        (map Some (dropWhile (λx. x=0) [c,d,e,f,g,h]) = xs ⟹ (IPv6AddrPreferred a' b' c d e f g h) = ip') ⟹
        (IPv6AddrPreferred a b c d e f g h) = ip'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>xs</span><span> </span><span>a'</span><span> </span><span>b'</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"a=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"b=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"c=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"d=0"</span></span></span><span class="delimiter">,</span><span>
</span><span>            </span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"e=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"f=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"g=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"h=0"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv6_preferred_to_compressed_pull_out_if</span><span> </span><span>max_zero_streak_def</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*5s*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ipv6_preferred_to_compressed_None4</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"ipv6_preferred_to_compressed (IPv6AddrPreferred a b c d e f g h) = (Some a')#(Some b')#(Some c')#None#xs ⟹
        (map Some (dropWhile (λx. x=0) [d,e,f,g,h]) = xs ⟹ (IPv6AddrPreferred a' b' c' d e f g h) = ip') ⟹
        (IPv6AddrPreferred a b c d e f g h) = ip'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>xs</span><span> </span><span>a'</span><span> </span><span>b'</span><span> </span><span>c'</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"a=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"b=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"c=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"d=0"</span></span></span><span class="delimiter">,</span><span>
</span><span>            </span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"e=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"f=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"g=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"h=0"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv6_preferred_to_compressed_pull_out_if</span><span> </span><span>max_zero_streak_def</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*5s*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ipv6_preferred_to_compressed_None5</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"ipv6_preferred_to_compressed (IPv6AddrPreferred a b c d e f g h) = (Some a')#(Some b')#(Some c')#(Some d')#None#xs ⟹
        (map Some (dropWhile (λx. x=0) [e,f,g,h]) = xs ⟹ (IPv6AddrPreferred a' b' c' d' e f g h) = ip') ⟹
        (IPv6AddrPreferred a b c d e f g h) = ip'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>xs</span><span> </span><span>a'</span><span> </span><span>b'</span><span> </span><span>c'</span><span> </span><span>d'</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"a=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"b=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"c=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"d=0"</span></span></span><span class="delimiter">,</span><span>
</span><span>            </span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"e=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"f=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"g=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"h=0"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv6_preferred_to_compressed_pull_out_if</span><span> </span><span>max_zero_streak_def</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*5s*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ipv6_preferred_to_compressed_None6</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"ipv6_preferred_to_compressed (IPv6AddrPreferred a b c d e f g h) = (Some a')#(Some b')#(Some c')#(Some d')#(Some e')#None#xs ⟹
        (map Some (dropWhile (λx. x=0) [f,g,h]) = xs ⟹ (IPv6AddrPreferred a' b' c' d' e' f g h) = ip') ⟹
        (IPv6AddrPreferred a b c d e f g h) = ip'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>xs</span><span> </span><span>a'</span><span> </span><span>b'</span><span> </span><span>c'</span><span> </span><span>d'</span><span> </span><span>e'</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"a=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"b=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"c=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"d=0"</span></span></span><span class="delimiter">,</span><span>
</span><span>            </span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"e=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"f=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"g=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"h=0"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv6_preferred_to_compressed_pull_out_if</span><span> </span><span>max_zero_streak_def</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*5s*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ipv6_preferred_to_compressed_None7</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"ipv6_preferred_to_compressed (IPv6AddrPreferred a b c d e f g h) = (Some a')#(Some b')#(Some c')#(Some d')#(Some e')#(Some f')#None#xs ⟹
        (map Some (dropWhile (λx. x=0) [g,h]) = xs ⟹ (IPv6AddrPreferred a' b' c' d' e' f' g h) = ip') ⟹
        (IPv6AddrPreferred a b c d e f g h) = ip'"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>xs</span><span> </span><span>a'</span><span> </span><span>b'</span><span> </span><span>c'</span><span> </span><span>d'</span><span> </span><span>e'</span><span> </span><span>f'</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"a=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"b=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"c=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"d=0"</span></span></span><span class="delimiter">,</span><span>
</span><span>            </span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"e=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"f=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"g=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"h=0"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv6_preferred_to_compressed_pull_out_if</span><span> </span><span>max_zero_streak_def</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*5s*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ipv6_preferred_to_compressed_None8</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"ipv6_preferred_to_compressed (IPv6AddrPreferred a b c d e f g h) = (Some a')#(Some b')#(Some c')#(Some d')#(Some e')#(Some f')#(Some g')#None#xs ⟹
        (map Some (dropWhile (λx. x=0) [h]) = xs ⟹ (IPv6AddrPreferred a' b' c' d' e' f' g' h) = ip') ⟹
        (IPv6AddrPreferred a b c d e f g h) = ip'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>xs</span><span> </span><span>a'</span><span> </span><span>b'</span><span> </span><span>c'</span><span> </span><span>d'</span><span> </span><span>e'</span><span> </span><span>f'</span><span> </span><span>g'</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"a=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"b=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"c=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"d=0"</span></span></span><span class="delimiter">,</span><span>
</span><span>            </span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"e=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"f=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"g=0"</span></span></span><span class="delimiter">,</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"h=0"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipv6_preferred_to_compressed_pull_out_if</span><span> </span><span>max_zero_streak_def</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*5s*)</span></span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"parse_ipv6_address_compressed (ipv6_preferred_to_compressed (IPv6AddrPreferred a b c d e f g h))
                = Some ipv6compressed ⟹
       ipv6addr_c2p ipv6compressed = ip' ⟹
       IPv6AddrPreferred a b c d e f g h = ip'"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ipv6compressed</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>parse_ipv6_address_compressed_someE</span><span class="delimiter">)</span><span>
</span><span>                                         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>                                         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>ipv6_preferred_to_compressed_None1</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>                                 </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>ipv6_preferred_to_compressed_None2</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>                         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>ipv6_preferred_to_compressed_None3</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>                    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>ipv6_preferred_to_compressed_None4</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>               </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>ipv6_preferred_to_compressed_None5</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>ipv6_preferred_to_compressed_None6</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>ipv6_preferred_to_compressed_None7</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>ipv6_preferred_to_compressed_None8</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>ip</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>elim</span><span> </span><span>exE</span><span> </span><span>conjE</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Prefix_Match">
<div class="head"><h1>Theory Prefix_Match</h1>
<span class="command">theory</span> <span class="name">Prefix_Match</span><br/>
<span class="keyword">imports</span> <a href="IP_Address.html"><span class="name">IP_Address</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      Prefix_Match.thy
    Authors:    Julius Michaelis, Cornelius Diekmann
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Prefix_Match</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>IP_Address</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Prefix Match›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
  The main difference between the prefix match defined here and CIDR notation is a validity
  constraint imposed on prefix matches.

  For example, 192.168.42.42/16 is valid CIDR notation whereas for a prefix match,
  it must be 192.168.0.0/16.

  I.e. the last bits of the prefix must be set to zero.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>typedef_overloaded</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">'a</span><span> </span><span>prefix_match</span><span> </span><span class="delimiter">=</span><span> </span><span>PrefixMatch</span><span> </span><span class="delimiter">(</span><span>pfxm_prefix</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::len word"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>pfxm_length</span><span class="delimiter">:</span><span> </span><span>nat</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>pfxm_mask</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a prefix_match ⇒ 'a::len word"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pfxm_mask x ≡ mask (len_of (TYPE('a)) - pfxm_length x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>valid_prefix</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::len) prefix_match ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"valid_prefix pf = ((pfxm_mask pf) AND pfxm_prefix pf = 0)"</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Note that @{const valid_prefix} looks very elegant as a definition. However, it hides something nasty:›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_prefix (PrefixMatch (0::32 word) 42)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹When zeroing all least significant bits which exceed the @{const pfxm_length},
     you get a @{const valid_prefix}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mk_valid_prefix</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>base</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a::len word"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_prefix (PrefixMatch (base AND NOT (mask (len_of TYPE ('a) - len))) len)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mask (len - m) AND base AND NOT (mask (len - m)) = 0"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>m</span><span> </span><span>len</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>base</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a::len word"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>word_bw_lcs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valid_prefix_def</span><span> </span><span>pfxm_mask_def</span><span> </span><span>pfxm_length_def</span><span> </span><span>pfxm_prefix_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The type @{typ "'a prefix_match"} usually requires @{const valid_prefix}.
      When we allow working on arbitrary IPs in CIDR notation,
      we will use the type @{typ "('i::len word × nat)"} directly.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_prefix_00</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_prefix (PrefixMatch 0 0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valid_prefix_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>prefix_match_to_CIDR</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('i::len) prefix_match ⇒ ('i word × nat)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prefix_match_to_CIDR pfx ≡ (pfxm_prefix pfx, pfxm_length pfx)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prefix_match_to_CIDR_def2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prefix_match_to_CIDR = (λpfx. (pfxm_prefix pfx, pfxm_length pfx))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>prefix_match_to_CIDR_def</span><span> </span><span>fun_eq_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefix_match_dtor m ≡ (case m of PrefixMatch p l ⇒ (p,l))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Some more or less random linear order on prefixes.
     Only used for serialization at the time of this writing.›</span></span></span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>prefix_match</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>len</span><span class="delimiter">)</span><span> </span><span>linorder</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>	</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≤ b ⟷ (if pfxm_length a = pfxm_length b
                         then pfxm_prefix a ≤ pfxm_prefix b
                         else pfxm_length a &gt; pfxm_length b)"</span></span></span><span>
</span><span>	</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a &lt; b ⟷ (a ≠ b ∧
	                       (if pfxm_length a = pfxm_length b
	                        then pfxm_prefix a ≤ pfxm_prefix b
	                        else pfxm_length a &gt; pfxm_length b))"</span></span></span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>less_eq_prefix_match_def</span><span> </span><span>less_prefix_match_def</span><span> </span><span>prefix_match.expand</span><span>
</span><span>                  </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sorted_list_of_set
 {PrefixMatch 0 32 :: 32 prefix_match,
  PrefixMatch 42 32,
  PrefixMatch 0 0,
  PrefixMatch 0 1,
  PrefixMatch 12 31} =
    [PrefixMatch 0 32, PrefixMatch 0x2A 32, PrefixMatch 0xC 31, PrefixMatch 0 1, PrefixMatch 0 0]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_prefix_E</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_prefix pf ⟹ ((pfxm_mask pf) AND pfxm_prefix pf = 0)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_prefix_def</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_prefix_alt</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>p</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a::len prefix_match"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_prefix p = (pfxm_prefix p AND (2 ^ ((len_of TYPE ('a)) - pfxm_length p) - 1) = 0)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_prefix_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mask_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>word_bw_comms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>   </span><span>arg_cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"λx. (pfxm_prefix p AND x - 1 = 0)"</span></span></span><span class="delimiter">]</span><span>
</span><span>   </span><span>shiftl_1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pfxm_prefix_def</span><span> </span><span>pfxm_mask_def</span><span> </span><span>mask_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Address Semantics›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Matching on a @{typ "'a::len prefix_match"}. Think of routing tables.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>prefix_match_semantics</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"prefix_match_semantics m a ≡ pfxm_prefix m = NOT (pfxm_mask m) AND a"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>same_length_prefixes_distinct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_prefix pfx1 ⟹ valid_prefix pfx2 ⟹ pfx1 ≠ pfx2 ⟹ pfxm_length pfx1 = pfxm_length pfx2 ⟹ prefix_match_semantics pfx1 w ⟹ prefix_match_semantics pfx2 w ⟹ False"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pfxm_mask_def</span><span> </span><span>prefix_match.expand</span><span> </span><span>prefix_match_semantics_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Relation between prefix and set›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>prefix_to_wordset</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::len prefix_match ⇒ 'a word set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"prefix_to_wordset pfx = {pfxm_prefix pfx .. pfxm_prefix pfx OR pfxm_mask pfx}"</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pfx_not_empty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_prefix pfx ⟹ prefix_to_wordset pfx ≠ {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_prefix_def</span><span> </span><span>prefix_to_wordset_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>le_word_or2</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zero_prefix_match_all</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"valid_prefix m ⟹ pfxm_length m = 0 ⟹ prefix_match_semantics m ip"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pfxm_mask_def</span><span> </span><span>mask_2pm1</span><span> </span><span>valid_prefix_alt</span><span> </span><span>prefix_match_semantics_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prefix_to_wordset_subset_ipset_from_cidr</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"prefix_to_wordset pfx ⊆ ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>prefix_to_wordset_def</span><span> </span><span>addr_in_ipset_from_cidr_code</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>impI</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>erased</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>order_trans</span><span> </span><span>word_and_le2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pfxm_mask_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Equivalence Proofs›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>prefix_match_semantics_wordset</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_prefix pfx"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefix_match_semantics pfx a ⟷ a ∈ prefix_to_wordset pfx"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_prefix_def</span><span> </span><span>pfxm_mask_def</span><span> </span><span>prefix_match_semantics_def</span><span> </span><span>prefix_to_wordset_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>pfx</span><span class="delimiter">,</span><span> </span><span>rename_tac</span><span> </span><span>base</span><span> </span><span>len</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>base</span><span class="delimiter">=</span><span>base</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>len</span><span class="delimiter">=</span><span>len</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a</span><span class="delimiter">=</span><span>a</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>zero_base_lsb_imp_set_eq_as_bit_operation</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_prefix_ipset_from_netmask_ipset_from_cidr</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipset_from_netmask (pfxm_prefix pfx) (NOT (pfxm_mask pfx)) =
            ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>pfx</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipset_from_cidr_alt2</span><span> </span><span>pfxm_mask_def</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prefix_match_semantics_ipset_from_netmask</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_prefix pfx"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefix_match_semantics pfx a ⟷
            a ∈ ipset_from_netmask (pfxm_prefix pfx) (NOT (pfxm_mask pfx))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>prefix_match_semantics_wordset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>valid_prefix_ipset_from_netmask_ipset_from_cidr</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>prefix_to_wordset_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>ipset_from_cidr_base_wellforemd</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valid_prefix_def</span><span> </span><span>pfxm_mask_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pfxm_mask_def</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prefix_match_semantics_ipset_from_netmask2</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_prefix pfx"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefix_match_semantics pfx (a :: 'i::len word) ⟷
            a ∈ ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx)"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>prefix_match_semantics_ipset_from_netmask</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>pfxm_mask_def</span><span> </span><span>ipset_from_cidr_def</span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>NOT_mask_shifted_lenword</span><span> </span><span>word_not_not</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prefix_to_wordset_ipset_from_cidr</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_prefix (pfx::'a::len prefix_match)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefix_to_wordset pfx = ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>helper3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x::'a::len word) OR y = x OR y AND NOT x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>word_oa_dist2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>prefix_match_semantics_ipset_from_netmask</span><span class="delimiter">:</span><span>
</span><span>           </span><span class="string"><span class="delete"><span class="delete">"(prefix_to_wordset pfx) = ipset_from_netmask (pfxm_prefix pfx) (NOT (pfxm_mask pfx))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>prefix_to_wordset_def</span><span> </span><span>ipset_from_netmask_def</span><span> </span><span>Let_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>word_bool_alg.double_compl</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pfxm_prefix pfx AND NOT (pfxm_mask pfx) = pfxm_prefix pfx"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mask_eq_0_eq_x</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid_prefix_E</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>word_bw_comms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"pfxm_prefix pfx"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>**</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pfxm_prefix pfx AND NOT (pfxm_mask pfx) OR pfxm_mask pfx =
                    pfxm_prefix pfx OR pfxm_mask pfx"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>*</span><span> </span><span>**</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((mask len)::'a::len word) &lt;&lt; LENGTH('a) - len = ~~ (mask (LENGTH('a) - len))"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>len</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NOT_mask_shifted_lenword</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>word_not_not</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(pfxm_length pfx)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>mask_def2_symmetric</span><span class="delimiter">:</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"((mask (pfxm_length pfx)::'a::len word) &lt;&lt; LENGTH('a) - pfxm_length pfx) =
          NOT (pfxm_mask pfx)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pfxm_mask_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ipset_from_netmask_prefix</span><span class="delimiter">:</span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"ipset_from_netmask (pfxm_prefix pfx) (NOT (pfxm_mask pfx)) =
          ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx)"</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ipset_from_netmask_def</span><span> </span><span>ipset_from_cidr_alt</span><span>
</span><span>       </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pfxm_mask_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>       </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mask_def2_symmetric</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Let_def</span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>valid_prefix_def</span><span class="delimiter">]</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>helper3</span><span> </span><span>word_bw_comms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ipset_from_netmask_prefix</span><span> </span><span>local.prefix_match_semantics_ipset_from_netmask</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>prefix_to_wordinterval</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::len prefix_match ⇒ 'a wordinterval"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"prefix_to_wordinterval pfx ≡ WordInterval (pfxm_prefix pfx) (pfxm_prefix pfx OR pfxm_mask pfx)"</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prefix_to_wordinterval_set_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set (prefix_to_wordinterval pfx) = prefix_to_wordset pfx"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>prefix_to_wordinterval_def</span><span> </span><span>prefix_to_wordset_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prefix_to_wordinterval_def2</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"prefix_to_wordinterval pfx =
      iprange_interval ((pfxm_prefix pfx), (pfxm_prefix pfx OR pfxm_mask pfx))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>iprange_interval.simps</span><span> </span><span>prefix_to_wordinterval_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>prefix_to_wordinterval_ipset_from_cidr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_prefix pfx ⟹
    wordinterval_to_set (prefix_to_wordinterval pfx) =
      ipset_from_cidr (pfxm_prefix pfx) (pfxm_length pfx)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prefix_to_wordset_ipset_from_cidr</span><span> </span><span>prefix_to_wordinterval_set_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prefix_never_empty</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>d</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::len prefix_match"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span class="string"><span class="delete"><span class="delete">"¬ wordinterval_empty (prefix_to_wordinterval d)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>le_word_or2</span><span> </span><span>prefix_to_wordinterval_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Getting a lowest element›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipset_from_cidr_lowest</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ ipset_from_cidr a n"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ip_cidr_set_def</span><span> </span><span>ipset_from_cidr_eq_ip_cidr_set</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*this is why I call the previous lemma 'lowest'*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_prefix (PrefixMatch a n) ⟹ is_lowest_element a (ipset_from_cidr a n)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_lowest_element_def</span><span> </span><span>ipset_from_cidr_lowest</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ipset_from_cidr_eq_ip_cidr_set</span><span> </span><span>ip_cidr_set_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valid_prefix_def</span><span> </span><span>pfxm_mask_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>diff_zero</span><span> </span><span>eq_iff</span><span> </span><span>mask_out_sub_mask</span><span> </span><span>word_and_le2</span><span> </span><span>word_bw_comms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="CIDR_Split">
<div class="head"><h1>Theory CIDR_Split</h1>
<span class="command">theory</span> <span class="name">CIDR_Split</span><br/>
<span class="keyword">imports</span> <a href="Prefix_Match.html"><span class="name">Prefix_Match</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      CIDR_Split.thy
    Authors:    Julius Michaelis, Cornelius Diekmann
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>CIDR_Split</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>IP_Address</span><span>
</span><span>        </span><span>Prefix_Match</span><span>
</span><span>        </span><span>Hs_Compat</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹CIDR Split Motivation (Example for IPv4)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹When talking about ranges of IP addresses, we can make the ranges explicit by listing their elements.›</span></span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map (of_nat ∘ nat) [1 .. 4] = ([1, 2, 3, 4]:: 32 word list)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ipv4addr_upto</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"32 word ⇒ 32 word ⇒ 32 word list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ipv4addr_upto i j ≡ map (of_nat ∘ nat) [int (unat i) .. int (unat j)]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ipv4addr_upto</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (ipv4addr_upto i j) = {i .. j}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>int_interval_eq_image</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{int m..int n} = int ` {m..n}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>m</span><span> </span><span>n</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>image_eqI</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>int</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat k"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>helpX</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"⋀f (i::nat) (j::nat). (f ∘ nat) ` {int i..int j} = f ` {i .. j}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>image_comp</span><span> </span><span>int_interval_eq_image</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>   </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>xa</span><span> </span><span class="delimiter">::</span><span> </span><span>int</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"int (unat i) ≤ xa ∧ xa ≤ int (unat j)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"int (nat xa) = xa"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"unat (of_int xa::32 word) = nat xa"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>le_unat_uoi</span><span> </span><span>nat_int</span><span> </span><span>nat_mono</span><span> </span><span>of_int_of_nat_eq</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ≤ of_int xa"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"of_int xa ≤ j"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>uint_nat</span><span> </span><span>word_le_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>hlp</span><span class="delimiter">=</span><span>this</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ipv4addr_upto_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>set_eqI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>safe</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hlp</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hlp</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>atLeastAtMost_iff</span><span> </span><span>imageI</span><span> </span><span>image_int_atLeastAtMost</span><span> </span><span>of_int_of_nat_eq</span><span> </span><span>word_le_nat_alt</span><span> </span><span>word_unat.Rep_inverse</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The function @{const ipv4addr_upto} gives back a list of all the ips in the list.
        This list can be pretty huge! In the following, we will use CIDR notation (e.g. 192.168.0.0/24)
        to describe the list more compactly.›</span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹CIDR Split›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>find_SomeD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"find f x = Some y ⟹ f y ∧ y ∈ set x"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>x</span><span class="delimiter">;</span><span> </span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*pfxes needs a dummy parameter. The first parameter is a dummy that we have the 'a::len0 type and
  can refer to its length.*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>pfxes</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::len0 itself ⇒ nat list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pfxes _ = map nat [0..int(len_of TYPE ('a))]"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pfxes TYPE(32) = map nat [0 .. 32]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"largest_contained_prefix (a::('a :: len) word) r = (
  let cs = (map (λs. PrefixMatch a s) (pfxes TYPE('a)));
      ― ‹anything that is a subset should also be a valid prefix. but try proving that.›
      cfs = find (λs. valid_prefix s ∧ wordinterval_subset (prefix_to_wordinterval s) r) cs in
  cfs)
"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* The joke is that it is always Some, given that a ∈ r. *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Split off one prefix:›</span></span></span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>wordinterval_CIDR_split1</span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::len wordinterval ⇒ 'a prefix_match option × 'a wordinterval"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wordinterval_CIDR_split1 r ≡ (
   let ma = wordinterval_lowest_element r in
   case ma of 
      None ⇒ (None, r) |
      Some a ⇒ (case largest_contained_prefix a r of 
        None ⇒ (None, r) |
        Some m ⇒ (Some m, wordinterval_setminus r (prefix_to_wordinterval m))))"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_CIDR_split1_innard_helper</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>a</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a::len word"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_lowest_element r = Some a ⟹ 
  largest_contained_prefix a r ≠ None"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_lowest_element r = Some a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a,len_of(TYPE('a))) ∈ set (map (Pair a) (pfxes TYPE('a)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pfxes_def</span><span> </span><span>set_map</span><span> </span><span>set_upto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Set.image_iff</span><span> </span><span>atLeastAtMost_iff</span><span> </span><span>int_eq_iff</span><span> </span><span>order_refl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*400ms*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_prefix (PrefixMatch a (len_of(TYPE('a))))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valid_prefix_def</span><span> </span><span>pfxm_mask_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set (prefix_to_wordinterval (PrefixMatch a (len_of(TYPE('a))))) = {a}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>prefix_to_wordinterval_def</span><span> </span><span>pfxm_mask_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ wordinterval_to_set r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>wordinterval_lowest_element_set_eq</span><span> </span><span>wordinterval_lowest_none_empty</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>is_lowest_element_def</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>d</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set (prefix_to_wordinterval (PrefixMatch a (LENGTH('a)))) ⊆ wordinterval_to_set r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>largest_contained_prefix_def</span><span> </span><span>Let_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>find_None_iff</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>r_split1_not_none</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>r</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::len wordinterval"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ wordinterval_empty r ⟹ fst (wordinterval_CIDR_split1 r) ≠ None"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wordinterval_CIDR_split1_def</span><span> </span><span>Let_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_lowest_element r"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wordinterval_lowest_none_empty</span><span> 
</span><span>          </span><span>dest</span><span class="delimiter">:</span><span> </span><span>wordinterval_CIDR_split1_innard_helper</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>largest_contained_prefix_subset</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"largest_contained_prefix a r = Some p ⟹ wordinterval_to_set (prefix_to_wordinterval p) ⊆ wordinterval_to_set r"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>largest_contained_prefix_def</span><span> </span><span>Let_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>drule</span><span> </span><span>find_SomeD</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_CIDR_split1_snd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_CIDR_split1 r = (Some s, u) ⟹ u = wordinterval_setminus r (prefix_to_wordinterval s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wordinterval_CIDR_split1_def</span><span> </span><span>Let_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>largest_contained_prefix_subset_s1D</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wordinterval_CIDR_split1 r = (Some s, u) ⟹ wordinterval_to_set (prefix_to_wordinterval s) ⊆ wordinterval_to_set r"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>largest_contained_prefix_subset</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"the (wordinterval_lowest_element r)"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wordinterval_CIDR_split1_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>wordinterval_CIDR_split1_preserve</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>r</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::len wordinterval"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_CIDR_split1 r = (Some s, u) ⟹ wordinterval_eq (wordinterval_union (prefix_to_wordinterval s) u) r"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>wordinterval_eq_set_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_CIDR_split1 r = (Some s, u)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ud</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u = wordinterval_setminus r (prefix_to_wordinterval s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>as</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>wordinterval_CIDR_split1_snd</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>largest_contained_prefix_subset_s1D</span><span class="delimiter">[</span><span>OF</span><span> </span><span>as</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set (wordinterval_union (prefix_to_wordinterval s) u) = wordinterval_to_set r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ud</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_CIDR_split1_some_r_ne</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wordinterval_CIDR_split1 r = (Some s, u) ⟹ ¬ wordinterval_empty r"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_lowest_element r = None"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wordinterval_lowest_none_empty</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>not_not</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_CIDR_split1 r = (None, r)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wordinterval_CIDR_split1_def</span><span> </span><span>Let_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_CIDR_split1_distinct</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>r</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::len wordinterval"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_CIDR_split1 r = (Some s, u) ⟹
           wordinterval_empty (wordinterval_intersection (prefix_to_wordinterval s) u)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_lowest_element r ≠ None"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wordinterval_CIDR_split1_some_r_ne</span><span> </span><span>1</span><span> </span><span>wordinterval_lowest_none_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u = wordinterval_setminus r (prefix_to_wordinterval s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>elim</span><span> </span><span>wordinterval_CIDR_split1_snd</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_CIDR_split1_distinct2</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>r</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::len wordinterval"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_CIDR_split1 r = (Some s, u) ⟹
          wordinterval_empty (wordinterval_intersection (prefix_to_wordinterval s) u)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>wordinterval_CIDR_split1_distinct</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>r</span><span> </span><span class="delimiter">=</span><span> </span><span>r</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span>wordinterval_CIDR_split_prefixmatch</span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::len wordinterval ⇒ 'a prefix_match list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wordinterval_CIDR_split_prefixmatch rs = (
      if
        ¬ wordinterval_empty rs
      then case wordinterval_CIDR_split1 rs
                      of (Some s, u) ⇒ s # wordinterval_CIDR_split_prefixmatch u
                      |   _ ⇒ []
      else
        []
      )"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>pat_completeness</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">termination</span></span><span> </span><span>wordinterval_CIDR_split_prefixmatch</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>relation</span><span> </span><span class="string"><span class="delete"><span class="delete">"measure (card ∘ wordinterval_to_set)"</span></span></span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>wf_measure</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>in_measure</span><span> </span><span>comp_def</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>vernichter</span><span> </span><span class="delimiter">=</span><span> </span><span>wordinterval_empty_set_eq</span><span> </span><span>wordinterval_intersection_set_eq</span><span> </span><span>wordinterval_union_set_eq</span><span> </span><span>wordinterval_eq_set_eq</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>rs</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>x2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>some</span><span> </span><span class="delimiter">=</span><span> </span><span>1</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>1</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>prefix_never_empty</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set (prefix_to_wordinterval x2) ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vernichter</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wordinterval_CIDR_split1_preserve</span><span class="delimiter">[</span><span>OF</span><span> </span><span>some</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>vernichter</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>card_Un_disjoint</span><span class="delimiter">[</span><span>OF</span><span> </span><span>finite</span><span> </span><span>finite</span><span> </span><span>wordinterval_CIDR_split1_distinct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>some</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>vernichter</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unfold_rsplit_case</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>su</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Some s, u) = wordinterval_CIDR_split1 rs"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(case wordinterval_CIDR_split1 rs of (None, u) ⇒ []
                                            | (Some s, u) ⇒ s # wordinterval_CIDR_split_prefixmatch u) = s # wordinterval_CIDR_split_prefixmatch u"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>su</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>option.simps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>split_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_CIDR_split_prefixmatch
          (RangeUnion (WordInterval (0x40000000) 0x5FEFBBCC) (WordInterval 0x5FEEBB1C 0x7FFFFFFF))
       = [PrefixMatch (0x40000000::32 word) 2]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (wordinterval_CIDR_split_prefixmatch (WordInterval 0 (0xFFFFFFFE::32 word))) = 32"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>wordinterval_CIDR_split_prefixmatch.simps</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>wordinterval_CIDR_split_prefixmatch</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set r = (⋃x∈set (wordinterval_CIDR_split_prefixmatch r). prefix_to_wordset x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>r</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wordinterval_CIDR_split_prefixmatch.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>rs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_empty rs"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wordinterval_CIDR_split_prefixmatch.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_CIDR_split1 rs = (Some x, y)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>r_split1_not_none</span><span class="delimiter">[</span><span>OF</span><span> </span><span>False</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fst_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>mIH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set y = (⋃x∈set (wordinterval_CIDR_split_prefixmatch y). prefix_to_wordset x)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>False</span><span> </span><span>s1</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>refl</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set rs = prefix_to_wordset x ∪ (⋃x∈set (wordinterval_CIDR_split_prefixmatch y). prefix_to_wordset x)"</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mIH</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ud</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y = wordinterval_setminus rs (prefix_to_wordinterval x)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wordinterval_CIDR_split1_snd</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prefix_to_wordset x ⊆ wordinterval_to_set rs"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>largest_contained_prefix_subset_s1D</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set rs = prefix_to_wordset x ∪ wordinterval_to_set y"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ud</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ss</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>wordinterval_CIDR_split_prefixmatch.simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>if_P</span><span class="delimiter">[</span><span>OF</span><span> </span><span>False</span><span class="delimiter">]</span><span> </span><span>s1</span><span> </span><span>prod.simps</span><span> </span><span>option.simps</span><span> </span><span>*</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* WOOOOO simplifier bug (* try making this a simp add: *) *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_CIDR_split_prefixmatch_all_valid_Ball</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>r</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::len wordinterval"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀e∈set (wordinterval_CIDR_split_prefixmatch r). valid_prefix e ∧ pfxm_length e ≤ LENGTH('a)"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* The induction is somewhat verbose, so it is less annoying to write the two down at once *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>r</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wordinterval_CIDR_split_prefixmatch.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>rs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_empty rs"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_CIDR_split1 rs = (Some x, y)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>r_split1_not_none</span><span class="delimiter">[</span><span>OF</span><span> </span><span>False</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fst_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>i1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_prefix x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wordinterval_CIDR_split1_def</span><span> </span><span>Let_def</span><span> </span><span>largest_contained_prefix_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>find_SomeD</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pfxm_length x ≤ LENGTH('a)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wordinterval_CIDR_split1_def</span><span> </span><span>Let_def</span><span> </span><span>largest_contained_prefix_def</span><span> </span><span>pfxes_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>force</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>find_SomeD</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nat_le_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>mIH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a∈set (wordinterval_CIDR_split_prefixmatch y). valid_prefix a ∧ pfxm_length a ≤ LENGTH('a)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>False</span><span> </span><span>s1</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>refl</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>i1</span><span> </span><span>i2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>wordinterval_CIDR_split_prefixmatch.simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>if_P</span><span class="delimiter">[</span><span>OF</span><span> </span><span>False</span><span class="delimiter">]</span><span> </span><span>s1</span><span> </span><span>prod.simps</span><span> </span><span>option.simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wordinterval_CIDR_split_prefixmatch.simps</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_CIDR_split_prefixmatch_all_valid_less_Ball_hlp</span><span class="delimiter">:</span><span>
</span><span>	</span><span class="string"><span class="delete"><span class="delete">"x ∈ set [s←map (PrefixMatch x2) (pfxes TYPE('a::len0)) . valid_prefix s ∧ wordinterval_to_set (prefix_to_wordinterval s) ⊆ wordinterval_to_set rs] ⟹ pfxm_length x ≤ LENGTH('a)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pfxes_def</span><span class="delimiter">)</span><span> </span><span>presburger</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Since @{const wordinterval_CIDR_split_prefixmatch} only returns valid prefixes, we can safely convert it to CIDR lists›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* actually, just valid_prefix doesn't mean that the prefix length is sane. Fortunately, wordinterval_CIDR_split_prefixmatch_all_valid_Ball does entail that *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_prefix (PrefixMatch (0::16 word) 20)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>valid_prefix_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_CIDR_split_disjunct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ set (wordinterval_CIDR_split_prefixmatch i) ⟹
  b ∈ set (wordinterval_CIDR_split_prefixmatch i) ⟹ a ≠ b ⟹
  prefix_to_wordset a ∩ prefix_to_wordset b = {}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>i</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wordinterval_CIDR_split_prefixmatch.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>rs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span>1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>prema</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ set (wordinterval_CIDR_split_prefixmatch rs)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ ?os"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>premb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ ?os"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_empty rs"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_CIDR_split1 rs = (Some x, y)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>r_split1_not_none</span><span class="delimiter">[</span><span>OF</span><span> </span><span>False</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fst_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>mi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"k ∈ set (wordinterval_CIDR_split_prefixmatch y)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k ∈ ?rs"</span></span></span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"k ≠ x"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k ∈ ?os"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span> </span><span>s1</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>wordinterval_CIDR_split_prefixmatch.simps</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>if_P</span><span class="delimiter">[</span><span>OF</span><span> </span><span>False</span><span class="delimiter">]</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span> </span><span>option.splits</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"k ∈ ?rs ⟹ prefix_to_wordset k ⊆ wordinterval_to_set y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span> 
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* this is actually a quite general statement, might make a lemma out of it *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wordinterval_CIDR_split_prefixmatch</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prefix_to_wordset x ∩ wordinterval_to_set y = {}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wordinterval_CIDR_split1_snd</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"a = x"</span></span></span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"b = x"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a = x"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ≠ x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>a</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mi</span><span class="delimiter">[</span><span>OF</span><span> </span><span>as</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>premb</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>b</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≠ x"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b = x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>a</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mi</span><span class="delimiter">[</span><span>OF</span><span> </span><span>as</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>prema</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>b</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≠ x"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ≠ x"</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Nothing to do case *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ ?rs"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ ?rs"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>as</span><span> </span><span>mi</span><span> </span><span>prema</span><span> </span><span>premb</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefix_to_wordset a ∩ prefix_to_wordset b = {}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>False</span><span> </span><span>s1</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>refl</span><span> </span><span>i</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fact</span><span> </span><span>1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a = x"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b = x"</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* impossible case *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_CIDR_split_prefixmatch rs = []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wordinterval_CIDR_split_prefixmatch.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prema</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_CIDR_split_distinct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct (wordinterval_CIDR_split_prefixmatch i)"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* wish this was a corollary *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>i</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wordinterval_CIDR_split_prefixmatch.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>rs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_empty rs"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_CIDR_split1 rs = (Some x, y)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>r_split1_not_none</span><span class="delimiter">[</span><span>OF</span><span> </span><span>False</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fst_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>mIH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct (wordinterval_CIDR_split_prefixmatch y)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>False</span><span> </span><span>s1</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>refl</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefix_to_wordset x ∩ wordinterval_to_set y = {}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wordinterval_CIDR_split1_snd</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>i1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ set (wordinterval_CIDR_split_prefixmatch y)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wordinterval_CIDR_split_prefixmatch</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prefix_never_empty</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s1</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>wordinterval_CIDR_split_prefixmatch.simps</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>if_P</span><span class="delimiter">[</span><span>OF</span><span> </span><span>False</span><span class="delimiter">]</span><span> </span><span>mIH</span><span> </span><span>i1</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wordinterval_CIDR_split_prefixmatch.simps</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_CIDR_split_existential</span><span class="delimiter">:</span><span>
</span><span>	</span><span class="string"><span class="delete"><span class="delete">"x ∈ wordinterval_to_set w ⟹ ∃s. s ∈ set (wordinterval_CIDR_split_prefixmatch w) ∧ x ∈ prefix_to_wordset s"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wordinterval_CIDR_split_prefixmatch</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Versions for @{const ipset_from_cidr}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cidr_split</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'i::len wordinterval ⇒ ('i word × nat) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"cidr_split rs ≡ map prefix_match_to_CIDR (wordinterval_CIDR_split_prefixmatch rs)"</span></span></span><span>
</span><span>                                        
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>cidr_split_prefix</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>r</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'i::len wordinterval"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋃x∈set (cidr_split r). uncurry ipset_from_cidr x) = wordinterval_to_set r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wordinterval_CIDR_split_prefixmatch</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>cidr_split_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>prefix_match_to_CIDR_def2</span><span> </span><span>wordinterval_CIDR_split_prefixmatch</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prefix_to_wordset_ipset_from_cidr</span><span> </span><span>wordinterval_CIDR_split_prefixmatch_all_valid_Ball</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>cidr_split_prefix_single</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>start</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'i::len word"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋃x∈set (cidr_split (iprange_interval (start, end))). uncurry ipset_from_cidr x) = {start..end}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wordinterval_to_set.simps</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cidr_split_prefix</span><span> </span><span>iprange_interval.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>interval_in_splitD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"xa ∈ foo ⟹ prefix_to_wordset xa ⊆ ⋃(prefix_to_wordset ` foo)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cidrsplit_no_overlaps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦
        x ∈ set (wordinterval_CIDR_split_prefixmatch wi);
        xa ∈ set (wordinterval_CIDR_split_prefixmatch wi); 
        pt &amp;&amp; ~~ (pfxm_mask x) = pfxm_prefix x;
        pt &amp;&amp; ~~ (pfxm_mask xa) = pfxm_prefix xa
        ⟧
       ⟹ x = xa"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>	</span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>	</span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefix_match_semantics x pt"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefix_match_semantics xa pt"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>prefix_match_semantics_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>word_bw_comms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>	</span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_prefix x"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_prefix xa"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>1</span><span>-</span><span>2</span><span class="delimiter">)</span><span> </span><span>wordinterval_CIDR_split_prefixmatch_all_valid_Ball</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>	</span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pt ∈ prefix_to_wordset x"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pt ∈ prefix_to_wordset xa"</span></span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prefix_match_semantics_wordset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>	</span><span class="keyword1"><span class="command">with</span></span><span> </span><span>wordinterval_CIDR_split_disjunct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>1</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="WordInterval_Sorted">
<div class="head"><h1>Theory WordInterval_Sorted</h1>
<span class="command">theory</span> <span class="name">WordInterval_Sorted</span><br/>
<span class="keyword">imports</span> <a href="WordInterval.html"><span class="name">WordInterval</span></a> <a href="Misc.html"><span class="name">Misc</span></a> <a href="Product_Lexorder.html"><span class="name">Product_Lexorder</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>WordInterval_Sorted</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>WordInterval</span><span>
</span><span>        </span><span>Automatic_Refinement.Misc</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Mergesort. TODO: dependnecy! we need a mergesort afp entry!!*)</span></span></span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Product_Lexorder"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*has afp mergesort dependency*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Use this and @{thm wordinterval_compress} before pretty-printing.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>wordinterval_sort</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a::len wordinterval ⇒ 'a::len wordinterval"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wordinterval_sort w ≡ l2wi (mergesort_remdups (wi2l w))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wordinterval_sort</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wordinterval_to_set (wordinterval_sort w) = wordinterval_to_set w"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wordinterval_sort_def</span><span> </span><span>wi2l</span><span> </span><span>l2wi</span><span> </span><span>mergesort_remdups_correct</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*A wordinterval is essentially a tree.
  We could vastly improve the computational complexity for all operations!*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="IP_Address_Parser">
<div class="head"><h1>Theory IP_Address_Parser</h1>
<span class="command">theory</span> <span class="name">IP_Address_Parser</span><br/>
<span class="keyword">imports</span> <a href="IPv4.html"><span class="name">IPv4</span></a> <a href="IPv6.html"><span class="name">IPv6</span></a> <a href="Code_Target_Nat.html"><span class="name">Code_Target_Nat</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>IP_Address_Parser</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>IP_Address</span><span>
</span><span>        </span><span>IPv4</span><span>
</span><span>        </span><span>IPv6</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Code_Target_Nat"</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*!!*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Parsing IP Addresses›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹IPv4 Parser›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
local
  fun extract_int ss = case ss |&gt; implode |&gt; Int.fromString
                                of SOME i =&gt; i
                                |  NONE   =&gt; raise Fail "unparsable int";

  fun mk_nat maxval i = if i &lt; 0 orelse i &gt; maxval
            then
              raise Fail("nat ("^Int.toString i^") must be between 0 and "^Int.toString maxval)
            else (HOLogic.mk_number HOLogic.natT i);
  val mk_nat255 = mk_nat 255;

  fun mk_quadrupel (((a,b),c),d) = HOLogic.mk_prod
           (mk_nat255 a, HOLogic.mk_prod (mk_nat255 b, HOLogic.mk_prod (mk_nat255 c, mk_nat255 d)));

in 
  fun mk_ipv4addr ip = @{const ipv4addr_of_dotdecimal} $ mk_quadrupel ip;

  val parser_ipv4 = (Scan.many1 Symbol.is_ascii_digit &gt;&gt; extract_int) --| ($$ ".") --
                  (Scan.many1 Symbol.is_ascii_digit &gt;&gt; extract_int) --| ($$ ".") --
                  (Scan.many1 Symbol.is_ascii_digit &gt;&gt; extract_int) --| ($$ ".") --
                  (Scan.many1 Symbol.is_ascii_digit &gt;&gt; extract_int);
end;

local
  val (ip_term, rest) = "10.8.0.255" |&gt; raw_explode |&gt; Scan.finite Symbol.stopper (parser_ipv4 &gt;&gt; mk_ipv4addr);
in
  val _ = if rest &lt;&gt; [] then raise Fail "did not parse everything" else writeln "parsed";
  val _ = if
            Code_Evaluation.dynamic_value_strict @{context} ip_term
            &lt;&gt; @{term "168296703::ipv4addr"}
          then
            raise Fail "parser failed"
          else
            writeln "test passed";
end;
›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹IPv6 Parser›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mk_ipv6addr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"16 word option list ⇒ ipv6addr_syntax option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"mk_ipv6addr partslist = (
      let ― ‹remove empty lists to the beginning and end if omission occurs at start/end›
          ― ‹to join over ▩‹:› properly›
          fix_start = (λps. case ps of None#None#_ ⇒ tl ps | _ ⇒ ps);
          fix_end = (λps. case rev ps of None#None#_ ⇒ butlast ps | _ ⇒ ps);
          ps = (fix_end ∘ fix_start) partslist
      in
      if length (filter (λp. p = None) ps) = 1
      then ipv6_unparsed_compressed_to_preferred ps
      else case ps of [Some a,Some b,Some c,Some d,Some e,Some f,Some g,Some h]
                              ⇒ Some (IPv6AddrPreferred a b c d e f g h)
                   |  _ ⇒ None
      )"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
local
  val fromHexString = StringCvt.scanString (Int.scan StringCvt.HEX);

  fun extract_int ss = case ss of "" =&gt; NONE
                               |  xs =&gt;
                          case xs |&gt; fromHexString
                                of SOME i =&gt; SOME i
                                |  NONE   =&gt; raise Fail "unparsable int";
in
  val mk_ipv6addr = map (fn p =&gt; case p of NONE =&gt; @{const None ("16 word")}
                                        |  SOME i =&gt; @{const Some ("16 word")} $
                                                      (@{const word_of_int (16)} $
                                                                  HOLogic.mk_number HOLogic.intT i)
                        )
                 #&gt; HOLogic.mk_list @{typ "16 word option"}
                 (*TODO: never use THE! is there some option_dest?*)
                 #&gt; (fn x =&gt; @{const ipv6preferred_to_int} $
                                   (@{const the ("ipv6addr_syntax")} $ (@{const mk_ipv6addr} $ x)));

  val parser_ipv6 = Scan.many1 (fn x =&gt; Symbol.is_ascii_hex x orelse x = ":")
                      &gt;&gt; (implode #&gt; space_explode ":" #&gt; map extract_int)
                  (* a different implementation which returns a list of exploded strings:
                    Scan.repeat ((Scan.many Symbol.is_ascii_hex &gt;&gt; extract_int) --| ($$ ":"))
                   @@@ (Scan.many Symbol.is_ascii_hex &gt;&gt; extract_int &gt;&gt; (fn p =&gt; [p]))*)
end;

local
  val parse_ipv6 = raw_explode
                   #&gt; Scan.finite Symbol.stopper (parser_ipv6 &gt;&gt; mk_ipv6addr);
  fun unit_test (ip_string, ip_result) = let
    val (ip_term, rest) = ip_string |&gt; parse_ipv6;
    val _ = if rest &lt;&gt; [] then raise Fail "did not parse everything" else ();
    val _ = Code_Evaluation.dynamic_value_strict @{context} ip_term |&gt; Syntax.pretty_term @{context} |&gt; Pretty.writeln;
    val _ = if
              Code_Evaluation.dynamic_value_strict @{context} ip_term &lt;&gt; ip_result
            then
              raise Fail "parser failed"
            else
              writeln ("test passed for "^ip_string);
  in
    ()
  end;
in
  val _ = map unit_test
          [("10:ab:FF:0::FF:4:255", @{term "83090298060623265259947972050027093::ipv6addr"})
          ,("2001:db8::8:800:200c:417a", @{term "42540766411282592856906245548098208122::ipv6addr"})
          ,("ff01::101", @{term "338958331222012082418099330867817087233::ipv6addr"})
          ,("::8:800:200c:417a", @{term "2260596444381562::ipv6addr"})
          ,("2001:db8::", @{term "42540766411282592856903984951653826560::ipv6addr"})
          ,("ff00::", @{term "338953138925153547590470800371487866880::ipv6addr"})
          ,("fe80::", @{term "338288524927261089654018896841347694592::ipv6addr"})
          ,("1::", @{term "5192296858534827628530496329220096::ipv6addr"})
          ,("1::", @{term "5192296858534827628530496329220096::ipv6addr"})
          ,("::", @{term "0::ipv6addr"})
          ,("::1", @{term "1::ipv6addr"})
          ,("2001:db8:0:1:1:1:1:1", @{term "42540766411282592875351010504635121665::ipv6addr"})
          ,("ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff", @{term "340282366920938463463374607431768211455::ipv6addr"})
          ];
end;
›</span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Lib_Numbers_toString">
<div class="head"><h1>Theory Lib_Numbers_toString</h1>
<span class="command">theory</span> <span class="name">Lib_Numbers_toString</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Lib_Numbers_toString</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Printing Numbers›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*http://stackoverflow.com/questions/23864965/string-of-nat-in-isabelle*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>string_of_nat</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ string"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"string_of_nat n = (if n &lt; 10 then [char_of (48 + n)] else 
     string_of_nat (n div 10) @ [char_of (48 + (n mod 10))])"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>string_of_int</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"int ⇒ string"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"string_of_int i = (if i &lt; 0 then ''-'' @ string_of_nat (nat (- i)) else 
     string_of_nat (nat i))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"string_of_nat 123456 = ''123456''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>string_of_nat.simps</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Lib_Word_toString">
<div class="head"><h1>Theory Lib_Word_toString</h1>
<span class="command">theory</span> <span class="name">Lib_Word_toString</span><br/>
<span class="keyword">imports</span> <a href="Lib_Numbers_toString.html"><span class="name">Lib_Numbers_toString</span></a> <a href="../Word_Lib/Word_Lemmas.html"><span class="name">Word_Lemmas</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Lib_Word_toString</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Lib_Numbers_toString</span><span>
</span><span>        </span><span>Word_Lib.Word_Lemmas</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Printing Machine Words›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*imitation of http://stackoverflow.com/questions/23864965/string-of-nat-in-isabelle*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*parameters:
    lc = lower-case
    w  = word to print*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>string_of_word_single</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"bool ⇒ 'a::len word ⇒ string"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"string_of_word_single lc w ≡
    (if
       w &lt; 10
     then
       [char_of (48 + unat w)]
     else if
       w &lt; 36
     then
       [char_of ((if lc then 87 else 55) + unat w)]
     else
       undefined)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Example:›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"let word_upto = ((λ i j. map (of_nat ∘ nat) [i .. j]) :: int ⇒ int ⇒ 32 word list)
       in map (string_of_word_single False) (word_upto 1 35) =
  [''1'', ''2'', ''3'', ''4'', ''5'', ''6'', ''7'', ''8'', ''9'',
   ''A'', ''B'', ''C'', ''D'', ''E'', ''F'', ''G'', ''H'', ''I'',
   ''J'', ''K'', ''L'', ''M'', ''N'', ''O'', ''P'', ''Q'', ''R'',
   ''S'', ''T'', ''U'', ''V'', ''W'', ''X'', ''Y'', ''Z'']"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* parameters: lowercase, base, minimum length - 1, to-be-serialized word *)</span></span></span></span></span><span> 
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span>string_of_word</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"bool ⇒ ('a :: len) word ⇒ nat ⇒ ('a :: len) word ⇒ string"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"string_of_word lc base ml w =
    (if
       base &lt; 2 ∨ LENGTH('a) &lt; 2
     then
       undefined
     else if
       w &lt; base ∧ ml = 0
     then
       string_of_word_single lc w
     else
       string_of_word lc base (ml - 1) (w div base) @ string_of_word_single lc (w mod base)
     )"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>pat_completeness</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hex_string_of_word l ≡ string_of_word True (16 :: ('a::len) word) l"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hex_string_of_word0 ≡ hex_string_of_word 0"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* be careful though, these functions only make sense with words &gt; length 4.
   With 4 bits, base 16 is not representable. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dec_string_of_word0 ≡ string_of_word True 10 0"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">termination</span></span><span> </span><span>string_of_word</span><span>
</span><span>	</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>relation</span><span> </span><span class="string"><span class="delete"><span class="delete">"measure (λ(a,b,c,d). unat d + c)"</span></span></span><span class="delimiter">)</span><span>
</span><span>	 </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_measure</span><span class="delimiter">)</span><span>
</span><span>	</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>in_measure</span><span class="delimiter">)</span><span>
</span><span>	</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>	</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>base</span><span> </span><span>ml</span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"ml ≠ 0"</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>less_eq_Suc_le</span><span> </span><span>unat_div</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"(n div base) &lt; n"</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>unat_mono</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>div_less_dividend_word</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>metis</span><span> </span><span>Word_Lemmas.power_not_zero</span><span> </span><span>linorder_neqE_nat</span><span> </span><span>numeral_less_iff</span><span>
</span><span>                      </span><span>power_zero_numeral</span><span> </span><span>semiring_norm</span><span class="delimiter">(</span><span>76</span><span class="delimiter">)</span><span> </span><span>word_neq_0_conv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>thin_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"n ≠ 0"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>mult.right_neutral</span><span> </span><span>power_0</span><span> </span><span>power_Suc</span><span> </span><span>unat_1</span><span>
</span><span>                      </span><span>unat_power_lower</span><span> </span><span>Suc_1</span><span> </span><span>inc_induct</span><span> </span><span>le_def</span><span> </span><span>less_eq_Suc_le</span><span> </span><span>lt1_neq0</span><span>
</span><span>                      </span><span>not_degenerate_imp_2_neq_0</span><span> </span><span>word_le_less_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>string_of_word.simps</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hex_string_of_word0 (0xdeadbeef42 :: 42 word) = ''deadbeef42''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hex_string_of_word 1 (0x1 :: 5 word) = ''01''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hex_string_of_word 8 (0xff::32 word) = ''0000000ff''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dec_string_of_word0 (8::32 word) = ''8''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dec_string_of_word0 (3::2 word) = ''11''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dec_string_of_word0 (-1::8 word) = ''255''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>string_of_word_single_atoi</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"n &lt; 10 ⟹ string_of_word_single True n = [char_of (48 + unat n)]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>string_of_word_single_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*TODO: move!*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bintrunc_pos_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≥ 0 ⟹ bintrunc n x = x ⟷ x &lt; 2^n"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bintr_lt2p</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mod_pos_pos_trivial</span><span> </span><span>no_bintr_alt1</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*The following lemma [symmetric] as [code_unfold] may give some cool speedup*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>string_of_word_base_ten_zeropad</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>w</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a::len word"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>lena</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"LENGTH('a) ≥ 5"</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*word must be long enough to encode 10 = 0xA*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"base = 10 ⟹ zero = 0 ⟹ string_of_word True base zero w = string_of_nat (unat w)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>True</span><span> </span><span>base</span><span> </span><span>zero</span><span> </span><span>w</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>string_of_word.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>base</span><span> </span><span>ml</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span>  </span><span>Word.word_less_no</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span>  </span><span>Word.uint_bintrunc</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"5 ≤ n ⟹ bintrunc n 10 = 10"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>bintrunc_pos_eq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>Nat.dec_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>lena</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unat_ten</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"unat (0xA::'a::len word) = 10"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"5 ≤ n ⟹ bintrunc n 2 = 2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>bintrunc_pos_eq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>Nat.dec_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>lena</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unat_two</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"unat (2::'a::len word) = 2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unat_mod_ten</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"unat (n mod 0xA) = unat n mod 10"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Word.unat_mod</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>unat_ten</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unat_div_ten</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(unat (n div 0xA)) = unat n div 10"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Word.unat_div</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>unat_ten</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_less_ten_unat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n &lt; 0xA ⟹ (unat n &lt; 10)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Word_Lemmas.unat_less_helper</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0xA ≤ n ⟹ 10 ≤ unat n"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>Word.word_le_nat_alt</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>unat_ten</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>n_less_ten_unat_not</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ n &lt; 0xA ⟹ ¬ unat n &lt; 10"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>not_wordlength_too_small</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ LENGTH('a) &lt; 2"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lena</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 ≤ (0xA::'a word)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>word_le_nat_alt</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>unat_ten</span><span> </span><span>unat_two</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>unat_two</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ten_not_less_two</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (0xA::'a word) &lt; 2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Word.word_less_no</span><span> </span><span>Word.uint_bintrunc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" ¬ (base &lt; 2 ∨ LENGTH(32) &lt; 2)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>1</span><span> </span><span>not_wordlength_too_small</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ n &lt; 0xA ⟹ string_of_word True 0xA 0 (n div 0xA) = string_of_nat (unat (n div 0xA))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"n &lt; 0xA"</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>string_of_word.simps</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>string_of_nat.simps</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>n_less_ten_unat</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>not_wordlength_too_small</span><span> </span><span>ten_not_less_two</span><span> </span><span>string_of_word_single_atoi</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sym</span><span class="delimiter">[</span><span>OF</span><span> </span><span>IH</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>string_of_word.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>string_of_nat.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>not_wordlength_too_small</span><span> </span><span>ten_not_less_two</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>string_of_word_single_atoi</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Word.word_mod_less_divisor</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unat_ten</span><span> </span><span>word_gt_0_no</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>unat_mod_ten</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>sym</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule</span><span> </span><span>n_less_ten_unat_not</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>unat_div_ten</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>string_of_nat.simps</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*TODO: one for all words?*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dec_string_of_word0</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dec_string_of_word0 (w8:: 8 word) = string_of_nat (unat w8)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dec_string_of_word0 (w16:: 16 word) = string_of_nat (unat w16)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dec_string_of_word0 (w32:: 32 word) = string_of_nat (unat w32)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dec_string_of_word0 (w64:: 64 word) = string_of_nat (unat w64)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dec_string_of_word0 (w128:: 128 word) = string_of_nat (unat w128)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dec_string_of_word0_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>string_of_word_base_ten_zeropad</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Lib_List_toString">
<div class="head"><h1>Theory Lib_List_toString</h1>
<span class="command">theory</span> <span class="name">Lib_List_toString</span><br/>
<span class="keyword">imports</span> <a href="Lib_Numbers_toString.html"><span class="name">Lib_Numbers_toString</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Lib_List_toString</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Lib_Numbers_toString</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Printing Lists›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>intersperse</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a list list ⇒ 'a list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"intersperse _ [] = []"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"intersperse a [x] = x"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"intersperse a (x#xs) = x @ a # intersperse a xs"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*this is similar to space_implode or Data.List.intersperse (in Haskell)*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>list_separated_toString</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"string ⇒ ('a ⇒ string) ⇒ 'a list ⇒ string"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"list_separated_toString sep toStr ls = concat (splice (map toStr ls) (replicate (length ls - 1) sep))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹A slightly more efficient code equation, which is actually not really faster (in certain languages)›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>list_separated_toString_helper</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"string ⇒ ('a ⇒ string) ⇒ 'a list ⇒ string"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"list_separated_toString_helper sep toStr [] = ''''"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"list_separated_toString_helper sep toStr [l] = toStr l"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"list_separated_toString_helper sep toStr (l#ls) = (toStr l)@sep@list_separated_toString_helper sep toStr ls"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_separated_toString_helper</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"list_separated_toString = list_separated_toString_helper"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>sep</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>toStr</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('a ⇒ char list)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ls</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"list_separated_toString sep toStr ls = list_separated_toString_helper sep toStr ls"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>sep</span><span> </span><span>toStr</span><span> </span><span>ls</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>list_separated_toString_helper.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>list_separated_toString_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_separated_toString_intersperse</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"intersperse sep (map f xs) = list_separated_toString [sep] f xs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>list_separated_toString_helper</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induction</span><span> </span><span class="string"><span class="delete"><span class="delete">"[sep]"</span></span></span><span> </span><span>f</span><span> </span><span>xs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>list_separated_toString_helper.induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>list_toString</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ string) ⇒ 'a list ⇒ string"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"list_toString toStr ls = ''[''@ list_separated_toString '', '' toStr ls @'']''"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"list_toString string_of_nat [1,2,3] = ''[1, 2, 3]''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="IP_Address_toString">
<div class="head"><h1>Theory IP_Address_toString</h1>
<span class="command">theory</span> <span class="name">IP_Address_toString</span><br/>
<span class="keyword">imports</span> <a href="IPv4.html"><span class="name">IPv4</span></a> <a href="IPv6.html"><span class="name">IPv6</span></a> <a href="Lib_Word_toString.html"><span class="name">Lib_Word_toString</span></a> <a href="Lib_List_toString.html"><span class="name">Lib_List_toString</span></a> <a href="Code_Target_Nat.html"><span class="name">Code_Target_Nat</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>IP_Address_toString</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>IP_Address</span><span> </span><span>IPv4</span><span> </span><span>IPv6</span><span>
</span><span>        </span><span>Lib_Word_toString</span><span>
</span><span>        </span><span>Lib_List_toString</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Code_Target_Nat"</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*!!*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Pretty Printing IP Addresses›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Generic Pretty Printer›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Generic function. Whenever possible, use IPv4 or IPv6 pretty printing!›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ipaddr_generic_toString</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'i::len word ⇒ string"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ipaddr_generic_toString ip ≡
      ''[IP address ('' @ string_of_nat (LENGTH('i)) @ '' bit): '' @ dec_string_of_word0 ip @ '']''"</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipaddr_generic_toString (ipv4addr_of_dotdecimal (192,168,0,1)) = ''[IP address (32 bit): 3232235521]''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹IPv4 Pretty Printing›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>dotteddecimal_toString</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat × nat × nat × nat ⇒ string"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"dotteddecimal_toString (a,b,c,d) =
      string_of_nat a@''.''@string_of_nat b@''.''@string_of_nat c@''.''@string_of_nat d"</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ipv4addr_toString</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv4addr ⇒ string"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ipv4addr_toString ip = dotteddecimal_toString (dotdecimal_of_ipv4addr ip)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv4addr_toString (ipv4addr_of_dotdecimal (192, 168, 0, 1)) = ''192.168.0.1''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness Theorems:›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>dotdecimal_of_ipv4addr_ipv4addr_of_dotdecimal</span><span>
</span><span>      </span><span>ipv4addr_of_dotdecimal_dotdecimal_of_ipv4addr</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹IPv6 Pretty Printing›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ipv6addr_toString</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr ⇒ string"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_toString ip = (
      let partslist = ipv6_preferred_to_compressed (int_to_ipv6preferred ip);
          ― ‹add empty lists to the beginning and end if omission occurs at start/end›
          ― ‹to join over ▩‹:› properly›
          fix_start = (λps. case ps of None#_ ⇒ None#ps | _ ⇒ ps);
          fix_end = (λps. case rev ps of None#_ ⇒ ps@[None] | _ ⇒ ps)
      in list_separated_toString '':''
        (λpt. case pt of None ⇒ ''''
                      |  Some w ⇒ hex_string_of_word0 w)
        ((fix_end ∘ fix_start) partslist)
      )"</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_toString (ipv6preferred_to_int (IPv6AddrPreferred 0x2001 0xDB8 0x0 0x0 0x8 0x800 0x200C 0x417A))
              = ''2001:db8::8:800:200c:417a''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span> </span><span class="comment">― ‹a unicast address›</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_toString (ipv6preferred_to_int (IPv6AddrPreferred 0xFF01 0x0 0x0 0x0 0x0 0x0 0x0 0x0101)) =
              ''ff01::101''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span> </span><span class="comment">― ‹a multicast address›</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_toString (ipv6preferred_to_int (IPv6AddrPreferred 0 0 0 0 0x8 0x800 0x200C 0x417A)) =
               ''::8:800:200c:417a''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_toString (ipv6preferred_to_int (IPv6AddrPreferred 0x2001 0xDB8 0 0 0 0 0 0)) =
               ''2001:db8::''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span> 
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_toString (ipv6preferred_to_int (IPv6AddrPreferred 0xFF00 0 0 0 0 0 0 0)) =
               ''ff00::''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span> </span><span class="comment">― ‹Multicast›</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_toString (ipv6preferred_to_int (IPv6AddrPreferred 0xFE80 0 0 0 0 0 0 0)) =
               ''fe80::''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span> </span><span class="comment">― ‹Link-Local unicast›</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_toString (ipv6preferred_to_int (IPv6AddrPreferred 0 0 0 0 0 0 0 0)) =
               ''::''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span> </span><span class="comment">― ‹unspecified address›</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_toString (ipv6preferred_to_int (IPv6AddrPreferred 0 0 0 0 0 0 0 1)) =
               ''::1''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span> </span><span class="comment">― ‹loopback address›</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_toString (ipv6preferred_to_int
          (IPv6AddrPreferred 0x2001 0xdb8 0x0 0x0 0x0 0x0 0x0 0x1)) =
              ''2001:db8::1''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span> </span><span class="comment">― ‹Section 4.1 of RFC5952›</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_toString (ipv6preferred_to_int
          (IPv6AddrPreferred 0x2001 0xdb8 0x0 0x0 0x0 0x0 0x2 0x1)) =
              ''2001:db8::2:1''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span> </span><span class="comment">― ‹Section 4.2.1 of RFC5952›</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_toString (ipv6preferred_to_int
          (IPv6AddrPreferred 0x2001 0xdb8 0x0 0x1 0x1 0x1 0x1 0x1)) =
              ''2001:db8:0:1:1:1:1:1''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span> </span><span class="comment">― ‹Section 4.2.2 of RFC5952›</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_toString (ipv6preferred_to_int
          (IPv6AddrPreferred 0x2001 0x0 0x0 0x1 0x0 0x0 0x0 0x1)) =
              ''2001:0:0:1::1''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span> </span><span class="comment">― ‹Section 4.2.3 of RFC5952›</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_toString (ipv6preferred_to_int
          (IPv6AddrPreferred 0x2001 0xdb8 0x0 0x0 0x1 0x0 0x0 0x1)) =
              ''2001:db8::1:0:0:1''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span> </span><span class="comment">― ‹Section 4.2.3 of RFC5952›</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_toString max_ipv6_addr = ''ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ipv6addr_toString (ipv6preferred_to_int
           (IPv6AddrPreferred 0xffff 0xffff 0xffff 0xffff 0xffff 0xffff 0xffff 0xffff)) =
              ''ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>eval</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Correctness Theorems:›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>ipv6_preferred_to_compressed</span><span>
</span><span>      </span><span>ipv6_preferred_to_compressed_RFC_4291_format</span><span>
</span><span>      </span><span>ipv6_unparsed_compressed_to_preferred_identity1</span><span>
</span><span>      </span><span>ipv6_unparsed_compressed_to_preferred_identity2</span><span>
</span><span>      </span><span>RFC_4291_format</span><span>
</span><span>      </span><span>ipv6preferred_to_int_int_to_ipv6preferred</span><span>
</span><span>      </span><span>int_to_ipv6preferred_ipv6preferred_to_int</span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Prefix_Match_toString">
<div class="head"><h1>Theory Prefix_Match_toString</h1>
<span class="command">theory</span> <span class="name">Prefix_Match_toString</span><br/>
<span class="keyword">imports</span> <a href="IP_Address_toString.html"><span class="name">IP_Address_toString</span></a> <a href="Prefix_Match.html"><span class="name">Prefix_Match</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Prefix_Match_toString</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>IP_Address_toString</span><span> </span><span>Prefix_Match</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>prefix_match_32_toString</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"32 prefix_match ⇒ string"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prefix_match_32_toString pfx = (case pfx of PrefixMatch p l ⇒ ipv4addr_toString p @ (if l ≠ 32 then ''/'' @ string_of_nat l else []))"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>prefix_match_128_toString</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"128 prefix_match ⇒ string"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prefix_match_128_toString pfx = (case pfx of PrefixMatch p l ⇒ ipv6addr_toString p @ (if l ≠ 128 then ''/'' @ string_of_nat l else []))"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>