<div id="Tree">
<div class="head">
<h1>Theory Tree</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Tree Automata
    Author:      Peter Lammich &lt;peter dot lammich at uni-muenster.de&gt;
    Maintainer:  Peter Lammich &lt;peter dot lammich at uni-muenster.de&gt;
*)</span>
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Trees"</span></span>
<span class="keyword1"><span class="command">theory</span></span> Tree
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:tree}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This theory defines trees as nodes with a label and a list of subtrees.
›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="tfree">'l</span> tree <span class="main">=</span> NODE <span class="tfree"><span class="quoted"><span class="tfree">'l</span></span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'l</span> tree list"</span></span>

<span class="keyword1"><span class="command">datatype_compat</span></span> tree

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Ta">
<div class="head">
<h1>Theory Ta</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Tree Automata
    Author:      Peter Lammich &lt;peter dot lammich at uni-muenster.de&gt;
    Maintainer:  Peter Lammich &lt;peter dot lammich at uni-muenster.de&gt;
*)</span>
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Tree Automata"</span></span>
<span class="keyword1"><span class="command">theory</span></span> Ta
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a> <a href="../Automatic_Refinement/Misc.html">Automatic_Refinement.Misc</a> <a href="Tree.html">Tree</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:ta}›</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This theory defines tree automata, tree regular languages and 
  specifies basic algorithms.

  Nondeterministic and deterministic (bottom-up) tree automata are defined.

  For non-deterministic tree automata, basic algorithms for membership, union,
  intersection, forward and backward reduction, and emptiness check are 
  specified.
  Moreover, a (brute-force) determinization algorithm is specified.
  
  For deterministic tree automata, we specify algorithms for complement 
  and completion. 

  Finally, the class of regular languages over a given ranked alphabet is defined
  and its standard closure properties are proved.

  The specification of the algorithms in this theory is very high-level, and the
  specifications are not executable. A bit more specific algorithms are defined 
  in Section~\ref{sec:absalgo}, and a refinement to executable definitions is 
  done in Section~\ref{sec:taimpl}.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Basic Definitions"</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">"Tree Automata"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  A tree automata consists of a (finite) set of initial states
  and a (finite) set of rules. 

  A rule has the form <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>q → l q1…qn›</span></span></span></span>, 
  with the meaning that one can derive 
  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>l(q1…qn)›</span></span></span></span> from the state <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>q›</span></span></span></span>.
›</span></span>

<span class="comment1">(* Workaround for bug in Haskell-code generator: Type variables have to be 
  lower-case *)</span>
<span class="comment1">(* datatype ('Q,'L) ta_rule = RULE 'Q 'L "'Q list" ("_ → _ _") *)</span>
<span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span><span class="tfree">'q</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> ta_rule <span class="main">=</span> RULE <span class="tfree"><span class="quoted"><span class="tfree">'q</span></span></span> <span class="tfree"><span class="quoted"><span class="tfree">'l</span></span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'q</span> list"</span></span> <span class="main">(</span><span class="quoted">"_ <span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1">→</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> _ _"</span><span class="main">)</span>

<span class="keyword1"><span class="command">record</span></span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> tree_automaton_rec <span class="main">=</span>
  ta_initial <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> set"</span></span>
  ta_rules <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule set"</span></span>

  <span class="comment1">― ‹Rule deconstruction›</span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">lhs</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">lhs</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">→</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">qs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span>"</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">rhsq</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">rhsq</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">→</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">qs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">qs</span></span></span>"</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">rhsl</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">rhsl</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">→</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">qs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>
  <span class="comment1">― ‹States in a rule›</span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">rule_states</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">rule_states</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">→</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">qs</span></span></span><span class="main">)</span> <span class="main">=</span> insert <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">(</span>set <span class="free"><span class="bound"><span class="entity">qs</span></span></span><span class="main">)</span>"</span></span>
  <span class="comment1">― ‹States in a set of rules›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">δ_states</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">==</span> <span class="main">⋃</span><span class="main">(</span>rule_states <span class="main">`</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span><span class="main">)</span>"</span></span>
  <span class="comment1">― ‹States in a tree automaton›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ta_rstates</span> <span class="free"><span class="bound"><span class="entity">TA</span></span></span> <span class="main">=</span> ta_initial <span class="free"><span class="bound"><span class="entity">TA</span></span></span> <span class="main">∪</span> δ_states <span class="main">(</span>ta_rules <span class="free"><span class="bound"><span class="entity">TA</span></span></span><span class="main">)</span>"</span></span>
  <span class="comment1">― ‹Symbols occurring in rules›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">δ_symbols</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">==</span> rhsl<span class="main">`</span><span class="free"><span class="bound"><span class="entity">δ</span></span></span>"</span></span>

  <span class="comment1">― ‹Nondeterministic, finite tree automaton (NFTA)›</span>
<span class="keyword1"><span class="command">locale</span></span> tree_automaton <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">TA</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> tree_automaton_rec"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> finite_rules<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>ta_rules <span class="free">TA</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> finite_initial<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>ta_initial <span class="free">TA</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">Qi</span> <span class="main">==</span> ta_initial <span class="free">TA</span>"</span></span>
  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">δ</span> <span class="main">==</span> ta_rules <span class="free">TA</span>"</span></span>
  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="main">==</span> ta_rstates <span class="free">TA</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">"Acceptance"</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The predicate <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>accs δ t q›</span></span></span></span> is true, iff the tree <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>t›</span></span></span></span> is accepted
  in state <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>q›</span></span></span></span> w.r.t. the rules in <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>δ›</span></span></span></span>.
  
  A tree is accepted in state $q$, if it can be produced from $q$ using the 
  rules.
›</span></span>
<span class="keyword1"><span class="command">inductive</span></span> <span class="entity">accs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule set <span class="main">⇒</span> <span class="tfree">'L</span> tree <span class="main">⇒</span> <span class="tfree">'Q</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>
     <span class="main">(</span><span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">→</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">qs</span></span></span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span><span class="main">;</span> length <span class="free"><span class="bound"><span class="entity">ts</span></span></span> <span class="main">=</span> length <span class="free"><span class="bound"><span class="entity">qs</span></span></span><span class="main">;</span> 
     <span class="main">!!</span><span class="bound">i</span><span class="main">.</span> <span class="bound">i</span><span class="main">&lt;</span>length <span class="free"><span class="bound"><span class="entity">qs</span></span></span> <span class="main">⟹</span> <span class="free">accs</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ts</span></span></span> <span class="main">!</span> <span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">qs</span></span></span> <span class="main">!</span> <span class="bound">i</span><span class="main">)</span> 
   <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">accs</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">(</span>NODE <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span>"</span></span>


<span class="comment1">― ‹Characterization of <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> accs<span class="antiquote">}</span></span> using <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> list_all_zip<span class="antiquote">}</span></span>›</span>
<span class="keyword1"><span class="command">inductive</span></span> <span class="entity">accs_laz</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule set <span class="main">⇒</span> <span class="tfree">'L</span> tree <span class="main">⇒</span> <span class="tfree">'Q</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>
     <span class="main">(</span><span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">→</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">qs</span></span></span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span><span class="main">;</span> 
     list_all_zip <span class="main">(</span><span class="free">accs_laz</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span> <span class="free"><span class="bound"><span class="entity">qs</span></span></span>
   <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">accs_laz</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">(</span>NODE <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> accs_laz<span class="main">:</span> <span class="quoted"><span class="quoted">"accs <span class="main">=</span> accs_laz"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> accs.induct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> accs_laz.intros<span class="main"><span class="main">[</span></span><span class="operator">simplified</span> list_all_zip_alt<span class="main"><span class="main">]</span></span><span class="main">)</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> accs_laz.induct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> accs.intros <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list_all_zip_alt<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">"Language"</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The language of a tree automaton is the set of all trees that are accepted
  in an initial state.
›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ta_lang</span> <span class="free"><span class="bound"><span class="entity">TA</span></span></span> <span class="main">==</span> <span class="main">{</span> <span class="bound">t</span> <span class="main">.</span> <span class="main">∃</span><span class="bound">q</span><span class="main">∈</span>ta_initial <span class="free"><span class="bound"><span class="entity">TA</span></span></span><span class="main">.</span> accs <span class="main">(</span>ta_rules <span class="free"><span class="bound"><span class="entity">TA</span></span></span><span class="main">)</span> <span class="bound">t</span> <span class="bound">q</span> <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Basic Properties"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> rule_states_simp<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"rule_states <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">x</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">q</span> <span class="main">→</span> <span class="bound">l</span> <span class="bound">qs</span><span class="main">)</span> <span class="main">⇒</span> insert <span class="bound">q</span> <span class="main">(</span>set <span class="bound">qs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> rule_states_lhs<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lhs <span class="free">r</span> <span class="main">∈</span> rule_states <span class="free">r</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> ta_rule.split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rule_states_simp<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> rule_states_rhsq<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>rhsq <span class="free">r</span><span class="main">)</span> <span class="main">⊆</span> rule_states <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> ta_rule.split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rule_states_simp<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> rule_states_finite<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>rule_states <span class="free">r</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rule_states_simp <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> ta_rule.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> δ_statesI<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">q</span> <span class="main">→</span> <span class="free">l</span> <span class="free">qs</span><span class="main">)</span><span class="main">∈</span><span class="free">δ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">q</span><span class="main">∈</span>δ_states <span class="free">δ</span>"</span></span>
        <span class="quoted"><span class="quoted">"set <span class="free">qs</span> <span class="main">⊆</span> δ_states <span class="free">δ</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> A
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> δ_states_def<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> ta_rule.split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rule_states_simp<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> δ_statesI'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">(</span><span class="free">q</span> <span class="main">→</span> <span class="free">l</span> <span class="free">qs</span><span class="main">)</span><span class="main">∈</span><span class="free">δ</span><span class="main">;</span> <span class="free">qi</span><span class="main">∈</span>set <span class="free">qs</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">qi</span><span class="main">∈</span>δ_states <span class="free">δ</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> δ_statesI<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fast</span>

<span class="keyword1"><span class="command">lemma</span></span> δ_states_accsI<span class="main">:</span> <span class="quoted"><span class="quoted">"accs <span class="free">δ</span> <span class="free">n</span> <span class="free">q</span> <span class="main">⟹</span> <span class="free">q</span><span class="main">∈</span>δ_states <span class="free">δ</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> accs.cases <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> δ_statesI<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> δ_states_union<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"δ_states <span class="main">(</span><span class="free">δ</span><span class="main">∪</span><span class="free">δ'</span><span class="main">)</span> <span class="main">=</span> δ_states <span class="free">δ</span> <span class="main">∪</span> δ_states <span class="free">δ'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> δ_states_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> δ_states_insert<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"δ_states <span class="main">(</span>insert <span class="free">r</span> <span class="free">δ</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>rule_states <span class="free">r</span> <span class="main">∪</span> δ_states <span class="free">δ</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> δ_states_def<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> δ_states_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">δ</span> <span class="main">⊆</span> <span class="free">δ'</span><span class="main">⟧</span> <span class="main">⟹</span> δ_states <span class="free">δ</span> <span class="main">⊆</span> δ_states <span class="free">δ'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> δ_states_def<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> δ_states_finite<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">δ</span> <span class="main">⟹</span> finite <span class="main">(</span>δ_states <span class="free">δ</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> δ_states_def<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> δ_statesE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">q</span><span class="main">∈</span>δ_states <span class="free">Δ</span><span class="main">;</span>
    <span class="main">!!</span><span class="bound">f</span> <span class="bound">qs</span><span class="main">.</span> <span class="main">⟦</span> <span class="main">(</span><span class="free">q</span> <span class="main">→</span> <span class="bound">f</span> <span class="bound">qs</span><span class="main">)</span><span class="main">∈</span><span class="free">Δ</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span><span class="main">;</span>
    <span class="main">!!</span><span class="bound">ql</span> <span class="bound">f</span> <span class="bound">qs</span><span class="main">.</span> <span class="main">⟦</span> <span class="main">(</span><span class="bound">ql</span> <span class="main">→</span> <span class="bound">f</span> <span class="bound">qs</span><span class="main">)</span><span class="main">∈</span><span class="free">Δ</span><span class="main">;</span> <span class="free">q</span><span class="main">∈</span>set <span class="bound">qs</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span>
  <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> δ_states_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rule_states_simp <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> ta_rule.split_asm<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> δ_symbolsI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">q</span> <span class="main">→</span> <span class="free">f</span> <span class="free">qs</span><span class="main">)</span><span class="main">∈</span><span class="free">δ</span> <span class="main">⟹</span> <span class="free">f</span><span class="main">∈</span>δ_symbols <span class="free">δ</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> δ_symbols_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> δ_symbolsE<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">∈</span>δ_symbols <span class="free">δ</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">q</span> <span class="free">qs</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">q</span> <span class="main">→</span> <span class="free">f</span> <span class="free">qs</span><span class="main">)</span> <span class="main">∈</span> <span class="free">δ</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> A
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> δ_symbols_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> imageE<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> δ_symbols_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"δ_symbols <span class="main">{}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="quoted"><span class="quoted">"δ_symbols <span class="main">(</span>insert <span class="free">r</span> <span class="free">δ</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span>rhsl <span class="free">r</span><span class="main">)</span> <span class="main">(</span>δ_symbols <span class="free">δ</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"δ_symbols <span class="main">(</span><span class="free">δ</span><span class="main">∪</span><span class="free">δ'</span><span class="main">)</span> <span class="main">=</span> δ_symbols <span class="free">δ</span> <span class="main">∪</span> δ_symbols <span class="free">δ'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> δ_symbols_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> δ_symbols_finite<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"finite <span class="free">δ</span> <span class="main">⟹</span> finite <span class="main">(</span>δ_symbols <span class="free">δ</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> δ_symbols_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> accs_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>accs <span class="free">δ</span> <span class="free">n</span> <span class="free">q</span><span class="main">;</span> <span class="free">δ</span><span class="main">⊆</span><span class="free">δ'</span><span class="main">⟧</span> <span class="main">⟹</span> accs <span class="free">δ'</span> <span class="free">n</span> <span class="free">q</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> accs.induct<span class="main"><span class="main">[</span></span><span class="operator">case_names</span> step<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">q</span> <span class="skolem">l</span> <span class="skolem">qs</span> <span class="skolem">δ</span> <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> R'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">q</span> <span class="main">→</span> <span class="skolem">l</span> <span class="skolem">qs</span><span class="main">)</span> <span class="main">∈</span> <span class="free">δ'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> accs.intros<span class="main">[</span><span class="operator">OF</span> R' step.hyps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> 
       step.hyps<span class="main">(</span>4<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> _ step.prems<span class="main">]</span> 
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">context</span></span> tree_automaton
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> initial_subset<span class="main">:</span> <span class="quoted"><span class="quoted">"ta_initial <span class="free">TA</span> <span class="main">⊆</span> ta_rstates <span class="free">TA</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> ta_rstates_def<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">lemma</span></span> states_subset<span class="main">:</span> <span class="quoted"><span class="quoted">"δ_states <span class="main">(</span>ta_rules <span class="free">TA</span><span class="main">)</span> <span class="main">⊆</span> ta_rstates <span class="free">TA</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> ta_rstates_def<span class="main">)</span> <span class="operator">auto</span>
  
  <span class="keyword1"><span class="command">lemma</span></span> finite_states<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>ta_rstates <span class="free">TA</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ta_rstates_def δ_states_def 
             <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_rules finite_UN_I<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> finite_symbols<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>δ_symbols <span class="main">(</span>ta_rules <span class="free">TA</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command">lemmas</span></span> is_subset <span class="main">=</span> rev_subsetD<span class="main">[</span><span class="operator">OF</span> _ initial_subset<span class="main">]</span> 
                     rev_subsetD<span class="main">[</span><span class="operator">OF</span> _ states_subset<span class="main">]</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Other Classes of Tree Automata"</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">"Automata over Ranked Alphabets"</span></span>
  <span class="comment1">― ‹All trees over ranked alphabet›</span>
<span class="keyword1"><span class="command">inductive_set</span></span> <span class="entity">ranked_trees</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'L</span> <span class="main">⇀</span> nat<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'L</span> tree set"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="entity">A</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">∀</span><span class="bound">t</span><span class="main">∈</span>set <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">.</span> <span class="bound">t</span><span class="main">∈</span><span class="free">ranked_trees</span> <span class="free">A</span><span class="main">;</span> <span class="free">A</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> Some <span class="main">(</span>length <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">)</span> <span class="main">⟧</span> 
    <span class="main">⟹</span> NODE <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span> <span class="main">∈</span> <span class="free">ranked_trees</span> <span class="free">A</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> finite_alphabet <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'L</span> <span class="main">⇀</span> nat<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> A_finite<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>dom <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">F</span> <span class="main">==</span> dom <span class="free">A</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> finite_alphabet
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">legal_rules</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">==</span> <span class="main">{</span> <span class="main">(</span><span class="bound">q</span> <span class="main">→</span> <span class="bound">f</span> <span class="bound">qs</span><span class="main">)</span> <span class="main">|</span> <span class="bound">q</span> <span class="bound">f</span> <span class="bound">qs</span><span class="main">.</span>
    <span class="bound">q</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span>
    <span class="main">∧</span> <span class="bound">qs</span> <span class="main">∈</span> lists <span class="free"><span class="bound"><span class="entity">Q</span></span></span>
    <span class="main">∧</span> <span class="free">A</span> <span class="bound">f</span> <span class="main">=</span> Some <span class="main">(</span>length <span class="bound">qs</span><span class="main">)</span><span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> legal_rulesI<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span> 
      <span class="free">r</span><span class="main">∈</span><span class="free">δ</span><span class="main">;</span> 
      rule_states <span class="free">r</span> <span class="main">⊆</span> <span class="free">Q</span><span class="main">;</span> 
      <span class="free">A</span> <span class="main">(</span>rhsl <span class="free">r</span><span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span>length <span class="main">(</span>rhsq <span class="free">r</span><span class="main">)</span><span class="main">)</span> 
    <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">r</span><span class="main">∈</span>legal_rules <span class="free">Q</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> legal_rules_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">r</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">lemma</span></span> legal_rules_finite<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">Q</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> set"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">Q</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>legal_rules <span class="free">Q</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">possible_rules_f</span></span>
      <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">possible_rules_f</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">Q</span><span class="main">::</span><span class="tfree">'Q</span> set<span class="main">)</span> <span class="bound">f</span><span class="main">.</span> 
      <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">q</span><span class="main">,</span><span class="bound">qs</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">q</span> <span class="main">→</span> <span class="bound">f</span> <span class="bound">qs</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> <span class="main">(</span><span class="bound">Q</span> <span class="main">×</span> <span class="main">(</span>lists <span class="bound">Q</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">qs</span><span class="main">.</span> <span class="free">A</span> <span class="bound">f</span> <span class="main">=</span> Some <span class="main">(</span>length <span class="bound">qs</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"legal_rules <span class="free">Q</span> <span class="main">=</span> <span class="main">⋃</span><span class="main">(</span><span class="skolem">possible_rules_f</span> <span class="free">Q</span><span class="main">`</span>F<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> legal_rules_def possible_rules_f_def<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">!!</span><span class="bound">f</span><span class="main">.</span> finite <span class="main">(</span><span class="skolem">possible_rules_f</span> <span class="free">Q</span> <span class="bound">f</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> possible_rules_f_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> finite_imageI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> finite_SigmaI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="improper">f</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lists_of_len_fin<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

  <span class="comment1">― ‹Finite tree automata with ranked alphabet›</span>
<span class="keyword1"><span class="command">locale</span></span> ranked_tree_automaton <span class="main">=</span> 
  tree_automaton <span class="quoted"><span class="free">TA</span></span> <span class="main">+</span>
  finite_alphabet <span class="quoted"><span class="free">A</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">TA</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> tree_automaton_rec"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'L</span> <span class="main">⇀</span> nat"</span></span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ranked<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">q</span> <span class="main">→</span> <span class="free">f</span> <span class="free">qs</span><span class="main">)</span><span class="main">∈</span>δ <span class="main">⟹</span> <span class="free">A</span> <span class="free">f</span> <span class="main">=</span> Some <span class="main">(</span>length <span class="free">qs</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> rules_legal<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">r</span><span class="main">∈</span>δ <span class="main">⟹</span> <span class="free">r</span><span class="main">∈</span>legal_rules Q"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> legal_rulesI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ta_rstates_def δ_states_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="free">r</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ranked<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="comment1">― ‹Only well-ranked trees are accepted›</span>
  <span class="keyword1"><span class="command">lemma</span></span> accs_is_ranked<span class="main">:</span> <span class="quoted"><span class="quoted">"accs δ <span class="free">t</span> <span class="free">q</span> <span class="main">⟹</span> <span class="free">t</span><span class="main">∈</span>ranked_trees <span class="free">A</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="skolem">δ</span><span class="main"><span class="main">≡</span></span><span class="quoted">δ</span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">q</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> accs.induct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ranked_trees.intros<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_conv_nth ranked<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="comment1">― ‹The language consists of well-ranked trees›</span>
  <span class="keyword1"><span class="command">theorem</span></span> lang_is_ranked<span class="main">:</span> <span class="quoted"><span class="quoted">"ta_lang <span class="free">TA</span> <span class="main">⊆</span> ranked_trees <span class="free">A</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> accs_is_ranked <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ta_lang_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">"Deterministic Tree Automata"</span></span>

  <span class="comment1">― ‹Deterministic, (bottom-up) finite tree automaton (DFTA)›</span>
<span class="keyword1"><span class="command">locale</span></span> det_tree_automaton <span class="main">=</span> ranked_tree_automaton <span class="quoted"><span class="free">TA</span></span> <span class="quoted"><span class="free">A</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">TA</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> tree_automaton_rec"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">A</span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> deterministic<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="free">q</span> <span class="main">→</span> <span class="free">f</span> <span class="free">qs</span><span class="main">)</span><span class="main">∈</span>δ<span class="main">;</span> <span class="main">(</span><span class="free">q'</span> <span class="main">→</span> <span class="free">f</span> <span class="free">qs</span><span class="main">)</span><span class="main">∈</span>δ <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">q</span><span class="main">=</span><span class="free">q'</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">theorem</span></span> accs_unique<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> accs δ <span class="free">t</span> <span class="free">q</span><span class="main">;</span> accs δ <span class="free">t</span> <span class="free">q'</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">q</span><span class="main">=</span><span class="free">q'</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> accs_laz
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="skolem">δ</span><span class="main"><span class="main">≡</span></span><span class="quoted">δ</span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">q</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">q'</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> accs_laz.induct<span class="main"><span class="main">[</span></span><span class="operator">case_names</span> step<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">q</span> <span class="skolem">f</span> <span class="skolem">qs</span> <span class="skolem">ts</span> <span class="skolem">q'</span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> I<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">q</span> <span class="main">→</span> <span class="skolem">f</span> <span class="skolem">qs</span><span class="main">)</span> <span class="main">∈</span> δ"</span></span>
      <span class="quoted"><span class="quoted">"list_all_zip <span class="main">(</span>accs_laz δ<span class="main">)</span> <span class="skolem">ts</span> <span class="skolem">qs</span>"</span></span>
      <span class="quoted"><span class="quoted">"list_all_zip <span class="main">(</span><span class="main">λ</span><span class="bound">t</span> <span class="bound">q</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">q'</span><span class="main">.</span> accs_laz δ <span class="bound">t</span> <span class="bound">q'</span> <span class="main">⟶</span> <span class="bound">q</span><span class="main">=</span><span class="bound">q'</span><span class="main">)</span><span class="main">)</span> <span class="skolem">ts</span> <span class="skolem">qs</span>"</span></span>
      <span class="quoted"><span class="quoted">"accs_laz δ <span class="main">(</span>NODE <span class="skolem">f</span> <span class="skolem">ts</span><span class="main">)</span> <span class="skolem">q'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> I<span class="main">(</span>4<span class="main">)</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">qs'</span></span> <span class="keyword2"><span class="keyword">where</span></span> A'<span class="main">:</span>
      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">q'</span> <span class="main">→</span> <span class="skolem">f</span> <span class="skolem">qs'</span><span class="main">)</span> <span class="main">∈</span> δ"</span></span>
      <span class="quoted"><span class="quoted">"list_all_zip <span class="main">(</span>accs_laz δ<span class="main">)</span> <span class="skolem">ts</span> <span class="skolem">qs'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> accs_laz.cases<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> I<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span> A'<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"list_all_zip <span class="main">(=)</span> <span class="skolem">qs</span> <span class="skolem">qs'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list_all_zip_alt<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">qs</span><span class="main">=</span><span class="skolem">qs'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> laz_eq<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> deterministic<span class="main">[</span><span class="operator">OF</span> I<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">q'</span></span><span class="main">]</span> A'<span class="main">(</span>1<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span><span class="main">=</span><span class="skolem">q'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
    
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">"Complete Tree Automata"</span></span>

<span class="keyword1"><span class="command">locale</span></span> complete_tree_automaton <span class="main">=</span> det_tree_automaton <span class="quoted"><span class="free">TA</span></span> <span class="quoted"><span class="free">A</span></span> 
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">TA</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> tree_automaton_rec"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">A</span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> complete<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">qs</span><span class="main">∈</span>lists Q<span class="main">;</span> <span class="free">A</span> <span class="free">f</span> <span class="main">=</span> Some <span class="main">(</span>length <span class="free">qs</span><span class="main">)</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">q</span><span class="main">.</span> <span class="main">(</span><span class="bound">q</span> <span class="main">→</span> <span class="free">f</span> <span class="free">qs</span><span class="main">)</span><span class="main">∈</span>δ"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

    <span class="comment1">― ‹In a complete DFTA, all trees can be labeled by some state›</span>
  <span class="keyword1"><span class="command">theorem</span></span> label_all<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">t</span><span class="main">∈</span>ranked_trees <span class="free">A</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">q</span><span class="main">∈</span>Q<span class="main">.</span> accs δ <span class="free">t</span> <span class="bound">q</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> ranked_trees.induct<span class="main"><span class="main">[</span></span><span class="operator">case_names</span> constr<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>constr <span class="skolem">ts</span> <span class="skolem">f</span><span class="main">)</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">qs</span></span> <span class="keyword2"><span class="keyword">where</span></span> QS<span class="main">:</span>
      <span class="quoted"><span class="quoted">"<span class="skolem">qs</span><span class="main">∈</span>lists Q"</span></span>
      <span class="quoted"><span class="quoted">"list_all_zip <span class="main">(</span>accs δ<span class="main">)</span> <span class="skolem">ts</span> <span class="skolem">qs</span>"</span></span> 
      <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="skolem">qs</span> <span class="main">=</span> length <span class="skolem">ts</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">from</span></span> constr<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>length <span class="skolem">ts</span><span class="main">.</span> <span class="main">∃</span><span class="bound">q</span><span class="main">.</span> <span class="bound">q</span><span class="main">∈</span>Q <span class="main">∧</span> accs δ <span class="main">(</span><span class="skolem">ts</span><span class="main">!</span><span class="bound">i</span><span class="main">)</span> <span class="bound">q</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule_tac</span> obtain_list_from_elements<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> that<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list_all_zip_alt set_conv_nth<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> complete<span class="main">[</span><span class="operator">OF</span> QS<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> <span class="operator">OF</span> constr<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">q</span></span> 
      <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">q</span> <span class="main">→</span> <span class="skolem">f</span> <span class="skolem">qs</span><span class="main">)</span> <span class="main">∈</span>δ"</span></span> <span class="keyword1"><span class="command">..</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> accs_laz ta_rstates_def 
               <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> accs_laz.intros δ_statesI<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Algorithms"</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  In this section, basic algorithms on tree-automata are specified.
  The specification is a high-level, non-executable specification, intended
  to be refined to more low-level specifications, as done in 
  Sections~\ref{sec:absalgo} and \ref{sec:taimpl}.
›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">"Empty Automaton"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ta_empty</span> <span class="main">==</span> <span class="main">⦇</span> ta_initial <span class="main">=</span> <span class="main">{}</span><span class="main">,</span> ta_rules <span class="main">=</span> <span class="main">{}</span><span class="main">⦈</span>"</span></span>

<span class="keyword1"><span class="command">theorem</span></span> ta_empty_lang<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ta_lang ta_empty <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ta_empty_def ta_lang_def<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> ta_empty_ta<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"tree_automaton ta_empty"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> ta_empty_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">theorem</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> finite_alphabet<span class="main">)</span> ta_empty_rta<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"ranked_tree_automaton ta_empty <span class="free">A</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> ta_empty_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">theorem</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> finite_alphabet<span class="main">)</span> ta_empty_dta<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"det_tree_automaton ta_empty <span class="free">A</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> ta_empty_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">"Remapping of States"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">remap_rule</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">remap_rule</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">→</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">qs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">q</span></span></span><span class="main">)</span> <span class="main">→</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">(</span>map <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">qs</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">ta_remap</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">TA</span></span></span> <span class="main">==</span> <span class="main">⦇</span> ta_initial <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">`</span> ta_initial <span class="free"><span class="bound"><span class="entity">TA</span></span></span><span class="main">,</span> 
                      ta_rules <span class="main">=</span> remap_rule <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">`</span> ta_rules <span class="free"><span class="bound"><span class="entity">TA</span></span></span> 
                    <span class="main">⦈</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> δ_states_remap<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"δ_states <span class="main">(</span>remap_rule <span class="free">f</span> <span class="main">`</span> <span class="free">δ</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span><span class="main">`</span> δ_states <span class="free">δ</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> δ_states_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">a</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">xb</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> remap_accs1<span class="main">:</span> <span class="quoted"><span class="quoted">"accs <span class="free">δ</span> <span class="free">n</span> <span class="free">q</span> <span class="main">⟹</span> accs <span class="main">(</span>remap_rule <span class="free">f</span> <span class="main">`</span> <span class="free">δ</span><span class="main">)</span> <span class="free">n</span> <span class="main">(</span><span class="free">f</span> <span class="free">q</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> accs.induct<span class="main"><span class="main">[</span></span><span class="operator">case_names</span> step<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">q</span> <span class="skolem">l</span> <span class="skolem">qs</span> <span class="skolem">δ</span> <span class="skolem">ts</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> step.hyps<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">f</span> <span class="skolem">q</span><span class="main">)</span> <span class="main">→</span> <span class="skolem">l</span> <span class="main">(</span>map <span class="free">f</span> <span class="skolem">qs</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> remap_rule <span class="free">f</span> <span class="main">`</span> <span class="skolem">δ</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">drule_tac</span> f<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"remap_rule <span class="free">f</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> imageI<span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> accs.intros<span class="main"><span class="main">[</span></span><span class="operator">OF</span> 1<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">&lt;</span>length <span class="main">(</span>map <span class="free">f</span> <span class="skolem">qs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> step.hyps<span class="main">(</span>4<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"accs <span class="main">(</span>remap_rule <span class="free">f</span> <span class="main">`</span> <span class="skolem">δ</span><span class="main">)</span> <span class="main">(</span><span class="skolem">ts</span> <span class="main">!</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">(</span>map <span class="free">f</span> <span class="skolem">qs</span> <span class="main">!</span> <span class="skolem">i</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> step.hyps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> remap_lang1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">t</span><span class="main">∈</span>ta_lang <span class="free">TA</span> <span class="main">⟹</span> <span class="free">t</span><span class="main">∈</span>ta_lang <span class="main">(</span>ta_remap <span class="free">f</span> <span class="free">TA</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> ta_lang_def ta_remap_def<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> remap_accs1<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> remap_accs2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> 
    accs <span class="free">δ'</span> <span class="free">n</span> <span class="free">q'</span><span class="main">;</span> 
    <span class="free">δ'</span><span class="main">=</span><span class="main">(</span>remap_rule <span class="free">f</span> <span class="main">`</span> <span class="free">δ</span><span class="main">)</span><span class="main">;</span> 
    <span class="free">q'</span><span class="main">=</span><span class="free">f</span> <span class="free">q</span><span class="main">;</span> 
    inj_on <span class="free">f</span> <span class="free">Q</span><span class="main">;</span> 
    <span class="free">q</span><span class="main">∈</span><span class="free">Q</span><span class="main">;</span> 
    δ_states <span class="free">δ</span> <span class="main">⊆</span> <span class="free">Q</span> 
  <span class="main">⟧</span> <span class="main">⟹</span> accs <span class="free">δ</span> <span class="free">n</span> <span class="free">q</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">δ</span></span> <span class="quoted"><span class="free">q</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> accs.induct<span class="main"><span class="main">[</span></span><span class="operator">case_names</span> step<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">q'</span> <span class="skolem">l</span> <span class="skolem">qs</span> <span class="skolem">δ'</span> <span class="skolem">ts</span> <span class="skolem">δ</span> <span class="skolem">q</span><span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> step.prems<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> step.hyps<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">simplified</span><span class="main">]</span> step.prems<span class="main">(</span>3<span class="main">,</span>4<span class="main">,</span>5<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> 
    R<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">q</span> <span class="main">→</span> <span class="skolem">l</span> <span class="main">(</span>map <span class="main">(</span>inv_on <span class="free">f</span> <span class="free">Q</span><span class="main">)</span> <span class="skolem">qs</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span><span class="skolem">δ</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule_tac</span> imageE<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span>map_map<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> inj_on_map_inv_f<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> δ_statesI<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span><span class="main">∈</span>δ_states <span class="skolem">δ</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> inj_on_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> δ_statesI<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> contra_subsetD<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> δ_statesI<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> inj_onD<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> accs.intros<span class="main"><span class="main">[</span></span><span class="operator">OF</span> R<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> 
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> length <span class="main">(</span>map <span class="main">(</span>inv_on <span class="free">f</span> <span class="free">Q</span><span class="main">)</span> <span class="skolem">qs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> L<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">&lt;</span>length <span class="skolem">qs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">from</span></span> step.hyps<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">simplified</span><span class="main">]</span> step.prems<span class="main">(</span>5<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> 
      IR<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">!!</span><span class="bound">i</span><span class="main">.</span> <span class="bound">i</span><span class="main">&lt;</span>length <span class="skolem">qs</span> <span class="main">⟹</span> <span class="skolem">qs</span><span class="main">!</span><span class="bound">i</span> <span class="main">∈</span> <span class="free">f</span> <span class="main">`</span> <span class="free">Q</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> list<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="improper">list</span><span class="main">!</span><span class="improper">i</span> <span class="main">∈</span> δ_states <span class="skolem">δ</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> δ_statesI<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"accs <span class="skolem">δ</span> <span class="main">(</span><span class="skolem">ts</span> <span class="main">!</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">(</span>map <span class="main">(</span>inv_on <span class="free">f</span> <span class="free">Q</span><span class="main">)</span> <span class="skolem">qs</span> <span class="main">!</span> <span class="skolem">i</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> step.hyps<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> L<span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> f_inv_on_f<span class="main"><span class="main">[</span></span><span class="operator">OF</span> IR<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> L<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span> 
                      inv_on_f_range<span class="main"><span class="main">[</span></span><span class="operator">OF</span> IR<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> L<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span> 
                      L step.prems<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">,</span></span>5<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> step.hyps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> tree_automaton<span class="main">)</span> remap_lang2<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"inj_on <span class="free">f</span> <span class="main">(</span>ta_rstates <span class="free">TA</span><span class="main">)</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span><span class="main">∈</span>ta_lang <span class="main">(</span>ta_remap <span class="free">f</span> <span class="free">TA</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">t</span><span class="main">∈</span>ta_lang <span class="free">TA</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> ta_lang_def ta_remap_def<span class="main">)</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> bexI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> remap_accs2<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ _ _ I<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> is_subset<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">theorem</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> tree_automaton<span class="main">)</span> remap_lang<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"inj_on <span class="free">f</span> <span class="main">(</span>ta_rstates <span class="free">TA</span><span class="main">)</span> <span class="main">⟹</span> ta_lang <span class="main">(</span>ta_remap <span class="free">f</span> <span class="free">TA</span><span class="main">)</span> <span class="main">=</span> ta_lang <span class="free">TA</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> remap_lang1 remap_lang2<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> tree_automaton<span class="main">)</span> remap_ta<span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"tree_automaton <span class="main">(</span>ta_remap <span class="free">f</span> <span class="free">TA</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> initial_subset states_subset finite_states finite_rules
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ta_remap_def ta_rstates_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> ranked_tree_automaton<span class="main">)</span> remap_rta<span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ranked_tree_automaton <span class="main">(</span>ta_remap <span class="free">f</span> <span class="free">TA</span><span class="main">)</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> ta<span class="main">:</span> tree_automaton <span class="quoted"><span class="quoted">"<span class="main">(</span>ta_remap <span class="free">f</span> <span class="free">TA</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ta_remap_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ta_remap_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ranked<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> det_tree_automaton<span class="main">)</span> remap_dta<span class="main">[</span><span class="operator">intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> INJ<span class="main">:</span> <span class="quoted"><span class="quoted">"inj_on <span class="free">f</span> Q"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"det_tree_automaton <span class="main">(</span>ta_remap <span class="free">f</span> <span class="free">TA</span><span class="main">)</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> ta<span class="main">:</span> ranked_tree_automaton <span class="quoted"><span class="quoted">"<span class="main">(</span>ta_remap <span class="free">f</span> <span class="free">TA</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="free">A</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">q</span> <span class="skolem">q'</span> <span class="skolem">l</span> <span class="skolem">qs</span>
    <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">q</span> <span class="main">→</span> <span class="skolem">l</span> <span class="skolem">qs</span><span class="main">)</span> <span class="main">∈</span>ta_rules <span class="main">(</span>ta_remap <span class="free">f</span> <span class="free">TA</span><span class="main">)</span>"</span></span>
      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">q'</span> <span class="main">→</span> <span class="skolem">l</span> <span class="skolem">qs</span><span class="main">)</span> <span class="main">∈</span>ta_rules <span class="main">(</span>ta_remap <span class="free">f</span> <span class="free">TA</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">qo</span></span> <span class="skolem"><span class="skolem">qo'</span></span> <span class="skolem"><span class="skolem">qso</span></span> <span class="skolem"><span class="skolem">qso'</span></span> <span class="keyword2"><span class="keyword">where</span></span> RO<span class="main">:</span>
      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">qo</span> <span class="main">→</span> <span class="skolem">l</span> <span class="skolem">qso</span><span class="main">)</span> <span class="main">∈</span> δ"</span></span>
      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">qo'</span> <span class="main">→</span> <span class="skolem">l</span> <span class="skolem">qso'</span><span class="main">)</span> <span class="main">∈</span> δ"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
      <span class="quoted"><span class="quoted">"<span class="skolem">q</span><span class="main">=</span><span class="free">f</span> <span class="skolem">qo</span>"</span></span>
      <span class="quoted"><span class="quoted">"<span class="skolem">q'</span><span class="main">=</span><span class="free">f</span> <span class="skolem">qo'</span>"</span></span>
      <span class="quoted"><span class="quoted">"<span class="skolem">qs</span> <span class="main">=</span> map <span class="free">f</span> <span class="skolem">qso</span>"</span></span>
      <span class="quoted"><span class="quoted">"map <span class="free">f</span> <span class="skolem">qso</span> <span class="main">=</span> map <span class="free">f</span> <span class="skolem">qso'</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ta_remap_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">xa</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">from</span></span> RO <span class="keyword1"><span class="command">have</span></span> OQ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">qo</span><span class="main">∈</span>Q"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">qo'</span><span class="main">∈</span>Q"</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">qso</span> <span class="main">⊆</span> Q"</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">qso'</span> <span class="main">⊆</span> Q"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> ta_rstates_def<span class="main">)</span>
         <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> δ_statesI<span class="main">)</span>
    
    <span class="keyword1"><span class="command">from</span></span> OQ<span class="main">(</span>3<span class="main">,</span>4<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> INJQSO<span class="main">:</span> <span class="quoted"><span class="quoted">"inj_on <span class="free">f</span> <span class="main">(</span>set <span class="skolem">qso</span> <span class="main">∪</span> set <span class="skolem">qso'</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> subset_inj_on<span class="main"><span class="main">[</span></span><span class="operator">OF</span> INJ<span class="main"><span class="main">]</span></span><span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> inj_on_map_eq_map<span class="main">[</span><span class="operator">OF</span> INJQSO<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">qso</span><span class="main">=</span><span class="skolem">qso'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> deterministic<span class="main">[</span><span class="operator">OF</span> RO<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> RO<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">qo</span><span class="main">=</span><span class="skolem">qo'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span><span class="main">=</span><span class="skolem">q'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

  
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> complete_tree_automaton<span class="main">)</span> remap_cta<span class="main">[</span><span class="operator">intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> INJ<span class="main">:</span> <span class="quoted"><span class="quoted">"inj_on <span class="free">f</span> Q"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"complete_tree_automaton <span class="main">(</span>ta_remap <span class="free">f</span> <span class="free">TA</span><span class="main">)</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> ta<span class="main">:</span> det_tree_automaton <span class="quoted"><span class="quoted">"<span class="main">(</span>ta_remap <span class="free">f</span> <span class="free">TA</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="free">A</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> INJ<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">qs</span> <span class="skolem">l</span>
    <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span>
      <span class="quoted"><span class="quoted">"<span class="skolem">qs</span> <span class="main">∈</span> lists <span class="main">(</span>ta_rstates <span class="main">(</span>ta_remap <span class="free">f</span> <span class="free">TA</span><span class="main">)</span><span class="main">)</span>"</span></span> 
      <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="skolem">l</span> <span class="main">=</span> Some <span class="main">(</span>length <span class="skolem">qs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> A<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">qs</span><span class="main">∈</span>lists <span class="main">(</span><span class="free">f</span><span class="main">`</span>Q<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ta_rstates_def ta_remap_def<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">qso</span></span> <span class="keyword2"><span class="keyword">where</span></span> QSO<span class="main">:</span>
      <span class="quoted"><span class="quoted">"<span class="skolem">qso</span><span class="main">∈</span>lists Q"</span></span>
      <span class="quoted"><span class="quoted">"<span class="skolem">qs</span> <span class="main">=</span> map <span class="free">f</span> <span class="skolem">qso</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> lists_image_witness<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="skolem">qso</span> <span class="main">=</span> length <span class="skolem">qs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">from</span></span> complete<span class="main">[</span><span class="operator">OF</span> QSO<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> A<span class="main">(</span>2<span class="main">)</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">qo</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">qo</span> <span class="main">→</span> <span class="skolem">l</span> <span class="skolem">qso</span><span class="main">)</span> <span class="main">∈</span> δ"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    
    <span class="keyword1"><span class="command">with</span></span> QSO<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">f</span> <span class="skolem">qo</span><span class="main">)</span> <span class="main">→</span> <span class="skolem">l</span> <span class="skolem">qs</span><span class="main">)</span><span class="main">∈</span>ta_rules <span class="main">(</span>ta_remap <span class="free">f</span> <span class="free">TA</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ta_remap_def<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">q</span><span class="main">.</span> <span class="bound">q</span> <span class="main">→</span> <span class="skolem">l</span> <span class="skolem">qs</span> <span class="main">∈</span> ta_rules <span class="main">(</span>ta_remap <span class="free">f</span> <span class="free">TA</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">"Union"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ta_union</span> <span class="free"><span class="bound"><span class="entity">TA</span></span></span> <span class="free"><span class="bound"><span class="entity">TA'</span></span></span> <span class="main">==</span> 
  <span class="main">⦇</span> ta_initial <span class="main">=</span> ta_initial <span class="free"><span class="bound"><span class="entity">TA</span></span></span> <span class="main">∪</span> ta_initial <span class="free"><span class="bound"><span class="entity">TA'</span></span></span><span class="main">,</span> 
    ta_rules <span class="main">=</span> ta_rules <span class="free"><span class="bound"><span class="entity">TA</span></span></span> <span class="main">∪</span> ta_rules <span class="free"><span class="bound"><span class="entity">TA'</span></span></span> 
  <span class="main">⦈</span>"</span></span>

<span class="comment1">― ‹Given two disjoint sets of states, where no rule contains states from
  both sets, then any accepted tree is also accepted when only using one of the 
  subsets of states and rules. 
  This lemma and its corollaries capture the basic idea of 
  the union-algorithm.›</span>
<span class="keyword1"><span class="command">lemma</span></span> accs_exclusive_aux<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> accs <span class="free">δn</span> <span class="free">n</span> <span class="free">q</span><span class="main">;</span> <span class="free">δn</span><span class="main">=</span><span class="free">δ</span><span class="main">∪</span><span class="free">δ'</span><span class="main">;</span> δ_states <span class="free">δ</span> <span class="main">∩</span> δ_states <span class="free">δ'</span> <span class="main">=</span> <span class="main">{}</span><span class="main">;</span> <span class="free">q</span><span class="main">∈</span>δ_states <span class="free">δ</span> <span class="main">⟧</span> 
   <span class="main">⟹</span> accs <span class="free">δ</span> <span class="free">n</span> <span class="free">q</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">δ</span></span> <span class="quoted"><span class="free">δ'</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> accs.induct<span class="main"><span class="main">[</span></span><span class="operator">case_names</span> step<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">q</span> <span class="skolem">l</span> <span class="skolem">qs</span> <span class="skolem">δn</span> <span class="skolem">ts</span> <span class="skolem">δ</span> <span class="skolem">δ'</span><span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> step.prems<span class="main">(</span>1<span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> step.hyps<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> step.hyps<span class="main">(</span>3<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> step.prems <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span><span class="main">∉</span>δ_states <span class="skolem">δ'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">with</span></span> step.hyps<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">qs</span> <span class="main">⊆</span> δ_states <span class="skolem">δ</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> R<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">q</span> <span class="main">→</span> <span class="skolem">l</span> <span class="skolem">qs</span><span class="main">)</span><span class="main">∈</span><span class="skolem">δ</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> δ_statesI<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">!!</span><span class="bound">i</span><span class="main">.</span> <span class="bound">i</span><span class="main">&lt;</span>length <span class="skolem">qs</span> <span class="main">⟹</span> accs <span class="skolem">δ</span> <span class="main">(</span><span class="skolem">ts</span> <span class="main">!</span> <span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="skolem">qs</span> <span class="main">!</span> <span class="bound">i</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> step.hyps<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ step.prems<span class="main"><span class="main"><span class="main">(</span></span></span>1<span class="main"><span class="main"><span class="main">,</span></span></span>2<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> accs.intros<span class="main">[</span><span class="operator">OF</span> R step.hyps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">corollary</span></span> accs_exclusive1<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> accs <span class="main">(</span><span class="free">δ</span><span class="main">∪</span><span class="free">δ'</span><span class="main">)</span> <span class="free">n</span> <span class="free">q</span><span class="main">;</span> δ_states <span class="free">δ</span> <span class="main">∩</span> δ_states <span class="free">δ'</span> <span class="main">=</span> <span class="main">{}</span><span class="main">;</span> <span class="free">q</span><span class="main">∈</span>δ_states <span class="free">δ</span> <span class="main">⟧</span> 
   <span class="main">⟹</span> accs <span class="free">δ</span> <span class="free">n</span> <span class="free">q</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> accs_exclusive_aux<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">q</span></span> <span class="quoted"><span class="free">δ</span></span> <span class="quoted"><span class="free">δ'</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">corollary</span></span> accs_exclusive2<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> accs <span class="main">(</span><span class="free">δ</span><span class="main">∪</span><span class="free">δ'</span><span class="main">)</span> <span class="free">n</span> <span class="free">q</span><span class="main">;</span> δ_states <span class="free">δ</span> <span class="main">∩</span> δ_states <span class="free">δ'</span> <span class="main">=</span> <span class="main">{}</span><span class="main">;</span> <span class="free">q</span><span class="main">∈</span>δ_states <span class="free">δ'</span> <span class="main">⟧</span> 
   <span class="main">⟹</span> accs <span class="free">δ'</span> <span class="free">n</span> <span class="free">q</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> accs_exclusive_aux<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">q</span></span> <span class="quoted"><span class="free">δ'</span></span> <span class="quoted"><span class="free">δ</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> ta_union_correct_aux1<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">TA</span> <span class="free">TA'</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> TA<span class="main">:</span> <span class="quoted"><span class="quoted">"tree_automaton <span class="free">TA</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> TA'<span class="main">:</span> <span class="quoted"><span class="quoted">"tree_automaton <span class="free">TA'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> DJ<span class="main">:</span> <span class="quoted"><span class="quoted">"ta_rstates <span class="free">TA</span> <span class="main">∩</span> ta_rstates <span class="free">TA'</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ta_lang <span class="main">(</span>ta_union <span class="free">TA</span> <span class="free">TA'</span><span class="main">)</span> <span class="main">=</span> ta_lang <span class="free">TA</span> <span class="main">∪</span> ta_lang <span class="free">TA'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">safe</span><span class="main">)</span>
  <span class="keyword1"><span class="command">interpret</span></span> ta<span class="main">:</span> tree_automaton <span class="quoted"><span class="free">TA</span></span> <span class="keyword1"><span class="command">using</span></span> TA <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> ta'<span class="main">:</span> tree_automaton <span class="quoted"><span class="free">TA'</span></span> <span class="keyword1"><span class="command">using</span></span> TA' <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">from</span></span> DJ ta.states_subset ta'.states_subset <span class="keyword1"><span class="command">have</span></span> 
    DJ'<span class="main">:</span> <span class="quoted"><span class="quoted">"δ_states <span class="main">(</span>ta_rules <span class="free">TA</span><span class="main">)</span> <span class="main">∩</span> δ_states <span class="main">(</span>ta_rules <span class="free">TA'</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span>
  <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">∈</span> ta_lang <span class="main">(</span>ta_union <span class="free">TA</span> <span class="free">TA'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">∉</span> ta_lang <span class="free">TA'</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> A<span class="main">(</span>1<span class="main">)</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">q</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    B<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span><span class="main">∈</span>ta_initial <span class="free">TA</span> <span class="main">∪</span> ta_initial <span class="free">TA'</span>"</span></span> 
       <span class="quoted"><span class="quoted">"accs <span class="main">(</span>ta_rules <span class="free">TA</span> <span class="main">∪</span> ta_rules <span class="free">TA'</span><span class="main">)</span> <span class="skolem">n</span> <span class="skolem">q</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ta_lang_def ta_union_def<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> δ_states_accsI<span class="main">[</span><span class="operator">OF</span> B<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span><span class="main">∈</span>ta_lang <span class="free">TA</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">assume</span></span> C<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span><span class="main">∈</span>δ_states <span class="main">(</span>ta_rules <span class="free">TA</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> accs_exclusive1<span class="main">[</span><span class="operator">OF</span> B<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> DJ'<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"accs <span class="main">(</span>ta_rules <span class="free">TA</span><span class="main">)</span> <span class="skolem">n</span> <span class="skolem">q</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> DJ C ta'.initial_subset ta.states_subset B<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> 
      <span class="quoted"><span class="quoted">"<span class="skolem">q</span><span class="main">∈</span>ta_initial <span class="free">TA</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> ta_lang_def<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> C<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span><span class="main">∈</span>δ_states <span class="main">(</span>ta_rules <span class="free">TA'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> accs_exclusive2<span class="main">[</span><span class="operator">OF</span> B<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> DJ'<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"accs <span class="main">(</span>ta_rules <span class="free">TA'</span><span class="main">)</span> <span class="skolem">n</span> <span class="skolem">q</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> DJ C ta.initial_subset B<span class="main">(</span>1<span class="main">)</span> ta'.states_subset <span class="keyword1"><span class="command">have</span></span> 
      <span class="quoted"><span class="quoted">"<span class="skolem">q</span><span class="main">∈</span>ta_initial <span class="free">TA'</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> A<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> ta_lang_def<span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">unfold</span> ta_lang_def ta_union_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> accs_mono<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ta_union_correct_aux2<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">TA</span> <span class="free">TA'</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> TA<span class="main">:</span> <span class="quoted"><span class="quoted">"tree_automaton <span class="free">TA</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> TA'<span class="main">:</span> <span class="quoted"><span class="quoted">"tree_automaton <span class="free">TA'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"tree_automaton <span class="main">(</span>ta_union <span class="free">TA</span> <span class="free">TA'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> ta<span class="main">:</span> tree_automaton <span class="quoted"><span class="free">TA</span></span> <span class="keyword1"><span class="command">using</span></span> TA <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> ta'<span class="main">:</span> tree_automaton <span class="quoted"><span class="free">TA'</span></span> <span class="keyword1"><span class="command">using</span></span> TA' <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> ta_union_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

  <span class="comment1">― ‹If the sets of states are disjoint, the language of the union-automaton
    is the union of the languages of the original automata.›</span>
<span class="keyword1"><span class="command">theorem</span></span> ta_union_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">TA</span> <span class="free">TA'</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> TA<span class="main">:</span> <span class="quoted"><span class="quoted">"tree_automaton <span class="free">TA</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> TA'<span class="main">:</span> <span class="quoted"><span class="quoted">"tree_automaton <span class="free">TA'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> DJ<span class="main">:</span> <span class="quoted"><span class="quoted">"ta_rstates <span class="free">TA</span> <span class="main">∩</span> ta_rstates <span class="free">TA'</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ta_lang <span class="main">(</span>ta_union <span class="free">TA</span> <span class="free">TA'</span><span class="main">)</span> <span class="main">=</span> ta_lang <span class="free">TA</span> <span class="main">∪</span> ta_lang <span class="free">TA'</span>"</span></span>
        <span class="quoted"><span class="quoted">"tree_automaton <span class="main">(</span>ta_union <span class="free">TA</span> <span class="free">TA'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> ta_union_correct_aux1<span class="main">[</span><span class="operator">OF</span> TA TA' DJ<span class="main">]</span>
        ta_union_correct_aux2<span class="main">[</span><span class="operator">OF</span> TA TA'<span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> ta_union_rta<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">TA</span> <span class="free">TA'</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> TA<span class="main">:</span> <span class="quoted"><span class="quoted">"ranked_tree_automaton <span class="free">TA</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> TA'<span class="main">:</span> <span class="quoted"><span class="quoted">"ranked_tree_automaton <span class="free">TA'</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ranked_tree_automaton <span class="main">(</span>ta_union <span class="free">TA</span> <span class="free">TA'</span><span class="main">)</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> ta<span class="main">:</span> ranked_tree_automaton <span class="quoted"><span class="free">TA</span></span> <span class="quoted"><span class="free">A</span></span> <span class="keyword1"><span class="command">using</span></span> TA <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> ta'<span class="main">:</span> ranked_tree_automaton <span class="quoted"><span class="free">TA'</span></span> <span class="quoted"><span class="free">A</span></span> <span class="keyword1"><span class="command">using</span></span> TA' <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> ta_union_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ta.ranked ta'.ranked<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">"The union-algorithm may wrap the states of the first and second automaton 
      in order to make them disjoint"</span></span>
<span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span><span class="tfree">'q1</span><span class="main">,</span><span class="tfree">'q2</span><span class="main">)</span> ustate_wrapper <span class="main">=</span> USW1 <span class="tfree"><span class="quoted"><span class="tfree">'q1</span></span></span> <span class="main">|</span> USW2 <span class="tfree"><span class="quoted"><span class="tfree">'q2</span></span></span> 

<span class="keyword1"><span class="command">lemma</span></span> usw_disjoint<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"USW1 <span class="main">`</span> <span class="free">X</span> <span class="main">∩</span> USW2 <span class="main">`</span> <span class="free">Y</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="quoted"><span class="quoted">"remap_rule USW1 <span class="main">`</span> <span class="free">X</span> <span class="main">∩</span> remap_rule USW2 <span class="main">`</span> <span class="free">Y</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">xa</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">xb</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> states_usw_disjoint<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"ta_rstates <span class="main">(</span>ta_remap USW1 <span class="free">X</span><span class="main">)</span> <span class="main">∩</span> ta_rstates <span class="main">(</span>ta_remap USW2 <span class="free">Y</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ta_remap_def ta_rstates_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> usw_inj_on<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"inj_on USW1 <span class="free">X</span>"</span></span> 
  <span class="quoted"><span class="quoted">"inj_on USW2 <span class="free">X</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> inj_onI<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ta_union_wrap</span> <span class="free"><span class="bound"><span class="entity">TA</span></span></span> <span class="free"><span class="bound"><span class="entity">TA'</span></span></span> <span class="main">=</span> 
  ta_union <span class="main">(</span>ta_remap USW1 <span class="free"><span class="bound"><span class="entity">TA</span></span></span><span class="main">)</span> <span class="main">(</span>ta_remap USW2 <span class="free"><span class="bound"><span class="entity">TA'</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ta_union_wrap_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">TA</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q1</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> tree_automaton_rec"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">TA'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q2</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> tree_automaton_rec"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> TA<span class="main">:</span> <span class="quoted"><span class="quoted">"tree_automaton <span class="free">TA</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> TA'<span class="main">:</span> <span class="quoted"><span class="quoted">"tree_automaton <span class="free">TA'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ta_lang <span class="main">(</span>ta_union_wrap <span class="free">TA</span> <span class="free">TA'</span><span class="main">)</span> <span class="main">=</span> ta_lang <span class="free">TA</span> <span class="main">∪</span> ta_lang <span class="free">TA'</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T1</span></span></span><span class="main">)</span>
        <span class="quoted"><span class="quoted">"tree_automaton <span class="main">(</span>ta_union_wrap <span class="free">TA</span> <span class="free">TA'</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T2</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> a1<span class="main">:</span> tree_automaton <span class="quoted"><span class="free">TA</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword1"><span class="command">interpret</span></span> a2<span class="main">:</span> tree_automaton <span class="quoted"><span class="free">TA'</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?T1</span></span></span> <span class="var"><span class="quoted"><span class="var">?T2</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> ta_union_wrap_def<span class="main">)</span>
       <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ta_union_correct a1.remap_lang a2.remap_lang<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ta_union_wrap_rta<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">TA</span> <span class="free">TA'</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> TA<span class="main">:</span> <span class="quoted"><span class="quoted">"ranked_tree_automaton <span class="free">TA</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> TA'<span class="main">:</span> <span class="quoted"><span class="quoted">"ranked_tree_automaton <span class="free">TA'</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ranked_tree_automaton <span class="main">(</span>ta_union_wrap <span class="free">TA</span> <span class="free">TA'</span><span class="main">)</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> ta<span class="main">:</span> ranked_tree_automaton <span class="quoted"><span class="free">TA</span></span> <span class="quoted"><span class="free">A</span></span> <span class="keyword1"><span class="command">using</span></span> TA <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> ta'<span class="main">:</span> ranked_tree_automaton <span class="quoted"><span class="free">TA'</span></span> <span class="quoted"><span class="free">A</span></span> <span class="keyword1"><span class="command">using</span></span> TA' <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> ta_union_wrap_def<span class="main">)</span>
       <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ta_union_rta<span class="main">)</span>

<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">"Reduction"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">reduce_rules</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">==</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">∩</span> <span class="main">{</span> <span class="bound">r</span><span class="main">.</span> rule_states <span class="bound">r</span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> reduce_rulesI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">r</span><span class="main">∈</span><span class="free">δ</span><span class="main">;</span> rule_states <span class="free">r</span> <span class="main">⊆</span> <span class="free">P</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">r</span><span class="main">∈</span>reduce_rules <span class="free">δ</span> <span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> reduce_rules_def<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> reduce_rulesD<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">r</span><span class="main">∈</span>reduce_rules <span class="free">δ</span> <span class="free">P</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">r</span><span class="main">∈</span><span class="free">δ</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">r</span><span class="main">∈</span>reduce_rules <span class="free">δ</span> <span class="free">P</span><span class="main">;</span> <span class="free">q</span><span class="main">∈</span>rule_states <span class="free">r</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">q</span><span class="main">∈</span><span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> reduce_rules_def<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> reduce_rules_subset<span class="main">:</span> <span class="quoted"><span class="quoted">"reduce_rules <span class="free">δ</span> <span class="free">P</span> <span class="main">⊆</span> <span class="free">δ</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> reduce_rules_def<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> reduce_rules_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">⊆</span> <span class="free">P'</span> <span class="main">⟹</span> reduce_rules <span class="free">δ</span> <span class="free">P</span> <span class="main">⊆</span> reduce_rules <span class="free">δ</span> <span class="free">P'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> reduce_rules_def<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> δ_states_reduce_subset<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"δ_states <span class="main">(</span>reduce_rules <span class="free">δ</span> <span class="free">Q</span><span class="main">)</span> <span class="main">⊆</span> δ_states <span class="free">δ</span> <span class="main">∩</span> <span class="free">Q</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> δ_states_def reduce_rules_def<span class="main">)</span>
    <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemmas</span></span> δ_states_reduce_subsetI <span class="main">=</span> rev_subsetD<span class="main">[</span><span class="operator">OF</span> _ δ_states_reduce_subset<span class="main">]</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ta_reduce</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> tree_automaton_rec <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q</span> set<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> tree_automaton_rec"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ta_reduce</span> <span class="free"><span class="bound"><span class="entity">TA</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">==</span>
    <span class="main">⦇</span> ta_initial <span class="main">=</span> ta_initial <span class="free"><span class="bound"><span class="entity">TA</span></span></span> <span class="main">∩</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span><span class="main">,</span>
      ta_rules <span class="main">=</span> reduce_rules <span class="main">(</span>ta_rules <span class="free"><span class="bound"><span class="entity">TA</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">⦈</span>"</span></span>

<span class="comment1">― ‹Reducing a tree automaton preserves the tree automata invariants›</span>
<span class="keyword1"><span class="command">theorem</span></span> ta_reduce_inv<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"tree_automaton <span class="free">TA</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"tree_automaton <span class="main">(</span>ta_reduce <span class="free">TA</span> <span class="free">P</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> tree_automaton <span class="quoted"><span class="free">TA</span></span> <span class="keyword1"><span class="command">using</span></span> A <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>ta_rules <span class="main">(</span>ta_reduce <span class="free">TA</span> <span class="free">P</span><span class="main">)</span><span class="main">)</span>"</span></span> 
         <span class="quoted"><span class="quoted">"finite <span class="main">(</span>ta_initial <span class="main">(</span>ta_reduce <span class="free">TA</span> <span class="free">P</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> finite_states finite_rules finite_subset<span class="main">[</span><span class="operator">OF</span> reduce_rules_subset<span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> ta_reduce_def<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>
 
<span class="keyword1"><span class="command">lemma</span></span> reduce_δ_states_rules<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>ta_rules <span class="main">(</span>ta_reduce <span class="free">TA</span> <span class="main">(</span>δ_states <span class="main">(</span>ta_rules <span class="free">TA</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> ta_rules <span class="free">TA</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ta_reduce_def δ_states_def reduce_rules_def<span class="main">)</span>

<span class="comment1">― ‹Reducing a tree automaton to the states that occur in its rules does 
      not change its language›</span>
<span class="keyword1"><span class="command">lemma</span></span> ta_reduce_δ_states<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"ta_lang <span class="main">(</span>ta_reduce <span class="free">TA</span> <span class="main">(</span>δ_states <span class="main">(</span>ta_rules <span class="free">TA</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> ta_lang <span class="free">TA</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ta_lang_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> δ_states_accsI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ta_reduce_def δ_states_def reduce_rules_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> δ_states_accsI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ta_reduce_def δ_states_def reduce_rules_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\paragraph{Forward Reduction}›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We characterize the set of forward accessible states by the reflexive,
  transitive closure of a forward-successor (<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_succ ⊆ Q×Q›</span></span></span></span>) relation 
  applied to the initial states.
  
  The forward-successors of a state $q$ are those states $q'$ such that there is
  a rule $q \leftarrow f(\ldots q' \ldots)$.
›</span></span>

  <span class="comment1">― ‹Forward successors›</span>
<span class="keyword1"><span class="command">inductive_set</span></span> <span class="entity">f_succ</span> <span class="keyword2"><span class="keyword">for</span></span> <span class="entity">δ</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">→</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">qs</span></span></span><span class="main">)</span><span class="main">∈</span><span class="free">δ</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">q'</span></span></span><span class="main">∈</span>set <span class="free"><span class="bound"><span class="entity">qs</span></span></span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">q</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">q'</span></span></span><span class="main">)</span> <span class="main">∈</span> <span class="free">f_succ</span> <span class="free">δ</span>"</span></span>

  <span class="comment1">― ‹Alternative characterization of forward successors›</span>
<span class="keyword1"><span class="command">lemma</span></span> f_succ_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"f_succ <span class="free">δ</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">q</span><span class="main">,</span><span class="bound">q'</span><span class="main">)</span><span class="main">.</span> <span class="main">∃</span><span class="bound">l</span> <span class="bound">qs</span><span class="main">.</span> <span class="main">(</span><span class="bound">q</span> <span class="main">→</span> <span class="bound">l</span> <span class="bound">qs</span><span class="main">)</span><span class="main">∈</span><span class="free">δ</span> <span class="main">∧</span> <span class="bound">q'</span><span class="main">∈</span>set <span class="bound">qs</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> f_succ.intros <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> f_succ.cases<span class="main">)</span>

  <span class="comment1">― ‹Forward accessible states›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">f_accessible</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="free"><span class="bound"><span class="entity">Q0</span></span></span> <span class="main">==</span> <span class="main">(</span><span class="main">(</span>f_succ <span class="free"><span class="bound"><span class="entity">δ</span></span></span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">)</span> <span class="main">``</span> <span class="free"><span class="bound"><span class="entity">Q0</span></span></span>"</span></span>

  <span class="comment1">― ‹Alternative characterization of forward accessible states.
      The initial states are forward accessible, and if there is a rule
      whose lhs-state is forward-accessible, all rhs-states of that rule
      are forward-accessible, too.›</span>
<span class="keyword1"><span class="command">inductive_set</span></span> <span class="entity">f_accessible_alt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule set <span class="main">⇒</span> <span class="tfree">'Q</span> set <span class="main">⇒</span> <span class="tfree">'Q</span> set"</span></span>
<span class="keyword2"><span class="keyword">for</span></span> <span class="entity">δ</span> <span class="entity">Q0</span>
<span class="keyword2"><span class="keyword">where</span></span>
  fa_refl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">q0</span></span></span><span class="main">∈</span><span class="free">Q0</span> <span class="main">⟹</span> <span class="free"><span class="bound"><span class="entity">q0</span></span></span> <span class="main">∈</span> <span class="free">f_accessible_alt</span> <span class="free">δ</span> <span class="free">Q0</span>"</span></span> <span class="main">|</span>
  fa_step<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span><span class="main">∈</span><span class="free">f_accessible_alt</span> <span class="free">δ</span> <span class="free">Q0</span><span class="main">;</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">→</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">qs</span></span></span><span class="main">)</span><span class="main">∈</span><span class="free">δ</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">q'</span></span></span><span class="main">∈</span>set <span class="free"><span class="bound"><span class="entity">qs</span></span></span> <span class="main">⟧</span> 
            <span class="main">⟹</span> <span class="free"><span class="bound"><span class="entity">q'</span></span></span> <span class="main">∈</span> <span class="free">f_accessible_alt</span> <span class="free">δ</span> <span class="free">Q0</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> f_accessible_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"f_accessible <span class="free">δ</span> <span class="free">Q0</span> <span class="main">=</span> f_accessible_alt <span class="free">δ</span> <span class="free">Q0</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> f_accessible_def f_succ_alt<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">goal_cases</span>
  <span class="keyword3"><span class="command">case</span></span> 1 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rtrancl_induct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> f_accessible_alt.intros<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 2 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> f_accessible_alt.induct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Image_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rtrancl.intros<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> f_accessibleI <span class="main">=</span> f_accessible_alt.intros<span class="main">[</span><span class="operator">folded</span> f_accessible_alt<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> f_accessibleE <span class="main">=</span> f_accessible_alt.cases<span class="main">[</span><span class="operator">folded</span> f_accessible_alt<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> f_succ_finite<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">δ</span> <span class="main">⟹</span> finite <span class="main">(</span>f_succ <span class="free">δ</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> f_succ_alt<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> B<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"δ_states <span class="free">δ</span> <span class="main">×</span> δ_states <span class="free">δ</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> finite_subset<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> δ_statesI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> δ_states_finite<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> f_accessible_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q</span><span class="main">⊆</span><span class="free">Q'</span> <span class="main">⟹</span> <span class="free">x</span><span class="main">∈</span>f_accessible <span class="free">δ</span> <span class="free">Q</span> <span class="main">⟹</span> <span class="free">x</span><span class="main">∈</span>f_accessible <span class="free">δ</span> <span class="free">Q'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> f_accessible_def<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> f_accessible_prepend<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="free">q</span> <span class="main">→</span> <span class="free">l</span> <span class="free">qs</span><span class="main">)</span> <span class="main">∈</span> <span class="free">δ</span><span class="main">;</span> <span class="free">q'</span><span class="main">∈</span>set <span class="free">qs</span><span class="main">;</span> <span class="free">x</span><span class="main">∈</span>f_accessible <span class="free">δ</span> <span class="main">{</span><span class="free">q'</span><span class="main">}</span> <span class="main">⟧</span> 
    <span class="main">⟹</span> <span class="free">x</span><span class="main">∈</span>f_accessible <span class="free">δ</span> <span class="main">{</span><span class="free">q</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> f_succ.intros <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> f_accessible_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> f_accessible_subset<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q</span><span class="main">∈</span>f_accessible <span class="free">δ</span> <span class="free">Q</span> <span class="main">⟹</span> <span class="free">q</span><span class="main">∈</span><span class="free">Q</span> <span class="main">∪</span> δ_states <span class="free">δ</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> f_accessible_alt<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> f_accessible_alt.induct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> δ_states_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> ta_rule.split_asm<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> tree_automaton<span class="main">)</span> f_accessible_in_states<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">q</span><span class="main">∈</span>f_accessible <span class="main">(</span>ta_rules <span class="free">TA</span><span class="main">)</span> <span class="main">(</span>ta_initial <span class="free">TA</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">q</span><span class="main">∈</span>ta_rstates <span class="free">TA</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> initial_subset states_subset
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">drule_tac</span> f_accessible_subset<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> f_accessible_refl_inter_simp<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="main">∩</span> f_accessible <span class="free">r</span> <span class="free">Q</span> <span class="main">=</span> <span class="free">Q</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> f_accessible_alt<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> fa_refl<span class="main">)</span>

  <span class="comment1">― ‹A tree remains accepted by a state <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">q</span><span class="antiquote">}</span></span> if the rules are reduced to 
        the states that are forward-accessible from <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">q</span><span class="antiquote">}</span></span>›</span>
<span class="keyword1"><span class="command">lemma</span></span> accs_reduce_f_acc<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"accs <span class="free">δ</span> <span class="free">t</span> <span class="free">q</span> <span class="main">⟹</span> accs <span class="main">(</span>reduce_rules <span class="free">δ</span> <span class="main">(</span>f_accessible <span class="free">δ</span> <span class="main">{</span><span class="free">q</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="free">t</span> <span class="free">q</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> accs.induct<span class="main"><span class="main">[</span></span><span class="operator">case_names</span> step<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">q</span> <span class="skolem">l</span> <span class="skolem">qs</span> <span class="skolem">δ</span> <span class="skolem">n</span><span class="main">)</span> 
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> accs.intros<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="skolem">q</span></span> <span class="quoted"><span class="skolem">l</span></span> <span class="quoted"><span class="skolem">qs</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">q</span> <span class="main">→</span> <span class="skolem">l</span> <span class="skolem">qs</span><span class="main">)</span> <span class="main">∈</span> reduce_rules <span class="skolem">δ</span> <span class="main">(</span>f_accessible <span class="skolem">δ</span> <span class="main">{</span><span class="skolem">q</span><span class="main">}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> step<span class="main">(</span>1<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> 
        <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> reduce_rulesI 
        <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> f_succ.intros 
        <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> f_accessible_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> 
    <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">&lt;</span>length <span class="skolem">qs</span>"</span></span>

    <span class="keyword1"><span class="command">have</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"f_accessible <span class="skolem">δ</span> <span class="main">{</span><span class="skolem">q</span><span class="main">}</span> <span class="main">⊇</span> f_accessible <span class="skolem">δ</span> <span class="main">{</span><span class="skolem">qs</span><span class="main">!</span><span class="skolem">i</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> step.hyps<span class="main">(</span>1<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> 
        <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> A f_accessible_def 
        <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> converse_rtrancl_into_rtrancl f_succ.intros<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> q'<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="skolem">qs</span><span class="main">!</span><span class="skolem">i</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"accs <span class="main">(</span>reduce_rules <span class="skolem">δ</span> <span class="main">(</span>f_accessible <span class="skolem">δ</span> <span class="main">{</span><span class="skolem">q</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="skolem">n</span> <span class="main">!</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">(</span><span class="skolem">qs</span> <span class="main">!</span> <span class="skolem">i</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> accs_mono<span class="main">[</span><span class="operator">OF</span> step.hyps<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> A<span class="main"><span class="main">]</span></span> reduce_rules_mono<span class="main"><span class="main">[</span></span><span class="operator">OF</span> B<span class="main"><span class="main">]</span></span><span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> step.hyps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

  <span class="comment1">― ‹Short-hand notation for forward-reducing a tree-automaton›</span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">ta_fwd_reduce</span> <span class="free"><span class="bound"><span class="entity">TA</span></span></span> <span class="main">==</span> 
  <span class="main">(</span>ta_reduce <span class="free"><span class="bound"><span class="entity">TA</span></span></span> <span class="main">(</span>f_accessible <span class="main">(</span>ta_rules <span class="free"><span class="bound"><span class="entity">TA</span></span></span><span class="main">)</span> <span class="main">(</span>ta_initial <span class="free"><span class="bound"><span class="entity">TA</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="comment1">― ‹Forward-reducing a tree automaton does not change its language›</span>
<span class="keyword1"><span class="command">theorem</span></span> ta_reduce_f_acc<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ta_lang <span class="main">(</span>ta_fwd_reduce <span class="free">TA</span><span class="main">)</span> <span class="main">=</span> ta_lang <span class="free">TA</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> sym<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> ta_reduce_def ta_lang_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">q</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> bexI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> accs_reduce_f_acc<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> 
    P1<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span>f_accessible <span class="main">(</span>ta_rules <span class="free">TA</span><span class="main">)</span> <span class="main">{</span><span class="improper">q</span><span class="main">}</span><span class="main">)</span>"</span></span> 
    <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> accs_mono<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ reduce_rules_mono<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> f_accessible_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">q</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> bexI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> accs_mono<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ reduce_rules_subset<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\paragraph{Backward Reduction}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  A state is backward accessible, iff at least one tree is accepted in it.

  Inductively, backward accessible states can be characterized as follows:
  A state is backward accessible, if it occurs on the left hand side of a 
  rule, and all states on this rule's right hand side are backward accessible.
›</span></span>
<span class="keyword1"><span class="command">inductive_set</span></span> <span class="entity">b_accessible</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule set <span class="main">⇒</span> <span class="tfree">'Q</span> set"</span></span> 
  <span class="keyword2"><span class="keyword">for</span></span> <span class="entity">δ</span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">→</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">qs</span></span></span><span class="main">)</span><span class="main">∈</span><span class="free">δ</span><span class="main">;</span> <span class="main">!!</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span>set <span class="free"><span class="bound"><span class="entity">qs</span></span></span> <span class="main">⟹</span> <span class="bound">x</span><span class="main">∈</span><span class="free">b_accessible</span> <span class="free">δ</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span><span class="main">∈</span><span class="free">b_accessible</span> <span class="free">δ</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> b_accessibleI<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">(</span><span class="free">q</span> <span class="main">→</span> <span class="free">l</span> <span class="free">qs</span><span class="main">)</span><span class="main">∈</span><span class="free">δ</span><span class="main">;</span> set <span class="free">qs</span> <span class="main">⊆</span> b_accessible <span class="free">δ</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">q</span><span class="main">∈</span>b_accessible <span class="free">δ</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> b_accessible.intros<span class="main">)</span>

<span class="comment1">― ‹States that accept a tree are backward accessible›</span>
<span class="keyword1"><span class="command">lemma</span></span> accs_is_b_accessible<span class="main">:</span> <span class="quoted"><span class="quoted">"accs <span class="free">δ</span> <span class="free">t</span> <span class="free">q</span> <span class="main">⟹</span> <span class="free">q</span><span class="main">∈</span>b_accessible <span class="free">δ</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> accs.induct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> b_accessible.intros<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> in_set_conv_nth<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> b_acc_subset_δ_statesI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">∈</span>b_accessible <span class="free">δ</span> <span class="main">⟹</span> <span class="free">x</span><span class="main">∈</span>δ_states <span class="free">δ</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> b_accessible.cases<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> δ_statesI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> b_acc_subset_δ_states<span class="main">:</span> <span class="quoted"><span class="quoted">"b_accessible <span class="free">δ</span> <span class="main">⊆</span> δ_states <span class="free">δ</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> b_acc_subset_δ_statesI<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> b_acc_finite<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">δ</span> <span class="main">⟹</span> finite <span class="main">(</span>b_accessible <span class="free">δ</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main"><span class="main">[</span></span><span class="operator">OF</span> b_acc_subset_δ_states<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="comment1">― ‹Backward accessible states accept at least one tree›</span>
<span class="keyword1"><span class="command">lemma</span></span> b_accessible_is_accs<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">q</span><span class="main">∈</span>b_accessible <span class="main">(</span>ta_rules <span class="free">TA</span><span class="main">)</span><span class="main">;</span> 
     <span class="main">!!</span><span class="bound">t</span><span class="main">.</span> accs <span class="main">(</span>ta_rules <span class="free">TA</span><span class="main">)</span> <span class="bound">t</span> <span class="free">q</span> <span class="main">⟹</span> <span class="free">P</span>
   <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">P</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> b_accessible.induct<span class="main"><span class="main">[</span></span><span class="operator">case_names</span> IH<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>IH <span class="skolem">q</span> <span class="skolem">l</span> <span class="skolem">qs</span><span class="main">)</span> 

  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ts</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>length <span class="skolem">qs</span><span class="main">.</span> accs <span class="main">(</span>ta_rules <span class="free">TA</span><span class="main">)</span> <span class="main">(</span><span class="skolem">ts</span><span class="main">!</span><span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="skolem">qs</span><span class="main">!</span><span class="bound">i</span><span class="main">)</span>"</span></span> 
       <span class="quoted"><span class="quoted">"length <span class="skolem">ts</span> <span class="main">=</span> length <span class="skolem">qs</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> IH<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>set <span class="skolem">qs</span><span class="main">.</span> <span class="main">∃</span><span class="bound">t</span><span class="main">.</span> accs <span class="main">(</span>ta_rules <span class="free">TA</span><span class="main">)</span> <span class="bound">t</span> <span class="bound">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">ts</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>length <span class="skolem">qs</span><span class="main">.</span> accs <span class="main">(</span>ta_rules <span class="free">TA</span><span class="main">)</span> <span class="main">(</span><span class="bound">ts</span><span class="main">!</span><span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="skolem">qs</span><span class="main">!</span><span class="bound">i</span><span class="main">)</span><span class="main">)</span> 
                <span class="main">∧</span> length <span class="bound">ts</span> <span class="main">=</span> length <span class="skolem">qs</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">qs</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">q</span> <span class="skolem">qs</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ts</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
        IHAPP<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>length <span class="skolem">qs</span><span class="main">.</span> accs <span class="main">(</span>ta_rules <span class="free">TA</span><span class="main">)</span> <span class="main">(</span><span class="skolem">ts</span> <span class="main">!</span> <span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="skolem">qs</span> <span class="main">!</span> <span class="bound">i</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 
        L<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="skolem">ts</span> <span class="main">=</span> length <span class="skolem">qs</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> Cons <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">t</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"accs <span class="main">(</span>ta_rules <span class="free">TA</span><span class="main">)</span> <span class="skolem">t</span> <span class="skolem">q</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> 
        <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>length <span class="main">(</span><span class="skolem">q</span><span class="main">#</span><span class="skolem">qs</span><span class="main">)</span><span class="main">.</span> accs <span class="main">(</span>ta_rules <span class="free">TA</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="skolem">t</span><span class="main">#</span><span class="skolem">ts</span><span class="main">)</span> <span class="main">!</span> <span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="skolem">q</span><span class="main">#</span><span class="skolem">qs</span><span class="main">)</span> <span class="main">!</span> <span class="bound">i</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">i</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> L <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="skolem">thesis</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> that<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">from</span></span> A <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> IH<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> accs.intros<span class="main"><span class="main">[</span></span><span class="operator">OF</span> IH<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

  <span class="comment1">― ‹All trees remain accepted when reducing the rules to 
      backward-accessible states›</span>
<span class="keyword1"><span class="command">lemma</span></span> accs_reduce_b_acc<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"accs <span class="free">δ</span> <span class="free">t</span> <span class="free">q</span> <span class="main">⟹</span> accs <span class="main">(</span>reduce_rules <span class="free">δ</span> <span class="main">(</span>b_accessible <span class="free">δ</span><span class="main">)</span><span class="main">)</span> <span class="free">t</span> <span class="free">q</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> accs.induct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> accs.intros<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> reduce_rulesI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> t<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"NODE <span class="improper">f</span> <span class="improper">ts</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> accs_is_b_accessible<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> accs.intros<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> in_set_conv_nth<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule_tac</span> exE<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> t<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">ts</span> <span class="main">!</span> <span class="improper">i</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> accs_is_b_accessible<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="comment1">― ‹Shorthand notation for backward-reduction of a tree automaton›</span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">ta_bwd_reduce</span> <span class="free"><span class="bound"><span class="entity">TA</span></span></span> <span class="main">==</span> <span class="main">(</span>ta_reduce <span class="free"><span class="bound"><span class="entity">TA</span></span></span> <span class="main">(</span>b_accessible <span class="main">(</span>ta_rules <span class="free"><span class="bound"><span class="entity">TA</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="comment1">― ‹Backwards-reducing a tree automaton does not change its language›</span>
<span class="keyword1"><span class="command">theorem</span></span> ta_reduce_b_acc<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ta_lang <span class="main">(</span>ta_bwd_reduce <span class="free">TA</span><span class="main">)</span> <span class="main">=</span> ta_lang <span class="free">TA</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> sym<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> ta_reduce_def ta_lang_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">q</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> bexI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> accs_reduce_b_acc<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> accs_is_b_accessible<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">q</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> bexI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> accs_mono<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ reduce_rules_subset<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">.</span></span>

  <span class="comment1">― ‹Emptiness check by backward reduction. The language of a tree automaton 
    is empty, if and only if no initial state is backwards-accessible.›</span>
<span class="keyword1"><span class="command">theorem</span></span> empty_if_no_b_accessible<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"ta_lang <span class="free">TA</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟷</span> ta_initial <span class="free">TA</span> <span class="main">∩</span> b_accessible <span class="main">(</span>ta_rules <span class="free">TA</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
    <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ta_lang_def 
    <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> accs_is_b_accessible b_accessible_is_accs<span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">"Product Automaton"</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The product automaton of two tree automata accepts the intersection 
  of the languages of the two automata.
›</span></span>

  <span class="comment1">― ‹Product rule›</span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">r_prod</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">r_prod</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">q1</span></span></span> <span class="main">→</span> <span class="free"><span class="bound"><span class="entity">l1</span></span></span> <span class="free"><span class="bound"><span class="entity">qs1</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">q2</span></span></span> <span class="main">→</span> <span class="free"><span class="bound"><span class="entity">l2</span></span></span> <span class="free"><span class="bound"><span class="entity">qs2</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">q1</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">q2</span></span></span><span class="main">)</span> <span class="main">→</span> <span class="free"><span class="bound"><span class="entity">l1</span></span></span> <span class="main">(</span>zip <span class="free"><span class="bound"><span class="entity">qs1</span></span></span> <span class="free"><span class="bound"><span class="entity">qs2</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="comment1">― ‹Product rules›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">δ_prod</span> <span class="free"><span class="bound"><span class="entity">δ1</span></span></span> <span class="free"><span class="bound"><span class="entity">δ2</span></span></span> <span class="main">==</span> <span class="main">{</span>
  r_prod <span class="main">(</span><span class="bound">q1</span> <span class="main">→</span> <span class="bound">l</span> <span class="bound">qs1</span><span class="main">)</span> <span class="main">(</span><span class="bound">q2</span> <span class="main">→</span> <span class="bound">l</span> <span class="bound">qs2</span><span class="main">)</span> <span class="main">|</span> <span class="bound">q1</span> <span class="bound">q2</span> <span class="bound">l</span> <span class="bound">qs1</span> <span class="bound">qs2</span><span class="main">.</span>
    length <span class="bound">qs1</span> <span class="main">=</span> length <span class="bound">qs2</span> <span class="main">∧</span> 
    <span class="main">(</span><span class="bound">q1</span> <span class="main">→</span> <span class="bound">l</span> <span class="bound">qs1</span><span class="main">)</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">δ1</span></span></span> <span class="main">∧</span> 
    <span class="main">(</span><span class="bound">q2</span> <span class="main">→</span> <span class="bound">l</span> <span class="bound">qs2</span><span class="main">)</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">δ2</span></span></span>
<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> δ_prodI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> 
    length <span class="free">qs1</span> <span class="main">=</span> length <span class="free">qs2</span><span class="main">;</span>
    <span class="main">(</span><span class="free">q1</span> <span class="main">→</span> <span class="free">l</span> <span class="free">qs1</span><span class="main">)</span><span class="main">∈</span><span class="free">δ1</span><span class="main">;</span>
    <span class="main">(</span><span class="free">q2</span> <span class="main">→</span> <span class="free">l</span> <span class="free">qs2</span><span class="main">)</span><span class="main">∈</span><span class="free">δ2</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">(</span><span class="free">q1</span><span class="main">,</span><span class="free">q2</span><span class="main">)</span> <span class="main">→</span> <span class="free">l</span> <span class="main">(</span>zip <span class="free">qs1</span> <span class="free">qs2</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> δ_prod <span class="free">δ1</span> <span class="free">δ2</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> δ_prod_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> δ_prodE<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> 
    <span class="free">r</span><span class="main">∈</span>δ_prod <span class="free">δ1</span> <span class="free">δ2</span><span class="main">;</span> 
    <span class="main">!!</span><span class="bound">q1</span> <span class="bound">q2</span> <span class="bound">l</span> <span class="bound">qs1</span> <span class="bound">qs2</span><span class="main">.</span> <span class="main">⟦</span> length <span class="bound">qs1</span> <span class="main">=</span> length <span class="bound">qs2</span><span class="main">;</span>
                         <span class="main">(</span><span class="bound">q1</span> <span class="main">→</span> <span class="bound">l</span> <span class="bound">qs1</span><span class="main">)</span><span class="main">∈</span><span class="free">δ1</span><span class="main">;</span>
                         <span class="main">(</span><span class="bound">q2</span> <span class="main">→</span> <span class="bound">l</span> <span class="bound">qs2</span><span class="main">)</span><span class="main">∈</span><span class="free">δ2</span><span class="main">;</span>
                         <span class="free">r</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="bound">q1</span><span class="main">,</span><span class="bound">q2</span><span class="main">)</span> <span class="main">→</span> <span class="bound">l</span> <span class="main">(</span>zip <span class="bound">qs1</span> <span class="bound">qs2</span><span class="main">)</span><span class="main">)</span> 
                       <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> 
   <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> δ_prod_def<span class="main">)</span>

  <span class="comment1">― ‹With the product rules, only trees can be constructed that can also be 
      constructed with the two original sets of rules›</span>
<span class="keyword1"><span class="command">lemma</span></span> δ_prod_sound<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"accs <span class="main">(</span>δ_prod <span class="free">δ1</span> <span class="free">δ2</span><span class="main">)</span> <span class="free">t</span> <span class="main">(</span><span class="free">q1</span><span class="main">,</span><span class="free">q2</span><span class="main">)</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"accs <span class="free">δ1</span> <span class="free">t</span> <span class="free">q1</span>"</span></span> <span class="quoted"><span class="quoted">"accs <span class="free">δ2</span> <span class="free">t</span> <span class="free">q2</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">δ</span> <span class="skolem">q</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"accs <span class="skolem">δ</span> <span class="free">t</span> <span class="skolem">q</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">δ</span> <span class="main">=</span> <span class="main">(</span>δ_prod <span class="free">δ1</span> <span class="free">δ2</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span><span class="main">=</span><span class="main">(</span><span class="free">q1</span><span class="main">,</span><span class="free">q2</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"accs <span class="free">δ1</span> <span class="free">t</span> <span class="free">q1</span> <span class="main">∧</span> accs <span class="free">δ2</span> <span class="free">t</span> <span class="free">q2</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">δ1</span></span> <span class="quoted"><span class="free">δ2</span></span> <span class="quoted"><span class="free">q1</span></span> <span class="quoted"><span class="free">q2</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> accs.induct<span class="main">)</span>
         <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> accs.intros <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> δ_prod_def<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">with</span></span> A <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"accs <span class="free">δ1</span> <span class="free">t</span> <span class="free">q1</span>"</span></span> <span class="quoted"><span class="quoted">"accs <span class="free">δ2</span> <span class="free">t</span> <span class="free">q2</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

  <span class="comment1">― ‹Any tree that can be constructed with both original sets of rules can also
      be constructed with the product rules›</span>
<span class="keyword1"><span class="command">lemma</span></span> δ_prod_precise<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> accs <span class="free">δ1</span> <span class="free">t</span> <span class="free">q1</span><span class="main">;</span> accs <span class="free">δ2</span> <span class="free">t</span> <span class="free">q2</span> <span class="main">⟧</span> <span class="main">⟹</span> accs <span class="main">(</span>δ_prod <span class="free">δ1</span> <span class="free">δ2</span><span class="main">)</span> <span class="free">t</span> <span class="main">(</span><span class="free">q1</span><span class="main">,</span><span class="free">q2</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">δ2</span></span> <span class="quoted"><span class="free">q2</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> accs.induct<span class="main"><span class="main">[</span></span><span class="operator">case_names</span> step<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">q1</span> <span class="skolem">l</span> <span class="skolem">qs1</span> <span class="skolem">δ1</span> <span class="skolem">ts</span> <span class="skolem">δ2</span> <span class="skolem">q2</span><span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> step.hyps<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> step.hyps<span class="main">(</span>2<span class="main">)</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">qs2</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    I2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">q2</span> <span class="main">→</span> <span class="skolem">l</span> <span class="skolem">qs2</span><span class="main">)</span><span class="main">∈</span><span class="skolem">δ2</span>"</span></span> 
        <span class="quoted"><span class="quoted">"<span class="main">!!</span><span class="bound">i</span><span class="main">.</span> <span class="bound">i</span><span class="main">&lt;</span>length <span class="skolem">qs2</span> <span class="main">⟹</span> accs <span class="skolem">δ2</span> <span class="main">(</span><span class="skolem">ts</span> <span class="main">!</span> <span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="skolem">qs2</span> <span class="main">!</span> <span class="bound">i</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 
    <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="skolem">qs2</span> <span class="main">=</span> length <span class="skolem">ts</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> accs.cases<span class="main"><span class="main">[</span></span><span class="operator">OF</span> step.prems<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">fastforce</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> accs.intros<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> step.hyps<span class="main">(</span>1<span class="main">)</span> I2<span class="main">(</span>1<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> 
      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">q1</span><span class="main">,</span><span class="skolem">q2</span><span class="main">)</span> <span class="main">→</span> <span class="skolem">l</span> <span class="main">(</span>zip <span class="skolem">qs1</span> <span class="skolem">qs2</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>δ_prod <span class="skolem">δ1</span> <span class="skolem">δ2</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 
      <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="skolem">ts</span> <span class="main">=</span> length <span class="main">(</span>zip <span class="skolem">qs1</span> <span class="skolem">qs2</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> δ_prod_def<span class="main">)</span> <span class="operator">force</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span>
    <span class="keyword3"><span class="command">assume</span></span> L<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">&lt;</span>length <span class="main">(</span>zip <span class="skolem">qs1</span> <span class="skolem">qs2</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> step.hyps<span class="main">(</span>4<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> _ I2<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">i</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> 
      <span class="quoted"><span class="quoted">"accs <span class="main">(</span>δ_prod <span class="skolem">δ1</span> <span class="skolem">δ2</span><span class="main">)</span> <span class="main">(</span><span class="skolem">ts</span> <span class="main">!</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">(</span><span class="skolem">qs1</span> <span class="main">!</span> <span class="skolem">i</span><span class="main">,</span> <span class="skolem">qs2</span> <span class="main">!</span> <span class="skolem">i</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">qs1</span> <span class="main">!</span> <span class="skolem">i</span><span class="main">,</span> <span class="skolem">qs2</span> <span class="main">!</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">=</span> zip <span class="skolem">qs1</span> <span class="skolem">qs2</span> <span class="main">!</span> <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> L <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"accs <span class="main">(</span>δ_prod <span class="skolem">δ1</span> <span class="skolem">δ2</span><span class="main">)</span> <span class="main">(</span><span class="skolem">ts</span> <span class="main">!</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">(</span>zip <span class="skolem">qs1</span> <span class="skolem">qs2</span> <span class="main">!</span> <span class="skolem">i</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> δ_prod_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"δ_prod <span class="main">{}</span> <span class="free">δ</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="quoted"><span class="quoted">"δ_prod <span class="free">δ</span> <span class="main">{}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> δ_prod_def<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> δ_prod_2sng<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> rhsl <span class="free">r1</span> <span class="main">≠</span> rhsl <span class="free">r2</span> <span class="main">⟧</span> <span class="main">⟹</span> δ_prod <span class="main">{</span><span class="free">r1</span><span class="main">}</span> <span class="main">{</span><span class="free">r2</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> length <span class="main">(</span>rhsq <span class="free">r1</span><span class="main">)</span> <span class="main">≠</span> length <span class="main">(</span>rhsq <span class="free">r2</span><span class="main">)</span> <span class="main">⟧</span> <span class="main">⟹</span> δ_prod <span class="main">{</span><span class="free">r1</span><span class="main">}</span> <span class="main">{</span><span class="free">r2</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> rhsl <span class="free">r1</span> <span class="main">=</span> rhsl <span class="free">r2</span><span class="main">;</span> length <span class="main">(</span>rhsq <span class="free">r1</span><span class="main">)</span> <span class="main">=</span> length <span class="main">(</span>rhsq <span class="free">r2</span><span class="main">)</span> <span class="main">⟧</span> 
    <span class="main">⟹</span> δ_prod <span class="main">{</span><span class="free">r1</span><span class="main">}</span> <span class="main">{</span><span class="free">r2</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span>r_prod <span class="free">r1</span> <span class="free">r2</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> δ_prod_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">r1</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">r2</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> δ_prod_Un<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"δ_prod <span class="main">(</span><span class="free">δ1</span><span class="main">∪</span><span class="free">δ1'</span><span class="main">)</span> <span class="free">δ2</span> <span class="main">=</span> δ_prod <span class="free">δ1</span> <span class="free">δ2</span> <span class="main">∪</span> δ_prod <span class="free">δ1'</span> <span class="free">δ2</span>"</span></span>
  <span class="quoted"><span class="quoted">"δ_prod <span class="free">δ1</span> <span class="main">(</span><span class="free">δ2</span><span class="main">∪</span><span class="free">δ2'</span><span class="main">)</span> <span class="main">=</span> δ_prod <span class="free">δ1</span> <span class="free">δ2</span> <span class="main">∪</span> δ_prod <span class="free">δ1</span> <span class="free">δ2'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> δ_prodE <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> δ_prodI<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The next two definitions are solely for technical reasons.
  They are required to allow simplification of expressions of the form
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"δ_prod <span class="main"><span class="main">(</span></span>insert <span class="free"><span class="free">r</span></span> <span class="free"><span class="free">δ1</span></span><span class="main"><span class="main">)</span></span> <span class="free"><span class="free">δ2</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> or <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"δ_prod <span class="free"><span class="free">δ1</span></span> <span class="main"><span class="main">(</span></span>insert <span class="free"><span class="free">r</span></span> <span class="free"><span class="free">δ2</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, 
  without making the simplifier loop.
›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">δ_prod_sng1</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">δ2</span></span></span> <span class="main">==</span> 
  <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">q1</span> <span class="main">→</span> <span class="bound">l</span> <span class="bound">qs1</span><span class="main">)</span> <span class="main">⇒</span> 
    <span class="main">{</span> r_prod <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">(</span><span class="bound">q2</span> <span class="main">→</span> <span class="bound">l</span> <span class="bound">qs2</span><span class="main">)</span> <span class="main">|</span> 
         <span class="bound">q2</span> <span class="bound">qs2</span><span class="main">.</span> length <span class="bound">qs1</span> <span class="main">=</span> length <span class="bound">qs2</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">q2</span> <span class="main">→</span> <span class="bound">l</span> <span class="bound">qs2</span><span class="main">)</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">δ2</span></span></span> 
    <span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">δ_prod_sng2</span> <span class="free"><span class="bound"><span class="entity">δ1</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">==</span> 
  <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">q2</span> <span class="main">→</span> <span class="bound">l</span> <span class="bound">qs2</span><span class="main">)</span> <span class="main">⇒</span> 
    <span class="main">{</span> r_prod <span class="main">(</span><span class="bound">q1</span> <span class="main">→</span> <span class="bound">l</span> <span class="bound">qs1</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">|</span> 
         <span class="bound">q1</span> <span class="bound">qs1</span><span class="main">.</span> length <span class="bound">qs1</span> <span class="main">=</span> length <span class="bound">qs2</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">q1</span> <span class="main">→</span> <span class="bound">l</span> <span class="bound">qs1</span><span class="main">)</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">δ1</span></span></span> 
    <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> δ_prod_sng_alt<span class="main">:</span>
  <span class="quoted"><span class="quoted">"δ_prod_sng1 <span class="free">r</span> <span class="free">δ2</span> <span class="main">=</span> δ_prod <span class="main">{</span><span class="free">r</span><span class="main">}</span> <span class="free">δ2</span>"</span></span>
  <span class="quoted"><span class="quoted">"δ_prod_sng2 <span class="free">δ1</span> <span class="free">r</span> <span class="main">=</span> δ_prod <span class="free">δ1</span> <span class="main">{</span><span class="free">r</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> δ_prod_def δ_prod_sng1_def δ_prod_sng2_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> ta_rule.split<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
<span class="keyword1"><span class="command">lemmas</span></span> δ_prod_insert <span class="main">=</span> 
  δ_prod_Un<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="var">?δ1.0</span><span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">x</span><span class="main">}</span>"</span></span><span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> <span class="operator">folded</span> δ_prod_sng_alt<span class="main">]</span>
  δ_prod_Un<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="var">?δ2.0</span><span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">x</span><span class="main">}</span>"</span></span><span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> <span class="operator">folded</span> δ_prod_sng_alt<span class="main">]</span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">x</span>

  <span class="comment1">― ‹Product automaton›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ta_prod</span> <span class="free"><span class="bound"><span class="entity">TA1</span></span></span> <span class="free"><span class="bound"><span class="entity">TA2</span></span></span> <span class="main">==</span> 
  <span class="main">⦇</span> ta_initial <span class="main">=</span> ta_initial <span class="free"><span class="bound"><span class="entity">TA1</span></span></span> <span class="main">×</span> ta_initial <span class="free"><span class="bound"><span class="entity">TA2</span></span></span><span class="main">,</span> 
    ta_rules <span class="main">=</span> δ_prod <span class="main">(</span>ta_rules <span class="free"><span class="bound"><span class="entity">TA1</span></span></span><span class="main">)</span> <span class="main">(</span>ta_rules <span class="free"><span class="bound"><span class="entity">TA2</span></span></span><span class="main">)</span> 
  <span class="main">⦈</span>"</span></span>
   
<span class="keyword1"><span class="command">lemma</span></span> ta_prod_correct_aux1<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"ta_lang <span class="main">(</span>ta_prod <span class="free">TA1</span> <span class="free">TA2</span><span class="main">)</span> <span class="main">=</span> ta_lang <span class="free">TA1</span> <span class="main">∩</span> ta_lang <span class="free">TA2</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> ta_lang_def ta_prod_def<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> δ_prod_sound δ_prod_precise<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> δ_states_cart<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">∈</span> δ_states <span class="main">(</span>δ_prod <span class="free">δ1</span> <span class="free">δ2</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">q</span> <span class="main">∈</span> δ_states <span class="free">δ1</span> <span class="main">×</span> δ_states <span class="free">δ2</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> δ_states_def δ_prod_def<span class="main">)</span> 
     <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> ta_rule.split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_zip<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> δ_prod_finite <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"finite <span class="free">δ1</span> <span class="main">⟹</span> finite <span class="free">δ2</span> <span class="main">⟹</span> finite <span class="main">(</span>δ_prod <span class="free">δ1</span> <span class="free">δ2</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> 
    <span class="quoted"><span class="quoted">"δ_prod <span class="free">δ1</span> <span class="free">δ2</span> 
    <span class="main">⊆</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">r1</span><span class="main">,</span><span class="bound">r2</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">r1</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">q1</span> <span class="main">→</span> <span class="bound">l1</span> <span class="bound">qs1</span><span class="main">)</span> <span class="main">⇒</span> 
                  <span class="keyword1">case</span> <span class="bound">r2</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">q2</span> <span class="main">→</span> <span class="bound">l2</span> <span class="bound">qs2</span><span class="main">)</span> <span class="main">⇒</span> 
                    <span class="main">(</span><span class="main">(</span><span class="bound">q1</span><span class="main">,</span><span class="bound">q2</span><span class="main">)</span> <span class="main">→</span> <span class="bound">l1</span> <span class="main">(</span>zip <span class="bound">qs1</span> <span class="bound">qs2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
       <span class="main">`</span> <span class="main">(</span><span class="free">δ1</span> <span class="main">×</span> <span class="free">δ2</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> δ_prod_def<span class="main">)</span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">δ1</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">δ2</span>"</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> finite_imageI finite_cartesian_product finite_subset<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ta_prod_correct_aux2<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> TA<span class="main">:</span> <span class="quoted"><span class="quoted">"tree_automaton <span class="free">TA1</span>"</span></span> <span class="quoted"><span class="quoted">"tree_automaton <span class="free">TA2</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"tree_automaton <span class="main">(</span>ta_prod <span class="free">TA1</span> <span class="free">TA2</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> ta1<span class="main">:</span> tree_automaton <span class="quoted"><span class="free">TA1</span></span> <span class="keyword1"><span class="command">using</span></span> TA <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">interpret</span></span> ta2<span class="main">:</span> tree_automaton <span class="quoted"><span class="free">TA2</span></span> <span class="keyword1"><span class="command">using</span></span> TA <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> ta_prod_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
      <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ta1.is_subset ta2.is_subset δ_prod_finite 
      <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> δ_states_cart 
      <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ta1.finite_states ta2.finite_states 
                ta1.finite_rules ta2.finite_rules<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

  <span class="comment1">― ‹The language of the product automaton is the intersection of the languages
      of the two original automata›</span>
<span class="keyword1"><span class="command">theorem</span></span> ta_prod_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> TA<span class="main">:</span> <span class="quoted"><span class="quoted">"tree_automaton <span class="free">TA1</span>"</span></span> <span class="quoted"><span class="quoted">"tree_automaton <span class="free">TA2</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> 
    <span class="quoted"><span class="quoted">"ta_lang <span class="main">(</span>ta_prod <span class="free">TA1</span> <span class="free">TA2</span><span class="main">)</span> <span class="main">=</span> ta_lang <span class="free">TA1</span> <span class="main">∩</span> ta_lang <span class="free">TA2</span>"</span></span>
    <span class="quoted"><span class="quoted">"tree_automaton <span class="main">(</span>ta_prod <span class="free">TA1</span> <span class="free">TA2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> ta_prod_correct_aux1 
        ta_prod_correct_aux2<span class="main">[</span><span class="operator">OF</span> TA<span class="main">]</span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


<span class="keyword1"><span class="command">lemma</span></span> ta_prod_rta<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> TA<span class="main">:</span> <span class="quoted"><span class="quoted">"ranked_tree_automaton <span class="free">TA1</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"ranked_tree_automaton <span class="free">TA2</span> <span class="free">A</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ranked_tree_automaton <span class="main">(</span>ta_prod <span class="free">TA1</span> <span class="free">TA2</span><span class="main">)</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> ta1<span class="main">:</span> ranked_tree_automaton <span class="quoted"><span class="free">TA1</span></span> <span class="quoted"><span class="free">A</span></span> <span class="keyword1"><span class="command">using</span></span> TA <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">interpret</span></span> ta2<span class="main">:</span> ranked_tree_automaton <span class="quoted"><span class="free">TA2</span></span> <span class="quoted"><span class="free">A</span></span> <span class="keyword1"><span class="command">using</span></span> TA <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1"><span class="command">interpret</span></span> tap<span class="main">:</span> tree_automaton <span class="quoted"><span class="quoted">"<span class="main">(</span>ta_prod <span class="free">TA1</span> <span class="free">TA2</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ta_prod_correct_aux2<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> ta_prod_def δ_prod_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ta1.ranked ta2.ranked<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">"Determinization"</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We only formalize the brute-force subset construction without reduction. 

  The basic idea of this construction is to construct an automaton where the
  states are sets of original states, and the lhs of a rule consists of all
  states that a term with given rhs and function symbol may be labeled by.
›</span></span>

<span class="keyword1"><span class="command">context</span></span> ranked_tree_automaton
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="comment1">― ‹Left-hand side of subset rule for given symbol and rhs›</span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">δss_lhs</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">ss</span></span></span> <span class="main">==</span> 
    <span class="main">{</span> <span class="bound">q</span> <span class="main">|</span> <span class="bound">q</span> <span class="bound">qs</span><span class="main">.</span> <span class="main">(</span><span class="bound">q</span> <span class="main">→</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">qs</span><span class="main">)</span><span class="main">∈</span>δ <span class="main">∧</span> list_all_zip <span class="main">(∈)</span> <span class="bound">qs</span> <span class="free"><span class="bound"><span class="entity">ss</span></span></span> <span class="main">}</span>"</span></span>

  <span class="comment1">― ‹Subset construction›</span>
  <span class="keyword1"><span class="command">inductive_set</span></span> <span class="entity">δss</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span> set<span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">A</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> Some <span class="main">(</span>length <span class="free"><span class="bound"><span class="entity">ss</span></span></span><span class="main">)</span><span class="main">;</span> 
       <span class="free"><span class="bound"><span class="entity">ss</span></span></span> <span class="main">∈</span> lists <span class="main">{</span><span class="bound">s</span><span class="main">.</span> <span class="bound">s</span> <span class="main">⊆</span> ta_rstates <span class="free">TA</span><span class="main">}</span><span class="main">;</span> 
       <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> δss_lhs <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">ss</span></span></span>
     <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">→</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">ss</span></span></span><span class="main">)</span> <span class="main">∈</span> <span class="free">δss</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> δssI<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="free">f</span> <span class="main">=</span> Some <span class="main">(</span>length <span class="free">ss</span><span class="main">)</span>"</span></span>
               <span class="quoted"><span class="quoted">"<span class="free">ss</span> <span class="main">∈</span> lists <span class="main">{</span><span class="bound">s</span><span class="main">.</span> <span class="bound">s</span> <span class="main">⊆</span> ta_rstates <span class="free">TA</span><span class="main">}</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> 
      <span class="quoted"><span class="quoted">"<span class="main">(</span> <span class="main">(</span>δss_lhs <span class="free">f</span> <span class="free">ss</span><span class="main">)</span> <span class="main">→</span> <span class="free">f</span> <span class="free">ss</span><span class="main">)</span> <span class="main">∈</span> δss"</span></span>
    <span class="keyword1"><span class="command">using</span></span> δss.intros<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> s<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span>δss_lhs <span class="free">f</span> <span class="free">ss</span><span class="main">)</span>"</span></span><span class="main">]</span> A
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">lemma</span></span> δss_subset<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"δss_lhs <span class="free">f</span> <span class="free">ss</span> <span class="main">⊆</span> Q"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> ta_rstates_def δss_lhs_def<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> δ_statesI<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> δss_finite<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite δss"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"δss <span class="main">⊆</span> <span class="main">⋃</span><span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="bound">ss</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">s</span> <span class="main">→</span> <span class="bound">f</span> <span class="bound">ss</span><span class="main">)</span><span class="main">)</span>
                     <span class="main">`</span><span class="main">(</span><span class="main">{</span><span class="bound">s</span><span class="main">.</span> <span class="bound">s</span><span class="main">⊆</span>Q<span class="main">}</span> 
                       <span class="main">×</span> <span class="main">(</span>lists <span class="main">{</span><span class="bound">s</span><span class="main">.</span> <span class="bound">s</span><span class="main">⊆</span>Q<span class="main">}</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">l</span><span class="main">.</span> length <span class="bound">l</span> <span class="main">=</span> the <span class="main">(</span><span class="free">A</span> <span class="bound">f</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>
                  <span class="main">)</span> <span class="main">`</span> F<span class="main">)</span>"</span></span> 
      <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span><span class="main">⊆</span><span class="main">⋃</span><span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="var">?tr</span> <span class="bound">f</span> <span class="main">`</span> <span class="var">?prod</span> <span class="bound">f</span><span class="main">)</span><span class="main">`</span>F<span class="main">)</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> equalityI subsetI<span class="main">)</span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">r</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span><span class="main">∈</span>δss"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">f</span></span> <span class="skolem"><span class="skolem">s</span></span> <span class="skolem"><span class="skolem">ss</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
        U<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span><span class="main">=</span><span class="main">(</span><span class="skolem">s</span> <span class="main">→</span> <span class="skolem">f</span> <span class="skolem">ss</span><span class="main">)</span>"</span></span> 
           <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="skolem">f</span> <span class="main">=</span> Some <span class="main">(</span>length <span class="skolem">ss</span><span class="main">)</span>"</span></span> 
           <span class="quoted"><span class="quoted">"<span class="skolem">ss</span><span class="main">∈</span>lists <span class="main">{</span><span class="bound">s</span><span class="main">.</span> <span class="bound">s</span><span class="main">⊆</span>Q<span class="main">}</span>"</span></span> 
           <span class="quoted"><span class="quoted">"<span class="skolem">s</span><span class="main">=</span>δss_lhs <span class="skolem">f</span> <span class="skolem">ss</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> δss.cases<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> U<span class="main">(</span>4<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span><span class="main">⊆</span>Q"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> 
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> U<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="skolem">ss</span> <span class="main">=</span> the <span class="main">(</span><span class="free">A</span> <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">s</span><span class="main">,</span><span class="skolem">ss</span><span class="main">)</span><span class="main">∈</span><span class="var">?prod</span> <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> U<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">s</span> <span class="main">→</span> <span class="skolem">f</span> <span class="skolem">ss</span><span class="main">)</span><span class="main">∈</span><span class="var">?tr</span> <span class="skolem">f</span> <span class="main">`</span> <span class="var">?prod</span> <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> U<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span><span class="main">∈</span>F"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span><span class="main">∈</span><span class="main">⋃</span><span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="var">?tr</span> <span class="bound">f</span> <span class="main">`</span> <span class="var">?prod</span> <span class="bound">f</span><span class="main">)</span><span class="main">`</span>F<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> U<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">…</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> finite_imageI finite_SigmaI lists_of_len_fin<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_subset<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> δss_det<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="free">q</span> <span class="main">→</span> <span class="free">f</span> <span class="free">qs</span><span class="main">)</span> <span class="main">∈</span> δss<span class="main">;</span> <span class="main">(</span><span class="free">q'</span> <span class="main">→</span> <span class="free">f</span> <span class="free">qs</span><span class="main">)</span> <span class="main">∈</span>δss <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">q</span><span class="main">=</span><span class="free">q'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> δss.cases<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> δss_accs_sound<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"accs δ <span class="free">t</span> <span class="free">q</span>"</span></span>  
    <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">s</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊆</span>Q"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">q</span><span class="main">∈</span><span class="free">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"accs δss <span class="free">t</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound"><span class="bound">s</span></span><span class="main">⊆</span>Q<span class="main">.</span> <span class="free">q</span><span class="main">∈</span><span class="bound">s</span> <span class="main">∧</span> accs_laz δss <span class="free">t</span> <span class="bound">s</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> A<span class="main">[</span><span class="operator">unfolded</span> accs_laz<span class="main">]</span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="skolem">δ</span><span class="main"><span class="main">≡</span></span><span class="quoted">δ</span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">q</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> accs_laz.induct<span class="main"><span class="main">[</span></span><span class="operator">case_names</span> step<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">q</span> <span class="skolem">f</span> <span class="skolem">qs</span> <span class="skolem">ts</span><span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> I<span class="main">:</span>
        <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">q</span> <span class="main">→</span> <span class="skolem">f</span> <span class="skolem">qs</span><span class="main">)</span><span class="main">∈</span>δ"</span></span>
        <span class="quoted"><span class="quoted">"list_all_zip <span class="main">(</span>accs_laz δ<span class="main">)</span> <span class="skolem">ts</span> <span class="skolem">qs</span>"</span></span>
        <span class="quoted"><span class="quoted">"list_all_zip <span class="main">(</span><span class="main">λ</span><span class="bound">t</span> <span class="bound">q</span><span class="main">.</span> <span class="main">∃</span><span class="bound">s</span><span class="main">.</span> <span class="bound">s</span><span class="main">⊆</span>Q <span class="main">∧</span> <span class="bound">q</span><span class="main">∈</span><span class="bound">s</span> <span class="main">∧</span> accs_laz δss <span class="bound">t</span> <span class="bound">s</span><span class="main">)</span> <span class="skolem">ts</span> <span class="skolem">qs</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
      <span class="keyword1"><span class="command">from</span></span> I<span class="main">(</span>3<span class="main">)</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ss</span></span> <span class="keyword2"><span class="keyword">where</span></span> SS<span class="main">:</span> 
        <span class="quoted"><span class="quoted">"<span class="skolem">ss</span> <span class="main">∈</span> lists <span class="main">{</span><span class="bound">s</span><span class="main">.</span> <span class="bound">s</span><span class="main">⊆</span>Q<span class="main">}</span>"</span></span>
        <span class="quoted"><span class="quoted">"list_all_zip <span class="main">(∈)</span> <span class="skolem">qs</span> <span class="skolem">ss</span>"</span></span>
        <span class="quoted"><span class="quoted">"list_all_zip <span class="main">(</span>accs_laz δss<span class="main">)</span> <span class="skolem">ts</span> <span class="skolem">ss</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">erule_tac</span> laz_swap_ex<span class="main">)</span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> I<span class="main">(</span>2<span class="main">)</span> SS<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> 
        LEN<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="skolem">qs</span> <span class="main">=</span> length <span class="skolem">ts</span>"</span></span> <span class="quoted"><span class="quoted">"length <span class="skolem">ss</span> <span class="main">=</span> length <span class="skolem">ts</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list_all_zip_alt<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> ranked<span class="main">[</span><span class="operator">OF</span> I<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> AF<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="skolem">f</span> <span class="main">=</span> Some <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

      <span class="keyword1"><span class="command">from</span></span> δssI<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">f</span></span> <span class="quoted"><span class="skolem">ss</span></span><span class="main">,</span> <span class="operator">OF</span> _ SS<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> AF <span class="keyword1"><span class="command">have</span></span> 
        RULE_S<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>δss_lhs <span class="skolem">f</span> <span class="skolem">ss</span><span class="main">)</span> <span class="main">→</span> <span class="skolem">f</span> <span class="skolem">ss</span><span class="main">)</span> <span class="main">∈</span> δss"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      
      <span class="keyword1"><span class="command">from</span></span> accs_laz.intros<span class="main">[</span><span class="operator">OF</span> RULE_S SS<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> 
        G1<span class="main">:</span> <span class="quoted"><span class="quoted">"accs_laz δss <span class="main">(</span>NODE <span class="skolem">f</span> <span class="skolem">ts</span><span class="main">)</span> <span class="main">(</span>δss_lhs <span class="skolem">f</span> <span class="skolem">ss</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
      <span class="keyword1"><span class="command">from</span></span> I<span class="main">(</span>1<span class="main">)</span> SS<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span><span class="main">∈</span><span class="main">(</span>δss_lhs <span class="skolem">f</span> <span class="skolem">ss</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> δss_lhs_def<span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> G1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> exE conjE<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> that<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> accs_laz<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>


  <span class="keyword1"><span class="command">lemma</span></span> δss_accs_precise<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"accs δss <span class="free">t</span> <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">q</span><span class="main">∈</span><span class="free">s</span>"</span></span>  
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"accs δ <span class="free">t</span> <span class="free">q</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> A
    <span class="keyword1"><span class="command">unfolding</span></span> accs_laz
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="skolem">δ</span><span class="main"><span class="main">≡</span></span><span class="quoted">δss</span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">s</span></span> 
                <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">q</span></span> 
                <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> accs_laz.induct<span class="main"><span class="main">[</span></span><span class="operator">case_names</span> step<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">s</span> <span class="skolem">f</span> <span class="skolem">ss</span> <span class="skolem">ts</span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> I<span class="main">:</span>
      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">s</span> <span class="main">→</span> <span class="skolem">f</span> <span class="skolem">ss</span><span class="main">)</span> <span class="main">∈</span> δss"</span></span>
      <span class="quoted"><span class="quoted">"list_all_zip <span class="main">(</span>accs_laz δss<span class="main">)</span> <span class="skolem">ts</span> <span class="skolem">ss</span>"</span></span>
      <span class="quoted"><span class="quoted">"list_all_zip <span class="main">(</span><span class="main">λ</span><span class="bound">t</span> <span class="bound">s</span><span class="main">.</span> <span class="main">∀</span><span class="bound">q</span><span class="main">∈</span><span class="bound">s</span><span class="main">.</span> accs_laz δ <span class="bound">t</span> <span class="bound">q</span><span class="main">)</span> <span class="skolem">ts</span> <span class="skolem">ss</span>"</span></span>
      <span class="quoted"><span class="quoted">"<span class="skolem">q</span><span class="main">∈</span><span class="skolem">s</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Ball_def<span class="main">)</span>
      
    <span class="keyword1"><span class="command">from</span></span> I<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="skolem">ss</span> <span class="main">=</span> length <span class="skolem">ts</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list_all_zip_alt<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> I<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> SS<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="skolem">f</span> <span class="main">=</span> Some <span class="main">(</span>length <span class="skolem">ts</span><span class="main">)</span>"</span></span>
      <span class="quoted"><span class="quoted">"<span class="skolem">ss</span> <span class="main">∈</span> lists <span class="main">{</span><span class="bound">s</span><span class="main">.</span> <span class="bound">s</span><span class="main">⊆</span>Q<span class="main">}</span>"</span></span>
      <span class="quoted"><span class="quoted">"<span class="skolem">s</span><span class="main">=</span>δss_lhs <span class="skolem">f</span> <span class="skolem">ss</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> δss.cases<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      
    <span class="keyword1"><span class="command">from</span></span> I<span class="main">(</span>4<span class="main">)</span> SS<span class="main">(</span>3<span class="main">)</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">qs</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      RULE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">q</span> <span class="main">→</span> <span class="skolem">f</span> <span class="skolem">qs</span><span class="main">)</span> <span class="main">∈</span> δ"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
      QSISS<span class="main">:</span> <span class="quoted"><span class="quoted">"list_all_zip <span class="main">(∈)</span> <span class="skolem">qs</span> <span class="skolem">ss</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> δss_lhs_def<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> I<span class="main">(</span>3<span class="main">)</span> QSISS <span class="keyword1"><span class="command">have</span></span> CA<span class="main">:</span> <span class="quoted"><span class="quoted">"list_all_zip <span class="main">(</span>accs_laz δ<span class="main">)</span> <span class="skolem">ts</span> <span class="skolem">qs</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list_all_zip_alt<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> accs_laz.intros<span class="main">[</span><span class="operator">OF</span> RULE CA<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
    

  <span class="comment1">― ‹Determinization›</span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">detTA</span> <span class="main">==</span> <span class="main">⦇</span> ta_initial <span class="main">=</span> <span class="main">{</span> <span class="bound">s</span><span class="main">.</span> <span class="bound">s</span><span class="main">⊆</span>Q <span class="main">∧</span> <span class="bound">s</span><span class="main">∩</span>Qi <span class="main">≠</span> <span class="main">{}</span> <span class="main">}</span><span class="main">,</span> 
                         ta_rules <span class="main">=</span> δss <span class="main">⦈</span>"</span></span>
      
  <span class="keyword1"><span class="command">theorem</span></span> detTA_is_ta<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"det_tree_automaton detTA <span class="free">A</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> detTA_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> δss.cases<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    

  <span class="keyword1"><span class="command">theorem</span></span> detTA_lang<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"ta_lang <span class="main">(</span>detTA<span class="main">)</span> <span class="main">=</span> ta_lang <span class="free">TA</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> ta_lang_def detTA_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">t</span> <span class="skolem">s</span>
    <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="skolem">s</span><span class="main">⊆</span>Q <span class="main">∧</span> <span class="skolem">s</span><span class="main">∩</span>Qi <span class="main">≠</span> <span class="main">{}</span>"</span></span>
      <span class="quoted"><span class="quoted">"accs δss <span class="skolem">t</span> <span class="skolem">s</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> A<span class="main">(</span>1<span class="main">)</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">qi</span></span> <span class="keyword2"><span class="keyword">where</span></span> QI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">qi</span><span class="main">∈</span><span class="skolem">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">qi</span><span class="main">∈</span>Qi"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">from</span></span> δss_accs_precise<span class="main">[</span><span class="operator">OF</span> A<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> QI<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"accs δ <span class="skolem">t</span> <span class="skolem">qi</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">with</span></span> QI<span class="main">(</span>2<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">qi</span><span class="main">∈</span>Qi<span class="main">.</span> accs δ <span class="skolem">t</span> <span class="bound">qi</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">t</span> <span class="skolem">qi</span>
    <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="skolem">qi</span><span class="main">∈</span>Qi"</span></span> 
      <span class="quoted"><span class="quoted">"accs δ <span class="skolem">t</span> <span class="skolem">qi</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> δss_accs_sound<span class="main">[</span><span class="operator">OF</span> A<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">s</span></span> <span class="keyword2"><span class="keyword">where</span></span> SS<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="skolem">s</span><span class="main">⊆</span>Q"</span></span> 
      <span class="quoted"><span class="quoted">"<span class="skolem">qi</span><span class="main">∈</span><span class="skolem">s</span>"</span></span> 
      <span class="quoted"><span class="quoted">"accs δss <span class="skolem">t</span> <span class="skolem">s</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">with</span></span> A<span class="main">(</span>1<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound"><span class="bound">s</span></span><span class="main">⊆</span>Q<span class="main">.</span> <span class="bound">s</span> <span class="main">∩</span> Qi <span class="main">≠</span> <span class="main">{}</span> <span class="main">∧</span> accs δss <span class="skolem">t</span> <span class="bound">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
    
  <span class="keyword1"><span class="command">lemmas</span></span> detTA_correct <span class="main">=</span> detTA_is_ta detTA_lang
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">"Completion"</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  To each deterministic tree automaton, rules and states can be added to make
  it complete, without changing its language.
›</span></span>

<span class="keyword1"><span class="command">context</span></span> det_tree_automaton
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="comment1">― ‹States of the complete automaton›</span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">Qcomplete</span> <span class="main">==</span> insert None <span class="main">(</span>Some<span class="main">`</span>Q<span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> Qcomplete_finite<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite Qcomplete"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Qcomplete_def<span class="main">)</span>

  <span class="comment1">― ‹Rules of the complete automaton›</span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">δcomplete</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span> option<span class="main">,</span> <span class="tfree">'L</span><span class="main">)</span> ta_rule set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">δcomplete</span> <span class="main">==</span> <span class="main">(</span>remap_rule Some <span class="main">`</span> δ<span class="main">)</span> 
                  <span class="main">∪</span> <span class="main">{</span> <span class="main">(</span>None <span class="main">→</span> <span class="bound">f</span> <span class="bound">qs</span><span class="main">)</span> <span class="main">|</span> <span class="bound">f</span> <span class="bound">qs</span><span class="main">.</span> 
                         <span class="free">A</span> <span class="bound">f</span> <span class="main">=</span> Some <span class="main">(</span>length <span class="bound">qs</span><span class="main">)</span> 
                         <span class="main">∧</span> <span class="bound">qs</span><span class="main">∈</span>lists Qcomplete 
                         <span class="main">∧</span> <span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound">qo</span> <span class="bound">qso</span><span class="main">.</span> <span class="main">(</span><span class="bound">qo</span> <span class="main">→</span> <span class="bound">f</span> <span class="bound">qso</span><span class="main">)</span><span class="main">∈</span>δ <span class="main">∧</span> <span class="bound">qs</span><span class="main">=</span>map Some <span class="bound">qso</span> <span class="main">)</span> <span class="main">}</span>"</span></span>


  <span class="keyword1"><span class="command">lemma</span></span> δ_states_complete<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q</span><span class="main">∈</span>δ_states δcomplete <span class="main">⟹</span> <span class="free">q</span><span class="main">∈</span>Qcomplete"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> δ_statesE<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> δcomplete_def Qcomplete_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ta_rstates_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> δ_statesI<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ta_rstates_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> δ_statesI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    

  <span class="keyword1"><span class="command">definition</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">completeTA</span> <span class="main">==</span> <span class="main">⦇</span> ta_initial <span class="main">=</span> Some<span class="main">`</span>Qi<span class="main">,</span> ta_rules <span class="main">=</span> δcomplete <span class="main">⦈</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> δcomplete_finite<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite δcomplete"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"δcomplete <span class="main">⊆</span> legal_rules Qcomplete"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> legal_rulesI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> δcomplete_def Qcomplete_def ta_rstates_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">xa</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> δ_statesI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">xa</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> δ_statesI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> δcomplete_def Qcomplete_def ta_rstates_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">xa</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ranked<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_subset<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">theorem</span></span> completeTA_is_ta<span class="main">:</span> <span class="quoted"><span class="quoted">"complete_tree_automaton completeTA <span class="free">A</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> 1 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> completeTA_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> 2 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> completeTA_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> 3 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> completeTA_def δcomplete_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ranked<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> 4 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> completeTA_def δcomplete_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">xa</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> deterministic<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> prems<span class="main">:</span> <span class="main">(</span>5 <span class="skolem">qs</span> <span class="skolem">f</span><span class="main">)</span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">qo</span> <span class="skolem">qso</span>
      <span class="keyword3"><span class="command">assume</span></span> R<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">qo</span> <span class="main">→</span> <span class="skolem">f</span> <span class="skolem">qso</span><span class="main">)</span><span class="main">∈</span>δ"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">qs</span><span class="main">=</span>map Some <span class="skolem">qso</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>Some <span class="skolem">qo</span><span class="main">)</span> <span class="main">→</span> <span class="skolem">f</span> <span class="skolem">qs</span><span class="main">)</span> <span class="main">∈</span> remap_rule Some <span class="main">`</span> δ"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> completeTA_def δcomplete_def<span class="main">)</span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound">qo</span> <span class="bound">qso</span><span class="main">.</span> <span class="main">(</span><span class="bound">qo</span> <span class="main">→</span> <span class="skolem">f</span> <span class="bound">qso</span><span class="main">)</span><span class="main">∈</span>δ <span class="main">∧</span> <span class="skolem">qs</span><span class="main">=</span>map Some <span class="bound">qso</span><span class="main">)</span>"</span></span>

      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Some <span class="main">`</span> Qi <span class="main">∪</span> δ_states δcomplete<span class="main">)</span> <span class="main">⊆</span> Qcomplete"</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> δ_states_complete<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Qcomplete_def ta_rstates_def<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

      <span class="keyword1"><span class="command">with</span></span> prems <span class="keyword1"><span class="command">have</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">qs</span><span class="main">∈</span>lists Qcomplete"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> completeTA_def ta_rstates_def<span class="main">)</span>

      <span class="keyword1"><span class="command">from</span></span> A B prems<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted">None</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> completeTA_def δcomplete_def<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">theorem</span></span> completeTA_lang<span class="main">:</span> <span class="quoted"><span class="quoted">"ta_lang completeTA <span class="main">=</span> ta_lang <span class="free">TA</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> equalityI subsetI<span class="main">)</span>
    <span class="comment1">― ‹This direction is done by a monotonicity argument›</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">t</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">t</span><span class="main">∈</span>ta_lang <span class="free">TA</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">qi</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">qi</span><span class="main">∈</span>Qi"</span></span> <span class="quoted"><span class="quoted">"accs δ <span class="skolem">t</span> <span class="skolem">qi</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ta_lang_def<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> 
      QI<span class="main">:</span> <span class="quoted"><span class="quoted">"Some <span class="skolem">qi</span> <span class="main">∈</span> Some<span class="main">`</span>Qi"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
      ACCS<span class="main">:</span> <span class="quoted"><span class="quoted">"accs <span class="main">(</span>remap_rule Some<span class="main">`</span>δ<span class="main">)</span> <span class="skolem">t</span> <span class="main">(</span>Some <span class="skolem">qi</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> remap_accs1<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>remap_rule Some<span class="main">`</span>δ<span class="main">)</span> <span class="main">⊆</span> δcomplete"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> δcomplete_def<span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> ACCS <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"accs δcomplete <span class="skolem">t</span> <span class="main">(</span>Some <span class="skolem">qi</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> accs_mono<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">t</span><span class="main">∈</span>ta_lang completeTA"</span></span> <span class="keyword1"><span class="command">using</span></span> QI 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ta_lang_def completeTA_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">t</span>
    <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">t</span><span class="main">∈</span>ta_lang completeTA"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">qi</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
      QI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">qi</span><span class="main">∈</span>Qi"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
      ACCS<span class="main">:</span> <span class="quoted"><span class="quoted">"accs δcomplete <span class="skolem">t</span> <span class="main">(</span>Some <span class="skolem">qi</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ta_lang_def completeTA_def<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">qi</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> accs δcomplete <span class="skolem">t</span> <span class="main">(</span>Some <span class="skolem">qi</span><span class="main">)</span> <span class="main">⟧</span> <span class="main">⟹</span> accs δ <span class="skolem">t</span> <span class="skolem">qi</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> accs_laz
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="skolem">δ</span><span class="main"><span class="main">≡</span></span><span class="quoted">δcomplete</span> <span class="quoted"><span class="skolem">t</span></span> <span class="skolem">q</span><span class="main"><span class="main">≡</span></span><span class="quoted"><span class="quoted">"Some <span class="skolem">qi</span>"</span></span>
                    <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">qi</span></span>
                    <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> accs_laz.induct<span class="main"><span class="main">[</span></span><span class="operator">case_names</span> step<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">f</span> <span class="skolem">qs</span> <span class="skolem">ts</span> <span class="skolem">qi</span><span class="main">)</span>
        <span class="keyword1"><span class="command">hence</span></span> I<span class="main">:</span>
          <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>Some <span class="skolem">qi</span><span class="main">)</span> <span class="main">→</span> <span class="skolem">f</span> <span class="skolem">qs</span><span class="main">)</span> <span class="main">∈</span> δcomplete"</span></span>
          <span class="quoted"><span class="quoted">"list_all_zip <span class="main">(</span>accs_laz δcomplete<span class="main">)</span> <span class="skolem">ts</span> <span class="skolem">qs</span>"</span></span>
          <span class="quoted"><span class="quoted">"list_all_zip <span class="main">(</span><span class="main">λ</span><span class="bound">t</span> <span class="bound">q</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">qo</span><span class="main">.</span> <span class="bound">q</span><span class="main">=</span>Some <span class="bound">qo</span> <span class="main">⟶</span> accs_laz δ <span class="bound">t</span> <span class="bound">qo</span><span class="main">)</span><span class="main">)</span> <span class="skolem">ts</span> <span class="skolem">qs</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">from</span></span> I<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>Some <span class="skolem">qi</span><span class="main">)</span> <span class="main">→</span> <span class="skolem">f</span> <span class="skolem">qs</span><span class="main">)</span> <span class="main">∈</span> remap_rule Some<span class="main">`</span>δ"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> δcomplete_def<span class="main">)</span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">qso</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
          RULE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">qi</span> <span class="main">→</span> <span class="skolem">f</span> <span class="skolem">qso</span><span class="main">)</span><span class="main">∈</span>δ"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
          QSF<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">qs</span><span class="main">=</span>map Some <span class="skolem">qso</span>"</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
        <span class="keyword1"><span class="command">from</span></span> I<span class="main">(</span>3<span class="main">)</span> QSF <span class="keyword1"><span class="command">have</span></span> ACCS<span class="main">:</span> <span class="quoted"><span class="quoted">"list_all_zip <span class="main">(</span>accs_laz δ<span class="main">)</span> <span class="skolem">ts</span> <span class="skolem">qso</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list_all_zip_alt<span class="main">)</span>
        <span class="keyword1"><span class="command">from</span></span> accs_laz.intros<span class="main">[</span><span class="operator">OF</span> RULE ACCS<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">.</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"accs δ <span class="skolem">t</span> <span class="skolem">qi</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">t</span><span class="main">∈</span>ta_lang <span class="free">TA</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> QI <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ta_lang_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
        
  <span class="keyword1"><span class="command">lemmas</span></span> completeTA_correct <span class="main">=</span> completeTA_is_ta completeTA_lang
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">"Complement"</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  A deterministic, complete tree automaton can be transformed into an automaton
  accepting the complement language by complementing its initial states.
›</span></span>

<span class="keyword1"><span class="command">context</span></span> complete_tree_automaton
<span class="keyword2"><span class="keyword">begin</span></span>

    <span class="comment1">― ‹Complement automaton, i.e. that accepts exactly the 
        trees not accepted by this automaton›</span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">complementTA</span> <span class="main">==</span> <span class="main">⦇</span>
    ta_initial <span class="main">=</span> Q <span class="main">-</span> Qi<span class="main">,</span>
    ta_rules <span class="main">=</span> δ <span class="main">⦈</span>"</span></span>

    
  <span class="keyword1"><span class="command">lemma</span></span> cta_rules<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ta_rules complementTA <span class="main">=</span> δ"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> complementTA_def<span class="main">)</span>

  <span class="keyword1"><span class="command">theorem</span></span> complementTA_correct<span class="main">:</span>
    <span class="quoted"><span class="quoted">"ta_lang complementTA <span class="main">=</span> ranked_trees <span class="free">A</span> <span class="main">-</span> ta_lang <span class="free">TA</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T1</span></span></span><span class="main">)</span>
    <span class="quoted"><span class="quoted">"complete_tree_automaton complementTA <span class="free">A</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T2</span></span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?T1</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> ta_lang_def complementTA_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> accs_is_ranked <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> accs_unique label_all<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="keyword1"><span class="command">have</span></span> QSS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">!!</span><span class="bound">q</span><span class="main">.</span> <span class="bound">q</span><span class="main">∈</span>ta_rstates complementTA <span class="main">⟹</span> <span class="bound">q</span><span class="main">∈</span>Q"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> complementTA_def ta_rstates_def<span class="main">)</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?T2</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> complementTA_def<span class="main">)</span><span class="main"><span class="keyword3">[</span></span>4<span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> deterministic ranked 
                  <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> complete QSS<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Regular Tree Languages"</span></span>
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">"Definitions"</span></span>

  <span class="comment1">― ‹Regular languages over alphabet <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">A</span><span class="antiquote">}</span></span>›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">regular_languages</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'L</span> <span class="main">⇀</span> nat<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'L</span> tree set set"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">regular_languages</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">==</span> 
    <span class="main">{</span> ta_lang <span class="bound">TA</span> <span class="main">|</span> <span class="main">(</span><span class="bound">TA</span><span class="main">::</span><span class="main">(</span>nat<span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> tree_automaton_rec<span class="main">)</span><span class="main">.</span> 
                          ranked_tree_automaton <span class="bound">TA</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">}</span>"</span></span>


<span class="keyword1"><span class="command">lemma</span></span> rtlE<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">L</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'L</span> tree set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">L</span><span class="main">∈</span>regular_languages <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">TA</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span>nat<span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> tree_automaton_rec"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">L</span><span class="main">=</span>ta_lang <span class="free">TA</span>"</span></span>
    <span class="quoted"><span class="quoted">"ranked_tree_automaton <span class="free">TA</span> <span class="free">A</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> A that
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> regular_languages_def<span class="main">)</span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">context</span></span> ranked_tree_automaton
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> ranked_tree_automaton<span class="main">)</span> rtlI<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ta_lang <span class="free">TA</span> <span class="main">∈</span> regular_languages <span class="free">A</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="comment1">― ‹Obtain injective mapping from the finite set of states to the 
        natural numbers›</span>
    <span class="keyword1"><span class="command">from</span></span> finite_imp_inj_to_nat_seg<span class="main">[</span><span class="operator">OF</span> finite_states<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">f</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> <span class="main">⇒</span> nat"</span></span> 
      <span class="keyword2"><span class="keyword">where</span></span> INJMAP<span class="main">:</span> <span class="quoted"><span class="quoted">"inj_on <span class="skolem">f</span> <span class="main">(</span>ta_rstates <span class="free">TA</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="comment1">― ‹Remap automaton. The language remains the same.›</span>
    <span class="keyword1"><span class="command">from</span></span> remap_lang<span class="main">[</span><span class="operator">OF</span> INJMAP<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> LE<span class="main">:</span> <span class="quoted"><span class="quoted">"ta_lang <span class="main">(</span>ta_remap <span class="skolem">f</span> <span class="free">TA</span><span class="main">)</span> <span class="main">=</span> ta_lang <span class="free">TA</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ranked_tree_automaton <span class="main">(</span>ta_remap <span class="skolem">f</span> <span class="free">TA</span><span class="main">)</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> regular_languages_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
    It is sometimes more handy to obtain a complete, deterministic tree automaton
    accepting a given regular language.
›</span></span>
  <span class="keyword1"><span class="command">theorem</span></span> obtain_complete<span class="main">:</span>
    <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">TAC</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span> set option<span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> tree_automaton_rec"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"ta_lang <span class="free">TAC</span> <span class="main">=</span> ta_lang <span class="free">TA</span>"</span></span>
    <span class="quoted"><span class="quoted">"complete_tree_automaton <span class="free">TAC</span> <span class="free">A</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> detTA_correct <span class="keyword1"><span class="command">have</span></span> 
      DT<span class="main">:</span> <span class="quoted"><span class="quoted">"det_tree_automaton detTA <span class="free">A</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
      <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ta_lang detTA <span class="main">=</span> ta_lang <span class="free">TA</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
    
    <span class="keyword1"><span class="command">interpret</span></span> dt<span class="main">:</span> det_tree_automaton <span class="quoted">detTA</span> <span class="quoted"><span class="free">A</span></span> <span class="keyword1"><span class="command">using</span></span> DT <span class="keyword1"><span class="command">.</span></span>
    
    <span class="keyword1"><span class="command">from</span></span> dt.completeTA_correct <span class="keyword1"><span class="command">have</span></span> G<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"ta_lang <span class="main">(</span>det_tree_automaton.completeTA detTA <span class="free">A</span><span class="main">)</span> <span class="main">=</span> ta_lang <span class="free">TA</span>"</span></span>
      <span class="quoted"><span class="quoted">"complete_tree_automaton <span class="main">(</span>det_tree_automaton.completeTA detTA <span class="free">A</span><span class="main">)</span> <span class="free">A</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> that<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">lemma</span></span> rtlE_complete<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">L</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'L</span> tree set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">L</span><span class="main">∈</span>regular_languages <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">TA</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span>nat<span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> tree_automaton_rec"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">L</span><span class="main">=</span>ta_lang <span class="free">TA</span>"</span></span>
    <span class="quoted"><span class="quoted">"complete_tree_automaton <span class="free">TA</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> rtlE<span class="main">[</span><span class="operator">OF</span> A<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">TA</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat<span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> tree_automaton_rec"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">symmetric</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">L</span> <span class="main">=</span> ta_lang <span class="skolem">TA</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
        RT<span class="main">:</span> <span class="quoted"><span class="quoted">"ranked_tree_automaton <span class="skolem">TA</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">interpret</span></span> ta<span class="main">:</span> ranked_tree_automaton <span class="quoted"><span class="skolem">TA</span></span> <span class="quoted"><span class="free">A</span></span> <span class="keyword1"><span class="command">using</span></span> RT <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">TAC</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat set option<span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> tree_automaton_rec"</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ta_lang <span class="skolem">TAC</span> <span class="main">=</span> <span class="free">L</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> CT<span class="main">:</span> <span class="quoted"><span class="quoted">"complete_tree_automaton <span class="skolem">TAC</span> <span class="free">A</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> ta.obtain_complete<span class="main">)</span> <span class="operator">auto</span>
  
  <span class="keyword1"><span class="command">interpret</span></span> tac<span class="main">:</span> complete_tree_automaton <span class="quoted"><span class="skolem">TAC</span></span> <span class="quoted"><span class="free">A</span></span> <span class="keyword1"><span class="command">using</span></span> CT <span class="keyword1"><span class="command">.</span></span>

  <span class="comment1">― ‹Obtain injective mapping from the finite set of states to the 
      natural numbers›</span>
  <span class="keyword1"><span class="command">from</span></span> finite_imp_inj_to_nat_seg<span class="main">[</span><span class="operator">OF</span> tac.finite_states<span class="main">]</span> 
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">f</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat set option <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    INJMAP<span class="main">:</span> <span class="quoted"><span class="quoted">"inj_on <span class="skolem">f</span> <span class="main">(</span>ta_rstates <span class="skolem">TAC</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="comment1">― ‹Remap automaton. The language remains the same.›</span>
  <span class="keyword1"><span class="command">from</span></span> tac.remap_lang<span class="main">[</span><span class="operator">OF</span> INJMAP<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> LE<span class="main">:</span> <span class="quoted"><span class="quoted">"ta_lang <span class="main">(</span>ta_remap <span class="skolem">f</span> <span class="skolem">TAC</span><span class="main">)</span> <span class="main">=</span> <span class="free">L</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"complete_tree_automaton <span class="main">(</span>ta_remap <span class="skolem">f</span> <span class="skolem">TAC</span><span class="main">)</span> <span class="free">A</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> tac.remap_cta<span class="main">[</span><span class="operator">OF</span> INJMAP<span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> that<span class="main"><span class="main">[</span></span><span class="operator">OF</span> LE<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">"Closure Properties"</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  In this section, we derive the standard closure properties of regular languages,
  i.e. that regular languages are closed under union, intersection, complement, 
  and difference, as well as that the empty and the universal language are
  regular.
  
  Note that we do not formalize homomorphisms or tree transducers here.
›</span></span>
  
<span class="keyword1"><span class="command">theorem</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> finite_alphabet<span class="main">)</span> rtl_empty<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{}</span> <span class="main">∈</span> regular_languages <span class="free">A</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> ranked_tree_automaton.rtlI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ta_empty_rta<span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>


<span class="keyword1"><span class="command">theorem</span></span> rtl_union_closed<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">L1</span><span class="main">∈</span>regular_languages <span class="free">A</span><span class="main">;</span> <span class="free">L2</span><span class="main">∈</span>regular_languages <span class="free">A</span> <span class="main">⟧</span> 
    <span class="main">⟹</span> <span class="free">L1</span><span class="main">∪</span><span class="free">L2</span> <span class="main">∈</span> regular_languages <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">elim</span> rtlE<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">TA1</span> <span class="skolem">TA2</span>
  <span class="keyword3"><span class="command">assume</span></span> TA<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ranked_tree_automaton <span class="skolem">TA1</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"ranked_tree_automaton <span class="skolem">TA2</span> <span class="free">A</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">L1</span><span class="main">=</span>ta_lang <span class="skolem">TA1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">L2</span><span class="main">=</span>ta_lang <span class="skolem">TA2</span>"</span></span>


  <span class="keyword1"><span class="command">interpret</span></span> ta1<span class="main">:</span> ranked_tree_automaton <span class="quoted"><span class="skolem">TA1</span></span> <span class="quoted"><span class="free">A</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">interpret</span></span> ta2<span class="main">:</span> ranked_tree_automaton <span class="quoted"><span class="skolem">TA2</span></span> <span class="quoted"><span class="free">A</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ta_lang <span class="main">(</span>ta_union_wrap <span class="skolem">TA1</span> <span class="skolem">TA2</span><span class="main">)</span> <span class="main">=</span> ta_lang <span class="skolem">TA1</span> <span class="main">∪</span> ta_lang <span class="skolem">TA2</span>"</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ta_union_wrap_correct<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command">with</span></span> ranked_tree_automaton.rtlI<span class="main">[</span><span class="operator">OF</span> ta_union_wrap_rta<span class="main"><span class="main">[</span></span><span class="operator">OF</span> TA<span class="main"><span class="main">]</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">qed</span></span>
   
<span class="keyword1"><span class="command">theorem</span></span> rtl_inter_closed<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">L1</span><span class="main">∈</span>regular_languages <span class="free">A</span><span class="main">;</span> <span class="free">L2</span><span class="main">∈</span>regular_languages <span class="free">A</span><span class="main">⟧</span> <span class="main">⟹</span> 
    <span class="free">L1</span><span class="main">∩</span><span class="free">L2</span> <span class="main">∈</span> regular_languages <span class="free">A</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">elim</span> rtlE<span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">TA1</span> <span class="skolem">TA2</span><span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> ta_prod_correct<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">TA1</span></span></span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">TA2</span></span></span></span><span class="main">]</span> ta_prod_rta<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">TA1</span></span> <span class="quoted"><span class="free">A</span></span> <span class="quoted"><span class="skolem">TA2</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> 
     L<span class="main">:</span> <span class="quoted"><span class="quoted">"ta_lang <span class="main">(</span>ta_prod <span class="skolem">TA1</span> <span class="skolem">TA2</span><span class="main">)</span> <span class="main">=</span> <span class="free">L1</span><span class="main">∩</span><span class="free">L2</span>"</span></span>  <span class="keyword2"><span class="keyword">and</span></span>
     A<span class="main">:</span> <span class="quoted"><span class="quoted">"ranked_tree_automaton <span class="main">(</span>ta_prod <span class="skolem">TA1</span> <span class="skolem">TA2</span><span class="main">)</span> <span class="free">A</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ranked_tree_automaton.axioms<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> ranked_tree_automaton.rtlI<span class="main">[</span><span class="operator">OF</span> A<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> L<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> rtl_complement_closed<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">L</span><span class="main">∈</span>regular_languages <span class="free">A</span> <span class="main">⟹</span> ranked_trees <span class="free">A</span> <span class="main">-</span> <span class="free">L</span> <span class="main">∈</span> regular_languages <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">elim</span> rtlE_complete<span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> prems<span class="main">:</span> <span class="main">(</span>1 <span class="skolem">TA</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> ta<span class="main">:</span> complete_tree_automaton <span class="quoted"><span class="skolem">TA</span></span> <span class="quoted"><span class="free">A</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  
  <span class="keyword1"><span class="command">from</span></span> ta.complementTA_correct <span class="keyword1"><span class="command">have</span></span>
    <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ta_lang <span class="main">(</span>ta.complementTA<span class="main">)</span> <span class="main">=</span> ranked_trees <span class="free">A</span> <span class="main">-</span> ta_lang <span class="skolem">TA</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    CTA<span class="main">:</span> <span class="quoted"><span class="quoted">"complete_tree_automaton ta.complementTA <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">interpret</span></span> cta<span class="main">:</span> complete_tree_automaton <span class="quoted">ta.complementTA</span> <span class="quoted"><span class="free">A</span></span> <span class="keyword1"><span class="command">using</span></span> CTA <span class="keyword1"><span class="command">.</span></span>
  
  <span class="keyword1"><span class="command">from</span></span> cta.rtlI prems<span class="main">(</span>1<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> finite_alphabet<span class="main">)</span> rtl_univ<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"ranked_trees <span class="free">A</span> <span class="main">∈</span> regular_languages <span class="free">A</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> rtl_complement_closed<span class="main">[</span><span class="operator">OF</span> rtl_empty<span class="main">]</span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">theorem</span></span> rtl_diff_closed<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">L1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'L</span> tree set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">L1</span> <span class="main">∈</span> regular_languages <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">L2</span><span class="main">∈</span>regular_languages <span class="free">A</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">L1</span><span class="main">-</span><span class="free">L2</span> <span class="main">∈</span> regular_languages <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> rtlE<span class="main">[</span><span class="operator">OF</span> A<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">TA1</span></span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span>nat<span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> tree_automaton_rec"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    L1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">L1</span><span class="main">=</span>ta_lang <span class="skolem">TA1</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    RT1<span class="main">:</span> <span class="quoted"><span class="quoted">"ranked_tree_automaton <span class="skolem">TA1</span> <span class="free">A</span>"</span></span>
    <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">from</span></span> rtlE<span class="main">[</span><span class="operator">OF</span> A<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">TA2</span></span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span>nat<span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> tree_automaton_rec"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    L2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">L2</span><span class="main">=</span>ta_lang <span class="skolem">TA2</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    RT2<span class="main">:</span> <span class="quoted"><span class="quoted">"ranked_tree_automaton <span class="skolem">TA2</span> <span class="free">A</span>"</span></span>
    <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">interpret</span></span> ta1<span class="main">:</span> ranked_tree_automaton <span class="quoted"><span class="skolem">TA1</span></span> <span class="quoted"><span class="free">A</span></span> <span class="keyword1"><span class="command">using</span></span> RT1 <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> ta2<span class="main">:</span> ranked_tree_automaton <span class="quoted"><span class="skolem">TA2</span></span> <span class="quoted"><span class="free">A</span></span> <span class="keyword1"><span class="command">using</span></span> RT2 <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">from</span></span> ta1.lang_is_ranked <span class="keyword1"><span class="command">have</span></span> ALT<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">L1</span><span class="main">-</span><span class="free">L2</span> <span class="main">=</span> <span class="free">L1</span> <span class="main">∩</span> <span class="main">(</span>ranked_trees <span class="free">A</span> <span class="main">-</span> <span class="free">L2</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> L1 L2<span class="main">)</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> ALT
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rtl_complement_closed rtl_inter_closed<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">lemmas</span></span> rtl_closed <span class="main">=</span> finite_alphabet.rtl_empty finite_alphabet.rtl_univ 
  rtl_complement_closed
  rtl_inter_closed rtl_union_closed rtl_diff_closed


<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="AbsAlgo">
<div class="head">
<h1>Theory AbsAlgo</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Tree Automata
    Author:      Peter Lammich &lt;peter dot lammich at uni-muenster.de&gt;
    Maintainer:  Peter Lammich &lt;peter dot lammich at uni-muenster.de&gt;
*)</span>
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Abstract Tree Automata Algorithms"</span></span>
<span class="keyword1"><span class="command">theory</span></span> AbsAlgo
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="Ta.html">Ta</a> 
  <a href="../Collections_Examples/Exploration.html">Collections_Examples.Exploration</a>
  <a href="../Collections/CollectionsV1.html">Collections.CollectionsV1</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">no_notation</span></span> fun_rel_syn <span class="main">(</span><span class="keyword2"><span class="keyword">infixr</span></span> <span class="quoted">"<span class="keyword1">→</span>"</span> 60<span class="main">)</span>

<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:absalgo}›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This theory defines tree automata algorithms on an abstract level, 
  that is using non-executable datatypes and constructs like sets, 
  set-collecting operations, etc. 
    
  These algorithms are then refined to executable algorithms in 
  Section~\ref{sec:taimpl}.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Word Problem›</span></span>
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  First, a recursive version of the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> accs<span class="antiquote"><span class="antiquote">}</span></span></span></span>-predicate is defined.
›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">r_match</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">r_match</span> <span class="main">[]</span> <span class="main">[]</span> <span class="main">⟷</span> True"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">r_match</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">AS</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">∧</span> <span class="free">r_match</span> <span class="free"><span class="bound"><span class="entity">AS</span></span></span> <span class="free"><span class="bound"><span class="entity">as</span></span></span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">r_match</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">⟷</span> False"</span></span>

<span class="comment1">― ‹<span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> r_match<span class="antiquote">}</span></span> accepts two lists, if they have the same length and 
  the elements in the second list are contained in the respective 
  elements of the first list:›</span>
<span class="keyword1"><span class="command">lemma</span></span> r_match_alt<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"r_match <span class="free">L</span> <span class="free">l</span> <span class="main">⟷</span> length <span class="free">L</span> <span class="main">=</span> length <span class="free">l</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>length <span class="free">l</span><span class="main">.</span> <span class="free">l</span><span class="main">!</span><span class="bound">i</span> <span class="main">∈</span> <span class="free">L</span><span class="main">!</span><span class="bound">i</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">L</span></span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> r_match.induct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">i</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="comment1">― ‹Whether a rule matches the given state, label and list of sets of states›</span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">r_matchc</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">r_matchc</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">Qs</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">qr</span></span></span> <span class="main">→</span> <span class="free"><span class="bound"><span class="entity">lr</span></span></span> <span class="free"><span class="bound"><span class="entity">qsr</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">qr</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">lr</span></span></span> <span class="main">∧</span> r_match <span class="free"><span class="bound"><span class="entity">Qs</span></span></span> <span class="free"><span class="bound"><span class="entity">qsr</span></span></span>"</span></span>

<span class="comment1">― ‹recursive version of <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> accs<span class="antiquote">}</span></span>-predicate›</span>  
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">faccs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule set <span class="main">⇒</span> <span class="tfree">'L</span> tree <span class="main">⇒</span> <span class="tfree">'Q</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">faccs</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">(</span>NODE <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
    <span class="keyword1">let</span> <span class="bound">Qs</span> <span class="main">=</span> map <span class="main">(</span><span class="free">faccs</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">)</span> <span class="keyword1">in</span>
      <span class="main">{</span><span class="bound">q</span><span class="main">.</span> <span class="main">∃</span><span class="bound">r</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">δ</span></span></span><span class="main">.</span> r_matchc <span class="bound">q</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">Qs</span> <span class="bound">r</span> <span class="main">}</span>
  <span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> faccs_correct_aux<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">q</span><span class="main">∈</span>faccs <span class="free">δ</span> <span class="free">n</span> <span class="main">=</span> accs <span class="free">δ</span> <span class="free">n</span> <span class="free">q</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T1</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>map <span class="main">(</span>faccs <span class="free">δ</span><span class="main">)</span> <span class="free">ts</span> <span class="main">=</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">t</span><span class="main">.</span> <span class="main">{</span> <span class="bound">q</span> <span class="main">.</span> accs <span class="free">δ</span> <span class="bound">t</span> <span class="bound">q</span><span class="main">}</span><span class="main">)</span> <span class="free">ts</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T2</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">q</span><span class="main">.</span> <span class="bound">q</span><span class="main">∈</span>faccs <span class="free">δ</span> <span class="free">n</span> <span class="main">=</span> accs <span class="free">δ</span> <span class="free">n</span> <span class="bound">q</span><span class="main">)</span> 
        <span class="main">∧</span> <span class="main">(</span>map <span class="main">(</span>faccs <span class="free">δ</span><span class="main">)</span> <span class="free">ts</span> <span class="main">=</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">t</span><span class="main">.</span> <span class="main">{</span> <span class="bound">q</span> <span class="main">.</span> accs <span class="free">δ</span> <span class="bound">t</span> <span class="bound">q</span><span class="main">}</span><span class="main">)</span> <span class="free">ts</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> compat_tree_tree_list.induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>NODE <span class="skolem">f</span> <span class="skolem">ts</span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI iffI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> bexE<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> accs.intros<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> r_match_alt<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> accs.cases<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">qa</span> <span class="main">→</span> <span class="skolem">f</span> <span class="improper">qs</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> bexI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> r_match_alt<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?T1</span></span></span> <span class="var"><span class="quoted"><span class="var">?T2</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> faccs_correct1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q</span><span class="main">∈</span>faccs <span class="free">δ</span> <span class="free">n</span> <span class="main">⟹</span> accs <span class="free">δ</span> <span class="free">n</span> <span class="free">q</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> faccs_correct_aux<span class="main">)</span>
<span class="keyword1"><span class="command">theorem</span></span> faccs_correct2<span class="main">:</span> <span class="quoted"><span class="quoted">"accs <span class="free">δ</span> <span class="free">n</span> <span class="free">q</span> <span class="main">⟹</span> <span class="free">q</span><span class="main">∈</span>faccs <span class="free">δ</span> <span class="free">n</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> faccs_correct_aux<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> faccs_correct <span class="main">=</span> faccs_correct1 faccs_correct2

<span class="keyword1"><span class="command">lemma</span></span> faccs_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"faccs <span class="free">δ</span> <span class="free">t</span> <span class="main">=</span> <span class="main">{</span><span class="bound">q</span><span class="main">.</span> accs <span class="free">δ</span> <span class="free">t</span> <span class="bound">q</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> faccs_correct<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Backward Reduction and Emptiness Check›</span></span>
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">"Auxiliary Definitions"</span></span>

<span class="comment1">― ‹Step function, that maps a set of states to those states 
  that are reachable via one backward step.›</span>
<span class="keyword1"><span class="command">inductive_set</span></span> <span class="entity">bacc_step</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule set <span class="main">⇒</span> <span class="tfree">'Q</span> set <span class="main">⇒</span> <span class="tfree">'Q</span> set"</span></span> 
  <span class="keyword2"><span class="keyword">for</span></span> <span class="entity">δ</span> <span class="entity">Q</span> 
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">∈</span><span class="free">δ</span><span class="main">;</span> set <span class="main">(</span>rhsq <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">⊆</span> <span class="free">Q</span> <span class="main">⟧</span> <span class="main">⟹</span> lhs <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">∈</span> <span class="free">bacc_step</span> <span class="free">δ</span> <span class="free">Q</span>"</span></span>

<span class="comment1">― ‹If a set is closed under adding all states that are reachable from the set 
  by one backward step, then this set contains all backward accessible states.›</span>
<span class="keyword1"><span class="command">lemma</span></span> b_accs_as_closed<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"bacc_step <span class="free">δ</span> <span class="free">Q</span> <span class="main">⊆</span> <span class="free">Q</span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"b_accessible <span class="free">δ</span> <span class="main">⊆</span> <span class="free">Q</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">q</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span><span class="main">∈</span>b_accessible <span class="free">δ</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span><span class="main">∈</span><span class="free">Q</span>"</span></span> 
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> b_accessible.induct<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">q</span> <span class="skolem">f</span> <span class="skolem">qs</span>
    <span class="keyword3"><span class="command">assume</span></span> BC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">q</span><span class="main">→</span><span class="skolem">f</span> <span class="skolem">qs</span><span class="main">)</span><span class="main">∈</span><span class="free">δ</span>"</span></span> 
               <span class="quoted"><span class="quoted">"<span class="main">!!</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span>set <span class="skolem">qs</span> <span class="main">⟹</span> <span class="bound">x</span><span class="main">∈</span>b_accessible <span class="free">δ</span>"</span></span> 
               <span class="quoted"><span class="quoted">"<span class="main">!!</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span>set <span class="skolem">qs</span> <span class="main">⟹</span> <span class="bound">x</span><span class="main">∈</span><span class="free">Q</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> bacc_step.intros<span class="main">[</span><span class="operator">OF</span> BC<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> BC<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span><span class="main">∈</span>bacc_step <span class="free">δ</span> <span class="free">Q</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> A <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span><span class="main">∈</span><span class="free">Q</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">"Algorithms"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  First, the basic workset algorithm is specified. 
  Then, it is refined to contain a counter for each rule, 
  that counts the number of undiscovered states on the RHS. 
  For both levels of abstraction, a version that computes the 
  backwards reduction, and a version that checks for emptiness is specified.

  Additionally, a version of the algorithm that computes a witness
  for non-emptiness is provided.
  
  Levels of abstraction:
  \begin{itemize} 
    \item[<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>α›</span></span></span></span>] On this level, the state consists of a set of 
      discovered states and a workset.
    \item[<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>α'›</span></span></span></span>] On this level, the state consists of a set of 
      discovered states, a workset and a map from rules to number of 
      undiscovered rhs states. This map can be used to make the discovery of
      rules that have to be considered more efficient.
  \end{itemize}
›</span></span>

<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\paragraph {<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>α›</span></span></span></span> - Level:}›</span></span>

  <span class="comment1">― ‹A state contains the set of discovered states and a workset›</span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> br_state <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> set <span class="main">×</span> <span class="tfree">'Q</span> set"</span></span>

  <span class="comment1">― ‹Set of states that are non-empty (accept a tree) after adding the 
  state $q$ to the set of discovered states›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">br_dsq</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule set <span class="main">⇒</span> <span class="tfree">'Q</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> br_state <span class="main">⇒</span> <span class="tfree">'Q</span> set"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span>  
  <span class="quoted"><span class="quoted">"<span class="free">br_dsq</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">==</span> <span class="main">λ</span><span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">)</span><span class="main">.</span> <span class="main">{</span> lhs <span class="bound">r</span> <span class="main">|</span> <span class="bound">r</span><span class="main">.</span> <span class="bound">r</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">∧</span> set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">(</span><span class="bound">Q</span><span class="main">-</span><span class="main">(</span><span class="bound">W</span><span class="main">-</span><span class="main">{</span><span class="free"><span class="bound"><span class="entity">q</span></span></span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">}</span>"</span></span>

  <span class="comment1">― ‹Description of a step: One state is removed from the workset, and all 
  new states that become non-empty due to this state are added to, both, 
  the workset and the set of discovered states›</span>
<span class="keyword1"><span class="command">inductive_set</span></span> <span class="entity">br_step</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule set <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> br_state <span class="main">×</span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> br_state<span class="main">)</span> set"</span></span> 
  <span class="keyword2"><span class="keyword">for</span></span> <span class="entity">δ</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>
     <span class="free"><span class="bound"><span class="entity">q</span></span></span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">W</span></span></span><span class="main">;</span>
     <span class="free"><span class="bound"><span class="entity">Q'</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">∪</span> br_dsq <span class="free">δ</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">W</span></span></span><span class="main">)</span><span class="main">;</span>
     <span class="free"><span class="bound"><span class="entity">W'</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">W</span></span></span> <span class="main">-</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">q</span></span></span><span class="main">}</span> <span class="main">∪</span> <span class="main">(</span>br_dsq <span class="free">δ</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">W</span></span></span><span class="main">)</span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">)</span>
   <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">W</span></span></span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">Q'</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">W'</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">∈</span><span class="free">br_step</span> <span class="free">δ</span>"</span></span>

  <span class="comment1">― ‹Termination condition for backwards reduction: The workset is empty›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">br_cond</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> br_state set"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">br_cond</span> <span class="main">==</span> <span class="main">{</span><span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">)</span><span class="main">.</span> <span class="bound">W</span><span class="main">≠</span><span class="main">{}</span><span class="main">}</span>"</span></span>

  <span class="comment1">― ‹Termination condition for emptiness check: 
      The workset is empty or a non-empty initial state has been discovered›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">bre_cond</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> br_state set"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">bre_cond</span> <span class="free"><span class="bound"><span class="entity">Qi</span></span></span> <span class="main">==</span> <span class="main">{</span><span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">)</span><span class="main">.</span> <span class="bound">W</span><span class="main">≠</span><span class="main">{}</span> <span class="main">∧</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">Qi</span></span></span><span class="main">∩</span><span class="bound">Q</span><span class="main">=</span><span class="main">{}</span><span class="main">)</span><span class="main">}</span>"</span></span>

  <span class="comment1">― ‹Set of all states that occur on the lhs of a constant-rule›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">br_iq</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule set <span class="main">⇒</span> <span class="tfree">'Q</span> set"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">br_iq</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">==</span> <span class="main">{</span> lhs <span class="bound">r</span> <span class="main">|</span> <span class="bound">r</span><span class="main">.</span> <span class="bound">r</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">∧</span> rhsq <span class="bound">r</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">}</span>"</span></span>

  <span class="comment1">― ‹Initial state for the iteration›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">br_initial</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> br_state"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">br_initial</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">==</span> <span class="main">(</span>br_iq <span class="free"><span class="bound"><span class="entity">δ</span></span></span><span class="main">,</span> br_iq <span class="free"><span class="bound"><span class="entity">δ</span></span></span><span class="main">)</span>"</span></span>

  <span class="comment1">― ‹Invariant for the iteration: 
    \begin{itemize}
      \item States on the workset have been discovered
      \item Only accessible states have been discovered
      \item If a state is non-empty due to a rule whose 
            rhs-states have been discovered and processed 
            (i.e. are in $Q-W$), then the lhs state of the 
            rule has also been discovered.
      \item The set of discovered states is finite
    \end{itemize}›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">br_invar</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> br_state set"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">br_invar</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">==</span> <span class="main">{</span><span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">)</span><span class="main">.</span> 
    <span class="bound">W</span><span class="main">⊆</span><span class="bound">Q</span> <span class="main">∧</span> 
    <span class="bound">Q</span> <span class="main">⊆</span> b_accessible <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">∧</span> 
    bacc_step <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">(</span><span class="bound">Q</span> <span class="main">-</span> <span class="bound">W</span><span class="main">)</span> <span class="main">⊆</span> <span class="bound">Q</span> <span class="main">∧</span> 
    finite <span class="bound">Q</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">br_algo</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">==</span> <span class="main">⦇</span>
  wa_cond <span class="main">=</span> br_cond<span class="main">,</span>
  wa_step <span class="main">=</span> br_step <span class="free"><span class="bound"><span class="entity">δ</span></span></span><span class="main">,</span>
  wa_initial <span class="main">=</span> <span class="main">{</span>br_initial <span class="free"><span class="bound"><span class="entity">δ</span></span></span><span class="main">}</span><span class="main">,</span>
  wa_invar <span class="main">=</span> br_invar <span class="free"><span class="bound"><span class="entity">δ</span></span></span>
<span class="main">⦈</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">bre_algo</span> <span class="free"><span class="bound"><span class="entity">Qi</span></span></span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">==</span> <span class="main">⦇</span>
  wa_cond <span class="main">=</span> bre_cond <span class="free"><span class="bound"><span class="entity">Qi</span></span></span><span class="main">,</span>
  wa_step <span class="main">=</span> br_step <span class="free"><span class="bound"><span class="entity">δ</span></span></span><span class="main">,</span>
  wa_initial <span class="main">=</span> <span class="main">{</span>br_initial <span class="free"><span class="bound"><span class="entity">δ</span></span></span><span class="main">}</span><span class="main">,</span>
  wa_invar <span class="main">=</span> br_invar <span class="free"><span class="bound"><span class="entity">δ</span></span></span>
<span class="main">⦈</span>"</span></span>


  <span class="comment1">― ‹Termination: Either a new state is added, or the workset decreases.›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">br_termrel</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">==</span> 
  <span class="main">(</span><span class="main">{</span><span class="main">(</span><span class="bound">Q'</span><span class="main">,</span><span class="bound">Q</span><span class="main">)</span><span class="main">.</span> <span class="bound">Q</span> <span class="main">⊂</span> <span class="bound">Q'</span> <span class="main">∧</span> <span class="bound">Q'</span> <span class="main">⊆</span> b_accessible <span class="free"><span class="bound"><span class="entity">δ</span></span></span><span class="main">}</span><span class="main">)</span> <span class="keyword1">&lt;*lex*&gt;</span> finite_psubset"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> bre_cond_imp_br_cond<span class="main">[</span><span class="operator">intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bre_cond <span class="free">Qi</span> <span class="main">⊆</span> br_cond"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br_cond_def bre_cond_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> br_termrel_wf<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">δ</span> <span class="main">⟹</span> wf <span class="main">(</span>br_termrel <span class="free">δ</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> br_termrel_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> wf_bounded_supset<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="comment1">― ‹Only accessible states are discovered›</span>
<span class="keyword1"><span class="command">lemma</span></span> br_dsq_ss<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">)</span><span class="main">∈</span>br_invar <span class="free">δ</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">W</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">q</span><span class="main">∈</span><span class="free">W</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"br_dsq <span class="free">δ</span> <span class="free">q</span> <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">)</span> <span class="main">⊆</span> b_accessible <span class="free">δ</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">q'</span>
  <span class="keyword3"><span class="command">assume</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">q'</span><span class="main">∈</span>br_dsq <span class="free">δ</span> <span class="free">q</span> <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">r</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    R<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">q'</span> <span class="main">=</span> lhs <span class="skolem">r</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span><span class="main">∈</span><span class="free">δ</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 
    S<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>rhsq <span class="skolem">r</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">(</span><span class="free">Q</span><span class="main">-</span><span class="main">(</span><span class="free">W</span><span class="main">-</span><span class="main">{</span><span class="free">q</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> br_dsq_def<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">note</span></span> S
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Q</span><span class="main">-</span><span class="main">(</span><span class="free">W</span><span class="main">-</span><span class="main">{</span><span class="free">q</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> b_accessible <span class="free">δ</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> A<span class="main">(</span>1<span class="main">,</span>3<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br_invar_def<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q'</span><span class="main">∈</span>b_accessible <span class="free">δ</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> R
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">r</span></span><span class="main">)</span>
  <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> b_accessible.intros<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> br_step_in_termrel<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Σ</span><span class="main">∈</span>br_cond"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Σ</span><span class="main">∈</span>br_invar <span class="free">δ</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Σ</span><span class="main">,</span><span class="free">Σ'</span><span class="main">)</span><span class="main">∈</span>br_step <span class="free">δ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Σ'</span><span class="main">,</span> <span class="free">Σ</span><span class="main">)</span><span class="main">∈</span>br_termrel <span class="free">δ</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">Q</span></span> <span class="skolem"><span class="skolem">W</span></span> <span class="skolem"><span class="skolem">Q'</span></span> <span class="skolem"><span class="skolem">W'</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Σ</span><span class="main">=</span><span class="main">(</span><span class="skolem">Q</span><span class="main">,</span><span class="skolem">W</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Σ'</span><span class="main">=</span><span class="main">(</span><span class="skolem">Q'</span><span class="main">,</span><span class="skolem">W'</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">Σ</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">Σ'</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">q</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    QIW<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span><span class="main">∈</span><span class="skolem">W</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 
    ASSFMT<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">Q'</span> <span class="main">=</span> <span class="skolem">Q</span> <span class="main">∪</span> br_dsq <span class="free">δ</span> <span class="skolem">q</span> <span class="main">(</span><span class="skolem">Q</span><span class="main">,</span> <span class="skolem">W</span><span class="main">)</span>"</span></span>
                  <span class="quoted"><span class="quoted">"<span class="skolem">W'</span> <span class="main">=</span> <span class="skolem">W</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">q</span><span class="main">}</span> <span class="main">∪</span> <span class="main">(</span>br_dsq <span class="free">δ</span> <span class="skolem">q</span> <span class="main">(</span><span class="skolem">Q</span><span class="main">,</span> <span class="skolem">W</span><span class="main">)</span> <span class="main">-</span> <span class="skolem">Q</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> br_step.cases<span class="main"><span class="main">[</span></span><span class="operator">OF</span> A<span class="main"><span class="main"><span class="main">(</span></span></span>3<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">simplified</span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

  <span class="keyword1"><span class="command">from</span></span> A<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="skolem">Q</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br_invar_def<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> A<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> br_invar_def<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="skolem">W</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_subset<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> A<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> WNE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">W</span><span class="main">≠</span><span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> br_cond_def<span class="main">)</span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">note</span></span> DSQSS <span class="main">=</span> br_dsq_ss<span class="main">[</span><span class="operator">OF</span> A<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span> WNE QIW<span class="main">]</span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"br_dsq <span class="free">δ</span> <span class="skolem">q</span> <span class="main">(</span><span class="skolem">Q</span><span class="main">,</span><span class="skolem">W</span><span class="main">)</span> <span class="main">-</span> <span class="skolem">Q</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> QIW
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br_termrel_def set_simps<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"br_dsq <span class="free">δ</span> <span class="skolem">q</span> <span class="main">(</span><span class="skolem">Q</span><span class="main">,</span><span class="skolem">W</span><span class="main">)</span> <span class="main">-</span> <span class="skolem">Q</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">Q</span> <span class="main">⊂</span> <span class="skolem">Q'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> DSQSS A<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> br_invar_def<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> 
      <span class="quoted"><span class="quoted">"<span class="skolem">Q'</span> <span class="main">⊆</span> b_accessible <span class="free">δ</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br_termrel_def<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> br_invar_initial<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">δ</span> <span class="main">⟹</span> <span class="main">(</span>br_initial <span class="free">δ</span><span class="main">)</span><span class="main">∈</span>br_invar <span class="free">δ</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br_initial_def br_invar_def br_iq_def<span class="main">)</span>
    
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">r</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> b_accessible.intros<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> bacc_step.cases<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> br_invar_step<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">δ</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Σ</span><span class="main">∈</span>br_cond"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Σ</span><span class="main">∈</span>br_invar <span class="free">δ</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Σ</span><span class="main">,</span><span class="free">Σ'</span><span class="main">)</span><span class="main">∈</span>br_step <span class="free">δ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">Σ'</span><span class="main">∈</span>br_invar <span class="free">δ</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">Q</span></span> <span class="skolem"><span class="skolem">W</span></span> <span class="skolem"><span class="skolem">Q'</span></span> <span class="skolem"><span class="skolem">W'</span></span> <span class="keyword2"><span class="keyword">where</span></span> SF<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Σ</span><span class="main">=</span><span class="main">(</span><span class="skolem">Q</span><span class="main">,</span><span class="skolem">W</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Σ'</span><span class="main">=</span><span class="main">(</span><span class="skolem">Q'</span><span class="main">,</span><span class="skolem">W'</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">Σ</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">Σ'</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">q</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    QIW<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span><span class="main">∈</span><span class="skolem">W</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 
    ASSFMT<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">Q'</span> <span class="main">=</span> <span class="skolem">Q</span> <span class="main">∪</span> br_dsq <span class="free">δ</span> <span class="skolem">q</span> <span class="main">(</span><span class="skolem">Q</span><span class="main">,</span> <span class="skolem">W</span><span class="main">)</span>"</span></span>
                  <span class="quoted"><span class="quoted">"<span class="skolem">W'</span> <span class="main">=</span> <span class="skolem">W</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">q</span><span class="main">}</span> <span class="main">∪</span> <span class="main">(</span>br_dsq <span class="free">δ</span> <span class="skolem">q</span> <span class="main">(</span><span class="skolem">Q</span><span class="main">,</span> <span class="skolem">W</span><span class="main">)</span> <span class="main">-</span> <span class="skolem">Q</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> br_step.cases<span class="main"><span class="main">[</span></span><span class="operator">OF</span> A<span class="main"><span class="main"><span class="main">(</span></span></span>3<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">simplified</span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

  <span class="keyword1"><span class="command">from</span></span> A<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> WNE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">W</span><span class="main">≠</span><span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> br_cond_def<span class="main">)</span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">have</span></span> DSQSS<span class="main">:</span> <span class="quoted"><span class="quoted">"br_dsq <span class="free">δ</span> <span class="skolem">q</span> <span class="main">(</span><span class="skolem">Q</span><span class="main">,</span><span class="skolem">W</span><span class="main">)</span> <span class="main">⊆</span> b_accessible <span class="free">δ</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> br_dsq_ss<span class="main">[</span><span class="operator">OF</span> A<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span> WNE QIW<span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br_invar_def <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> ASSFMT<span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> conjI<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> A<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">W</span> <span class="main">⊆</span> <span class="skolem">Q</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br_invar_def<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">W'</span> <span class="main">⊆</span> <span class="skolem">Q'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword1"><span class="command">from</span></span> A<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">Q</span> <span class="main">⊆</span> b_accessible <span class="free">δ</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br_invar_def<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> DSQSS <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">Q'</span> <span class="main">⊆</span> b_accessible <span class="free">δ</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bacc_step <span class="free">δ</span> <span class="main">(</span><span class="skolem">Q'</span> <span class="main">-</span> <span class="skolem">W'</span><span class="main">)</span> <span class="main">⊆</span> <span class="skolem">Q'</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> bacc_step.cases<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br_dsq_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"finite <span class="skolem">Q'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> A<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br_invar_def br_dsq_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">lemma</span></span> br_invar_final<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">Σ</span><span class="main">.</span> <span class="bound">Σ</span><span class="main">∈</span>wa_invar <span class="main">(</span>br_algo <span class="free">δ</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">Σ</span><span class="main">∉</span>wa_cond <span class="main">(</span>br_algo <span class="free">δ</span><span class="main">)</span> 
   <span class="main">⟶</span> fst <span class="bound">Σ</span> <span class="main">=</span> b_accessible <span class="free">δ</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br_invar_def br_cond_def br_algo_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_subsetD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ b_accs_as_closed<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="comment1">(*  shows "⟦(Q,W)∈br_invar δ; (Q,W)∉br_cond⟧ ⟹ Q = b_accessible δ"
  apply (simp add: br_invar_def br_cond_def)
  apply (auto intro: rev_subsetD[OF _ b_accs_as_closed])
  done*)</span>

<span class="keyword1"><span class="command">theorem</span></span> br_while_algo<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> FIN<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">δ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"while_algo <span class="main">(</span>br_algo <span class="free">δ</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br_algo_def br_invar_step br_invar_initial 
                       br_step_in_termrel<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> r<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"br_termrel <span class="free">δ</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> wf_subset<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> br_step_in_termrel<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> bre_invar_final<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">Σ</span><span class="main">.</span> <span class="bound">Σ</span><span class="main">∈</span>wa_invar <span class="main">(</span>bre_algo <span class="free">Qi</span> <span class="free">δ</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">Σ</span><span class="main">∉</span>wa_cond <span class="main">(</span>bre_algo <span class="free">Qi</span> <span class="free">δ</span><span class="main">)</span> 
     <span class="main">⟶</span> <span class="main">(</span><span class="main">(</span><span class="free">Qi</span><span class="main">∩</span>fst <span class="bound">Σ</span><span class="main">=</span><span class="main">{}</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">Qi</span> <span class="main">∩</span> b_accessible <span class="free">δ</span> <span class="main">=</span> <span class="main">{}</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br_invar_def bre_cond_def bre_algo_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> b_accs_as_closed<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">theorem</span></span> bre_while_algo<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> FIN<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">δ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"while_algo <span class="main">(</span>bre_algo <span class="free">Qi</span> <span class="free">δ</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> bre_algo_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br_invar_initial br_step_in_termrel
    <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> br_invar_step 
    <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> rev_subsetD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ bre_cond_imp_br_cond<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> r<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"br_termrel <span class="free">δ</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> wf_subset<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> br_step_in_termrel
              <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> rev_subsetD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ bre_cond_imp_br_cond<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\paragraph{<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>α'›</span></span></span></span> - Level}›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Here, an optimization is added:
    For each rule, the algorithm now maintains a counter that counts the number
    of undiscovered states on the rules RHS. Whenever a new state is discovered,
    this counter is decremented for all rules where the state occurs on the RHS.
    The LHS states of rules where the counter falls to 0 are added to the 
    worklist. The idea is that decrementing the counter is more efficient than 
    checking whether all states on the rule's RHS have been discovered.

  A similar algorithm is sketched in \cite{tata2007}(Exercise~1.18).
›</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> br'_state <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> set <span class="main">×</span> <span class="tfree">'Q</span> set <span class="main">×</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule <span class="main">⇀</span> nat<span class="main">)</span>"</span></span>

  <span class="comment1">― ‹Abstraction to <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">α</span><span class="antiquote">}</span></span>-level›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">br'_α</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> br'_state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> br_state"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">br'_α</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">rcm</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">br'_invar_add</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> br'_state set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">br'_invar_add</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">==</span> <span class="main">{</span><span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">rcm</span><span class="main">)</span><span class="main">.</span> 
    <span class="main">(</span><span class="main">∀</span><span class="bound">r</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">δ</span></span></span><span class="main">.</span> <span class="bound">rcm</span> <span class="bound">r</span> <span class="main">=</span> Some <span class="main">(</span>card <span class="main">(</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="bound">Q</span> <span class="main">-</span> <span class="bound">W</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> 
    <span class="main">{</span>lhs <span class="bound">r</span> <span class="main">|</span> <span class="bound">r</span><span class="main">.</span> <span class="bound">r</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">∧</span> the <span class="main">(</span><span class="bound">rcm</span> <span class="bound">r</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span><span class="main">}</span> <span class="main">⊆</span> <span class="bound">Q</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">br'_invar</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> br'_state set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">br'_invar</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">==</span> br'_invar_add <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">∩</span> <span class="main">{</span><span class="bound">Σ</span><span class="main">.</span> br'_α <span class="bound">Σ</span> <span class="main">∈</span> br_invar <span class="free"><span class="bound"><span class="entity">δ</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">inductive_set</span></span> <span class="entity">br'_step</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule set <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> br'_state <span class="main">×</span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> br'_state<span class="main">)</span> set"</span></span> 
  <span class="keyword2"><span class="keyword">for</span></span> <span class="entity">δ</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">W</span></span></span><span class="main">;</span>
     <span class="free"><span class="bound"><span class="entity">Q'</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">∪</span> <span class="main">{</span> lhs <span class="bound">r</span> <span class="main">|</span> <span class="bound">r</span><span class="main">.</span> <span class="bound">r</span><span class="main">∈</span><span class="free">δ</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">∈</span> set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span> <span class="main">∧</span> the <span class="main">(</span><span class="free"><span class="bound"><span class="entity">rcm</span></span></span> <span class="bound">r</span><span class="main">)</span> <span class="main">≤</span> <span class="main">1</span> <span class="main">}</span><span class="main">;</span>
     <span class="free"><span class="bound"><span class="entity">W'</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">W</span></span></span><span class="main">-</span><span class="main">{</span><span class="free"><span class="bound"><span class="entity">q</span></span></span><span class="main">}</span><span class="main">)</span> 
          <span class="main">∪</span> <span class="main">(</span><span class="main">{</span> lhs <span class="bound">r</span> <span class="main">|</span> <span class="bound">r</span><span class="main">.</span> <span class="bound">r</span><span class="main">∈</span><span class="free">δ</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">∈</span> set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span> <span class="main">∧</span> the <span class="main">(</span><span class="free"><span class="bound"><span class="entity">rcm</span></span></span> <span class="bound">r</span><span class="main">)</span> <span class="main">≤</span> <span class="main">1</span> <span class="main">}</span> 
              <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">)</span><span class="main">;</span>
     <span class="main">!!</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span><span class="main">∈</span><span class="free">δ</span> <span class="main">⟹</span> <span class="free"><span class="bound"><span class="entity">rcm'</span></span></span> <span class="bound">r</span> <span class="main">=</span> <span class="main">(</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">∈</span> set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span> <span class="keyword1">then</span> 
                               Some <span class="main">(</span>the <span class="main">(</span><span class="free"><span class="bound"><span class="entity">rcm</span></span></span> <span class="bound">r</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> 
                             <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">rcm</span></span></span> <span class="bound">r</span>
                           <span class="main">)</span>
   <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">W</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">rcm</span></span></span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">Q'</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">W'</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">rcm'</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> <span class="free">br'_step</span> <span class="free">δ</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">br'_cond</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> br'_state set"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">br'_cond</span> <span class="main">==</span> <span class="main">{</span><span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">rcm</span><span class="main">)</span><span class="main">.</span> <span class="bound">W</span><span class="main">≠</span><span class="main">{}</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">bre'_cond</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> br'_state set"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">bre'_cond</span> <span class="free"><span class="bound"><span class="entity">Qi</span></span></span> <span class="main">==</span> <span class="main">{</span><span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">rcm</span><span class="main">)</span><span class="main">.</span> <span class="bound">W</span><span class="main">≠</span><span class="main">{}</span> <span class="main">∧</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">Qi</span></span></span><span class="main">∩</span><span class="bound">Q</span><span class="main">=</span><span class="main">{}</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">inductive_set</span></span> <span class="entity">br'_initial</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> br'_state set"</span></span> 
  <span class="keyword2"><span class="keyword">for</span></span> <span class="entity">δ</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">!!</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span><span class="main">∈</span><span class="free">δ</span> <span class="main">⟹</span> <span class="free"><span class="bound"><span class="entity">rcm</span></span></span> <span class="bound">r</span> <span class="main">=</span> Some <span class="main">(</span>card <span class="main">(</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">⟧</span> 
     <span class="main">⟹</span> <span class="main">(</span>br_iq <span class="free">δ</span><span class="main">,</span> br_iq <span class="free">δ</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">rcm</span></span></span><span class="main">)</span><span class="main">∈</span><span class="free">br'_initial</span> <span class="free">δ</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">br'_algo</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">==</span> <span class="main">⦇</span>
  wa_cond<span class="main">=</span>br'_cond<span class="main">,</span>
  wa_step <span class="main">=</span> br'_step <span class="free"><span class="bound"><span class="entity">δ</span></span></span><span class="main">,</span>
  wa_initial <span class="main">=</span> br'_initial <span class="free"><span class="bound"><span class="entity">δ</span></span></span><span class="main">,</span>
  wa_invar <span class="main">=</span> br'_invar <span class="free"><span class="bound"><span class="entity">δ</span></span></span>
<span class="main">⦈</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">bre'_algo</span> <span class="free"><span class="bound"><span class="entity">Qi</span></span></span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">==</span> <span class="main">⦇</span>
  wa_cond<span class="main">=</span>bre'_cond <span class="free"><span class="bound"><span class="entity">Qi</span></span></span><span class="main">,</span>
  wa_step <span class="main">=</span> br'_step <span class="free"><span class="bound"><span class="entity">δ</span></span></span><span class="main">,</span>
  wa_initial <span class="main">=</span> br'_initial <span class="free"><span class="bound"><span class="entity">δ</span></span></span><span class="main">,</span>
  wa_invar <span class="main">=</span> br'_invar <span class="free"><span class="bound"><span class="entity">δ</span></span></span>
<span class="main">⦈</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> br'_step_invar<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> finite<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">δ</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Σ</span><span class="main">∈</span>br'_invar_add <span class="free">δ</span>"</span></span> <span class="quoted"><span class="quoted">"br'_α <span class="free">Σ</span> <span class="main">∈</span> br_invar <span class="free">δ</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> STEP<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Σ</span><span class="main">,</span><span class="free">Σ'</span><span class="main">)</span> <span class="main">∈</span> br'_step <span class="free">δ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">Σ'</span><span class="main">∈</span>br'_invar_add <span class="free">δ</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">Q</span></span> <span class="skolem"><span class="skolem">W</span></span> <span class="skolem"><span class="skolem">rcm</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Σ</span><span class="main">=</span><span class="main">(</span><span class="skolem">Q</span><span class="main">,</span><span class="skolem">W</span><span class="main">,</span><span class="skolem">rcm</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">Σ</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">Q'</span></span> <span class="skolem"><span class="skolem">W'</span></span> <span class="skolem"><span class="skolem">rcm'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Σ'</span><span class="main">=</span><span class="main">(</span><span class="skolem">Q'</span><span class="main">,</span><span class="skolem">W'</span><span class="main">,</span><span class="skolem">rcm'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">Σ'</span></span><span class="main">)</span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">from</span></span> STEP <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">q</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    STEPF<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="skolem">q</span><span class="main">∈</span><span class="skolem">W</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="skolem">Q'</span> <span class="main">=</span> <span class="skolem">Q</span> <span class="main">∪</span> <span class="main">{</span> lhs <span class="bound">r</span> <span class="main">|</span> <span class="bound">r</span><span class="main">.</span> <span class="bound">r</span><span class="main">∈</span><span class="free">δ</span> <span class="main">∧</span> <span class="skolem">q</span> <span class="main">∈</span> set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span> <span class="main">∧</span> the <span class="main">(</span><span class="skolem">rcm</span> <span class="bound">r</span><span class="main">)</span> <span class="main">≤</span> <span class="main">1</span> <span class="main">}</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="skolem">W'</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">W</span><span class="main">-</span><span class="main">{</span><span class="skolem">q</span><span class="main">}</span><span class="main">)</span> 
          <span class="main">∪</span> <span class="main">(</span><span class="main">{</span> lhs <span class="bound">r</span> <span class="main">|</span> <span class="bound">r</span><span class="main">.</span> <span class="bound">r</span><span class="main">∈</span><span class="free">δ</span> <span class="main">∧</span> <span class="skolem">q</span> <span class="main">∈</span> set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span> <span class="main">∧</span> the <span class="main">(</span><span class="skolem">rcm</span> <span class="bound">r</span><span class="main">)</span> <span class="main">≤</span> <span class="main">1</span> <span class="main">}</span> 
              <span class="main">-</span> <span class="skolem">Q</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">!!</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span><span class="main">∈</span><span class="free">δ</span> <span class="main">⟹</span> <span class="skolem">rcm'</span> <span class="bound">r</span> <span class="main">=</span> <span class="main">(</span> <span class="keyword1">if</span> <span class="skolem">q</span> <span class="main">∈</span> set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span> <span class="keyword1">then</span> 
                               Some <span class="main">(</span>the <span class="main">(</span><span class="skolem">rcm</span> <span class="bound">r</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> 
                             <span class="keyword1">else</span> <span class="skolem">rcm</span> <span class="bound">r</span>
                           <span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> br'_step.cases<span class="main">)</span>

  <span class="keyword1"><span class="command">from</span></span> INV<span class="main">[</span><span class="operator">unfolded</span> br'_invar_def br_invar_def br'_invar_add_def br'_α_def<span class="main">,</span> 
           <span class="operator">simplified</span><span class="main">]</span> 
  <span class="keyword1"><span class="command">have</span></span> INV<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">r</span><span class="main">∈</span><span class="free">δ</span><span class="main">.</span> <span class="skolem">rcm</span> <span class="bound">r</span> <span class="main">=</span> Some <span class="main">(</span>card <span class="main">(</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="skolem">Q</span> <span class="main">-</span> <span class="skolem">W</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="quoted"><span class="quoted">"<span class="main">{</span>lhs <span class="bound">r</span> <span class="main">|</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span> <span class="main">∈</span> <span class="free">δ</span> <span class="main">∧</span> the <span class="main">(</span><span class="skolem">rcm</span> <span class="bound">r</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span><span class="main">}</span> <span class="main">⊆</span> <span class="skolem">Q</span>"</span></span> 
    <span class="quoted"><span class="quoted">"<span class="skolem">W</span> <span class="main">⊆</span> <span class="skolem">Q</span>"</span></span> 
    <span class="quoted"><span class="quoted">"<span class="skolem">Q</span> <span class="main">⊆</span> b_accessible <span class="free">δ</span>"</span></span> 
    <span class="quoted"><span class="quoted">"bacc_step <span class="free">δ</span> <span class="main">(</span><span class="skolem">Q</span> <span class="main">-</span> <span class="skolem">W</span><span class="main">)</span> <span class="main">⊆</span> <span class="skolem">Q</span>"</span></span> 
    <span class="quoted"><span class="quoted">"finite <span class="skolem">Q</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">r</span>
    <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span><span class="main">∈</span><span class="free">δ</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> INV<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> RCMR<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">rcm</span> <span class="skolem">r</span> <span class="main">=</span> Some <span class="main">(</span>card <span class="main">(</span>set <span class="main">(</span>rhsq <span class="skolem">r</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="skolem">Q</span> <span class="main">-</span> <span class="skolem">W</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">rcm'</span> <span class="skolem">r</span> <span class="main">=</span> Some <span class="main">(</span>card <span class="main">(</span>set <span class="main">(</span>rhsq <span class="skolem">r</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="skolem">Q'</span> <span class="main">-</span> <span class="skolem">W'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="skolem">r</span><span class="main">)</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">with</span></span> A STEPF<span class="main">(</span>4<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">rcm'</span> <span class="skolem">r</span> <span class="main">=</span> <span class="skolem">rcm</span> <span class="skolem">r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> STEPF INV<span class="main">(</span>3<span class="main">)</span> False <span class="keyword1"><span class="command">have</span></span> 
        <span class="quoted"><span class="quoted">"set <span class="main">(</span>rhsq <span class="skolem">r</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="skolem">Q</span><span class="main">-</span><span class="skolem">W</span><span class="main">)</span> <span class="main">=</span> set <span class="main">(</span>rhsq <span class="skolem">r</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="skolem">Q'</span><span class="main">-</span><span class="skolem">W'</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RCMR<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">with</span></span> A STEPF<span class="main">(</span>4<span class="main">)</span> RCMR <span class="keyword1"><span class="command">have</span></span> 
        <span class="quoted"><span class="quoted">"<span class="skolem">rcm'</span> <span class="skolem">r</span> <span class="main">=</span> Some <span class="main">(</span><span class="main">(</span>card <span class="main">(</span>set <span class="main">(</span>rhsq <span class="skolem">r</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="skolem">Q</span> <span class="main">-</span> <span class="skolem">W</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> STEPF INV<span class="main">(</span>3<span class="main">)</span> True <span class="keyword1"><span class="command">have</span></span> 
        <span class="quoted"><span class="quoted">"set <span class="main">(</span>rhsq <span class="skolem">r</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="skolem">Q</span><span class="main">-</span><span class="skolem">W</span><span class="main">)</span> <span class="main">=</span> insert <span class="skolem">q</span> <span class="main">(</span>set <span class="main">(</span>rhsq <span class="skolem">r</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="skolem">Q'</span><span class="main">-</span><span class="skolem">W'</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="quoted"><span class="quoted">"<span class="skolem">q</span><span class="main">∉</span><span class="main">(</span>set <span class="main">(</span>rhsq <span class="skolem">r</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="skolem">Q'</span><span class="main">-</span><span class="skolem">W'</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RCMR card_insert_disjoint'<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">r</span>
    <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span><span class="main">∈</span><span class="free">δ</span>"</span></span> <span class="quoted"><span class="quoted">"the <span class="main">(</span><span class="skolem">rcm'</span> <span class="skolem">r</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lhs <span class="skolem">r</span> <span class="main">∈</span> <span class="skolem">Q'</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="skolem">r</span><span class="main">)</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">with</span></span> A<span class="main">(</span>1<span class="main">)</span> STEPF<span class="main">(</span>4<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">rcm'</span> <span class="skolem">r</span> <span class="main">=</span> Some <span class="main">(</span>the <span class="main">(</span><span class="skolem">rcm</span> <span class="skolem">r</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> A<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"the <span class="main">(</span><span class="skolem">rcm</span> <span class="skolem">r</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"the <span class="main">(</span><span class="skolem">rcm</span> <span class="skolem">r</span><span class="main">)</span> <span class="main">≤</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> STEPF<span class="main">(</span>2<span class="main">)</span> A<span class="main">(</span>1<span class="main">)</span> True <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">with</span></span> A<span class="main">(</span>1<span class="main">)</span> STEPF<span class="main">(</span>4<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">rcm'</span> <span class="skolem">r</span> <span class="main">=</span> <span class="skolem">rcm</span> <span class="skolem">r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> A<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"the <span class="main">(</span><span class="skolem">rcm</span> <span class="skolem">r</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> A<span class="main">(</span>1<span class="main">)</span> INV<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lhs <span class="skolem">r</span> <span class="main">∈</span> <span class="skolem">Q</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> STEPF<span class="main">(</span>2<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br'_invar_add_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> br'_invar_initial<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"br'_initial <span class="free">δ</span> <span class="main">⊆</span> br'_invar_add <span class="free">δ</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> br'_initial.cases<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> br'_invar_add_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br_iq_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> br'_rcm_aux'<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">,</span><span class="free">rcm</span><span class="main">)</span><span class="main">∈</span>br'_invar <span class="free">δ</span><span class="main">;</span> <span class="free">q</span><span class="main">∈</span><span class="free">W</span> <span class="main">⟧</span> 
    <span class="main">⟹</span> <span class="main">{</span><span class="bound"><span class="bound">r</span></span> <span class="main">∈</span> <span class="free">δ</span><span class="main">.</span> <span class="free">q</span> <span class="main">∈</span> set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span> <span class="main">∧</span> the <span class="main">(</span><span class="free">rcm</span> <span class="bound">r</span><span class="main">)</span> <span class="main">≤</span> Suc <span class="main">0</span><span class="main">}</span> 
         <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="free">δ</span><span class="main">.</span> <span class="free">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span> <span class="main">∧</span> set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">(</span><span class="free">Q</span> <span class="main">-</span> <span class="main">(</span><span class="free">W</span><span class="main">-</span><span class="main">{</span><span class="free">q</span><span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> subsetI equalityI<span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> prems<span class="main">:</span> <span class="main">(</span>1 <span class="skolem">r</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span>  B<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span><span class="main">∈</span><span class="free">δ</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="skolem">r</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"the <span class="main">(</span><span class="free">rcm</span> <span class="skolem">r</span><span class="main">)</span> <span class="main">≤</span> Suc <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> B<span class="main">(</span>1<span class="main">,</span>3<span class="main">)</span> prems<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> br'_invar_def br'_invar_add_def<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> 
    CARD<span class="main">:</span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>set <span class="main">(</span>rhsq <span class="skolem">r</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="free">Q</span> <span class="main">-</span> <span class="free">W</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> Suc <span class="main">0</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> prems<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> br'_invar_def br_invar_def br'_α_def<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> WSQ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">W</span><span class="main">⊆</span><span class="free">Q</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>rhsq <span class="skolem">r</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="free">Q</span> <span class="main">-</span> <span class="free">W</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="free">q</span><span class="main">}</span>"</span></span> 
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> B<span class="main">(</span>2<span class="main">)</span> prems<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> R1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="skolem">r</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="free">Q</span> <span class="main">-</span> <span class="free">W</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
      <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span><span class="main">≠</span><span class="free">q</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="skolem">r</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="free">Q</span> <span class="main">-</span> <span class="free">W</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> R1 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="skolem">x</span><span class="main">,</span><span class="free">q</span><span class="main">}</span> <span class="main">⊆</span> set <span class="main">(</span>rhsq <span class="skolem">r</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="free">Q</span> <span class="main">-</span> <span class="free">W</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"card <span class="main">{</span><span class="skolem">x</span><span class="main">,</span><span class="free">q</span><span class="main">}</span> <span class="main">≤</span> card <span class="main">(</span>set <span class="main">(</span>rhsq <span class="skolem">r</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="free">Q</span> <span class="main">-</span> <span class="free">W</span><span class="main">)</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_mono<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> CARD A<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">with</span></span> prems<span class="main">(</span>2<span class="main">)</span> WSQ <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>rhsq <span class="skolem">r</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">Q</span> <span class="main">-</span> <span class="main">(</span><span class="free">W</span> <span class="main">-</span> <span class="main">{</span><span class="free">q</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> B<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> prems<span class="main">:</span> <span class="main">(</span>2 <span class="skolem">r</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span><span class="main">∈</span><span class="free">δ</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="skolem">r</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>rhsq <span class="skolem">r</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">Q</span> <span class="main">-</span> <span class="main">(</span><span class="free">W</span> <span class="main">-</span> <span class="main">{</span><span class="free">q</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> prems<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> br'_invar_def br'_invar_add_def 
                         br'_α_def br_invar_def<span class="main">]</span> 
  <span class="keyword1"><span class="command">have</span></span> 
    IC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">W</span><span class="main">⊆</span><span class="free">Q</span>"</span></span> <span class="quoted"><span class="quoted">"the <span class="main">(</span><span class="free">rcm</span> <span class="skolem">r</span><span class="main">)</span> <span class="main">=</span> card <span class="main">(</span>set <span class="main">(</span>rhsq <span class="skolem">r</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="free">Q</span> <span class="main">-</span> <span class="free">W</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>rhsq <span class="skolem">r</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="free">Q</span> <span class="main">-</span> <span class="free">W</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="free">q</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> B<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span> IC<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> card_mono<span class="main">[</span><span class="operator">OF</span> _ this<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"the <span class="main">(</span><span class="free">rcm</span> <span class="skolem">r</span><span class="main">)</span> <span class="main">≤</span> Suc <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> IC<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> B<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> br'_rcm_aux<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">,</span><span class="free">rcm</span><span class="main">)</span><span class="main">∈</span>br'_invar <span class="free">δ</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">q</span><span class="main">∈</span><span class="free">W</span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span>lhs <span class="bound">r</span> <span class="main">|</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span> <span class="main">∈</span> <span class="free">δ</span> <span class="main">∧</span> <span class="free">q</span> <span class="main">∈</span> set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span> <span class="main">∧</span> the <span class="main">(</span><span class="free">rcm</span> <span class="bound">r</span><span class="main">)</span> <span class="main">≤</span> Suc <span class="main">0</span><span class="main">}</span> 
         <span class="main">=</span> <span class="main">{</span>lhs <span class="bound">r</span> <span class="main">|</span> <span class="bound">r</span><span class="main">.</span> <span class="bound">r</span><span class="main">∈</span><span class="free">δ</span> <span class="main">∧</span> <span class="free">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span> <span class="main">∧</span> set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">(</span><span class="free">Q</span> <span class="main">-</span> <span class="main">(</span><span class="free">W</span><span class="main">-</span><span class="main">{</span><span class="free">q</span><span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span>lhs <span class="bound">r</span> <span class="main">|</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span> <span class="main">∈</span> <span class="free">δ</span> <span class="main">∧</span> <span class="free">q</span> <span class="main">∈</span> set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span> <span class="main">∧</span> the <span class="main">(</span><span class="free">rcm</span> <span class="bound">r</span><span class="main">)</span> <span class="main">≤</span> Suc <span class="main">0</span><span class="main">}</span> 
        <span class="main">=</span> lhs <span class="main">`</span> <span class="main">{</span><span class="bound"><span class="bound">r</span></span> <span class="main">∈</span> <span class="free">δ</span><span class="main">.</span> <span class="free">q</span> <span class="main">∈</span> set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span> <span class="main">∧</span> the <span class="main">(</span><span class="free">rcm</span> <span class="bound">r</span><span class="main">)</span> <span class="main">≤</span> Suc <span class="main">0</span><span class="main">}</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> br'_rcm_aux'<span class="main">[</span><span class="operator">OF</span> A<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> 
    <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> lhs <span class="main">`</span> <span class="main">{</span><span class="bound"><span class="bound">r</span></span> <span class="main">∈</span> <span class="free">δ</span><span class="main">.</span> <span class="free">q</span> <span class="main">∈</span> set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span> <span class="main">∧</span> set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">Q</span> <span class="main">-</span> <span class="main">(</span><span class="free">W</span> <span class="main">-</span> <span class="main">{</span><span class="free">q</span><span class="main">}</span><span class="main">)</span><span class="main">}</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> 
    <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">{</span>lhs <span class="bound">r</span> <span class="main">|</span> <span class="bound">r</span><span class="main">.</span> <span class="bound">r</span><span class="main">∈</span><span class="free">δ</span> <span class="main">∧</span> <span class="free">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span> <span class="main">∧</span> set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">(</span><span class="free">Q</span> <span class="main">-</span> <span class="main">(</span><span class="free">W</span><span class="main">-</span><span class="main">{</span><span class="free">q</span><span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> br'_invar_QcD<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">,</span><span class="free">rcm</span><span class="main">)</span> <span class="main">∈</span> br'_invar <span class="free">δ</span> <span class="main">⟹</span> <span class="main">{</span>lhs <span class="bound">r</span> <span class="main">|</span> <span class="bound">r</span><span class="main">.</span> <span class="bound">r</span><span class="main">∈</span><span class="free">δ</span> <span class="main">∧</span> set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">(</span><span class="free">Q</span><span class="main">-</span><span class="free">W</span><span class="main">)</span><span class="main">}</span> <span class="main">⊆</span> <span class="free">Q</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">safe</span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">r</span>
  <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">,</span><span class="free">rcm</span><span class="main">)</span><span class="main">∈</span>br'_invar <span class="free">δ</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span><span class="main">∈</span><span class="free">δ</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>rhsq <span class="skolem">r</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">Q</span> <span class="main">-</span> <span class="free">W</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> A<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> br'_invar_def br'_invar_add_def br'_α_def br_invar_def<span class="main">,</span> 
            <span class="operator">simplified</span><span class="main">]</span> 
  <span class="keyword1"><span class="command">have</span></span> 
    IC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">W</span> <span class="main">⊆</span> <span class="free">Q</span>"</span></span> 
        <span class="quoted"><span class="quoted">"finite <span class="free">Q</span>"</span></span> 
        <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">r</span><span class="main">∈</span><span class="free">δ</span><span class="main">.</span> <span class="free">rcm</span> <span class="bound">r</span> <span class="main">=</span> Some <span class="main">(</span>card <span class="main">(</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="free">Q</span> <span class="main">-</span> <span class="free">W</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> 
        <span class="quoted"><span class="quoted">"<span class="main">{</span>lhs <span class="bound">r</span> <span class="main">|</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span> <span class="main">∈</span> <span class="free">δ</span> <span class="main">∧</span> the <span class="main">(</span><span class="free">rcm</span> <span class="bound">r</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span><span class="main">}</span> <span class="main">⊆</span> <span class="free">Q</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> IC<span class="main">(</span>3<span class="main">)</span> A<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"the <span class="main">(</span><span class="free">rcm</span> <span class="skolem">r</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> IC<span class="main">(</span>4<span class="main">)</span> A<span class="main">(</span>2<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lhs <span class="skolem">r</span> <span class="main">∈</span> <span class="free">Q</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> br'_rcm_aux2<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">,</span><span class="free">rcm</span><span class="main">)</span><span class="main">∈</span>br'_invar <span class="free">δ</span><span class="main">;</span> <span class="free">q</span><span class="main">∈</span><span class="free">W</span> <span class="main">⟧</span> 
    <span class="main">⟹</span> <span class="free">Q</span> <span class="main">∪</span> br_dsq <span class="free">δ</span> <span class="free">q</span> <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">)</span> 
        <span class="main">=</span> <span class="free">Q</span> <span class="main">∪</span> <span class="main">{</span>lhs <span class="bound">r</span> <span class="main">|</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span> <span class="main">∈</span> <span class="free">δ</span> <span class="main">∧</span> <span class="free">q</span> <span class="main">∈</span> set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span> <span class="main">∧</span> the <span class="main">(</span><span class="free">rcm</span> <span class="bound">r</span><span class="main">)</span> <span class="main">≤</span> Suc <span class="main">0</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> br'_rcm_aux<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> br_dsq_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> br'_invar_QcD<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> br'_rcm_aux3<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">,</span><span class="free">rcm</span><span class="main">)</span><span class="main">∈</span>br'_invar <span class="free">δ</span><span class="main">;</span> <span class="free">q</span><span class="main">∈</span><span class="free">W</span> <span class="main">⟧</span> 
    <span class="main">⟹</span> br_dsq <span class="free">δ</span> <span class="free">q</span> <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">)</span> <span class="main">-</span> <span class="free">Q</span> 
        <span class="main">=</span> <span class="main">{</span>lhs <span class="bound">r</span> <span class="main">|</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span> <span class="main">∈</span> <span class="free">δ</span> <span class="main">∧</span> <span class="free">q</span> <span class="main">∈</span> set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span> <span class="main">∧</span> the <span class="main">(</span><span class="free">rcm</span> <span class="bound">r</span><span class="main">)</span> <span class="main">≤</span> Suc <span class="main">0</span><span class="main">}</span> <span class="main">-</span> <span class="free">Q</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> br'_rcm_aux<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> br_dsq_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> br'_invar_QcD<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> br'_step_abs<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> 
     <span class="free">Σ</span><span class="main">∈</span>br'_invar <span class="free">δ</span><span class="main">;</span> 
     <span class="main">(</span><span class="free">Σ</span><span class="main">,</span><span class="free">Σ'</span><span class="main">)</span> <span class="main">∈</span> br'_step <span class="free">δ</span> 
   <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span>br'_α <span class="free">Σ</span><span class="main">,</span> br'_α <span class="free">Σ'</span><span class="main">)</span><span class="main">∈</span>br_step <span class="free">δ</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">Σ</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">Σ'</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> br'_step.cases<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br'_α_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> q<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">q</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> br_step.intros<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> br'_rcm_aux2<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> br'_rcm_aux3<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  

<span class="keyword1"><span class="command">lemma</span></span> br'_initial_abs<span class="main">:</span> <span class="quoted"><span class="quoted">"br'_α<span class="main">`</span><span class="main">(</span>br'_initial <span class="free">δ</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span>br_initial <span class="free">δ</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br_initial_def br'_α_def
               <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> br'_initial.cases 
               <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> br'_initial.intros<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> br'_cond_abs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Σ</span><span class="main">∈</span>br'_cond <span class="main">⟷</span> <span class="main">(</span>br'_α <span class="free">Σ</span><span class="main">)</span> <span class="main">∈</span> br_cond"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">Σ</span></span><span class="main">)</span> 
     <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br'_cond_def br_cond_def br'_α_def image_Collect 
                br'_algo_def br_algo_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> bre'_cond_abs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Σ</span><span class="main">∈</span>bre'_cond <span class="free">Qi</span> <span class="main">⟷</span> <span class="main">(</span>br'_α <span class="free">Σ</span><span class="main">)</span><span class="main">∈</span>bre_cond <span class="free">Qi</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">Σ</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bre'_cond_def bre_cond_def br'_α_def image_Collect 
                          bre'_algo_def bre_algo_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> br'_invar_abs<span class="main">:</span> <span class="quoted"><span class="quoted">"br'_α<span class="main">`</span>br'_invar <span class="free">δ</span> <span class="main">⊆</span> br_invar <span class="free">δ</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br'_invar_def<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> br'_pref_br<span class="main">:</span> <span class="quoted"><span class="quoted">"wa_precise_refine <span class="main">(</span>br'_algo <span class="free">δ</span><span class="main">)</span> <span class="main">(</span>br_algo <span class="free">δ</span><span class="main">)</span> br'_α"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br'_algo_def br_algo_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br'_cond_abs br'_step_abs br'_invar_abs br'_initial_abs<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">interpretation</span></span> br'_pref<span class="main">:</span> wa_precise_refine <span class="quoted"><span class="quoted">"br'_algo <span class="free">δ</span>"</span></span> <span class="quoted"><span class="quoted">"br_algo <span class="free">δ</span>"</span></span> <span class="quoted"><span class="quoted">"br'_α"</span></span> 
  <span class="keyword1"><span class="command">using</span></span> br'_pref_br <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">theorem</span></span> br'_while_algo<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"finite <span class="free">δ</span> <span class="main">⟹</span> while_algo <span class="main">(</span>br'_algo <span class="free">δ</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> br'_pref.wa_intro<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br_while_algo<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br'_algo_def br_algo_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br'_invar_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> <span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> br'_step_invar<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br'_invar_initial<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> fst_br'_α<span class="main">:</span> <span class="quoted"><span class="quoted">"fst <span class="main">(</span>br'_α <span class="free">s</span><span class="main">)</span> <span class="main">=</span> fst <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br'_α_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> br'_invar_final <span class="main">=</span> 
  br'_pref.transfer_correctness<span class="main">[</span><span class="operator">OF</span> br_invar_final<span class="main">,</span> <span class="operator">unfolded</span> fst_br'_α<span class="main">]</span>

<span class="keyword1"><span class="command">theorem</span></span> bre'_pref_br<span class="main">:</span> <span class="quoted"><span class="quoted">"wa_precise_refine <span class="main">(</span>bre'_algo <span class="free">Qi</span> <span class="free">δ</span><span class="main">)</span> <span class="main">(</span>bre_algo <span class="free">Qi</span> <span class="free">δ</span><span class="main">)</span> br'_α"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bre'_algo_def bre_algo_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bre'_cond_abs br'_step_abs br'_invar_abs br'_initial_abs<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">interpretation</span></span> bre'_pref<span class="main">:</span> 
  wa_precise_refine <span class="quoted"><span class="quoted">"bre'_algo <span class="free">Qi</span> <span class="free">δ</span>"</span></span> <span class="quoted"><span class="quoted">"bre_algo <span class="free">Qi</span> <span class="free">δ</span>"</span></span> <span class="quoted"><span class="quoted">"br'_α"</span></span> 
  <span class="keyword1"><span class="command">using</span></span> bre'_pref_br <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">theorem</span></span> bre'_while_algo<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"finite <span class="free">δ</span> <span class="main">⟹</span> while_algo <span class="main">(</span>bre'_algo <span class="free">Qi</span> <span class="free">δ</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> bre'_pref.wa_intro<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bre_while_algo<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bre'_algo_def bre_algo_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br'_invar_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> <span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> br'_step_invar<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br'_invar_initial<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> bre'_invar_final <span class="main">=</span> 
  bre'_pref.transfer_correctness<span class="main">[</span><span class="operator">OF</span> bre_invar_final<span class="main">,</span> <span class="operator">unfolded</span> fst_br'_α<span class="main">]</span>

<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\paragraph{Implementing a Step}›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  In this paragraph, it is shown how to implement a step of the br'-algorithm 
  by iteration over the rules that have the discovered state on their RHS.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">br'_inner_step</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> br'_state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> br'_state"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">br'_inner_step</span> <span class="main">==</span> <span class="main">λ</span><span class="bound">r</span> <span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">rcm</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">let</span> <span class="bound">c</span><span class="main">=</span>the <span class="main">(</span><span class="bound">rcm</span> <span class="bound">r</span><span class="main">)</span> <span class="keyword1">in</span> <span class="main">(</span>
    <span class="keyword1">if</span> <span class="bound">c</span><span class="main">≤</span><span class="main">1</span> <span class="keyword1">then</span> insert <span class="main">(</span>lhs <span class="bound">r</span><span class="main">)</span> <span class="bound">Q</span> <span class="keyword1">else</span> <span class="bound">Q</span><span class="main">,</span>
    <span class="keyword1">if</span> <span class="bound">c</span><span class="main">≤</span><span class="main">1</span> <span class="main">∧</span> <span class="main">(</span>lhs <span class="bound">r</span><span class="main">)</span> <span class="main">∉</span> <span class="bound">Q</span> <span class="keyword1">then</span> insert <span class="main">(</span>lhs <span class="bound">r</span><span class="main">)</span> <span class="bound">W</span> <span class="keyword1">else</span> <span class="bound">W</span><span class="main">,</span>
    <span class="bound">rcm</span> <span class="main">(</span> <span class="bound">r</span> <span class="main">↦</span> <span class="main">(</span><span class="bound">c</span><span class="main">-</span><span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span><span class="main">)</span>
  <span class="main">)</span>
"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">br'_inner_invar</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule set <span class="main">⇒</span> <span class="tfree">'Q</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> br'_state 
      <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> br'_state <span class="main">⇒</span> bool"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">br'_inner_invar</span> <span class="free"><span class="bound"><span class="entity">rules</span></span></span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">==</span> <span class="main">λ</span><span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">rcm</span><span class="main">)</span> <span class="bound">it</span> <span class="main">(</span><span class="bound">Q'</span><span class="main">,</span><span class="bound">W'</span><span class="main">,</span><span class="bound">rcm'</span><span class="main">)</span><span class="main">.</span> 
    <span class="bound">Q'</span> <span class="main">=</span> <span class="bound">Q</span> <span class="main">∪</span> <span class="main">{</span> lhs <span class="bound">r</span> <span class="main">|</span> <span class="bound">r</span><span class="main">.</span> <span class="bound">r</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">rules</span></span></span><span class="main">-</span><span class="bound">it</span> <span class="main">∧</span> the <span class="main">(</span><span class="bound">rcm</span> <span class="bound">r</span><span class="main">)</span> <span class="main">≤</span> <span class="main">1</span> <span class="main">}</span> <span class="main">∧</span> 
    <span class="bound">W'</span> <span class="main">=</span> <span class="main">(</span><span class="bound">W</span><span class="main">-</span><span class="main">{</span><span class="free"><span class="bound"><span class="entity">q</span></span></span><span class="main">}</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span><span class="main">{</span> lhs <span class="bound">r</span> <span class="main">|</span> <span class="bound">r</span><span class="main">.</span> <span class="bound">r</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">rules</span></span></span><span class="main">-</span><span class="bound">it</span> <span class="main">∧</span> the <span class="main">(</span><span class="bound">rcm</span> <span class="bound">r</span><span class="main">)</span> <span class="main">≤</span> <span class="main">1</span> <span class="main">}</span> <span class="main">-</span> <span class="bound">Q</span><span class="main">)</span> <span class="main">∧</span> 
    <span class="main">(</span><span class="main">∀</span><span class="bound">r</span><span class="main">.</span> <span class="bound">rcm'</span> <span class="bound">r</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">r</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">rules</span></span></span><span class="main">-</span><span class="bound">it</span> <span class="keyword1">then</span> Some <span class="main">(</span>the <span class="main">(</span><span class="bound">rcm</span> <span class="bound">r</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">else</span> <span class="bound">rcm</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>
  "</span></span>

<span class="keyword1"><span class="command">lemma</span></span> br'_inner_invar_imp_final<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">q</span><span class="main">∈</span><span class="free">W</span><span class="main">;</span> br'_inner_invar <span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="free">δ</span><span class="main">.</span> <span class="free">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span><span class="main">}</span> <span class="free">q</span> <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">-</span><span class="main">{</span><span class="free">q</span><span class="main">}</span><span class="main">,</span><span class="free">rcm</span><span class="main">)</span> <span class="main">{}</span> <span class="free">Σ'</span> <span class="main">⟧</span> 
     <span class="main">⟹</span> <span class="main">(</span><span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">,</span><span class="free">rcm</span><span class="main">)</span><span class="main">,</span><span class="free">Σ'</span><span class="main">)</span> <span class="main">∈</span> br'_step <span class="free">δ</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> br'_inner_invar_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> br'_step.intros<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> br'_inner_invar_step<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">q</span><span class="main">∈</span><span class="free">W</span><span class="main">;</span> br'_inner_invar <span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="free">δ</span><span class="main">.</span> <span class="free">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span><span class="main">}</span> <span class="free">q</span> <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">-</span><span class="main">{</span><span class="free">q</span><span class="main">}</span><span class="main">,</span><span class="free">rcm</span><span class="main">)</span> <span class="free">it</span> <span class="free">Σ'</span><span class="main">;</span> 
     <span class="free">r</span><span class="main">∈</span><span class="free">it</span><span class="main">;</span> <span class="free">it</span><span class="main">⊆</span><span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="free">δ</span><span class="main">.</span> <span class="free">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span><span class="main">}</span> 
   <span class="main">⟧</span> <span class="main">⟹</span> br'_inner_invar <span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="free">δ</span><span class="main">.</span> <span class="free">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span><span class="main">}</span> <span class="free">q</span> <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">-</span><span class="main">{</span><span class="free">q</span><span class="main">}</span><span class="main">,</span><span class="free">rcm</span><span class="main">)</span> 
                         <span class="main">(</span><span class="free">it</span><span class="main">-</span><span class="main">{</span><span class="free">r</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span>br'_inner_step <span class="free">r</span> <span class="free">Σ'</span><span class="main">)</span>
  "</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">Σ'</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> br'_inner_invar_def br'_inner_step_def Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> br'_inner_invar_initial<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">q</span><span class="main">∈</span><span class="free">W</span> <span class="main">⟧</span> <span class="main">⟹</span> br'_inner_invar <span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="free">δ</span><span class="main">.</span> <span class="free">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span><span class="main">}</span> <span class="free">q</span> <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">-</span><span class="main">{</span><span class="free">q</span><span class="main">}</span><span class="main">,</span><span class="free">rcm</span><span class="main">)</span> 
                               <span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="free">δ</span><span class="main">.</span> <span class="free">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span><span class="main">}</span> <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">-</span><span class="main">{</span><span class="free">q</span><span class="main">}</span><span class="main">,</span><span class="free">rcm</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br'_inner_invar_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> br'_inner_step_proof<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">αs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Σ</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> br'_state"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">cstep</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule <span class="main">⇒</span> <span class="tfree">'Σ</span> <span class="main">⇒</span> <span class="tfree">'Σ</span>"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">Σh</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Σ</span>"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">cinvar</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule set <span class="main">⇒</span> <span class="tfree">'Σ</span> <span class="main">⇒</span> bool"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> iterable_set<span class="main">:</span> <span class="quoted"><span class="quoted">"set_iteratei <span class="free">α</span> <span class="free">invar</span> <span class="free">iteratei</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> invar_initial<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">cinvar</span> <span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="free">δ</span><span class="main">.</span> <span class="free">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span><span class="main">}</span> <span class="free">Σh</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> invar_step<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">!!</span><span class="bound">it</span> <span class="bound">r</span> <span class="bound">Σ</span><span class="main">.</span> <span class="main">⟦</span> <span class="bound">r</span><span class="main">∈</span><span class="bound">it</span><span class="main">;</span> <span class="bound">it</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="free">δ</span><span class="main">.</span> <span class="free">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span><span class="main">}</span><span class="main">;</span> <span class="free">cinvar</span> <span class="bound">it</span> <span class="bound">Σ</span> <span class="main">⟧</span> 
                 <span class="main">⟹</span> <span class="free">cinvar</span> <span class="main">(</span><span class="bound">it</span><span class="main">-</span><span class="main">{</span><span class="bound">r</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="free">cstep</span> <span class="bound">r</span> <span class="bound">Σ</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> step_desc<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">!!</span><span class="bound">it</span> <span class="bound">r</span> <span class="bound">Σ</span><span class="main">.</span> <span class="main">⟦</span> <span class="bound">r</span><span class="main">∈</span><span class="bound">it</span><span class="main">;</span> <span class="bound">it</span><span class="main">⊆</span><span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="free">δ</span><span class="main">.</span> <span class="free">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span><span class="main">}</span><span class="main">;</span> <span class="free">cinvar</span> <span class="bound">it</span> <span class="bound">Σ</span> <span class="main">⟧</span> 
                 <span class="main">⟹</span> <span class="free">αs</span> <span class="main">(</span><span class="free">cstep</span> <span class="bound">r</span> <span class="bound">Σ</span><span class="main">)</span> <span class="main">=</span> br'_inner_step <span class="bound">r</span> <span class="main">(</span><span class="free">αs</span> <span class="bound">Σ</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> it_set_desc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free">it_set</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">α</span> <span class="free">it_set</span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="free">δ</span><span class="main">.</span> <span class="free">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span><span class="main">}</span>"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> QIW<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q</span><span class="main">∈</span><span class="free">W</span>"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> Σ_desc<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">αs</span> <span class="free">Σ</span> <span class="main">=</span> <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">,</span><span class="free">rcm</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Σh_desc<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">αs</span> <span class="free">Σh</span> <span class="main">=</span> <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">-</span><span class="main">{</span><span class="free">q</span><span class="main">}</span><span class="main">,</span><span class="free">rcm</span><span class="main">)</span>"</span></span>

  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">αs</span> <span class="free">Σ</span><span class="main">,</span> <span class="free">αs</span> <span class="main">(</span><span class="free">iteratei</span> <span class="free">it_set</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="free">cstep</span> <span class="free">Σh</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>br'_step <span class="free">δ</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> set_iteratei <span class="quoted"><span class="free">α</span></span> <span class="quoted"><span class="free">invar</span></span> <span class="quoted"><span class="free">iteratei</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> 
      I<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">it</span> <span class="bound">Σ</span><span class="main">.</span> <span class="free">cinvar</span> <span class="bound">it</span> <span class="bound">Σ</span> 
                <span class="main">∧</span> br'_inner_invar <span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="free">δ</span><span class="main">.</span> <span class="free">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span><span class="main">}</span> <span class="free">q</span> <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">-</span><span class="main">{</span><span class="free">q</span><span class="main">}</span><span class="main">,</span><span class="free">rcm</span><span class="main">)</span> 
                                  <span class="bound">it</span> <span class="main">(</span><span class="free">αs</span> <span class="bound">Σ</span><span class="main">)</span>"</span></span> 
      <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> iterate_rule_P<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> 
      <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> it_set_desc invar_initial br'_inner_invar_initial invar_step 
           step_desc br'_inner_invar_step<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> br'_inner_invar_imp_final<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> QIW<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\paragraph{Computing Witnesses}›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The algorithm is now refined further, such that it stores, for each discovered
  state, a witness for non-emptiness, i.e. a tree that is accepted with the
  discovered state.
›</span></span>

<span class="comment1">― ‹A map from states to trees has the witness-property, if it maps states to 
    trees that are accepted with that state:›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">witness_prop</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">==</span> <span class="main">∀</span><span class="bound">q</span> <span class="bound">t</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="bound">q</span> <span class="main">=</span> Some <span class="bound">t</span> <span class="main">⟶</span> accs <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="bound">t</span> <span class="bound">q</span>"</span></span>

<span class="comment1">― ‹Construct a witness for the LHS of a rule, provided that the map contains 
    witnesses for all states on the RHS:›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">construct_witness</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span> <span class="main">⇀</span> <span class="tfree">'L</span> tree<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule <span class="main">⇒</span> <span class="tfree">'L</span> tree"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">construct_witness</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">==</span> NODE <span class="main">(</span>rhsl <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">(</span>List.map <span class="main">(</span><span class="main">λ</span><span class="bound">q</span><span class="main">.</span> the <span class="main">(</span><span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="bound">q</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>rhsq <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> witness_propD<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>witness_prop <span class="free">δ</span> <span class="free">m</span><span class="main">;</span> <span class="free">m</span> <span class="free">q</span> <span class="main">=</span> Some <span class="free">t</span><span class="main">⟧</span> <span class="main">⟹</span> accs <span class="free">δ</span> <span class="free">t</span> <span class="free">q</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> witness_prop_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> construct_witness_correct<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> witness_prop <span class="free">δ</span> <span class="free">Q</span><span class="main">;</span> <span class="free">r</span><span class="main">∈</span><span class="free">δ</span><span class="main">;</span> set <span class="main">(</span>rhsq <span class="free">r</span><span class="main">)</span> <span class="main">⊆</span> dom <span class="free">Q</span> <span class="main">⟧</span> 
    <span class="main">⟹</span> accs <span class="free">δ</span> <span class="main">(</span>construct_witness <span class="free">Q</span> <span class="free">r</span><span class="main">)</span> <span class="main">(</span>lhs <span class="free">r</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> construct_witness_def witness_prop_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">r</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> accs.intros<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> nth_mem<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> construct_witness_eq<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">Q</span> <span class="main">|`</span> set <span class="main">(</span>rhsq <span class="free">r</span><span class="main">)</span> <span class="main">=</span> <span class="free">Q'</span> <span class="main">|`</span> set <span class="main">(</span>rhsq <span class="free">r</span><span class="main">)</span> <span class="main">⟧</span> <span class="main">⟹</span> 
    construct_witness <span class="free">Q</span> <span class="free">r</span> <span class="main">=</span> construct_witness <span class="free">Q'</span> <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> construct_witness_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="improper">x</span> <span class="main">=</span> <span class="free">Q'</span> <span class="improper">x</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> fun_cong<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The set of discovered states is refined by a map from discovered states to 
  their witnesses:
›</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> brw_state <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">⇀</span><span class="tfree">'L</span> tree<span class="main">)</span> <span class="main">×</span> <span class="tfree">'Q</span> set <span class="main">×</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule <span class="main">⇀</span> nat<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">brw_α</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> brw_state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> br'_state"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">brw_α</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">rcm</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span>dom <span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">rcm</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">brw_invar_add</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> brw_state set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">brw_invar_add</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">==</span> <span class="main">{</span><span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">rcm</span><span class="main">)</span><span class="main">.</span> witness_prop <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="bound">Q</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">brw_invar</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">==</span> brw_invar_add <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">∩</span> <span class="main">{</span><span class="bound">s</span><span class="main">.</span> brw_α <span class="bound">s</span> <span class="main">∈</span> br'_invar <span class="free"><span class="bound"><span class="entity">δ</span></span></span><span class="main">}</span>"</span></span>

<span class="comment1">(* TODO:
    This step description does not allow full flexibility, because
    we may want to construct new witnesses from other witnesses constructed 
    in the same step!
    
    However, if we say t = construct_witness Q' r, may we run into cyclicity 
    problems, where a cycle of witnesses
    may witness itself?. Hmm? As these cyclic witnesses would have to
    be infinite, they cannot exist?

    But, if we use a BFS search strategy, the current step description will 
    compute minimal depth witnesses.
    The argumentation is, that:
      Initially, all witnesses of depth 1 (definitely minimal) are discovered
      A witness of depth n has children of length &lt; n
      The states that are initially on the workset are all those with 
      witnesses of depth 1. Thus,
      after they have been processed, all states with witnesses of depth 2 have
      been discovered. This argument can be iterated inductively.
*)</span>
<span class="keyword1"><span class="command">inductive_set</span></span> <span class="entity">brw_step</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule set <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> brw_state <span class="main">×</span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> brw_state<span class="main">)</span> set"</span></span> 
  <span class="keyword2"><span class="keyword">for</span></span> <span class="entity">δ</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> 
     <span class="free"><span class="bound"><span class="entity">q</span></span></span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">W</span></span></span><span class="main">;</span>
     <span class="free"><span class="bound"><span class="entity">dsqr</span></span></span> <span class="main">=</span> <span class="main">{</span> <span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="free">δ</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">∈</span> set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span> <span class="main">∧</span> the <span class="main">(</span><span class="free"><span class="bound"><span class="entity">rcm</span></span></span> <span class="bound">r</span><span class="main">)</span> <span class="main">≤</span> <span class="main">1</span> <span class="main">}</span><span class="main">;</span>
     dom <span class="free"><span class="bound"><span class="entity">Q'</span></span></span> <span class="main">=</span> dom <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">∪</span> lhs<span class="main">`</span><span class="free"><span class="bound"><span class="entity">dsqr</span></span></span><span class="main">;</span>
     <span class="main">!!</span><span class="bound">q</span> <span class="bound">t</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">Q'</span></span></span> <span class="bound">q</span> <span class="main">=</span> Some <span class="bound">t</span> <span class="main">⟹</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="bound">q</span> <span class="main">=</span> Some <span class="bound">t</span> 
                              <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">r</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">dsqr</span></span></span><span class="main">.</span> <span class="bound">q</span><span class="main">=</span>lhs <span class="bound">r</span> <span class="main">∧</span> <span class="bound">t</span><span class="main">=</span>construct_witness <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="bound">r</span><span class="main">)</span><span class="main">;</span>
     <span class="free"><span class="bound"><span class="entity">W'</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">W</span></span></span><span class="main">-</span><span class="main">{</span><span class="free"><span class="bound"><span class="entity">q</span></span></span><span class="main">}</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>lhs<span class="main">`</span><span class="free"><span class="bound"><span class="entity">dsqr</span></span></span> <span class="main">-</span> dom <span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">)</span><span class="main">;</span>
     <span class="main">!!</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span><span class="main">∈</span><span class="free">δ</span> <span class="main">⟹</span> <span class="free"><span class="bound"><span class="entity">rcm'</span></span></span> <span class="bound">r</span> <span class="main">=</span> <span class="main">(</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">∈</span> set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span> <span class="keyword1">then</span> 
                               Some <span class="main">(</span>the <span class="main">(</span><span class="free"><span class="bound"><span class="entity">rcm</span></span></span> <span class="bound">r</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> 
                             <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">rcm</span></span></span> <span class="bound">r</span>
                           <span class="main">)</span>
   <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">W</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">rcm</span></span></span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">Q'</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">W'</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">rcm'</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> <span class="free">brw_step</span> <span class="free">δ</span>"</span></span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">brw_cond</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> brw_state set"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">brw_cond</span> <span class="free"><span class="bound"><span class="entity">Qi</span></span></span> <span class="main">==</span> <span class="main">{</span><span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">rcm</span><span class="main">)</span><span class="main">.</span> <span class="bound">W</span><span class="main">≠</span><span class="main">{}</span> <span class="main">∧</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">Qi</span></span></span><span class="main">∩</span>dom <span class="bound">Q</span><span class="main">=</span><span class="main">{}</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">inductive_set</span></span> <span class="entity">brw_iq</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q</span> <span class="main">⇀</span> <span class="tfree">'L</span> tree<span class="main">)</span> set"</span></span> 
  <span class="keyword2"><span class="keyword">for</span></span> <span class="entity">δ</span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> 
    <span class="main">∀</span><span class="bound">q</span> <span class="bound">t</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="bound">q</span> <span class="main">=</span> Some <span class="bound">t</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">r</span><span class="main">∈</span><span class="free">δ</span><span class="main">.</span> rhsq <span class="bound">r</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">∧</span> <span class="bound">q</span> <span class="main">=</span> lhs <span class="bound">r</span> 
                                  <span class="main">∧</span> <span class="bound">t</span> <span class="main">=</span> NODE <span class="main">(</span>rhsl <span class="bound">r</span><span class="main">)</span> <span class="main">[]</span><span class="main">)</span><span class="main">;</span>
    <span class="main">∀</span><span class="bound">r</span><span class="main">∈</span><span class="free">δ</span><span class="main">.</span> rhsq <span class="bound">r</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">(</span>lhs <span class="bound">r</span><span class="main">)</span> <span class="main">≠</span> None
   <span class="main">⟧</span> <span class="main">⟹</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">∈</span> <span class="free">brw_iq</span> <span class="free">δ</span>"</span></span>

<span class="keyword1"><span class="command">inductive_set</span></span> <span class="entity">brw_initial</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> brw_state set"</span></span> 
  <span class="keyword2"><span class="keyword">for</span></span> <span class="entity">δ</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">!!</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span><span class="main">∈</span><span class="free">δ</span> <span class="main">⟹</span> <span class="free"><span class="bound"><span class="entity">rcm</span></span></span> <span class="bound">r</span> <span class="main">=</span> Some <span class="main">(</span>card <span class="main">(</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">∈</span>brw_iq <span class="free">δ</span> <span class="main">⟧</span> 
     <span class="main">⟹</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">,</span> br_iq <span class="free">δ</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">rcm</span></span></span><span class="main">)</span><span class="main">∈</span><span class="free">brw_initial</span> <span class="free">δ</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">brw_algo</span> <span class="free"><span class="bound"><span class="entity">Qi</span></span></span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">==</span> <span class="main">⦇</span>
  wa_cond<span class="main">=</span>brw_cond <span class="free"><span class="bound"><span class="entity">Qi</span></span></span><span class="main">,</span>
  wa_step <span class="main">=</span> brw_step <span class="free"><span class="bound"><span class="entity">δ</span></span></span><span class="main">,</span>
  wa_initial <span class="main">=</span> brw_initial <span class="free"><span class="bound"><span class="entity">δ</span></span></span><span class="main">,</span>
  wa_invar <span class="main">=</span> brw_invar <span class="free"><span class="bound"><span class="entity">δ</span></span></span>
<span class="main">⦈</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> brw_cond_abs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Σ</span><span class="main">∈</span>brw_cond <span class="free">Qi</span> <span class="main">⟷</span> <span class="main">(</span>brw_α <span class="free">Σ</span><span class="main">)</span><span class="main">∈</span>bre'_cond <span class="free">Qi</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">Σ</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brw_cond_def bre'_cond_def brw_α_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> brw_initial_abs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Σ</span><span class="main">∈</span>brw_initial <span class="free">δ</span> <span class="main">⟹</span> brw_α <span class="free">Σ</span> <span class="main">∈</span> br'_initial <span class="free">δ</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">Σ</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> brw_initial.cases<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> brw_iq.cases<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brw_α_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"dom <span class="improper">Qa</span> <span class="main">=</span> br_iq <span class="free">δ</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> br'_initial.intros<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br_iq_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">lemma</span></span> brw_invar_initial<span class="main">:</span> <span class="quoted"><span class="quoted">"brw_initial <span class="free">δ</span> <span class="main">⊆</span> brw_invar_add <span class="free">δ</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> brw_invar_add_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> witness_prop_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> brw_initial.cases<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> brw_iq.cases<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">goal_cases</span>
  <span class="keyword3"><span class="command">case</span></span> prems<span class="main">:</span> <span class="main">(</span>1 <span class="skolem">q</span> <span class="skolem">t</span> <span class="skolem">rcm</span> <span class="skolem">Q</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> prems<span class="main">(</span>3<span class="main">)</span><span class="main">[</span><span class="operator">rule_format</span><span class="main">,</span> <span class="operator">OF</span> prems<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">r</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span><span class="main">∈</span><span class="free">δ</span>"</span></span> <span class="quoted"><span class="quoted">"rhsq <span class="skolem">r</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span><span class="main">=</span>lhs <span class="skolem">r</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">t</span><span class="main">=</span>NODE <span class="main">(</span>rhsl <span class="skolem">r</span><span class="main">)</span> <span class="main">[]</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">have</span></span> RF<span class="main">[</span><span class="operator">simplified</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span><span class="main">=</span><span class="main">(</span><span class="main">(</span>lhs <span class="skolem">r</span><span class="main">)</span> <span class="main">→</span> <span class="main">(</span>rhsl <span class="skolem">r</span><span class="main">)</span> <span class="main">(</span>rhsq <span class="skolem">r</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">r</span></span><span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> accs.intros<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> RF<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>
    
<span class="keyword1"><span class="command">lemma</span></span> brw_step_abs<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="free">Σ</span><span class="main">,</span><span class="free">Σ'</span><span class="main">)</span><span class="main">∈</span>brw_step <span class="free">δ</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span>brw_α <span class="free">Σ</span><span class="main">,</span> brw_α <span class="free">Σ'</span><span class="main">)</span><span class="main">∈</span>br'_step <span class="free">δ</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">Σ</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">Σ'</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> brw_step.cases<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brw_α_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">hypsubst</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> br'_step.intros<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> brw_step_invar<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> FIN<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">δ</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Σ</span><span class="main">∈</span>brw_invar_add <span class="free">δ</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> BR'INV<span class="main">:</span> <span class="quoted"><span class="quoted">"brw_α <span class="free">Σ</span> <span class="main">∈</span> br'_invar <span class="free">δ</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> STEP<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Σ</span><span class="main">,</span><span class="free">Σ'</span><span class="main">)</span> <span class="main">∈</span> brw_step <span class="free">δ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">Σ'</span><span class="main">∈</span>brw_invar_add <span class="free">δ</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">Q</span></span> <span class="skolem"><span class="skolem">W</span></span> <span class="skolem"><span class="skolem">rcm</span></span> <span class="skolem"><span class="skolem">Q'</span></span> <span class="skolem"><span class="skolem">W'</span></span> <span class="skolem"><span class="skolem">rcm'</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Σ</span><span class="main">=</span><span class="main">(</span><span class="skolem">Q</span><span class="main">,</span><span class="skolem">W</span><span class="main">,</span><span class="skolem">rcm</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Σ'</span><span class="main">=</span><span class="main">(</span><span class="skolem">Q'</span><span class="main">,</span><span class="skolem">W'</span><span class="main">,</span><span class="skolem">rcm'</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">Σ</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">Σ'</span></span><span class="main">)</span> <span class="operator">force</span>

  <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">have</span></span> WP<span class="main">:</span> <span class="quoted"><span class="quoted">"witness_prop <span class="free">δ</span> <span class="skolem">Q</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brw_invar_add_def<span class="main">)</span>

  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">qw</span></span> <span class="skolem"><span class="skolem">dsqr</span></span> <span class="keyword2"><span class="keyword">where</span></span> SPROPS<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="skolem">dsqr</span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">r</span></span> <span class="main">∈</span> <span class="free">δ</span><span class="main">.</span> <span class="skolem">qw</span> <span class="main">∈</span> set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span> <span class="main">∧</span> the <span class="main">(</span><span class="skolem">rcm</span> <span class="bound">r</span><span class="main">)</span> <span class="main">≤</span> <span class="main">1</span><span class="main">}</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="skolem">qw</span><span class="main">∈</span><span class="skolem">W</span>"</span></span>
    <span class="quoted"><span class="quoted">"dom <span class="skolem">Q'</span> <span class="main">=</span> dom <span class="skolem">Q</span> <span class="main">∪</span> lhs <span class="main">`</span> <span class="skolem">dsqr</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">!!</span><span class="bound">q</span> <span class="bound">t</span><span class="main">.</span> <span class="skolem">Q'</span> <span class="bound">q</span> <span class="main">=</span> Some <span class="bound">t</span> <span class="main">⟹</span> <span class="skolem">Q</span> <span class="bound">q</span> <span class="main">=</span> Some <span class="bound">t</span> 
                              <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">r</span><span class="main">∈</span><span class="skolem">dsqr</span><span class="main">.</span> <span class="bound">q</span><span class="main">=</span>lhs <span class="bound">r</span> <span class="main">∧</span> <span class="bound">t</span><span class="main">=</span>construct_witness <span class="skolem">Q</span> <span class="bound">r</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> brw_step.cases<span class="main"><span class="main">[</span></span><span class="operator">OF</span> STEP<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">simplified</span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> br'_rcm_aux'<span class="main">[</span><span class="operator">OF</span> BR'INV<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> brw_α_def<span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span> SPROPS<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> 
    DSQR_ALT<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">dsqr</span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">r</span></span> <span class="main">∈</span> <span class="free">δ</span><span class="main">.</span> <span class="skolem">qw</span> <span class="main">∈</span> set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span> 
                              <span class="main">∧</span> set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span> <span class="main">⊆</span> dom <span class="skolem">Q</span> <span class="main">-</span> <span class="main">(</span><span class="skolem">W</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">qw</span><span class="main">}</span><span class="main">)</span><span class="main">}</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> SPROPS<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"witness_prop <span class="free">δ</span> <span class="skolem">Q'</span>"</span></span> 
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">unfold</span> witness_prop_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">safe</span><span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">q</span> <span class="skolem">t</span>
    <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">Q'</span> <span class="skolem">q</span> <span class="main">=</span> Some <span class="skolem">t</span>"</span></span>

    <span class="keyword1"><span class="command">from</span></span> SPROPS<span class="main">(</span>4<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> A<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> 
      <span class="quoted"><span class="quoted">"<span class="skolem">Q</span> <span class="skolem">q</span> <span class="main">=</span> Some <span class="skolem">t</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">r</span><span class="main">∈</span><span class="skolem">dsqr</span><span class="main">.</span> <span class="skolem">q</span> <span class="main">=</span> lhs <span class="bound">r</span> <span class="main">∧</span> <span class="skolem">t</span> <span class="main">=</span> construct_witness <span class="skolem">Q</span> <span class="bound">r</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> C<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">Q</span> <span class="skolem">q</span> <span class="main">=</span> Some <span class="skolem">t</span>"</span></span>
      <span class="keyword1"><span class="command">from</span></span> witness_propD<span class="main">[</span><span class="operator">OF</span> WP<span class="main">,</span> <span class="operator">OF</span> C<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"accs <span class="free">δ</span> <span class="skolem">t</span> <span class="skolem">q</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">r</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span><span class="main">∈</span><span class="skolem">dsqr</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span><span class="main">=</span>lhs <span class="skolem">r</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">t</span><span class="main">=</span>construct_witness <span class="skolem">Q</span> <span class="skolem">r</span>"</span></span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">r</span><span class="main">∈</span><span class="skolem">dsqr</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span><span class="main">∈</span><span class="free">δ</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>rhsq <span class="skolem">r</span><span class="main">)</span> <span class="main">⊆</span> dom <span class="skolem">Q</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DSQR_ALT<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> construct_witness_correct<span class="main">[</span><span class="operator">OF</span> WP 1<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"accs <span class="free">δ</span> <span class="skolem">t</span> <span class="skolem">q</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"accs <span class="free">δ</span> <span class="skolem">t</span> <span class="skolem">q</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brw_invar_add_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>
      
<span class="keyword1"><span class="command">theorem</span></span> brw_pref_bre'<span class="main">:</span> <span class="quoted"><span class="quoted">"wa_precise_refine <span class="main">(</span>brw_algo <span class="free">Qi</span> <span class="free">δ</span><span class="main">)</span> <span class="main">(</span>bre'_algo <span class="free">Qi</span> <span class="free">δ</span><span class="main">)</span> brw_α"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brw_algo_def bre'_algo_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brw_cond_abs brw_step_abs brw_initial_abs brw_invar_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">interpretation</span></span> brw_pref<span class="main">:</span> 
  wa_precise_refine <span class="quoted"><span class="quoted">"brw_algo <span class="free">Qi</span> <span class="free">δ</span>"</span></span> <span class="quoted"><span class="quoted">"bre'_algo <span class="free">Qi</span> <span class="free">δ</span>"</span></span> <span class="quoted"><span class="quoted">"brw_α"</span></span> 
  <span class="keyword1"><span class="command">using</span></span> brw_pref_bre' <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">theorem</span></span> brw_while_algo<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">δ</span> <span class="main">⟹</span> while_algo <span class="main">(</span>brw_algo <span class="free">Qi</span> <span class="free">δ</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> brw_pref.wa_intro<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bre'_while_algo<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brw_algo_def bre'_algo_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brw_invar_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> brw_step_invar <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brw_invar_initial<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> fst_brw_α<span class="main">:</span> <span class="quoted"><span class="quoted">"fst <span class="main">(</span>brw_α <span class="free">s</span><span class="main">)</span> <span class="main">=</span> dom <span class="main">(</span>fst <span class="free">s</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brw_α_def<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> brw_invar_final<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">sc</span><span class="main">.</span> <span class="bound">sc</span> <span class="main">∈</span> wa_invar <span class="main">(</span>brw_algo <span class="free">Qi</span> <span class="free">δ</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">sc</span> <span class="main">∉</span> wa_cond <span class="main">(</span>brw_algo <span class="free">Qi</span> <span class="free">δ</span><span class="main">)</span> 
    <span class="main">⟶</span> <span class="main">(</span><span class="free">Qi</span> <span class="main">∩</span> dom <span class="main">(</span>fst <span class="bound">sc</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">Qi</span> <span class="main">∩</span> b_accessible <span class="free">δ</span> <span class="main">=</span> <span class="main">{}</span><span class="main">)</span> 
        <span class="main">∧</span> <span class="main">(</span>witness_prop <span class="free">δ</span> <span class="main">(</span>fst <span class="bound">sc</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI allI impI<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> brw_pref.transfer_correctness<span class="main">[</span><span class="operator">OF</span> bre'_invar_final<span class="main">,</span> <span class="operator">unfolded</span> fst_brw_α<span class="main">]</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brw_algo_def brw_invar_def brw_invar_add_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
     

<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\paragraph{Implementing a Step}›</span></span>
<span class="keyword1"><span class="command">inductive_set</span></span> <span class="entity">brw_inner_step</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> brw_state <span class="main">×</span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> brw_state<span class="main">)</span> set"</span></span> 
  <span class="keyword2"><span class="keyword">for</span></span> <span class="entity">r</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>  <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">=</span> the <span class="main">(</span><span class="free"><span class="bound"><span class="entity">rcm</span></span></span> <span class="free">r</span><span class="main">)</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">Σ</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">W</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">rcm</span></span></span><span class="main">)</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">Σ'</span></span></span><span class="main">=</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">Q'</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">W'</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">rcm'</span></span></span><span class="main">)</span><span class="main">;</span>
     <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">≤</span><span class="main">1</span> <span class="main">∧</span> <span class="main">(</span>lhs <span class="free">r</span><span class="main">)</span> <span class="main">∉</span> dom <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="keyword1">then</span> 
       <span class="free"><span class="bound"><span class="entity">Q'</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">(</span>lhs <span class="free">r</span> <span class="main">↦</span> construct_witness <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free">r</span><span class="main">)</span> 
     <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">Q'</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">;</span>
     <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">≤</span><span class="main">1</span> <span class="main">∧</span> <span class="main">(</span>lhs <span class="free">r</span><span class="main">)</span> <span class="main">∉</span> dom <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="keyword1">then</span> 
       <span class="free"><span class="bound"><span class="entity">W'</span></span></span> <span class="main">=</span> insert <span class="main">(</span>lhs <span class="free">r</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">W</span></span></span> 
     <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">W'</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">W</span></span></span><span class="main">;</span>
     <span class="free"><span class="bound"><span class="entity">rcm'</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">rcm</span></span></span> <span class="main">(</span> <span class="free">r</span> <span class="main">↦</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">-</span><span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span><span class="main">)</span>
   <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">Σ</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">Σ'</span></span></span><span class="main">)</span><span class="main">∈</span><span class="free">brw_inner_step</span> <span class="free">r</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">brw_inner_invar</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule set <span class="main">⇒</span> <span class="tfree">'Q</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> brw_state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule set 
      <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> brw_state <span class="main">⇒</span> bool"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">brw_inner_invar</span> <span class="free"><span class="bound"><span class="entity">rules</span></span></span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">==</span> <span class="main">λ</span><span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">rcm</span><span class="main">)</span> <span class="bound">it</span> <span class="main">(</span><span class="bound">Q'</span><span class="main">,</span><span class="bound">W'</span><span class="main">,</span><span class="bound">rcm'</span><span class="main">)</span><span class="main">.</span>
    <span class="main">(</span>br'_inner_invar <span class="free"><span class="bound"><span class="entity">rules</span></span></span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">(</span>brw_α <span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">rcm</span><span class="main">)</span><span class="main">)</span> <span class="bound">it</span> <span class="main">(</span>brw_α <span class="main">(</span><span class="bound">Q'</span><span class="main">,</span><span class="bound">W'</span><span class="main">,</span><span class="bound">rcm'</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>  
    <span class="main">(</span><span class="bound">Q'</span><span class="main">|`</span>dom <span class="bound">Q</span> <span class="main">=</span> <span class="bound">Q</span><span class="main">)</span> <span class="main">∧</span> 
    <span class="main">(</span><span class="keyword1">let</span> <span class="bound">dsqr</span> <span class="main">=</span> <span class="main">{</span> <span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">rules</span></span></span> <span class="main">-</span> <span class="bound">it</span><span class="main">.</span> the <span class="main">(</span><span class="bound">rcm</span> <span class="bound">r</span><span class="main">)</span> <span class="main">≤</span> <span class="main">1</span> <span class="main">}</span> <span class="keyword1">in</span>
      <span class="main">(</span><span class="main">∀</span><span class="bound">q</span> <span class="bound">t</span><span class="main">.</span> <span class="bound">Q'</span> <span class="bound">q</span> <span class="main">=</span> Some <span class="bound">t</span> <span class="main">⟶</span> <span class="main">(</span><span class="bound">Q</span> <span class="bound">q</span> <span class="main">=</span> Some <span class="bound">t</span> 
           <span class="main">∨</span> <span class="main">(</span><span class="bound">Q</span> <span class="bound">q</span> <span class="main">=</span> None <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound">r</span><span class="main">∈</span><span class="bound">dsqr</span><span class="main">.</span> <span class="bound">q</span><span class="main">=</span>lhs <span class="bound">r</span> <span class="main">∧</span> <span class="bound">t</span><span class="main">=</span>construct_witness <span class="bound">Q</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>
                                <span class="main">)</span>
      <span class="main">)</span><span class="main">)</span><span class="main">)</span>
  "</span></span>

<span class="keyword1"><span class="command">lemma</span></span> brw_inner_step_abs<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Σ</span><span class="main">,</span><span class="free">Σ'</span><span class="main">)</span><span class="main">∈</span>brw_inner_step <span class="free">r</span> <span class="main">⟹</span> br'_inner_step <span class="free">r</span> <span class="main">(</span>brw_α <span class="free">Σ</span><span class="main">)</span> <span class="main">=</span> brw_α <span class="free">Σ'</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> brw_inner_step.cases<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> br'_inner_step_def brw_α_def Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">lemma</span></span> brw_inner_invar_imp_final<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">q</span><span class="main">∈</span><span class="free">W</span><span class="main">;</span> brw_inner_invar <span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="free">δ</span><span class="main">.</span> <span class="free">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span><span class="main">}</span> <span class="free">q</span> <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">-</span><span class="main">{</span><span class="free">q</span><span class="main">}</span><span class="main">,</span><span class="free">rcm</span><span class="main">)</span> <span class="main">{}</span> <span class="free">Σ'</span> <span class="main">⟧</span> 
    <span class="main">⟹</span> <span class="main">(</span><span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">,</span><span class="free">rcm</span><span class="main">)</span><span class="main">,</span><span class="free">Σ'</span><span class="main">)</span> <span class="main">∈</span> brw_step <span class="free">δ</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> brw_inner_invar_def br'_inner_invar_def brw_α_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> brw_step.intros<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">lemma</span></span> brw_inner_invar_step<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> INVI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">,</span><span class="free">rcm</span><span class="main">)</span><span class="main">∈</span>brw_invar <span class="free">δ</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q</span><span class="main">∈</span><span class="free">W</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span><span class="main">∈</span><span class="free">it</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">it</span><span class="main">⊆</span><span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="free">δ</span><span class="main">.</span> <span class="free">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span><span class="main">}</span>"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> INVH<span class="main">:</span> <span class="quoted"><span class="quoted">"brw_inner_invar <span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="free">δ</span><span class="main">.</span> <span class="free">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span><span class="main">}</span> <span class="free">q</span> <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">-</span><span class="main">{</span><span class="free">q</span><span class="main">}</span><span class="main">,</span><span class="free">rcm</span><span class="main">)</span> <span class="free">it</span> <span class="free">Σh</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> STEP<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Σh</span><span class="main">,</span><span class="free">Σ'</span><span class="main">)</span><span class="main">∈</span>brw_inner_step <span class="free">r</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"brw_inner_invar <span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="free">δ</span><span class="main">.</span> <span class="free">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span><span class="main">}</span> <span class="free">q</span> <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">-</span><span class="main">{</span><span class="free">q</span><span class="main">}</span><span class="main">,</span><span class="free">rcm</span><span class="main">)</span> <span class="main">(</span><span class="free">it</span><span class="main">-</span><span class="main">{</span><span class="free">r</span><span class="main">}</span><span class="main">)</span> <span class="free">Σ'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> INVI <span class="keyword1"><span class="command">have</span></span> BR'_INV<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>dom <span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">,</span><span class="free">rcm</span><span class="main">)</span><span class="main">∈</span>br'_invar <span class="free">δ</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brw_invar_def brw_α_def<span class="main">)</span>

  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">c</span></span> <span class="skolem"><span class="skolem">Qh</span></span> <span class="skolem"><span class="skolem">Wh</span></span> <span class="skolem"><span class="skolem">rcmh</span></span> <span class="skolem"><span class="skolem">Q'</span></span> <span class="skolem"><span class="skolem">W'</span></span> <span class="skolem"><span class="skolem">rcm'</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    SIGMAF<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Σh</span><span class="main">=</span><span class="main">(</span><span class="skolem">Qh</span><span class="main">,</span><span class="skolem">Wh</span><span class="main">,</span><span class="skolem">rcmh</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Σ'</span><span class="main">=</span><span class="main">(</span><span class="skolem">Q'</span><span class="main">,</span><span class="skolem">W'</span><span class="main">,</span><span class="skolem">rcm'</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    CF<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">=</span> the <span class="main">(</span><span class="skolem">rcmh</span> <span class="free">r</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    SF<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">if</span> <span class="skolem">c</span><span class="main">≤</span><span class="main">1</span> <span class="main">∧</span> <span class="main">(</span>lhs <span class="free">r</span><span class="main">)</span> <span class="main">∉</span> dom <span class="skolem">Qh</span> <span class="keyword1">then</span> 
           <span class="skolem">Q'</span> <span class="main">=</span> <span class="skolem">Qh</span><span class="main">(</span>lhs <span class="free">r</span> <span class="main">↦</span> <span class="main">(</span>construct_witness <span class="skolem">Qh</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span> 
         <span class="keyword1">else</span> <span class="skolem">Q'</span> <span class="main">=</span> <span class="skolem">Qh</span>"</span></span>

        <span class="quoted"><span class="quoted">"<span class="keyword1">if</span> <span class="skolem">c</span><span class="main">≤</span><span class="main">1</span> <span class="main">∧</span> <span class="main">(</span>lhs <span class="free">r</span><span class="main">)</span> <span class="main">∉</span> dom <span class="skolem">Qh</span> <span class="keyword1">then</span> 
           <span class="skolem">W'</span> <span class="main">=</span> insert <span class="main">(</span>lhs <span class="free">r</span><span class="main">)</span> <span class="skolem">Wh</span> 
         <span class="keyword1">else</span> <span class="skolem">W'</span> <span class="main">=</span> <span class="skolem">Wh</span>"</span></span>

        <span class="quoted"><span class="quoted">"<span class="skolem">rcm'</span> <span class="main">=</span> <span class="skolem">rcmh</span> <span class="main">(</span> <span class="free">r</span> <span class="main">↦</span> <span class="main">(</span><span class="skolem">c</span><span class="main">-</span><span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> brw_inner_step.cases<span class="main"><span class="main">[</span></span><span class="operator">OF</span> STEP<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?rules</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="free">δ</span><span class="main">.</span> <span class="free">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?dsqr</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">it</span><span class="main">.</span> <span class="main">{</span> <span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="var">?rules</span> <span class="main">-</span> <span class="bound">it</span><span class="main">.</span> the <span class="main">(</span><span class="free">rcm</span> <span class="bound">r</span><span class="main">)</span> <span class="main">≤</span> <span class="main">1</span> <span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> INVH <span class="keyword1"><span class="command">have</span></span> INVHF<span class="main">:</span>
    <span class="quoted"><span class="quoted">"br'_inner_invar <span class="var">?rules</span> <span class="free">q</span> <span class="main">(</span>dom <span class="free">Q</span><span class="main">,</span> <span class="free">W</span><span class="main">-</span><span class="main">{</span><span class="free">q</span><span class="main">}</span><span class="main">,</span> <span class="free">rcm</span><span class="main">)</span> <span class="main">(</span><span class="free">it</span><span class="main">)</span> <span class="main">(</span>dom <span class="skolem">Qh</span><span class="main">,</span><span class="skolem">Wh</span><span class="main">,</span><span class="skolem">rcmh</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="skolem">Qh</span><span class="main">|`</span>dom <span class="free">Q</span> <span class="main">=</span> <span class="free">Q</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">q</span> <span class="bound">t</span><span class="main">.</span> <span class="skolem">Qh</span> <span class="bound">q</span> <span class="main">=</span> Some <span class="bound">t</span> <span class="main">⟶</span> <span class="main">(</span><span class="free">Q</span> <span class="bound">q</span> <span class="main">=</span> Some <span class="bound">t</span> 
         <span class="main">∨</span> <span class="main">(</span><span class="free">Q</span> <span class="bound">q</span> <span class="main">=</span> None <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound">r</span><span class="main">∈</span><span class="var">?dsqr</span> <span class="free">it</span><span class="main">.</span> <span class="bound">q</span><span class="main">=</span>lhs <span class="bound">r</span> <span class="main">∧</span> <span class="bound">t</span><span class="main">=</span>construct_witness <span class="free">Q</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>
                               <span class="main">)</span>
     <span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brw_inner_invar_def Let_def brw_α_def<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> INVHF<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> br'_inner_invar_def<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> INV'HF<span class="main">:</span>
    <span class="quoted"><span class="quoted">"dom <span class="skolem">Qh</span> <span class="main">=</span> dom <span class="free">Q</span> <span class="main">∪</span> lhs<span class="main">`</span><span class="var">?dsqr</span> <span class="free">it</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">r</span><span class="main">.</span> <span class="skolem">rcmh</span> <span class="bound">r</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">r</span> <span class="main">∈</span> <span class="var">?rules</span> <span class="main">-</span> <span class="free">it</span> <span class="keyword1">then</span> 
                      Some <span class="main">(</span>the <span class="main">(</span><span class="free">rcm</span> <span class="bound">r</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> 
                    <span class="keyword1">else</span> <span class="free">rcm</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> brw_inner_step_abs<span class="main">[</span><span class="operator">OF</span> STEP<span class="main">]</span> 
       br'_inner_invar_step<span class="main">[</span><span class="operator">OF</span> A<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> INVHF<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> A<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> 
    G1<span class="main">:</span> <span class="quoted"><span class="quoted">"br'_inner_invar <span class="var">?rules</span> <span class="free">q</span> <span class="main">(</span>dom <span class="free">Q</span><span class="main">,</span> <span class="free">W</span><span class="main">-</span><span class="main">{</span><span class="free">q</span><span class="main">}</span><span class="main">,</span> <span class="free">rcm</span><span class="main">)</span> <span class="main">(</span><span class="free">it</span><span class="main">-</span><span class="main">{</span><span class="free">r</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span>dom <span class="skolem">Q'</span><span class="main">,</span><span class="skolem">W'</span><span class="main">,</span><span class="skolem">rcm'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brw_α_def<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">q</span> <span class="bound">t</span><span class="main">.</span> <span class="skolem">Q'</span> <span class="bound">q</span> <span class="main">=</span> Some <span class="bound">t</span> <span class="main">⟶</span> <span class="main">(</span><span class="free">Q</span> <span class="bound">q</span> <span class="main">=</span> Some <span class="bound">t</span> 
        <span class="main">∨</span> <span class="main">(</span> <span class="free">Q</span> <span class="bound">q</span> <span class="main">=</span> None 
            <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound">r</span><span class="main">∈</span><span class="var">?dsqr</span> <span class="main">(</span><span class="free">it</span><span class="main">-</span><span class="main">{</span><span class="free">r</span><span class="main">}</span><span class="main">)</span><span class="main">.</span> <span class="bound">q</span><span class="main">=</span>lhs <span class="bound">r</span> <span class="main">∧</span> <span class="bound">t</span><span class="main">=</span>construct_witness <span class="free">Q</span> <span class="bound">r</span><span class="main">)</span>
           <span class="main">)</span> 
                              <span class="main">)</span> 
     <span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span><span class="main">)</span>

    <span class="quoted"><span class="quoted">"<span class="skolem">Q'</span><span class="main">|`</span>dom <span class="free">Q</span> <span class="main">=</span> <span class="free">Q</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> C<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="skolem">c</span><span class="main">≤</span><span class="main">1</span> <span class="main">∨</span> lhs <span class="free">r</span> <span class="main">∈</span> dom <span class="skolem">Qh</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> SF <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">Q'</span><span class="main">=</span><span class="skolem">Qh</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> INVHF<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> C<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span><span class="main">≤</span><span class="main">1</span>"</span></span> <span class="quoted"><span class="quoted">"lhs <span class="free">r</span><span class="main">∉</span> dom <span class="skolem">Qh</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> SF <span class="keyword1"><span class="command">have</span></span> Q'F<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">Q'</span><span class="main">=</span><span class="skolem">Qh</span><span class="main">(</span>lhs <span class="free">r</span> <span class="main">↦</span> <span class="main">(</span>construct_witness <span class="skolem">Qh</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> C<span class="main">(</span>2<span class="main">)</span> INVHF<span class="main">(</span>2<span class="main">)</span> INV'HF<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> G2<span class="main">:</span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Q'F<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> C<span class="main">(</span>1<span class="main">)</span> INV'HF A <span class="keyword1"><span class="command">have</span></span> 
        RI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">r</span><span class="main">∈</span><span class="var">?dsqr</span> <span class="main">(</span><span class="free">it</span><span class="main">-</span><span class="main">{</span><span class="free">r</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 
        DSS<span class="main">:</span> <span class="quoted"><span class="quoted">"dom <span class="free">Q</span> <span class="main">⊆</span> dom <span class="skolem">Qh</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> br'_rcm_aux'<span class="main">[</span><span class="operator">OF</span> BR'_INV A<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> RI <span class="keyword1"><span class="command">have</span></span> 
        RDQ<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>rhsq <span class="free">r</span><span class="main">)</span> <span class="main">⊆</span> dom <span class="free">Q</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> INVHF<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">Qh</span> <span class="main">|`</span> set <span class="main">(</span>rhsq <span class="free">r</span><span class="main">)</span> <span class="main">=</span> <span class="free">Q</span> <span class="main">|`</span> set <span class="main">(</span>rhsq <span class="free">r</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> restrict_map_subset_eq<span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"construct_witness <span class="skolem">Qh</span> <span class="free">r</span> <span class="main">=</span> construct_witness <span class="free">Q</span> <span class="free">r</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> construct_witness_eq<span class="main">)</span>

      <span class="keyword1"><span class="command">from</span></span> DSS C<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="main">(</span>lhs <span class="free">r</span><span class="main">)</span> <span class="main">=</span> None"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">Qh</span> <span class="main">(</span>lhs <span class="free">r</span><span class="main">)</span> <span class="main">=</span> None"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">have</span></span> G1<span class="main">:</span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> allI impI<span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> prems<span class="main">:</span> <span class="main">(</span>1 <span class="skolem">q</span> <span class="skolem">t</span><span class="main">)</span>
        <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span><span class="main">=</span>lhs <span class="free">r</span>"</span></span>
          <span class="keyword1"><span class="command">from</span></span> prems Q'F <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">t</span> <span class="main">=</span> <span class="main">(</span>construct_witness <span class="skolem">Qh</span> <span class="free">r</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">from</span></span> RI <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span><span class="main">≠</span>lhs <span class="free">r</span>"</span></span>
          <span class="keyword1"><span class="command">with</span></span> Q'F prems <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">Qh</span> <span class="skolem">q</span> <span class="main">=</span> Some <span class="skolem">t</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">with</span></span> INVHF<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">note</span></span> G1 G2
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> brw_inner_invar_def Let_def brw_α_def<span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">lemma</span></span> brw_inner_invar_initial<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">q</span><span class="main">∈</span><span class="free">W</span><span class="main">⟧</span> <span class="main">⟹</span> brw_inner_invar <span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="free">δ</span><span class="main">.</span> <span class="free">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span><span class="main">}</span> <span class="free">q</span> <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">-</span><span class="main">{</span><span class="free">q</span><span class="main">}</span><span class="main">,</span><span class="free">rcm</span><span class="main">)</span> 
                             <span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="free">δ</span><span class="main">.</span> <span class="free">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span><span class="main">}</span> <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">-</span><span class="main">{</span><span class="free">q</span><span class="main">}</span><span class="main">,</span><span class="free">rcm</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brw_inner_invar_def br'_inner_invar_initial brw_α_def<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> brw_inner_step_proof<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">αs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Σ</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> brw_state"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">cstep</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule <span class="main">⇒</span> <span class="tfree">'Σ</span> <span class="main">⇒</span> <span class="tfree">'Σ</span>"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">Σh</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Σ</span>"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">cinvar</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule set <span class="main">⇒</span> <span class="tfree">'Σ</span> <span class="main">⇒</span> bool"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> set_iterate<span class="main">:</span> <span class="quoted"><span class="quoted">"set_iteratei <span class="free">α</span> <span class="free">invar</span> <span class="free">iteratei</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> invar_start<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">αs</span> <span class="free">Σ</span><span class="main">)</span><span class="main">∈</span>brw_invar <span class="free">δ</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> invar_initial<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">cinvar</span> <span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="free">δ</span><span class="main">.</span> <span class="free">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span><span class="main">}</span> <span class="free">Σh</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> invar_step<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">!!</span><span class="bound">it</span> <span class="bound">r</span> <span class="bound">Σ</span><span class="main">.</span> <span class="main">⟦</span> <span class="bound">r</span><span class="main">∈</span><span class="bound">it</span><span class="main">;</span> <span class="bound">it</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="free">δ</span><span class="main">.</span> <span class="free">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span><span class="main">}</span><span class="main">;</span> <span class="free">cinvar</span> <span class="bound">it</span> <span class="bound">Σ</span> <span class="main">⟧</span> 
                <span class="main">⟹</span> <span class="free">cinvar</span> <span class="main">(</span><span class="bound">it</span><span class="main">-</span><span class="main">{</span><span class="bound">r</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="free">cstep</span> <span class="bound">r</span> <span class="bound">Σ</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> step_desc<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">!!</span><span class="bound">it</span> <span class="bound">r</span> <span class="bound">Σ</span><span class="main">.</span> <span class="main">⟦</span> <span class="bound">r</span><span class="main">∈</span><span class="bound">it</span><span class="main">;</span> <span class="bound">it</span><span class="main">⊆</span><span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="free">δ</span><span class="main">.</span> <span class="free">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span><span class="main">}</span><span class="main">;</span> <span class="free">cinvar</span> <span class="bound">it</span> <span class="bound">Σ</span> <span class="main">⟧</span> 
                <span class="main">⟹</span> <span class="main">(</span><span class="free">αs</span> <span class="bound">Σ</span><span class="main">,</span> <span class="free">αs</span> <span class="main">(</span><span class="free">cstep</span> <span class="bound">r</span> <span class="bound">Σ</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> brw_inner_step <span class="bound">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> it_set_desc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free">it_set</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">α</span> <span class="free">it_set</span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="free">δ</span><span class="main">.</span> <span class="free">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span><span class="main">}</span>"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> QIW<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q</span><span class="main">∈</span><span class="free">W</span>"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> Σ_desc<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">αs</span> <span class="free">Σ</span> <span class="main">=</span> <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">,</span><span class="free">rcm</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Σh_desc<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">αs</span> <span class="free">Σh</span> <span class="main">=</span> <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">-</span><span class="main">{</span><span class="free">q</span><span class="main">}</span><span class="main">,</span><span class="free">rcm</span><span class="main">)</span>"</span></span>

  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">αs</span> <span class="free">Σ</span><span class="main">,</span> <span class="free">αs</span> <span class="main">(</span><span class="free">iteratei</span> <span class="free">it_set</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="free">cstep</span> <span class="free">Σh</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>brw_step <span class="free">δ</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> set_iteratei <span class="quoted"><span class="free">α</span></span> <span class="quoted"><span class="free">invar</span></span> <span class="quoted"><span class="free">iteratei</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> 
      I<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">it</span> <span class="bound">Σ</span><span class="main">.</span> <span class="free">cinvar</span> <span class="bound">it</span> <span class="bound">Σ</span> <span class="main">∧</span> brw_inner_invar <span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="free">δ</span><span class="main">.</span> <span class="free">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span><span class="main">}</span> <span class="free">q</span> 
                                                <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">-</span><span class="main">{</span><span class="free">q</span><span class="main">}</span><span class="main">,</span><span class="free">rcm</span><span class="main">)</span> <span class="bound">it</span> <span class="main">(</span><span class="free">αs</span> <span class="bound">Σ</span><span class="main">)</span>"</span></span> 
      <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> iterate_rule_P<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
      <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> it_set_desc invar_initial brw_inner_invar_initial invar_step 
                step_desc brw_inner_invar_step<span class="main"><span class="main">[</span></span><span class="operator">OF</span> invar_start<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">simplified</span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span> 
                brw_inner_invar_imp_final<span class="main"><span class="main">[</span></span><span class="operator">OF</span> QIW<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Product Automaton›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The forward-reduced product automaton can be described as a state-space
  exploration problem. 

  In this section, the DFS-algorithm for state-space exploration 
  (cf. Theory~<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> <a href="../Collections_Examples/Exploration.html"></a><a href="../Collections_Examples/Exploration.html">Collections_Examples.Exploration</a><span class="antiquote"><span class="antiquote">}</span></span></span></span> in the Isabelle Collections Framework) is refined to compute the product automaton.
›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'Q1</span><span class="main">,</span><span class="tfree">'Q2</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> frp_state <span class="main">=</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q1</span><span class="main">×</span><span class="tfree">'Q2</span><span class="main">)</span> set <span class="main">×</span> <span class="main">(</span><span class="tfree">'Q1</span><span class="main">×</span><span class="tfree">'Q2</span><span class="main">)</span> list <span class="main">×</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'Q1</span><span class="main">×</span><span class="tfree">'Q2</span><span class="main">)</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule set"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">frp_α</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q1</span><span class="main">,</span><span class="tfree">'Q2</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> frp_state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q1</span><span class="main">×</span><span class="tfree">'Q2</span><span class="main">)</span> dfs_state"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">frp_α</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">==</span> <span class="keyword1">let</span> <span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">δ</span><span class="main">)</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="keyword1">in</span> <span class="main">(</span><span class="bound">Q</span><span class="main">,</span> <span class="bound">W</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">frp_invar_add</span> <span class="free"><span class="bound"><span class="entity">δ1</span></span></span> <span class="free"><span class="bound"><span class="entity">δ2</span></span></span> <span class="main">==</span> 
  <span class="main">{</span> <span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">δd</span><span class="main">)</span><span class="main">.</span> <span class="bound">δd</span> <span class="main">=</span> <span class="main">{</span> <span class="bound">r</span><span class="main">.</span> <span class="bound">r</span><span class="main">∈</span>δ_prod <span class="free"><span class="bound"><span class="entity">δ1</span></span></span> <span class="free"><span class="bound"><span class="entity">δ2</span></span></span> <span class="main">∧</span> lhs <span class="bound">r</span> <span class="main">∈</span> <span class="bound">Q</span> <span class="main">-</span> set <span class="bound">W</span><span class="main">}</span> <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">frp_invar</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q1</span><span class="main">,</span> <span class="tfree">'L</span><span class="main">)</span> tree_automaton_rec <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q2</span><span class="main">,</span> <span class="tfree">'L</span><span class="main">)</span> tree_automaton_rec 
      <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q1</span><span class="main">,</span><span class="tfree">'Q2</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> frp_state set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">frp_invar</span> <span class="free"><span class="bound"><span class="entity">T1</span></span></span> <span class="free"><span class="bound"><span class="entity">T2</span></span></span> <span class="main">==</span> 
  frp_invar_add <span class="main">(</span>ta_rules <span class="free"><span class="bound"><span class="entity">T1</span></span></span><span class="main">)</span> <span class="main">(</span>ta_rules <span class="free"><span class="bound"><span class="entity">T2</span></span></span><span class="main">)</span> 
  <span class="main">∩</span> <span class="main">{</span> <span class="bound">s</span><span class="main">.</span> frp_α <span class="bound">s</span> <span class="main">∈</span> dfs_invar <span class="main">(</span>ta_initial <span class="free"><span class="bound"><span class="entity">T1</span></span></span> <span class="main">×</span> ta_initial <span class="free"><span class="bound"><span class="entity">T2</span></span></span><span class="main">)</span> 
                              <span class="main">(</span>f_succ <span class="main">(</span>δ_prod <span class="main">(</span>ta_rules <span class="free"><span class="bound"><span class="entity">T1</span></span></span><span class="main">)</span> <span class="main">(</span>ta_rules <span class="free"><span class="bound"><span class="entity">T2</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">inductive_set</span></span> <span class="entity">frp_step</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q1</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q2</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule set 
      <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'Q1</span><span class="main">,</span><span class="tfree">'Q2</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> frp_state <span class="main">×</span> <span class="main">(</span><span class="tfree">'Q1</span><span class="main">,</span><span class="tfree">'Q2</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> frp_state<span class="main">)</span> set"</span></span> 
  <span class="keyword2"><span class="keyword">for</span></span> <span class="entity">δ1</span> <span class="entity">δ2</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free"><span class="bound"><span class="entity">W</span></span></span><span class="main">=</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">q1</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">q2</span></span></span><span class="main">)</span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">Wtl</span></span></span><span class="main">;</span>
     distinct <span class="free"><span class="bound"><span class="entity">Wn</span></span></span><span class="main">;</span>
     set <span class="free"><span class="bound"><span class="entity">Wn</span></span></span> <span class="main">=</span> f_succ <span class="main">(</span>δ_prod <span class="free">δ1</span> <span class="free">δ2</span><span class="main">)</span> <span class="main">``</span> <span class="main">{</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">q1</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">q2</span></span></span><span class="main">)</span><span class="main">}</span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">;</span>
     <span class="free"><span class="bound"><span class="entity">W'</span></span></span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">Wn</span></span></span><span class="main">@</span><span class="free"><span class="bound"><span class="entity">Wtl</span></span></span><span class="main">;</span>
     <span class="free"><span class="bound"><span class="entity">Q'</span></span></span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">∪</span> f_succ <span class="main">(</span>δ_prod <span class="free">δ1</span> <span class="free">δ2</span><span class="main">)</span> <span class="main">``</span> <span class="main">{</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">q1</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">q2</span></span></span><span class="main">)</span><span class="main">}</span><span class="main">;</span>
     <span class="free"><span class="bound"><span class="entity">δd'</span></span></span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">δd</span></span></span> <span class="main">∪</span> <span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span>δ_prod <span class="free">δ1</span> <span class="free">δ2</span><span class="main">.</span> lhs <span class="bound">r</span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">q1</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">q2</span></span></span><span class="main">)</span> <span class="main">}</span>
  <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">W</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">δd</span></span></span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">Q'</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">W'</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">δd'</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">∈</span><span class="free">frp_step</span> <span class="free">δ1</span> <span class="free">δ2</span>"</span></span>

<span class="keyword1"><span class="command">inductive_set</span></span> <span class="entity">frp_initial</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q1</span> set <span class="main">⇒</span> <span class="tfree">'Q2</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q1</span><span class="main">,</span><span class="tfree">'Q2</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> frp_state set"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="entity">Q10</span> <span class="entity">Q20</span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> distinct <span class="free"><span class="bound"><span class="entity">W</span></span></span><span class="main">;</span> set <span class="free"><span class="bound"><span class="entity">W</span></span></span> <span class="main">=</span> <span class="free">Q10</span><span class="main">×</span><span class="free">Q20</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">Q10</span><span class="main">×</span><span class="free">Q20</span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">W</span></span></span><span class="main">,</span><span class="main">{}</span><span class="main">)</span> <span class="main">∈</span> <span class="free">frp_initial</span> <span class="free">Q10</span> <span class="free">Q20</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">frp_cond</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q1</span><span class="main">,</span><span class="tfree">'Q2</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> frp_state set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">frp_cond</span> <span class="main">==</span> <span class="main">{</span><span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">δd</span><span class="main">)</span><span class="main">.</span> <span class="bound">W</span><span class="main">≠</span><span class="main">[]</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">frp_algo</span> <span class="free"><span class="bound"><span class="entity">T1</span></span></span> <span class="free"><span class="bound"><span class="entity">T2</span></span></span> <span class="main">==</span> <span class="main">⦇</span>
  wa_cond <span class="main">=</span> frp_cond<span class="main">,</span>
  wa_step <span class="main">=</span> frp_step <span class="main">(</span>ta_rules <span class="free"><span class="bound"><span class="entity">T1</span></span></span><span class="main">)</span> <span class="main">(</span>ta_rules <span class="free"><span class="bound"><span class="entity">T2</span></span></span><span class="main">)</span><span class="main">,</span>
  wa_initial <span class="main">=</span> frp_initial <span class="main">(</span>ta_initial <span class="free"><span class="bound"><span class="entity">T1</span></span></span><span class="main">)</span> <span class="main">(</span>ta_initial <span class="free"><span class="bound"><span class="entity">T2</span></span></span><span class="main">)</span><span class="main">,</span>
  wa_invar <span class="main">=</span> frp_invar <span class="free"><span class="bound"><span class="entity">T1</span></span></span> <span class="free"><span class="bound"><span class="entity">T2</span></span></span>
<span class="main">⦈</span>"</span></span>

  <span class="comment1">― ‹The algorithm refines the DFS-algorithm›</span>
<span class="keyword1"><span class="command">theorem</span></span> frp_pref_dfs<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"wa_precise_refine <span class="main">(</span>frp_algo <span class="free">T1</span> <span class="free">T2</span><span class="main">)</span> 
     <span class="main">(</span>dfs_algo <span class="main">(</span>ta_initial <span class="free">T1</span> <span class="main">×</span> ta_initial <span class="free">T2</span><span class="main">)</span> 
               <span class="main">(</span>f_succ <span class="main">(</span>δ_prod <span class="main">(</span>ta_rules <span class="free">T1</span><span class="main">)</span> <span class="main">(</span>ta_rules <span class="free">T2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
     frp_α"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> frp_algo_def frp_α_def frp_cond_def dfs_algo_def 
                        dfs_cond_def frp_invar_def
    <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> frp_step.cases frp_initial.cases
    <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> dfs_step.intros dfs_initial.intros
  <span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span> 

<span class="keyword1"><span class="command">interpretation</span></span> frp_ref<span class="main">:</span> wa_precise_refine <span class="quoted"><span class="quoted">"<span class="main">(</span>frp_algo <span class="free">T1</span> <span class="free">T2</span><span class="main">)</span>"</span></span>
                  <span class="quoted"><span class="quoted">"<span class="main">(</span>dfs_algo <span class="main">(</span>ta_initial <span class="free">T1</span> <span class="main">×</span> ta_initial <span class="free">T2</span><span class="main">)</span> 
                             <span class="main">(</span>f_succ <span class="main">(</span>δ_prod <span class="main">(</span>ta_rules <span class="free">T1</span><span class="main">)</span> <span class="main">(</span>ta_rules <span class="free">T2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
                  <span class="quoted"><span class="quoted">"frp_α"</span></span> <span class="keyword1"><span class="command">using</span></span> frp_pref_dfs <span class="keyword1"><span class="command">.</span></span>

<span class="comment1">― ‹The algorithm is a well-defined while-algorithm›</span>
<span class="keyword1"><span class="command">theorem</span></span> frp_while_algo<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> TA<span class="main">:</span> <span class="quoted"><span class="quoted">"tree_automaton <span class="free">T1</span>"</span></span> 
              <span class="quoted"><span class="quoted">"tree_automaton <span class="free">T2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"while_algo <span class="main">(</span>frp_algo <span class="free">T1</span> <span class="free">T2</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> t1<span class="main">:</span> tree_automaton <span class="quoted"><span class="free">T1</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword1"><span class="command">interpret</span></span> t2<span class="main">:</span> tree_automaton <span class="quoted"><span class="free">T2</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>

  <span class="keyword1"><span class="command">have</span></span> finite<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">(</span>f_succ <span class="main">(</span>δ_prod <span class="main">(</span>ta_rules <span class="free">T1</span><span class="main">)</span> <span class="main">(</span>ta_rules <span class="free">T2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> 
               <span class="main">``</span> <span class="main">(</span>ta_initial <span class="free">T1</span> <span class="main">×</span> ta_initial <span class="free">T2</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>f_succ <span class="main">(</span>δ_prod <span class="main">(</span>ta_rules <span class="free">T1</span><span class="main">)</span> <span class="main">(</span>ta_rules <span class="free">T2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> 
               <span class="main">``</span> <span class="main">(</span>ta_initial <span class="free">T1</span> <span class="main">×</span> ta_initial <span class="free">T2</span><span class="main">)</span><span class="main">)</span> 
          <span class="main">⊆</span> <span class="main">(</span><span class="main">(</span>ta_initial <span class="free">T1</span> <span class="main">×</span> ta_initial <span class="free">T2</span><span class="main">)</span> 
             <span class="main">∪</span> δ_states <span class="main">(</span>δ_prod <span class="main">(</span>ta_rules <span class="free">T1</span><span class="main">)</span> <span class="main">(</span>ta_rules <span class="free">T2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> f_accessible_subset<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> f_accessible_def<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">…</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_subset<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> frp_ref.wa_intro<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> dfs_while_algo<span class="main"><span class="main">[</span></span><span class="operator">OF</span> finite<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> frp_algo_def dfs_algo_def frp_invar_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dfs_algo_def frp_algo_def frp_α_def 
                          dfs_α_def frp_invar_add_def dfs_invar_def 
                          dfs_invar_add_def sse_invar_def 
                <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> frp_step.cases<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> frp_algo_def frp_invar_add_def 
                 <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> frp_initial.cases<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(* unused
lemma f_succ_adv: 
  "⟦lhs r ∈ (f_succ δ)<span class="hidden">⇧</span><sup>*</sup> `` Q0; r∈δ⟧ ⟹ set (rhsq r) ⊆ (f_succ δ)<span class="hidden">⇧</span><sup>*</sup> `` Q0"
  by (case_tac r) (auto dest: rtrancl_into_rtrancl intro: f_succ.intros)
*)</span>

<span class="comment1">― ‹If the algorithm terminates, the forward reduced product automaton 
    can be constructed from the result›</span>
<span class="keyword1"><span class="command">theorem</span></span> frp_inv_final<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">s</span><span class="main">.</span> <span class="bound">s</span><span class="main">∈</span>wa_invar <span class="main">(</span>frp_algo <span class="free">T1</span> <span class="free">T2</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">s</span><span class="main">∉</span>wa_cond <span class="main">(</span>frp_algo <span class="free">T1</span> <span class="free">T2</span><span class="main">)</span>
       <span class="main">⟶</span> <span class="main">(</span><span class="keyword1">case</span> <span class="bound">s</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">δd</span><span class="main">)</span> <span class="main">⇒</span> 
             <span class="main">⦇</span> ta_initial <span class="main">=</span> ta_initial <span class="free">T1</span> <span class="main">×</span> ta_initial <span class="free">T2</span><span class="main">,</span> 
               ta_rules <span class="main">=</span> <span class="bound">δd</span> 
             <span class="main">⦈</span> <span class="main">=</span> ta_fwd_reduce <span class="main">(</span>ta_prod <span class="free">T1</span> <span class="free">T2</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI impI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">s</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ta_reduce_def ta_prod_def frp_algo_def<span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">Q</span> <span class="skolem">W</span> <span class="skolem">δd</span>
  <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">Q</span><span class="main">,</span><span class="skolem">W</span><span class="main">,</span><span class="skolem">δd</span><span class="main">)</span><span class="main">∈</span>frp_invar <span class="free">T1</span> <span class="free">T2</span> <span class="main">∧</span> <span class="main">(</span><span class="skolem">Q</span><span class="main">,</span><span class="skolem">W</span><span class="main">,</span><span class="skolem">δd</span><span class="main">)</span><span class="main">∉</span>frp_cond"</span></span>

  <span class="keyword1"><span class="command">from</span></span> frp_ref.transfer_correctness<span class="main">[</span><span class="operator">OF</span> dfs_invar_final<span class="main">,</span> 
                                    <span class="operator">unfolded</span> frp_algo_def<span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> 
                                    <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">OF</span> A<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">Q</span> <span class="main">=</span> f_accessible <span class="main">(</span>δ_prod <span class="main">(</span>ta_rules <span class="free">T1</span><span class="main">)</span> <span class="main">(</span>ta_rules <span class="free">T2</span><span class="main">)</span><span class="main">)</span> 
                                 <span class="main">(</span>ta_initial <span class="free">T1</span> <span class="main">×</span> ta_initial <span class="free">T2</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> f_accessible_def dfs_α_def frp_α_def<span class="main">)</span>

  <span class="keyword1"><span class="command">from</span></span> A <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">δd</span> <span class="main">=</span> reduce_rules 
    <span class="main">(</span>δ_prod <span class="main">(</span>ta_rules <span class="free">T1</span><span class="main">)</span> <span class="main">(</span>ta_rules <span class="free">T2</span><span class="main">)</span><span class="main">)</span> 
    <span class="main">(</span>f_accessible <span class="main">(</span>δ_prod <span class="main">(</span>ta_rules <span class="free">T1</span><span class="main">)</span> <span class="main">(</span>ta_rules <span class="free">T2</span><span class="main">)</span><span class="main">)</span> 
                  <span class="main">(</span>ta_initial <span class="free">T1</span> <span class="main">×</span> ta_initial <span class="free">T2</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> reduce_rules_def f_accessible_def frp_invar_def 
                          frp_invar_add_def frp_α_def frp_cond_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> rtrancl_into_rtrancl <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> f_succ.intros<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Ta_impl">
<div class="head">
<h1>Theory Ta_impl</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Tree Automata
    Author:      Peter Lammich &lt;peter dot lammich at uni-muenster.de&gt;
    Maintainer:  Peter Lammich &lt;peter dot lammich at uni-muenster.de&gt;
*)</span>
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Executable Implementation of Tree Automata"</span></span>
<span class="keyword1"><span class="command">theory</span></span> Ta_impl
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="../../HOL/HOL/Main.html">Main</a>
  <a href="../Collections/CollectionsV1.html">Collections.CollectionsV1</a> 
  <a href="Ta.html">Ta</a> <a href="AbsAlgo.html">AbsAlgo</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Code_Target_Numeral.html">HOL-Library.Code_Target_Numeral</a>"</span> 
<span class="keyword2"><span class="keyword">begin</span></span>




<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:taimpl}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  In this theory, an effcient executable implementation of non-deterministic 
  tree automata and basic algorithms is defined.

  The algorithms use red-black trees to represent sets of states or rules 
  where appropriate.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Prelude"</span></span>

  <span class="comment1">― ‹Make rules hashable›</span>
<span class="keyword1"><span class="command">instantiation</span></span> ta_rule <span class="main">::</span> <span class="main">(</span><span class="quoted">hashable</span><span class="main">,</span><span class="quoted">hashable</span><span class="main">)</span> <span class="quoted">hashable</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">hashcode_of_ta_rule</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q1</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'Q2</span><span class="main">::</span>hashable<span class="main">)</span> ta_rule <span class="main">⇒</span> hashcode"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">hashcode_of_ta_rule</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">→</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">qs</span></span></span><span class="main">)</span> <span class="main">=</span> hashcode <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">+</span> hashcode <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">+</span> hashcode <span class="free"><span class="bound"><span class="entity">qs</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hashcode <span class="main">=</span> hashcode_of_ta_rule"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"def_hashmap_size<span class="main">::</span><span class="main">(</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> ta_rule itself <span class="main">⇒</span> nat<span class="main">)</span> <span class="main">==</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="numeral">32</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> def_hashmap_size_ta_rule_def<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>


  <span class="comment1">― ‹Make wrapped states hashable›</span>
<span class="keyword1"><span class="command">instantiation</span></span> ustate_wrapper <span class="main">::</span> <span class="main">(</span><span class="quoted">hashable</span><span class="main">,</span><span class="quoted">hashable</span><span class="main">)</span> <span class="quoted">hashable</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"hashcode <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">==</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">of</span> USW1 <span class="bound">a</span> <span class="main">⇒</span> <span class="numeral">2</span> <span class="main">*</span> hashcode <span class="bound">a</span> <span class="main">|</span> USW2 <span class="bound">b</span> <span class="main">⇒</span> <span class="numeral">2</span> <span class="main">*</span> hashcode <span class="bound">b</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"def_hashmap_size <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main">::</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> ustate_wrapper<span class="main">)</span> itself<span class="main">.</span> def_hashmap_size <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">+</span> def_hashmap_size <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">using</span></span> def_hashmap_size<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tvar">?'a</span><span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span>"</span></span><span class="main">]</span> def_hashmap_size<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tvar">?'a</span><span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="tfree">'b</span>"</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bounded_hashcode_bounds def_hashmap_size_ustate_wrapper_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> ustate_wrapper.split<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Ad-Hoc instantiations of generic Algorithms›</span></span>
<span class="keyword1"><span class="command">setup</span></span> <span class="entity">Locale_Code.open_block</span>
<span class="keyword1"><span class="command">interpretation</span></span> hll_idx<span class="main">:</span> build_index_loc <span class="quoted">hm_ops</span> <span class="quoted">ls_ops</span> <span class="quoted">ls_ops</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
<span class="keyword1"><span class="command">interpretation</span></span> ll_set_xy<span class="main">:</span> g_set_xy_loc <span class="quoted">ls_ops</span> <span class="quoted">ls_ops</span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

<span class="keyword1"><span class="command">interpretation</span></span> lh_set_xx<span class="main">:</span> g_set_xx_loc <span class="quoted">ls_ops</span> <span class="quoted">hs_ops</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
<span class="keyword1"><span class="command">interpretation</span></span> lll_iflt_cp<span class="main">:</span> inj_image_filter_cp_loc <span class="quoted">ls_ops</span> <span class="quoted">ls_ops</span> <span class="quoted">ls_ops</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
<span class="keyword1"><span class="command">interpretation</span></span> hhh_cart<span class="main">:</span> cart_loc <span class="quoted">hs_ops</span> <span class="quoted">hs_ops</span> <span class="quoted">hs_ops</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
<span class="keyword1"><span class="command">interpretation</span></span> hh_set_xy<span class="main">:</span> g_set_xy_loc <span class="quoted">hs_ops</span> <span class="quoted">hs_ops</span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

<span class="keyword1"><span class="command">interpretation</span></span> llh_set_xyy<span class="main">:</span> g_set_xyy_loc <span class="quoted">ls_ops</span> <span class="quoted">ls_ops</span> <span class="quoted">hs_ops</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

<span class="keyword1"><span class="command">interpretation</span></span> hh_map_to_nat<span class="main">:</span> map_to_nat_loc <span class="quoted">hs_ops</span> <span class="quoted">hm_ops</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
<span class="keyword1"><span class="command">interpretation</span></span> hh_set_xy<span class="main">:</span> g_set_xy_loc <span class="quoted">hs_ops</span> <span class="quoted">hs_ops</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
<span class="keyword1"><span class="command">interpretation</span></span> lh_set_xy<span class="main">:</span> g_set_xy_loc <span class="quoted">ls_ops</span> <span class="quoted">hs_ops</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
<span class="keyword1"><span class="command">interpretation</span></span> hh_set_xx<span class="main">:</span> g_set_xx_loc <span class="quoted">hs_ops</span> <span class="quoted">hs_ops</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
<span class="keyword1"><span class="command">interpretation</span></span> hs_to_fifo<span class="main">:</span> set_to_list_loc <span class="quoted">hs_ops</span> <span class="quoted">fifo_ops</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

<span class="keyword1"><span class="command">setup</span></span> <span class="entity">Locale_Code.close_block</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Generating Indices of Rules"</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Rule indices are pieces of extra information that may be attached to a 
  tree automaton.
  There are three possible rule indices
    \begin{description}
      \item[f]   index of rules by function symbol
      \item[s]   index of rules by lhs
      \item[sf]  index of rules
    \end{description}
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">build_rule_index</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'q</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> ta_rule <span class="main">⇒</span> <span class="tfree">'i</span><span class="main">::</span>hashable<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'q</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> ta_rule ls 
      <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'i</span><span class="main">,</span><span class="main">(</span><span class="tfree">'q</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> ta_rule ls<span class="main">)</span> hm"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">build_rule_index</span> <span class="main">==</span> hll_idx.idx_build"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">build_rule_index_f</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">==</span> build_rule_index <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> rhsl <span class="bound">r</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">build_rule_index_s</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">==</span> build_rule_index <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> lhs <span class="bound">r</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">build_rule_index_sf</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">==</span> build_rule_index <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="main">(</span>lhs <span class="bound">r</span><span class="main">,</span> rhsl <span class="bound">r</span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> build_rule_index_f_correct<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> I<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ls_invar <span class="free">δ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"hll_idx.is_index rhsl <span class="main">(</span>ls_α <span class="free">δ</span><span class="main">)</span> <span class="main">(</span>build_rule_index_f <span class="free">δ</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> build_rule_index_f_def build_rule_index_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hll_idx.idx_build_is_index<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> build_rule_index_s_correct<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> I<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ls_invar <span class="free">δ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"hll_idx.is_index lhs <span class="main">(</span>ls_α <span class="free">δ</span><span class="main">)</span> <span class="main">(</span>build_rule_index_s <span class="free">δ</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> build_rule_index_s_def build_rule_index_def<span class="main">)</span>
     <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hll_idx.idx_build_is_index<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> build_rule_index_sf_correct<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> I<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ls_invar <span class="free">δ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"hll_idx.is_index <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="main">(</span>lhs <span class="bound">r</span><span class="main">,</span> rhsl <span class="bound">r</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>ls_α <span class="free">δ</span><span class="main">)</span> <span class="main">(</span>build_rule_index_sf <span class="free">δ</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> build_rule_index_sf_def build_rule_index_def<span class="main">)</span>
     <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hll_idx.idx_build_is_index<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Tree Automaton with Optional Indices"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  A tree automaton contains a hashset of initial states, a list-set of rules and
  several (optional) rule indices.
›</span></span>

<span class="keyword1"><span class="command">record</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">overloaded</span></span><span class="main">)</span> <span class="main">(</span><span class="tfree">'q</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> hashedTa <span class="main">=</span>
    <span class="comment1">― ‹Initial states›</span>
  hta_Qi <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'q</span> hs"</span></span>           
    <span class="comment1">― ‹Rules›</span>
  hta_δ <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'q</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> ta_rule ls"</span></span>    
    <span class="comment1">― ‹Rules by function symbol›</span>
  hta_idx_f <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'l</span><span class="main">,</span><span class="main">(</span><span class="tfree">'q</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> ta_rule ls<span class="main">)</span> hm option"</span></span> 
    <span class="comment1">― ‹Rules by lhs state›</span>
  hta_idx_s <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'q</span><span class="main">,</span><span class="main">(</span><span class="tfree">'q</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> ta_rule ls<span class="main">)</span> hm option"</span></span> 
    <span class="comment1">― ‹Rules by lhs state and function symbol›</span>
  hta_idx_sf <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'q</span><span class="main">×</span><span class="tfree">'l</span><span class="main">,</span><span class="main">(</span><span class="tfree">'q</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> ta_rule ls<span class="main">)</span> hm option"</span></span> 

  <span class="comment1">― ‹Abstraction of a concrete tree automaton to an abstract one›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">hta_α</span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">hta_α</span> <span class="free"><span class="bound"><span class="entity">H</span></span></span> <span class="main">=</span> <span class="main">⦇</span> ta_initial <span class="main">=</span> hs_α <span class="main">(</span>hta_Qi <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">)</span><span class="main">,</span> ta_rules <span class="main">=</span> ls_α <span class="main">(</span>hta_δ <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">)</span> <span class="main">⦈</span>"</span></span>

  <span class="comment1">― ‹Builds the f-index if not present›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hta_ensure_idx_f</span> <span class="free"><span class="bound"><span class="entity">H</span></span></span> <span class="main">==</span>
  <span class="keyword1">case</span> hta_idx_f <span class="free"><span class="bound"><span class="entity">H</span></span></span> <span class="keyword1">of</span> 
    None <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">⦇</span> hta_idx_f <span class="main">:=</span> Some <span class="main">(</span>build_rule_index_f <span class="main">(</span>hta_δ <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">⦈</span> <span class="main">|</span>
    Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">H</span></span></span>
  "</span></span>

  <span class="comment1">― ‹Builds the s-index if not present›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hta_ensure_idx_s</span> <span class="free"><span class="bound"><span class="entity">H</span></span></span> <span class="main">==</span>
  <span class="keyword1">case</span> hta_idx_s <span class="free"><span class="bound"><span class="entity">H</span></span></span> <span class="keyword1">of</span> 
    None <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">⦇</span> hta_idx_s <span class="main">:=</span> Some <span class="main">(</span>build_rule_index_s <span class="main">(</span>hta_δ <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">⦈</span> <span class="main">|</span>
    Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">H</span></span></span>
  "</span></span>

  <span class="comment1">― ‹Builds the sf-index if not present›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hta_ensure_idx_sf</span> <span class="free"><span class="bound"><span class="entity">H</span></span></span> <span class="main">==</span>
  <span class="keyword1">case</span> hta_idx_sf <span class="free"><span class="bound"><span class="entity">H</span></span></span> <span class="keyword1">of</span> 
    None <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">⦇</span> hta_idx_sf <span class="main">:=</span> Some <span class="main">(</span>build_rule_index_sf <span class="main">(</span>hta_δ <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">⦈</span> <span class="main">|</span>
    Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">H</span></span></span>
  "</span></span>

<span class="keyword1"><span class="command">lemma</span></span> hta_ensure_idx_f_correct_α<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"hta_α <span class="main">(</span>hta_ensure_idx_f <span class="free">H</span><span class="main">)</span> <span class="main">=</span> hta_α <span class="free">H</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hta_ensure_idx_f_def hta_α_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> hta_ensure_idx_s_correct_α<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"hta_α <span class="main">(</span>hta_ensure_idx_s <span class="free">H</span><span class="main">)</span> <span class="main">=</span> hta_α <span class="free">H</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hta_ensure_idx_s_def hta_α_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> hta_ensure_idx_sf_correct_α<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"hta_α <span class="main">(</span>hta_ensure_idx_sf <span class="free">H</span><span class="main">)</span> <span class="main">=</span> hta_α <span class="free">H</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hta_ensure_idx_sf_def hta_α_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> hta_ensure_idx_other<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"hta_Qi <span class="main">(</span>hta_ensure_idx_f <span class="free">H</span><span class="main">)</span> <span class="main">=</span> hta_Qi <span class="free">H</span>"</span></span>  
  <span class="quoted"><span class="quoted">"hta_δ <span class="main">(</span>hta_ensure_idx_f <span class="free">H</span><span class="main">)</span> <span class="main">=</span> hta_δ <span class="free">H</span>"</span></span>
  
  <span class="quoted"><span class="quoted">"hta_Qi <span class="main">(</span>hta_ensure_idx_s <span class="free">H</span><span class="main">)</span> <span class="main">=</span> hta_Qi <span class="free">H</span>"</span></span>  
  <span class="quoted"><span class="quoted">"hta_δ <span class="main">(</span>hta_ensure_idx_s <span class="free">H</span><span class="main">)</span> <span class="main">=</span> hta_δ <span class="free">H</span>"</span></span>
  
  <span class="quoted"><span class="quoted">"hta_Qi <span class="main">(</span>hta_ensure_idx_sf <span class="free">H</span><span class="main">)</span> <span class="main">=</span> hta_Qi <span class="free">H</span>"</span></span> 
  <span class="quoted"><span class="quoted">"hta_δ <span class="main">(</span>hta_ensure_idx_sf <span class="free">H</span><span class="main">)</span> <span class="main">=</span> hta_δ <span class="free">H</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
    <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hta_ensure_idx_f_def hta_ensure_idx_s_def hta_ensure_idx_sf_def 
    <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

  <span class="comment1">― ‹Check whether the f-index is present›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hta_has_idx_f</span> <span class="free"><span class="bound"><span class="entity">H</span></span></span> <span class="main">==</span> hta_idx_f <span class="free"><span class="bound"><span class="entity">H</span></span></span> <span class="main">≠</span> None"</span></span>
  <span class="comment1">― ‹Check whether the s-index is present›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hta_has_idx_s</span> <span class="free"><span class="bound"><span class="entity">H</span></span></span> <span class="main">==</span> hta_idx_s <span class="free"><span class="bound"><span class="entity">H</span></span></span> <span class="main">≠</span> None"</span></span>
  <span class="comment1">― ‹Check whether the sf-index is present›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hta_has_idx_sf</span> <span class="free"><span class="bound"><span class="entity">H</span></span></span> <span class="main">==</span> hta_idx_sf <span class="free"><span class="bound"><span class="entity">H</span></span></span> <span class="main">≠</span> None"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> hta_idx_f_pres
  <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hta_has_idx_f <span class="main">(</span>hta_ensure_idx_f <span class="free">H</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hta_has_idx_s <span class="free">H</span> <span class="main">⟹</span> hta_has_idx_s <span class="main">(</span>hta_ensure_idx_f <span class="free">H</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hta_has_idx_sf <span class="free">H</span> <span class="main">⟹</span> hta_has_idx_sf <span class="main">(</span>hta_ensure_idx_f <span class="free">H</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> 
    <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hta_has_idx_f_def hta_has_idx_s_def hta_has_idx_sf_def 
         hta_ensure_idx_f_def 
    <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> hta_idx_s_pres
  <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hta_has_idx_s <span class="main">(</span>hta_ensure_idx_s <span class="free">H</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hta_has_idx_f <span class="free">H</span> <span class="main">⟹</span> hta_has_idx_f <span class="main">(</span>hta_ensure_idx_s <span class="free">H</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hta_has_idx_sf <span class="free">H</span> <span class="main">⟹</span> hta_has_idx_sf <span class="main">(</span>hta_ensure_idx_s <span class="free">H</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> 
    <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hta_has_idx_f_def hta_has_idx_s_def hta_has_idx_sf_def 
         hta_ensure_idx_s_def 
    <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> hta_idx_sf_pres
  <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hta_has_idx_sf <span class="main">(</span>hta_ensure_idx_sf <span class="free">H</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hta_has_idx_f <span class="free">H</span> <span class="main">⟹</span> hta_has_idx_f <span class="main">(</span>hta_ensure_idx_sf <span class="free">H</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hta_has_idx_s <span class="free">H</span> <span class="main">⟹</span> hta_has_idx_s <span class="main">(</span>hta_ensure_idx_sf <span class="free">H</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> 
    <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hta_has_idx_f_def hta_has_idx_s_def hta_has_idx_sf_def 
         hta_ensure_idx_sf_def 
    <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The lookup functions are only defined if the required index is present. 
  This enforces generation of the index before applying lookup functions.
›</span></span>
  <span class="comment1">― ‹Lookup rules by function symbol›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hta_lookup_f</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">H</span></span></span> <span class="main">==</span> hll_idx.lookup <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>the <span class="main">(</span>hta_idx_f <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="comment1">― ‹Lookup rules by lhs-state›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hta_lookup_s</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="free"><span class="bound"><span class="entity">H</span></span></span> <span class="main">==</span> hll_idx.lookup <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">(</span>the <span class="main">(</span>hta_idx_s <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="comment1">― ‹Lookup rules by function symbol and lhs-state›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hta_lookup_sf</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">H</span></span></span> <span class="main">==</span> hll_idx.lookup <span class="main">(</span><span class="free"><span class="bound"><span class="entity">q</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span> <span class="main">(</span>the <span class="main">(</span>hta_idx_sf <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>


  <span class="comment1">― ‹This locale defines the invariants of a tree automaton›</span>
<span class="keyword1"><span class="command">locale</span></span> hashedTa <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">H</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'L</span><span class="main">::</span>hashable<span class="main">)</span> hashedTa"</span></span>

  <span class="comment1">― ‹The involved sets satisfy their invariants›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> invar<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"hs_invar <span class="main">(</span>hta_Qi <span class="free">H</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"ls_invar <span class="main">(</span>hta_δ <span class="free">H</span><span class="main">)</span>"</span></span>

  <span class="comment1">― ‹The indices are correct, if present›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> index_correct<span class="main">:</span>
    <span class="quoted"><span class="quoted">"hta_idx_f <span class="free">H</span> <span class="main">=</span> Some <span class="free">idx_f</span> 
      <span class="main">⟹</span> hll_idx.is_index rhsl <span class="main">(</span>ls_α <span class="main">(</span>hta_δ <span class="free">H</span><span class="main">)</span><span class="main">)</span> <span class="free">idx_f</span>"</span></span>
    <span class="quoted"><span class="quoted">"hta_idx_s <span class="free">H</span> <span class="main">=</span> Some <span class="free">idx_s</span> 
      <span class="main">⟹</span> hll_idx.is_index lhs <span class="main">(</span>ls_α <span class="main">(</span>hta_δ <span class="free">H</span><span class="main">)</span><span class="main">)</span> <span class="free">idx_s</span>"</span></span>
    <span class="quoted"><span class="quoted">"hta_idx_sf <span class="free">H</span> <span class="main">=</span> Some <span class="free">idx_sf</span> 
      <span class="main">⟹</span> hll_idx.is_index <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="main">(</span>lhs <span class="bound">r</span><span class="main">,</span> rhsl <span class="bound">r</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>ls_α <span class="main">(</span>hta_δ <span class="free">H</span><span class="main">)</span><span class="main">)</span> <span class="free">idx_sf</span>"</span></span>

<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="comment1">― ‹Inside this locale, some shorthand notations for the sets of 
      rules and initial states are used›</span>
  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">δ</span> <span class="main">==</span> hta_δ <span class="free">H</span>"</span></span>
  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">Qi</span> <span class="main">==</span> hta_Qi <span class="free">H</span>"</span></span>

  <span class="comment1">― ‹The lookup-xxx operations are correct›</span>
  <span class="keyword1"><span class="command">lemma</span></span> hta_lookup_f_correct<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"hta_has_idx_f <span class="free">H</span> <span class="main">⟹</span> ls_α <span class="main">(</span>hta_lookup_f <span class="free">f</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span>ls_α δ <span class="main">.</span> rhsl <span class="bound">r</span> <span class="main">=</span> <span class="free">f</span><span class="main">}</span>"</span></span>
    <span class="quoted"><span class="quoted">"hta_has_idx_f <span class="free">H</span> <span class="main">⟹</span> ls_invar <span class="main">(</span>hta_lookup_f <span class="free">f</span> <span class="free">H</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"hta_has_idx_f <span class="free">H</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> hta_has_idx_f_def hta_lookup_f_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
      <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hll_idx.lookup_correct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> index_correct<span class="main"><span class="main"><span class="main"><span class="main">(</span></span></span></span>1<span class="main"><span class="main"><span class="main"><span class="main">)</span></span></span></span><span class="main"><span class="main">]</span></span> 
                index_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">lemma</span></span> hta_lookup_s_correct<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"hta_has_idx_s <span class="free">H</span> <span class="main">⟹</span> ls_α <span class="main">(</span>hta_lookup_s <span class="free">q</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span>ls_α δ <span class="main">.</span> lhs <span class="bound">r</span> <span class="main">=</span> <span class="free">q</span><span class="main">}</span>"</span></span>
    <span class="quoted"><span class="quoted">"hta_has_idx_s <span class="free">H</span> <span class="main">⟹</span> ls_invar <span class="main">(</span>hta_lookup_s <span class="free">q</span> <span class="free">H</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"hta_has_idx_s <span class="free">H</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> hta_has_idx_s_def hta_lookup_s_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
      <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hll_idx.lookup_correct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> index_correct<span class="main"><span class="main"><span class="main"><span class="main">(</span></span></span></span>2<span class="main"><span class="main"><span class="main"><span class="main">)</span></span></span></span><span class="main"><span class="main">]</span></span> 
                index_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">lemma</span></span> hta_lookup_sf_correct<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"hta_has_idx_sf <span class="free">H</span> 
      <span class="main">⟹</span> ls_α <span class="main">(</span>hta_lookup_sf <span class="free">q</span> <span class="free">f</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span>ls_α δ <span class="main">.</span> lhs <span class="bound">r</span> <span class="main">=</span> <span class="free">q</span> <span class="main">∧</span> rhsl <span class="bound">r</span> <span class="main">=</span> <span class="free">f</span><span class="main">}</span>"</span></span>
    <span class="quoted"><span class="quoted">"hta_has_idx_sf <span class="free">H</span> <span class="main">⟹</span> ls_invar <span class="main">(</span>hta_lookup_sf <span class="free">q</span> <span class="free">f</span> <span class="free">H</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"hta_has_idx_sf <span class="free">H</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> hta_has_idx_sf_def hta_lookup_sf_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
      <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hll_idx.lookup_correct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> index_correct<span class="main"><span class="main"><span class="main"><span class="main">(</span></span></span></span>3<span class="main"><span class="main"><span class="main"><span class="main">)</span></span></span></span><span class="main"><span class="main">]</span></span> 
                index_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="comment1">― ‹The ensure-index operations preserve the invariants›</span>
  <span class="keyword1"><span class="command">lemma</span></span> hta_ensure_idx_f_correct<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hashedTa <span class="main">(</span>hta_ensure_idx_f <span class="free">H</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
      <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hta_ensure_idx_f_def hta_ensure_idx_s_def hta_ensure_idx_sf_def 
               index_correct 
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">lemma</span></span> hta_ensure_idx_s_correct<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hashedTa <span class="main">(</span>hta_ensure_idx_s <span class="free">H</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
      <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hta_ensure_idx_f_def hta_ensure_idx_s_def hta_ensure_idx_sf_def 
                index_correct 
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">lemma</span></span> hta_ensure_idx_sf_correct<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hashedTa <span class="main">(</span>hta_ensure_idx_sf <span class="free">H</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
      <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hta_ensure_idx_f_def hta_ensure_idx_s_def hta_ensure_idx_sf_def 
                index_correct 
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The abstract tree automaton satisfies the invariants for an abstract
          tree automaton›</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> hta_α_is_ta<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"tree_automaton <span class="main">(</span>hta_α <span class="free">H</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> hta_α_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">― ‹Add some lemmas to simpset -- also outside the locale›</span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span> <span class="main">=</span> 
  hashedTa.hta_ensure_idx_f_correct
  hashedTa.hta_ensure_idx_s_correct
  hashedTa.hta_ensure_idx_sf_correct

  <span class="comment1">― ‹Build a tree automaton from a set of initial states and a set of rules›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">init_hta</span> <span class="free"><span class="bound"><span class="entity">Qi</span></span></span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">==</span> 
  <span class="main">⦇</span> hta_Qi<span class="main">=</span> <span class="free"><span class="bound"><span class="entity">Qi</span></span></span><span class="main">,</span> 
    hta_δ <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span><span class="main">,</span> 
    hta_idx_f <span class="main">=</span> None<span class="main">,</span> 
    hta_idx_s <span class="main">=</span> None<span class="main">,</span> 
    hta_idx_sf <span class="main">=</span> None 
  <span class="main">⦈</span>"</span></span>

  <span class="comment1">― ‹Building a tree automaton from a valid tree automaton yields again a 
      valid tree automaton. This operation has the only effect of removing 
      the indices.›</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> hashedTa<span class="main">)</span> init_hta_is_hta<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"hashedTa <span class="main">(</span>init_hta <span class="main">(</span>hta_Qi <span class="free">H</span><span class="main">)</span> <span class="main">(</span>hta_δ <span class="free">H</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> init_hta_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Algorithm for the Word Problem"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> r_match_by_laz<span class="main">:</span> <span class="quoted"><span class="quoted">"r_match <span class="free">L</span> <span class="free">l</span> <span class="main">=</span> list_all_zip <span class="main">(</span><span class="main">λ</span><span class="bound">Q</span> <span class="bound">q</span><span class="main">.</span> <span class="bound">q</span><span class="main">∈</span><span class="bound">Q</span><span class="main">)</span> <span class="free">L</span> <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> r_match_alt list_all_zip_alt<span class="main">)</span>
      <span class="operator">auto</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">"Executable function that computes the set of accepting states for 
    a given tree"</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">faccs'</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">faccs'</span> <span class="free"><span class="bound"><span class="entity">H</span></span></span> <span class="main">(</span>NODE <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
    <span class="keyword1">let</span> <span class="bound">Qs</span> <span class="main">=</span> List.map <span class="main">(</span><span class="free">faccs'</span> <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span> <span class="keyword1">in</span>
      ll_set_xy.g_image_filter <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">r</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">q</span> <span class="main">→</span> <span class="bound">f'</span> <span class="bound">qs</span><span class="main">)</span> <span class="main">⇒</span> 
           <span class="keyword1">if</span> list_all_zip <span class="main">(</span><span class="main">λ</span><span class="bound">Q</span> <span class="bound">q</span><span class="main">.</span> ls_memb <span class="bound">q</span> <span class="bound">Q</span><span class="main">)</span> <span class="bound">Qs</span> <span class="bound">qs</span> <span class="keyword1">then</span> Some <span class="main">(</span>lhs <span class="bound">r</span><span class="main">)</span> <span class="keyword1">else</span> None
                          <span class="main">)</span> 
                      <span class="main">(</span>hta_lookup_f <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">)</span>
  <span class="main">)</span>"</span></span>

  <span class="comment1">― ‹Executable algorithm to decide the word-problem. The first version 
      depends on the f-index to be present, the second version computes the 
      index if not present.›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hta_mem'</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">H</span></span></span> <span class="main">==</span> <span class="main">¬</span>lh_set_xx.g_disjoint <span class="main">(</span>faccs' <span class="free"><span class="bound"><span class="entity">H</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span> <span class="main">(</span>hta_Qi <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hta_mem</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">H</span></span></span> <span class="main">==</span> hta_mem' <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">(</span>hta_ensure_idx_f <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">context</span></span> hashedTa
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> faccs'_invar<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> HI<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hta_has_idx_f <span class="free">H</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ls_invar <span class="main">(</span>faccs' <span class="free">H</span> <span class="free">t</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T1</span></span></span><span class="main">)</span> 
          <span class="quoted"><span class="quoted">"list_all ls_invar <span class="main">(</span>List.map <span class="main">(</span>faccs' <span class="free">H</span><span class="main">)</span> <span class="free">ts</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T2</span></span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?T1</span> <span class="main">∧</span> <span class="var">?T2</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> compat_tree_tree_list.induct<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ll_set_xy.image_filter_correct hta_lookup_f_correct<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?T1</span></span></span> <span class="var"><span class="quoted"><span class="var">?T2</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">declare</span></span> faccs'_invar<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span>

  <span class="keyword1"><span class="command">lemma</span></span> faccs'_correct<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> HI<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hta_has_idx_f <span class="free">H</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> 
      <span class="quoted"><span class="quoted">"ls_α <span class="main">(</span>faccs' <span class="free">H</span> <span class="free">t</span><span class="main">)</span> <span class="main">=</span> faccs <span class="main">(</span>ls_α <span class="main">(</span>hta_δ <span class="free">H</span><span class="main">)</span><span class="main">)</span> <span class="free">t</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T1</span></span></span><span class="main">)</span>
      <span class="quoted"><span class="quoted">"List.map ls_α <span class="main">(</span>List.map <span class="main">(</span>faccs' <span class="free">H</span><span class="main">)</span> <span class="free">ts</span><span class="main">)</span> 
       <span class="main">=</span> List.map <span class="main">(</span>faccs <span class="main">(</span>ls_α <span class="main">(</span>hta_δ <span class="free">H</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="free">ts</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T2</span></span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?T1</span> <span class="main">∧</span> <span class="var">?T2</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> compat_tree_tree_list.induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>NODE <span class="skolem">f</span> <span class="skolem">ts</span><span class="main">)</span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?δ</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>ls_α <span class="main">(</span>hta_δ <span class="free">H</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"faccs <span class="var">?δ</span> <span class="main">(</span>NODE <span class="skolem">f</span> <span class="skolem">ts</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
        <span class="keyword1">let</span> <span class="bound">Qs</span> <span class="main">=</span> List.map <span class="main">(</span>faccs <span class="var">?δ</span><span class="main">)</span> <span class="skolem">ts</span> <span class="keyword1">in</span>
          <span class="main">{</span><span class="bound">q</span><span class="main">.</span> <span class="main">∃</span><span class="bound">r</span><span class="main">∈</span><span class="var">?δ</span><span class="main">.</span> r_matchc <span class="bound">q</span> <span class="skolem">f</span> <span class="bound">Qs</span> <span class="bound">r</span> <span class="main">}</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> faccs.simps<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> NODE.hyps<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> 
        1<span class="main">:</span> <span class="quoted"><span class="quoted">"faccs <span class="var">?δ</span> <span class="main">(</span>NODE <span class="skolem">f</span> <span class="skolem">ts</span><span class="main">)</span> 
            <span class="main">=</span> <span class="main">(</span> <span class="keyword1">let</span> <span class="bound">Qs</span> <span class="main">=</span> List.map ls_α <span class="main">(</span>List.map <span class="main">(</span>faccs' <span class="free">H</span><span class="main">)</span> <span class="skolem">ts</span><span class="main">)</span> <span class="keyword1">in</span>
                 <span class="main">{</span><span class="bound">q</span><span class="main">.</span> <span class="main">∃</span><span class="bound">r</span><span class="main">∈</span><span class="var">?δ</span><span class="main">.</span> r_matchc <span class="bound">q</span> <span class="skolem">f</span> <span class="bound">Qs</span> <span class="bound">r</span> <span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
      <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">Qsc</span><span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> ls list"</span></span>
        <span class="keyword3"><span class="command">assume</span></span> QI<span class="main">:</span> <span class="quoted"><span class="quoted">"list_all ls_invar <span class="skolem">Qsc</span>"</span></span>
        <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?Qs</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"List.map ls_α <span class="skolem">Qsc</span>"</span></span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span> <span class="bound">q</span><span class="main">.</span> <span class="main">∃</span><span class="bound">r</span><span class="main">∈</span><span class="var">?δ</span><span class="main">.</span> r_matchc <span class="bound">q</span> <span class="skolem">f</span> <span class="var">?Qs</span> <span class="bound">r</span> <span class="main">}</span> 
              <span class="main">=</span> <span class="main">{</span> <span class="bound">q</span><span class="main">.</span> <span class="main">∃</span><span class="bound">qs</span><span class="main">.</span> <span class="main">(</span><span class="bound">q</span> <span class="main">→</span> <span class="skolem">f</span> <span class="bound">qs</span><span class="main">)</span><span class="main">∈</span><span class="var">?δ</span> <span class="main">∧</span> r_match <span class="var">?Qs</span> <span class="bound">qs</span> <span class="main">}</span>"</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">safe</span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">r</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> lhs <span class="main">`</span> <span class="main">{</span> <span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="var">?δ</span><span class="main">.</span> rhsl <span class="bound">r</span> <span class="main">=</span> <span class="skolem">f</span><span class="main">}</span><span class="main">.</span> 
                                 <span class="keyword1">case</span> <span class="bound">r</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">q</span> <span class="main">→</span> <span class="bound">f'</span> <span class="bound">qs</span><span class="main">)</span> <span class="main">⇒</span> r_match <span class="var">?Qs</span> <span class="bound">qs</span><span class="main">}</span>"</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">xa</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
        <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> 
          1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span> <span class="bound">q</span><span class="main">.</span> <span class="main">∃</span><span class="bound">r</span><span class="main">∈</span><span class="var">?δ</span><span class="main">.</span> r_matchc <span class="bound">q</span> <span class="skolem">f</span> <span class="var">?Qs</span> <span class="bound">r</span> <span class="main">}</span> 
              <span class="main">=</span> lhs <span class="main">`</span> <span class="main">{</span> <span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="var">?δ</span><span class="main">.</span> rhsl <span class="bound">r</span> <span class="main">=</span> <span class="skolem">f</span><span class="main">}</span><span class="main">.</span> 
                         <span class="keyword1">case</span> <span class="bound">r</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">q</span> <span class="main">→</span> <span class="bound">f'</span> <span class="bound">qs</span><span class="main">)</span> <span class="main">⇒</span> r_match <span class="var">?Qs</span> <span class="bound">qs</span><span class="main">}</span>"</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">from</span></span> QI <span class="keyword1"><span class="command">have</span></span> 
          <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">!!</span><span class="bound">qs</span><span class="main">.</span> list_all_zip <span class="main">(</span><span class="main">λ</span><span class="bound">Q</span> <span class="bound">q</span><span class="main">.</span> <span class="bound">q</span><span class="main">∈</span>ls_α <span class="bound">Q</span><span class="main">)</span> <span class="skolem">Qsc</span> <span class="bound">qs</span> 
                         <span class="main">⟷</span> list_all_zip <span class="main">(</span><span class="main">λ</span><span class="bound">Q</span> <span class="bound">q</span><span class="main">.</span> ls_memb <span class="bound">q</span> <span class="bound">Q</span><span class="main">)</span> <span class="skolem">Qsc</span> <span class="bound">qs</span>"</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">Qsc</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">qs</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">qs</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ls.correct<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
        <span class="keyword1"><span class="command">have</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">!!</span><span class="bound">qs</span><span class="main">.</span> r_match <span class="var">?Qs</span> <span class="bound">qs</span> <span class="main">=</span> list_all_zip <span class="main">(</span><span class="main">λ</span><span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> ls_memb <span class="bound">b</span> <span class="bound">a</span><span class="main">)</span> <span class="skolem">Qsc</span> <span class="bound">qs</span>"</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> r_match_by_laz<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list_all_zip_map1<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
        <span class="keyword1"><span class="command">from</span></span> 1 <span class="keyword1"><span class="command">have</span></span> 
          <span class="quoted"><span class="quoted">"<span class="main">{</span> <span class="bound">q</span><span class="main">.</span> <span class="main">∃</span><span class="bound">r</span><span class="main">∈</span><span class="var">?δ</span><span class="main">.</span> r_matchc <span class="bound">q</span> <span class="skolem">f</span> <span class="var">?Qs</span> <span class="bound">r</span> <span class="main">}</span> 
           <span class="main">=</span> lhs <span class="main">`</span> <span class="main">{</span> <span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="var">?δ</span><span class="main">.</span> rhsl <span class="bound">r</span> <span class="main">=</span> <span class="skolem">f</span><span class="main">}</span><span class="main">.</span> 
                     <span class="keyword1">case</span> <span class="bound">r</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">q</span> <span class="main">→</span> <span class="bound">f'</span> <span class="bound">qs</span><span class="main">)</span> <span class="main">⇒</span> 
                       list_all_zip <span class="main">(</span><span class="main">λ</span><span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> ls_memb <span class="bound">b</span> <span class="bound">a</span><span class="main">)</span> <span class="skolem">Qsc</span> <span class="bound">qs</span><span class="main">}</span>"</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> 2<span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> 
          <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> lhs <span class="main">`</span> <span class="main">{</span> <span class="bound"><span class="bound">r</span></span><span class="main">∈</span>ls_α <span class="main">(</span>hta_lookup_f <span class="skolem">f</span> <span class="free">H</span><span class="main">)</span><span class="main">.</span> 
                         <span class="keyword1">case</span> <span class="bound">r</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">q</span> <span class="main">→</span> <span class="bound">f'</span> <span class="bound">qs</span><span class="main">)</span> <span class="main">⇒</span> 
                           list_all_zip <span class="main">(</span><span class="main">λ</span><span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> ls_memb <span class="bound">b</span> <span class="bound">a</span><span class="main">)</span> <span class="skolem">Qsc</span> <span class="bound">qs</span><span class="main">}</span>"</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hta_lookup_f_correct<span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> 
          <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> ls_α <span class="main">(</span> ll_set_xy.g_image_filter 
                         <span class="main">(</span> <span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">r</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">q</span> <span class="main">→</span> <span class="bound">f'</span> <span class="bound">qs</span><span class="main">)</span> <span class="main">⇒</span> 
                             <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span>list_all_zip <span class="main">(</span><span class="main">λ</span><span class="bound">Q</span> <span class="bound">q</span><span class="main">.</span> ls_memb <span class="bound">q</span> <span class="bound">Q</span><span class="main">)</span> <span class="skolem">Qsc</span> <span class="bound">qs</span><span class="main">)</span> <span class="keyword1">then</span> Some <span class="main">(</span>lhs <span class="bound">r</span><span class="main">)</span> <span class="keyword1">else</span> None<span class="main">)</span><span class="main">)</span>
                         <span class="main">(</span>hta_lookup_f <span class="skolem">f</span> <span class="free">H</span><span class="main">)</span>
                     <span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ll_set_xy.image_filter_correct hta_lookup_f_correct<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> ta_rule.split<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">xa</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">a</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> image_iff<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">a</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
        <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> 
          <span class="quoted"><span class="quoted">"<span class="main">{</span> <span class="bound">q</span><span class="main">.</span> <span class="main">∃</span><span class="bound">r</span><span class="main">∈</span><span class="var">?δ</span><span class="main">.</span> r_matchc <span class="bound">q</span> <span class="skolem">f</span> <span class="var">?Qs</span> <span class="bound">r</span> <span class="main">}</span> 
           <span class="main">=</span> ls_α <span class="main">(</span> ll_set_xy.g_image_filter 
                      <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">r</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">q</span> <span class="main">→</span> <span class="bound">f'</span> <span class="bound">qs</span><span class="main">)</span> <span class="main">⇒</span> 
                        <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span>list_all_zip <span class="main">(</span><span class="main">λ</span><span class="bound">Q</span> <span class="bound">q</span><span class="main">.</span> ls_memb <span class="bound">q</span> <span class="bound">Q</span><span class="main">)</span> <span class="skolem">Qsc</span> <span class="bound">qs</span><span class="main">)</span> <span class="keyword1">then</span> Some <span class="main">(</span>lhs <span class="bound">r</span><span class="main">)</span> <span class="keyword1">else</span> None<span class="main">)</span><span class="main">)</span>
                      <span class="main">(</span>hta_lookup_f <span class="skolem">f</span> <span class="free">H</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
      <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> 2<span class="main">=</span>this
      
      <span class="keyword1"><span class="command">from</span></span> 
        1 
        2<span class="main">[</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> Qsc2 <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>List.map <span class="main">(</span>faccs' <span class="free">H</span><span class="main">)</span> <span class="skolem">ts</span><span class="main">)</span>"</span></span><span class="main">,</span> 
           <span class="operator">simplified</span> faccs'_invar<span class="main"><span class="main">[</span></span><span class="operator">OF</span> HI<span class="main"><span class="main">]</span></span><span class="main">]</span> 
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?T1</span></span></span> <span class="var"><span class="quoted"><span class="var">?T2</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>

    <span class="comment1">― ‹Correctness of the algorithms for the word problem›</span>
  <span class="keyword1"><span class="command">lemma</span></span> hta_mem'_correct<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"hta_has_idx_f <span class="free">H</span> <span class="main">⟹</span> hta_mem' <span class="free">t</span> <span class="free">H</span> <span class="main">⟷</span> <span class="free">t</span><span class="main">∈</span>ta_lang <span class="main">(</span>hta_α <span class="free">H</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> ta_lang_def hta_α_def hta_mem'_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lh_set_xx.disjoint_correct faccs'_correct faccs_alt<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">theorem</span></span> hta_mem_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"hta_mem <span class="free">t</span> <span class="free">H</span> <span class="main">⟷</span> <span class="free">t</span><span class="main">∈</span>ta_lang <span class="main">(</span>hta_α <span class="free">H</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> hashedTa.hta_mem'_correct<span class="main">[</span><span class="operator">OF</span> hta_ensure_idx_f_correct<span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> hta_mem_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Product Automaton and Intersection"</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">"Brute Force Product Automaton"</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  In this section, an algorithm that computes the product 
  automaton without reduction is implemented. While the runtime is always
  quadratic, this algorithm is very simple and the constant factors are 
  smaller than that of the version with integrated reduction.
  Moreover, lazy languages like Haskell seem to profit from this algorithm.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">δ_prod_h</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'q1</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'l</span><span class="main">::</span>hashable<span class="main">)</span> ta_rule ls 
      <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'q2</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> ta_rule ls <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'q1</span><span class="main">×</span><span class="tfree">'q2</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> ta_rule ls"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">δ_prod_h</span> <span class="free"><span class="bound"><span class="entity">δ1</span></span></span> <span class="free"><span class="bound"><span class="entity">δ2</span></span></span> <span class="main">==</span> 
    lll_iflt_cp.inj_image_filter_cp <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">r1</span><span class="main">,</span><span class="bound">r2</span><span class="main">)</span><span class="main">.</span> r_prod <span class="bound">r1</span> <span class="bound">r2</span><span class="main">)</span> 
                <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">r1</span><span class="main">,</span><span class="bound">r2</span><span class="main">)</span><span class="main">.</span> rhsl <span class="bound">r1</span> <span class="main">=</span> rhsl <span class="bound">r2</span> 
                         <span class="main">∧</span> length <span class="main">(</span>rhsq <span class="bound">r1</span><span class="main">)</span> <span class="main">=</span> length <span class="main">(</span>rhsq <span class="bound">r2</span><span class="main">)</span><span class="main">)</span> 
                <span class="free"><span class="bound"><span class="entity">δ1</span></span></span> <span class="free"><span class="bound"><span class="entity">δ2</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> r_prod_inj<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> rhsl <span class="free">r1</span> <span class="main">=</span> rhsl <span class="free">r2</span><span class="main">;</span> length <span class="main">(</span>rhsq <span class="free">r1</span><span class="main">)</span> <span class="main">=</span> length <span class="main">(</span>rhsq <span class="free">r2</span><span class="main">)</span><span class="main">;</span> 
     rhsl <span class="free">r1'</span> <span class="main">=</span> rhsl <span class="free">r2'</span><span class="main">;</span> length <span class="main">(</span>rhsq <span class="free">r1'</span><span class="main">)</span> <span class="main">=</span> length <span class="main">(</span>rhsq <span class="free">r2'</span><span class="main">)</span><span class="main">;</span> 
     r_prod <span class="free">r1</span> <span class="free">r2</span> <span class="main">=</span> r_prod <span class="free">r1'</span> <span class="free">r2'</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">r1</span><span class="main">=</span><span class="free">r1'</span> <span class="main">∧</span> <span class="free">r2</span><span class="main">=</span><span class="free">r2'</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">r1</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">r2</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">r1'</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">r2'</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> zip_inj<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> δ_prod_h_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ls_invar <span class="free">δ1</span>"</span></span> <span class="quoted"><span class="quoted">"ls_invar <span class="free">δ2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> 
    <span class="quoted"><span class="quoted">"ls_α <span class="main">(</span>δ_prod_h <span class="free">δ1</span> <span class="free">δ2</span><span class="main">)</span> <span class="main">=</span> δ_prod <span class="main">(</span>ls_α <span class="free">δ1</span><span class="main">)</span> <span class="main">(</span>ls_α <span class="free">δ2</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"ls_invar <span class="main">(</span>δ_prod_h <span class="free">δ1</span> <span class="free">δ2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> δ_prod_def δ_prod_h_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> lll_iflt_cp.inj_image_filter_cp_correct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span> <span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command">using</span></span> r_prod_inj
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> inj_onI<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">xa</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">y</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hta_prodWR</span> <span class="free"><span class="bound"><span class="entity">H1</span></span></span> <span class="free"><span class="bound"><span class="entity">H2</span></span></span> <span class="main">==</span> 
  init_hta <span class="main">(</span>hhh_cart.cart <span class="main">(</span>hta_Qi <span class="free"><span class="bound"><span class="entity">H1</span></span></span><span class="main">)</span> <span class="main">(</span>hta_Qi <span class="free"><span class="bound"><span class="entity">H2</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>δ_prod_h <span class="main">(</span>hta_δ <span class="free"><span class="bound"><span class="entity">H1</span></span></span><span class="main">)</span> <span class="main">(</span>hta_δ <span class="free"><span class="bound"><span class="entity">H2</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> hta_prodWR_correct_aux<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"hashedTa <span class="free">H1</span>"</span></span> <span class="quoted"><span class="quoted">"hashedTa <span class="free">H2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> 
    <span class="quoted"><span class="quoted">"hta_α <span class="main">(</span>hta_prodWR <span class="free">H1</span> <span class="free">H2</span><span class="main">)</span> <span class="main">=</span> ta_prod <span class="main">(</span>hta_α <span class="free">H1</span><span class="main">)</span> <span class="main">(</span>hta_α <span class="free">H2</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T1</span></span></span><span class="main">)</span>
    <span class="quoted"><span class="quoted">"hashedTa <span class="main">(</span>hta_prodWR <span class="free">H1</span> <span class="free">H2</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T2</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> a1<span class="main">:</span> hashedTa <span class="quoted"><span class="free">H1</span></span> <span class="main">+</span> a2<span class="main">:</span> hashedTa <span class="quoted"><span class="free">H2</span></span> <span class="keyword1"><span class="command">using</span></span> A <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?T1</span></span></span> <span class="var"><span class="quoted"><span class="var">?T2</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> hta_prodWR_def init_hta_def hta_α_def ta_prod_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hhh_cart.cart_correct δ_prod_h_correct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hhh_cart.cart_correct δ_prod_h_correct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> hta_prodWR_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> TA<span class="main">:</span> <span class="quoted"><span class="quoted">"hashedTa <span class="free">H1</span>"</span></span> <span class="quoted"><span class="quoted">"hashedTa <span class="free">H2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> 
    <span class="quoted"><span class="quoted">"ta_lang <span class="main">(</span>hta_α <span class="main">(</span>hta_prodWR <span class="free">H1</span> <span class="free">H2</span><span class="main">)</span><span class="main">)</span> 
     <span class="main">=</span> ta_lang <span class="main">(</span>hta_α <span class="free">H1</span><span class="main">)</span> <span class="main">∩</span> ta_lang <span class="main">(</span>hta_α <span class="free">H2</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"hashedTa <span class="main">(</span>hta_prodWR <span class="free">H1</span> <span class="free">H2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hta_prodWR_correct_aux<span class="main"><span class="main">[</span></span><span class="operator">OF</span> TA<span class="main"><span class="main">]</span></span> ta_prod_correct_aux1<span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">"Product Automaton with Forward-Reduction"</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  A more elaborated algorithm combines forward-reduction and the product 
  construction, i.e. product rules are only created ,,by need''.
›</span></span>

  <span class="comment1">― ‹State of the product-automaton DFS-algorithm›</span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'q1</span><span class="main">,</span><span class="tfree">'q2</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> pa_state 
  <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'q1</span><span class="main">×</span><span class="tfree">'q2</span><span class="main">)</span> hs <span class="main">×</span> <span class="main">(</span><span class="tfree">'q1</span><span class="main">×</span><span class="tfree">'q2</span><span class="main">)</span> list <span class="main">×</span> <span class="main">(</span><span class="tfree">'q1</span><span class="main">×</span><span class="tfree">'q2</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> ta_rule ls"</span></span>

  <span class="comment1">― ‹Abstraction mapping to algorithm specified in 
  Section~\ref{sec:absalgo}.›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">pa_α</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'q1</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'q2</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'l</span><span class="main">::</span>hashable<span class="main">)</span> pa_state 
      <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'q1</span><span class="main">,</span><span class="tfree">'q2</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> frp_state"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">pa_α</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">==</span> <span class="keyword1">let</span> <span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">δd</span><span class="main">)</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="keyword1">in</span> <span class="main">(</span>hs_α <span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span>ls_α <span class="bound">δd</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">pa_cond</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'q1</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'q2</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'l</span><span class="main">::</span>hashable<span class="main">)</span> pa_state <span class="main">⇒</span> bool"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">pa_cond</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">==</span> <span class="keyword1">let</span> <span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">δd</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="keyword1">in</span> <span class="bound">W</span><span class="main">≠</span><span class="main">[]</span>"</span></span>

  <span class="comment1">― ‹Adds all successor states to the set of discovered states and to the 
  worklist›</span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">pa_upd_rule</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'q1</span><span class="main">×</span><span class="tfree">'q2</span><span class="main">)</span> hs <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'q1</span><span class="main">×</span><span class="tfree">'q2</span><span class="main">)</span> list 
      <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'q1</span><span class="main">::</span>hashable<span class="main">)</span><span class="main">×</span><span class="main">(</span><span class="tfree">'q2</span><span class="main">::</span>hashable<span class="main">)</span><span class="main">)</span> list 
      <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'q1</span><span class="main">×</span><span class="tfree">'q2</span><span class="main">)</span> hs <span class="main">×</span> <span class="main">(</span><span class="tfree">'q1</span><span class="main">×</span><span class="tfree">'q2</span><span class="main">)</span> list<span class="main">)</span>"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">pa_upd_rule</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">W</span></span></span> <span class="main">[]</span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">W</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">pa_upd_rule</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">W</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">qp</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">qs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
    <span class="keyword1">if</span> <span class="main">¬</span> hs_memb <span class="free"><span class="bound"><span class="entity">qp</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="keyword1">then</span>
      <span class="free">pa_upd_rule</span> <span class="main">(</span>hs_ins <span class="free"><span class="bound"><span class="entity">qp</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">qp</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">W</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">qs</span></span></span>
    <span class="keyword1">else</span> <span class="free">pa_upd_rule</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">W</span></span></span> <span class="free"><span class="bound"><span class="entity">qs</span></span></span>
  <span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">pa_step</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'q1</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'l</span><span class="main">::</span>hashable<span class="main">)</span> hashedTa 
      <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'q2</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> hashedTa 
      <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'q1</span><span class="main">,</span><span class="tfree">'q2</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> pa_state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'q1</span><span class="main">,</span><span class="tfree">'q2</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> pa_state"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">pa_step</span> <span class="free"><span class="bound"><span class="entity">H1</span></span></span> <span class="free"><span class="bound"><span class="entity">H2</span></span></span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">==</span> <span class="keyword1">let</span> 
    <span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">δd</span><span class="main">)</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">S</span></span></span><span class="main">;</span>
    <span class="main">(</span><span class="bound">q1</span><span class="main">,</span><span class="bound">q2</span><span class="main">)</span><span class="main">=</span>hd <span class="bound">W</span>
  <span class="keyword1">in</span>  
    ls_iteratei <span class="main">(</span>hta_lookup_s <span class="bound">q1</span> <span class="free"><span class="bound"><span class="entity">H1</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r1</span> <span class="bound">res</span><span class="main">.</span> 
      ls_iteratei <span class="main">(</span>hta_lookup_sf <span class="bound">q2</span> <span class="main">(</span>rhsl <span class="bound">r1</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">H2</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r2</span> <span class="bound">res</span><span class="main">.</span>
        <span class="keyword1">if</span> <span class="main">(</span>length <span class="main">(</span>rhsq <span class="bound">r1</span><span class="main">)</span> <span class="main">=</span> length <span class="main">(</span>rhsq <span class="bound">r2</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">then</span>
          <span class="keyword1">let</span> 
            <span class="bound">rp</span><span class="main">=</span>r_prod <span class="bound">r1</span> <span class="bound">r2</span><span class="main">;</span>
            <span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">δd</span><span class="main">)</span> <span class="main">=</span> <span class="bound">res</span><span class="main">;</span>
            <span class="main">(</span><span class="bound">Q'</span><span class="main">,</span><span class="bound">W'</span><span class="main">)</span> <span class="main">=</span> pa_upd_rule <span class="bound">Q</span> <span class="bound">W</span> <span class="main">(</span>rhsq <span class="bound">rp</span><span class="main">)</span>
          <span class="keyword1">in</span>
            <span class="main">(</span><span class="bound">Q'</span><span class="main">,</span><span class="bound">W'</span><span class="main">,</span>ls_ins_dj <span class="bound">rp</span> <span class="bound">δd</span><span class="main">)</span>
        <span class="keyword1">else</span>
          <span class="bound">res</span>
      <span class="main">)</span> <span class="bound">res</span>
    <span class="main">)</span> <span class="main">(</span><span class="bound">Q</span><span class="main">,</span>tl <span class="bound">W</span><span class="main">,</span><span class="bound">δd</span><span class="main">)</span>
  "</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">pa_initial</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'q1</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'l</span><span class="main">::</span>hashable<span class="main">)</span> hashedTa 
      <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'q2</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> hashedTa 
      <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'q1</span><span class="main">,</span><span class="tfree">'q2</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> pa_state"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">pa_initial</span> <span class="free"><span class="bound"><span class="entity">H1</span></span></span> <span class="free"><span class="bound"><span class="entity">H2</span></span></span> <span class="main">==</span> 
  <span class="keyword1">let</span> <span class="bound">Qip</span> <span class="main">=</span> hhh_cart.cart <span class="main">(</span>hta_Qi <span class="free"><span class="bound"><span class="entity">H1</span></span></span><span class="main">)</span> <span class="main">(</span>hta_Qi <span class="free"><span class="bound"><span class="entity">H2</span></span></span><span class="main">)</span> <span class="keyword1">in</span> <span class="main">(</span>
    <span class="bound">Qip</span><span class="main">,</span>
    hs_to_list <span class="bound">Qip</span><span class="main">,</span>
    ls_empty <span class="main">()</span>
  <span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">pa_invar_add</span><span class="main">::</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'q1</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'q2</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'l</span><span class="main">::</span>hashable<span class="main">)</span> pa_state set"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">pa_invar_add</span> <span class="main">==</span> <span class="main">{</span> <span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">δd</span><span class="main">)</span><span class="main">.</span> hs_invar <span class="bound">Q</span> <span class="main">∧</span> ls_invar <span class="bound">δd</span> <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">pa_invar</span> <span class="free"><span class="bound"><span class="entity">H1</span></span></span> <span class="free"><span class="bound"><span class="entity">H2</span></span></span> <span class="main">==</span> 
  pa_invar_add <span class="main">∩</span> <span class="main">{</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span>pa_α <span class="bound">s</span><span class="main">)</span> <span class="main">∈</span> frp_invar <span class="main">(</span>hta_α <span class="free"><span class="bound"><span class="entity">H1</span></span></span><span class="main">)</span> <span class="main">(</span>hta_α <span class="free"><span class="bound"><span class="entity">H2</span></span></span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">pa_det_algo</span> <span class="free"><span class="bound"><span class="entity">H1</span></span></span> <span class="free"><span class="bound"><span class="entity">H2</span></span></span> 
  <span class="main">==</span> <span class="main">⦇</span> dwa_cond<span class="main">=</span>pa_cond<span class="main">,</span> 
       dwa_step <span class="main">=</span> pa_step <span class="free"><span class="bound"><span class="entity">H1</span></span></span> <span class="free"><span class="bound"><span class="entity">H2</span></span></span><span class="main">,</span> 
       dwa_initial <span class="main">=</span> pa_initial <span class="free"><span class="bound"><span class="entity">H1</span></span></span> <span class="free"><span class="bound"><span class="entity">H2</span></span></span><span class="main">,</span> 
       dwa_invar <span class="main">=</span> pa_invar <span class="free"><span class="bound"><span class="entity">H1</span></span></span> <span class="free"><span class="bound"><span class="entity">H2</span></span></span> <span class="main">⦈</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> pa_upd_rule_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hs_invar <span class="free">Q</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> FMT<span class="main">:</span> <span class="quoted"><span class="quoted">"pa_upd_rule <span class="free">Q</span> <span class="free">W</span> <span class="free">qs</span> <span class="main">=</span> <span class="main">(</span><span class="free">Q'</span><span class="main">,</span><span class="free">W'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>
    <span class="quoted"><span class="quoted">"hs_invar <span class="free">Q'</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T1</span></span></span><span class="main">)</span>
    <span class="quoted"><span class="quoted">"hs_α <span class="free">Q'</span> <span class="main">=</span> hs_α <span class="free">Q</span> <span class="main">∪</span> set <span class="free">qs</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T2</span></span></span><span class="main">)</span>
    <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">Wn</span><span class="main">.</span> distinct <span class="bound">Wn</span> <span class="main">∧</span> set <span class="bound">Wn</span> <span class="main">=</span> set <span class="free">qs</span> <span class="main">-</span> hs_α <span class="free">Q</span> <span class="main">∧</span> <span class="free">W'</span><span class="main">=</span><span class="bound">Wn</span><span class="main">@</span><span class="free">W</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T3</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> INV FMT <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?T1</span> <span class="main">∧</span> <span class="var">?T2</span> <span class="main">∧</span> <span class="var">?T3</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">qs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">Q</span></span> <span class="quoted"><span class="free">W</span></span> <span class="quoted"><span class="free">Q'</span></span> <span class="quoted"><span class="free">W'</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">q</span> <span class="skolem">qs</span> <span class="skolem">Q</span> <span class="skolem">W</span> <span class="skolem">Q'</span> <span class="skolem">W'</span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span><span class="main">∈</span>hs_α <span class="skolem">Q</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True 
      <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">Qh</span></span> <span class="skolem"><span class="skolem">Wh</span></span> <span class="keyword2"><span class="keyword">where</span></span> RF<span class="main">:</span> <span class="quoted"><span class="quoted">"pa_upd_rule <span class="skolem">Q</span> <span class="skolem">W</span> <span class="skolem">qs</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">Qh</span><span class="main">,</span><span class="skolem">Wh</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
      <span class="keyword1"><span class="command">with</span></span> True Cons.prems <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">Q'</span><span class="main">=</span><span class="skolem">Qh</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">W'</span><span class="main">=</span><span class="skolem">Wh</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hs.correct<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> Cons.hyps<span class="main">[</span><span class="operator">OF</span> Cons.prems<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> RF<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span>
        <span class="quoted"><span class="quoted">"hs_invar <span class="skolem">Qh</span>"</span></span> 
        <span class="quoted"><span class="quoted">"hs_α <span class="skolem">Qh</span> <span class="main">=</span> hs_α <span class="skolem">Q</span> <span class="main">∪</span> set <span class="skolem">qs</span>"</span></span> 
        <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">Wn</span><span class="main">.</span> distinct <span class="bound">Wn</span> <span class="main">∧</span> set <span class="bound">Wn</span> <span class="main">=</span> set <span class="skolem">qs</span> <span class="main">-</span> hs_α <span class="skolem">Q</span> <span class="main">∧</span> <span class="skolem">Wh</span> <span class="main">=</span> <span class="bound">Wn</span> <span class="main">@</span> <span class="skolem">W</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">with</span></span> Cons.prems <span class="keyword1"><span class="command">have</span></span> RF<span class="main">:</span> <span class="quoted"><span class="quoted">"pa_upd_rule <span class="main">(</span>hs_ins <span class="skolem">q</span> <span class="skolem">Q</span><span class="main">)</span> <span class="main">(</span><span class="skolem">q</span><span class="main">#</span><span class="skolem">W</span><span class="main">)</span> <span class="skolem">qs</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">Q'</span><span class="main">,</span><span class="skolem">W'</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hs.correct<span class="main">)</span>

      <span class="keyword1"><span class="command">from</span></span> Cons.hyps<span class="main">[</span><span class="operator">OF</span> _ RF<span class="main">]</span> Cons.prems<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span>
        <span class="quoted"><span class="quoted">"hs_invar <span class="skolem">Q'</span>"</span></span> 
        <span class="quoted"><span class="quoted">"hs_α <span class="skolem">Q'</span> <span class="main">=</span> insert <span class="skolem">q</span> <span class="main">(</span>hs_α <span class="skolem">Q</span><span class="main">)</span> <span class="main">∪</span> set <span class="main">(</span><span class="skolem">qs</span><span class="main">)</span>"</span></span>
        <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">Wn</span><span class="main">.</span> distinct <span class="bound">Wn</span> 
              <span class="main">∧</span> set <span class="bound">Wn</span> <span class="main">=</span> set <span class="skolem">qs</span> <span class="main">-</span> insert <span class="skolem">q</span> <span class="main">(</span>hs_α <span class="skolem">Q</span><span class="main">)</span> 
              <span class="main">∧</span> <span class="skolem">W'</span> <span class="main">=</span> <span class="bound">Wn</span> <span class="main">@</span> <span class="skolem">q</span> <span class="main">#</span> <span class="skolem">W</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hs.correct<span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> False <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?T1</span></span></span> <span class="var"><span class="quoted"><span class="var">?T2</span></span></span> <span class="var"><span class="quoted"><span class="var">?T3</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">lemma</span></span> pa_step_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> TA<span class="main">:</span> <span class="quoted"><span class="quoted">"hashedTa <span class="free">H1</span>"</span></span> <span class="quoted"><span class="quoted">"hashedTa <span class="free">H2</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> idx<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hta_has_idx_s <span class="free">H1</span>"</span></span> <span class="quoted"><span class="quoted">"hta_has_idx_sf <span class="free">H2</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">,</span><span class="free">δd</span><span class="main">)</span><span class="main">∈</span>pa_invar <span class="free">H1</span> <span class="free">H2</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> COND<span class="main">:</span> <span class="quoted"><span class="quoted">"pa_cond <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">,</span><span class="free">δd</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span>pa_step <span class="free">H1</span> <span class="free">H2</span> <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">,</span><span class="free">δd</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>pa_invar_add"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T1</span></span></span><span class="main">)</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span>pa_α <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">,</span><span class="free">δd</span><span class="main">)</span><span class="main">,</span> pa_α <span class="main">(</span>pa_step <span class="free">H1</span> <span class="free">H2</span> <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">,</span><span class="free">δd</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
     <span class="main">∈</span> frp_step <span class="main">(</span>ls_α <span class="main">(</span>hta_δ <span class="free">H1</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>ls_α <span class="main">(</span>hta_δ <span class="free">H2</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T2</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> h1<span class="main">:</span> hashedTa <span class="quoted"><span class="free">H1</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword1"><span class="command">interpret</span></span> h2<span class="main">:</span> hashedTa <span class="quoted"><span class="free">H2</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>

  <span class="keyword1"><span class="command">from</span></span> COND <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">q1</span></span> <span class="skolem"><span class="skolem">q2</span></span> <span class="skolem"><span class="skolem">Wtl</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">W</span><span class="main">=</span><span class="main">(</span><span class="skolem">q1</span><span class="main">,</span><span class="skolem">q2</span><span class="main">)</span><span class="main">#</span><span class="skolem">Wtl</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">W</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pa_cond_def<span class="main">)</span>

  <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hs_invar <span class="free">Q</span>"</span></span> <span class="quoted"><span class="quoted">"ls_invar <span class="free">δd</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pa_invar_add_def pa_invar_def<span class="main">)</span>

  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">inv</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">inv</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">δp</span> <span class="main">(</span><span class="bound">Q'</span><span class="main">,</span> <span class="bound">W'</span><span class="main">,</span> <span class="bound">δd'</span><span class="main">)</span><span class="main">.</span> 
    hs_invar <span class="bound">Q'</span> 
    <span class="main">∧</span> ls_invar <span class="bound">δd'</span> 
    <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound">Wn</span><span class="main">.</span> distinct <span class="bound">Wn</span> 
            <span class="main">∧</span> set <span class="bound">Wn</span> <span class="main">=</span> <span class="main">(</span>f_succ <span class="bound">δp</span> <span class="main">``</span> <span class="main">{</span><span class="main">(</span><span class="skolem">q1</span><span class="main">,</span><span class="skolem">q2</span><span class="main">)</span><span class="main">}</span><span class="main">)</span> <span class="main">-</span> hs_α <span class="free">Q</span> 
            <span class="main">∧</span> <span class="bound">W'</span><span class="main">=</span><span class="bound">Wn</span><span class="main">@</span><span class="skolem">Wtl</span> 
            <span class="main">∧</span> hs_α <span class="bound">Q'</span><span class="main">=</span>hs_α <span class="free">Q</span> <span class="main">∪</span> <span class="main">(</span>f_succ <span class="bound">δp</span> <span class="main">``</span> <span class="main">{</span><span class="main">(</span><span class="skolem">q1</span><span class="main">,</span><span class="skolem">q2</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>
    <span class="main">∧</span> <span class="main">(</span>ls_α <span class="bound">δd'</span> <span class="main">=</span> ls_α <span class="free">δd</span> <span class="main">∪</span> <span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="bound">δp</span><span class="main">.</span> lhs <span class="bound">r</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">q1</span><span class="main">,</span><span class="skolem">q2</span><span class="main">)</span> <span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">have</span></span> G<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">inv</span> <span class="main">(</span>δ_prod <span class="main">(</span>ls_α <span class="main">(</span>hta_δ <span class="free">H1</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>ls_α <span class="main">(</span>hta_δ <span class="free">H2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
               <span class="main">(</span>pa_step <span class="free">H1</span> <span class="free">H2</span> <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">,</span><span class="free">δd</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> pa_step_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> 
      I<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">it1</span> <span class="bound">res</span><span class="main">.</span> <span class="skolem">inv</span> <span class="main">(</span>δ_prod <span class="main">(</span>ls_α <span class="main">(</span>hta_δ <span class="free">H1</span><span class="main">)</span> <span class="main">-</span> <span class="bound">it1</span><span class="main">)</span> <span class="main">(</span>ls_α <span class="main">(</span>hta_δ <span class="free">H2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="bound">res</span>"</span></span>
      <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> ls.iterate_rule_P<span class="main">)</span>
    <span class="comment1">― ‹Invar›</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> h1.hta_lookup_s_correct<span class="main">)</span>
    <span class="comment1">― ‹Initial›</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inv_def δ_prod_def h1.hta_lookup_s_correct 
                              f_succ_alt<span class="main">)</span>
    <span class="comment1">― ‹Step›</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> 
      I<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">it2</span> <span class="bound">res</span><span class="main">.</span> <span class="skolem">inv</span> <span class="main">(</span> δ_prod <span class="main">(</span>ls_α <span class="main">(</span>hta_δ <span class="free">H1</span><span class="main">)</span> <span class="main">-</span> <span class="improper">it</span><span class="main">)</span> <span class="main">(</span>ls_α <span class="main">(</span>hta_δ <span class="free">H2</span><span class="main">)</span><span class="main">)</span> 
                         <span class="main">∪</span> δ_prod <span class="main">{</span><span class="improper">x</span><span class="main">}</span> <span class="main">(</span>ls_α <span class="main">(</span>hta_δ <span class="free">H2</span><span class="main">)</span> <span class="main">-</span> <span class="bound">it2</span><span class="main">)</span><span class="main">)</span> 
                        <span class="bound">res</span>"</span></span> 
      <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> ls.iterate_rule_P<span class="main">)</span>
      <span class="comment1">― ‹Invar›</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> h2.hta_lookup_sf_correct<span class="main">)</span>
      <span class="comment1">― ‹Init›</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">σ</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inv_def h1.hta_lookup_s_correct h2.hta_lookup_sf_correct<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> f_succ_alt <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> δ_prodE <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> δ_prodI<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
      <span class="comment1">― ‹Step›</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span> <span class="comment1">― ‹Requires considerably more work: Deferred to Isar proof below›</span>
      <span class="comment1">― ‹Final›</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> h1.hta_lookup_s_correct h2.hta_lookup_sf_correct<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> 
        <span class="quoted"><span class="quoted">"ls_α <span class="main">(</span>hta_δ <span class="free">H1</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="improper">it</span> <span class="main">-</span> <span class="main">{</span><span class="improper">x</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>ls_α <span class="main">(</span>hta_δ <span class="free">H1</span><span class="main">)</span> <span class="main">-</span> <span class="improper">it</span><span class="main">)</span> <span class="main">∪</span> <span class="main">{</span><span class="improper">x</span><span class="main">}</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> δ_prod_insert<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> Un_commute<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
    <span class="comment1">― ‹Final›</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">goal_cases</span>
    <span class="keyword3"><span class="command">case</span></span> prems<span class="main">:</span> <span class="main">(</span>1 <span class="skolem">r1</span> <span class="skolem">it1</span> <span class="skolem">resxh</span> <span class="skolem">r2</span> <span class="skolem">it2</span> <span class="skolem">resh</span><span class="main">)</span>
    <span class="comment1">― ‹Resolve lookup-operations›</span>
    <span class="keyword1"><span class="command">hence</span></span> G'<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="skolem">it1</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound"><span class="bound">r</span></span> <span class="main">∈</span> ls_α <span class="main">(</span>hta_δ <span class="free">H1</span><span class="main">)</span><span class="main">.</span> lhs <span class="bound">r</span> <span class="main">=</span> <span class="skolem">q1</span><span class="main">}</span>"</span></span> 
      <span class="quoted"><span class="quoted">"<span class="skolem">it2</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound"><span class="bound">r</span></span> <span class="main">∈</span> ls_α <span class="main">(</span>hta_δ <span class="free">H2</span><span class="main">)</span><span class="main">.</span> lhs <span class="bound">r</span> <span class="main">=</span> <span class="skolem">q2</span> <span class="main">∧</span> rhsl <span class="bound">r</span> <span class="main">=</span> rhsl <span class="skolem">r1</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> h1.hta_lookup_s_correct h2.hta_lookup_sf_correct<span class="main">)</span>

    <span class="comment1">― ‹Basic reasoning setup›</span>
    <span class="keyword1"><span class="command">from</span></span> prems<span class="main">(</span>1<span class="main">,</span>4<span class="main">)</span> G' <span class="keyword1"><span class="command">have</span></span> 
      <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ls_α <span class="main">(</span>hta_δ <span class="free">H2</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="skolem">it2</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">r2</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>ls_α <span class="main">(</span>hta_δ <span class="free">H2</span><span class="main">)</span> <span class="main">-</span> <span class="skolem">it2</span><span class="main">)</span> <span class="main">∪</span> <span class="main">{</span><span class="skolem">r2</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">Qh</span></span> <span class="skolem"><span class="skolem">Wh</span></span> <span class="skolem"><span class="skolem">δdh</span></span> <span class="skolem"><span class="skolem">Q'</span></span> <span class="skolem"><span class="skolem">W'</span></span> <span class="skolem"><span class="skolem">δd'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">resh</span><span class="main">=</span><span class="main">(</span><span class="skolem">Qh</span><span class="main">,</span><span class="skolem">Wh</span><span class="main">,</span><span class="skolem">δdh</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">resh</span></span><span class="main">)</span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">from</span></span> prems<span class="main">(</span>6<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> INVAH<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hs_invar <span class="skolem">Qh</span>"</span></span> <span class="quoted"><span class="quoted">"ls_invar <span class="skolem">δdh</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inv_def<span class="main">)</span>

    <span class="comment1">― ‹The involved rules have the same label, and their lhs is determined›</span>
    <span class="keyword1"><span class="command">from</span></span> prems<span class="main">(</span>1<span class="main">,</span>4<span class="main">)</span> G' <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">l</span></span> <span class="skolem"><span class="skolem">qs1</span></span> <span class="skolem"><span class="skolem">qs2</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
      RULE_FMT<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">r1</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">q1</span> <span class="main">→</span> <span class="skolem">l</span> <span class="skolem">qs1</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">r2</span><span class="main">=</span><span class="main">(</span><span class="skolem">q2</span> <span class="main">→</span> <span class="skolem">l</span> <span class="skolem">qs2</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">r1</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">r2</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="comment1">― ‹If the rhs have different lengths, the algorithm ignores the rule:›</span>
      <span class="keyword3"><span class="command">assume</span></span> LEN<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>rhsq <span class="skolem">r1</span><span class="main">)</span> <span class="main">≠</span> length <span class="main">(</span>rhsq <span class="skolem">r2</span><span class="main">)</span>"</span></span>
      
      <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"δ_prod_sng2 <span class="main">{</span><span class="skolem">r1</span><span class="main">}</span> <span class="skolem">r2</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> δ_prod_sng2_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> ta_rule.split<span class="main">)</span>

      <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> prems 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> LEN δ_prod_insert<span class="main">)</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
      <span class="comment1">― ‹If the rhs have the same length, the rule is inserted›</span>
      <span class="keyword3"><span class="command">assume</span></span> LEN<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>rhsq <span class="skolem">r1</span><span class="main">)</span> <span class="main">=</span> length <span class="main">(</span>rhsq <span class="skolem">r2</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="skolem">qs1</span> <span class="main">=</span> length <span class="skolem">qs2</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RULE_FMT<span class="main">)</span>

      <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"δ_prod_sng2 <span class="main">{</span><span class="skolem">r1</span><span class="main">}</span> <span class="skolem">r2</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="skolem">q1</span><span class="main">,</span><span class="skolem">q2</span><span class="main">)</span> <span class="main">→</span> <span class="skolem">l</span> <span class="main">(</span>zip <span class="skolem">qs1</span> <span class="skolem">qs2</span><span class="main">)</span><span class="main">}</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> prems<span class="main">(</span>1<span class="main">,</span>4<span class="main">)</span> G'
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> δ_prod_sng2_def RULE_FMT<span class="main">)</span>

      <span class="comment1">― ‹Obtain invariant of previous state›</span>
      <span class="keyword1"><span class="command">from</span></span> prems<span class="main">(</span>6<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> inv_def<span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">Wn</span></span> <span class="keyword2"><span class="keyword">where</span></span> INVH<span class="main">:</span>
        <span class="quoted"><span class="quoted">"distinct <span class="skolem">Wn</span>"</span></span>
        <span class="quoted"><span class="quoted">"set <span class="skolem">Wn</span> <span class="main">=</span> f_succ <span class="main">(</span>δ_prod <span class="main">(</span>ls_α <span class="main">(</span>hta_δ <span class="free">H1</span><span class="main">)</span> <span class="main">-</span> <span class="skolem">it1</span><span class="main">)</span> <span class="main">(</span>ls_α <span class="main">(</span>hta_δ <span class="free">H2</span><span class="main">)</span><span class="main">)</span> 
                          <span class="main">∪</span> δ_prod <span class="main">{</span><span class="skolem">r1</span><span class="main">}</span> <span class="main">(</span>ls_α <span class="main">(</span>hta_δ <span class="free">H2</span><span class="main">)</span> <span class="main">-</span> <span class="skolem">it2</span><span class="main">)</span><span class="main">)</span> 
                  <span class="main">``</span> <span class="main">{</span><span class="main">(</span><span class="skolem">q1</span><span class="main">,</span> <span class="skolem">q2</span><span class="main">)</span><span class="main">}</span> <span class="main">-</span> hs_α <span class="free">Q</span>"</span></span>
        <span class="quoted"><span class="quoted">"<span class="skolem">Wh</span> <span class="main">=</span> <span class="skolem">Wn</span> <span class="main">@</span> <span class="skolem">Wtl</span>"</span></span> 
        <span class="quoted"><span class="quoted">"hs_α <span class="skolem">Qh</span> <span class="main">=</span> hs_α <span class="free">Q</span> 
                   <span class="main">∪</span> f_succ <span class="main">(</span>δ_prod <span class="main">(</span>ls_α <span class="main">(</span>hta_δ <span class="free">H1</span><span class="main">)</span> <span class="main">-</span> <span class="skolem">it1</span><span class="main">)</span> <span class="main">(</span>ls_α <span class="main">(</span>hta_δ <span class="free">H2</span><span class="main">)</span><span class="main">)</span>
                              <span class="main">∪</span> δ_prod <span class="main">{</span><span class="skolem">r1</span><span class="main">}</span> <span class="main">(</span>ls_α <span class="main">(</span>hta_δ <span class="free">H2</span><span class="main">)</span> <span class="main">-</span> <span class="skolem">it2</span><span class="main">)</span><span class="main">)</span> 
                      <span class="main">``</span> <span class="main">{</span><span class="main">(</span><span class="skolem">q1</span><span class="main">,</span> <span class="skolem">q2</span><span class="main">)</span><span class="main">}</span>"</span></span> 
        <span class="quoted"><span class="quoted">"ls_α <span class="skolem">δdh</span> <span class="main">=</span> ls_α <span class="free">δd</span> 
          <span class="main">∪</span> <span class="main">{</span><span class="bound">r</span><span class="main">.</span> <span class="main">(</span> <span class="bound">r</span> <span class="main">∈</span> δ_prod <span class="main">(</span>ls_α <span class="main">(</span>hta_δ <span class="free">H1</span><span class="main">)</span> <span class="main">-</span> <span class="skolem">it1</span><span class="main">)</span> <span class="main">(</span>ls_α <span class="main">(</span>hta_δ <span class="free">H2</span><span class="main">)</span><span class="main">)</span> 
                  <span class="main">∨</span> <span class="bound">r</span> <span class="main">∈</span> δ_prod <span class="main">{</span><span class="skolem">r1</span><span class="main">}</span> <span class="main">(</span>ls_α <span class="main">(</span>hta_δ <span class="free">H2</span><span class="main">)</span> <span class="main">-</span> <span class="skolem">it2</span><span class="main">)</span>
                 <span class="main">)</span> <span class="main">∧</span> lhs <span class="bound">r</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">q1</span><span class="main">,</span> <span class="skolem">q2</span><span class="main">)</span>
             <span class="main">}</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

      <span class="comment1">― ‹Required to justify disjoint insert›</span>
      <span class="keyword1"><span class="command">have</span></span> RPD<span class="main">:</span> <span class="quoted"><span class="quoted">"r_prod <span class="skolem">r1</span> <span class="skolem">r2</span> <span class="main">∉</span> ls_α <span class="skolem">δdh</span>"</span></span> 
      <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
        <span class="keyword1"><span class="command">from</span></span> INV<span class="main">[</span><span class="operator">unfolded</span> pa_invar_def frp_invar_def frp_invar_add_def<span class="main">]</span>
        <span class="keyword1"><span class="command">have</span></span> LSDD<span class="main">:</span> 
          <span class="quoted"><span class="quoted">"ls_α <span class="free">δd</span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">r</span></span> <span class="main">∈</span> δ_prod <span class="main">(</span>ls_α <span class="main">(</span>hta_δ <span class="free">H1</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>ls_α <span class="main">(</span>hta_δ <span class="free">H2</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> 
                        lhs <span class="bound">r</span> <span class="main">∈</span> hs_α <span class="free">Q</span> <span class="main">-</span> set <span class="free">W</span><span class="main">}</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pa_α_def hta_α_def<span class="main">)</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"r_prod <span class="skolem">r1</span> <span class="skolem">r2</span> <span class="main">∉</span> ls_α <span class="free">δd</span>"</span></span>
        <span class="keyword1"><span class="command">proof</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"r_prod <span class="skolem">r1</span> <span class="skolem">r2</span> <span class="main">∈</span> ls_α <span class="free">δd</span>"</span></span>
          <span class="keyword1"><span class="command">with</span></span> LSDD <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lhs <span class="main">(</span>r_prod <span class="skolem">r1</span> <span class="skolem">r2</span><span class="main">)</span> <span class="main">∉</span> set <span class="free">W</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> prems<span class="main">(</span>1<span class="main">,</span>4<span class="main">)</span> G' <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lhs <span class="main">(</span>r_prod <span class="skolem">r1</span> <span class="skolem">r2</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">q1</span><span class="main">,</span><span class="skolem">q2</span><span class="main">)</span>"</span></span> 
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">r1</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">r2</span></span><span class="main">)</span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> prems<span class="main">(</span>6<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ls_α <span class="skolem">δdh</span> <span class="main">=</span> 
          ls_α <span class="free">δd</span> <span class="main">∪</span> 
          <span class="main">{</span><span class="bound">r</span><span class="main">.</span> <span class="main">(</span> <span class="bound">r</span> <span class="main">∈</span> δ_prod <span class="main">(</span>ls_α <span class="main">(</span>hta_δ <span class="free">H1</span><span class="main">)</span> <span class="main">-</span> <span class="skolem">it1</span><span class="main">)</span> <span class="main">(</span>ls_α <span class="main">(</span>hta_δ <span class="free">H2</span><span class="main">)</span><span class="main">)</span> 
                <span class="main">∨</span> <span class="bound">r</span> <span class="main">∈</span> δ_prod <span class="main">{</span><span class="skolem">r1</span><span class="main">}</span> <span class="main">(</span>ls_α <span class="main">(</span>hta_δ <span class="free">H2</span><span class="main">)</span> <span class="main">-</span> <span class="skolem">it2</span><span class="main">)</span>
              <span class="main">)</span> <span class="main">∧</span> lhs <span class="bound">r</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">q1</span><span class="main">,</span> <span class="skolem">q2</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span><span class="main">=</span> <span class="main">_</span> <span class="main">∪</span> <span class="var">?s</span>"</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inv_def<span class="main">)</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"r_prod <span class="skolem">r1</span> <span class="skolem">r2</span> <span class="main">∉</span> <span class="var">?s</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> prems<span class="main">(</span>1<span class="main">,</span>4<span class="main">)</span> G'<span class="main">(</span>2<span class="main">)</span> LEN
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">r1</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">r2</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> δ_prod_def<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">qed</span></span>

      <span class="comment1">― ‹Correctness of result of <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">pa_upd_rule</span><span class="antiquote">}</span></span>›</span>
      <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">Q'</span></span> <span class="skolem"><span class="skolem">W'</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
        PAUF<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>pa_upd_rule <span class="skolem">Qh</span> <span class="skolem">Wh</span> <span class="main">(</span>rhsq <span class="main">(</span>r_prod <span class="skolem">r1</span> <span class="skolem">r2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">Q'</span><span class="main">,</span><span class="skolem">W'</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
      <span class="keyword1"><span class="command">from</span></span> pa_upd_rule_correct<span class="main">[</span><span class="operator">OF</span> INVAH<span class="main"><span class="main"><span class="main"><span class="main">(</span></span></span></span>1<span class="main"><span class="main"><span class="main"><span class="main">)</span></span></span></span> PAUF<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">Wnn</span></span> <span class="keyword2"><span class="keyword">where</span></span> UC<span class="main">:</span>
        <span class="quoted"><span class="quoted">"hs_invar <span class="skolem">Q'</span>"</span></span>
        <span class="quoted"><span class="quoted">"hs_α <span class="skolem">Q'</span> <span class="main">=</span> hs_α <span class="skolem">Qh</span> <span class="main">∪</span> set <span class="main">(</span>rhsq <span class="main">(</span>r_prod <span class="skolem">r1</span> <span class="skolem">r2</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="quoted"><span class="quoted">"distinct <span class="skolem">Wnn</span>"</span></span> 
        <span class="quoted"><span class="quoted">"set <span class="skolem">Wnn</span> <span class="main">=</span> set <span class="main">(</span>rhsq <span class="main">(</span>r_prod <span class="skolem">r1</span> <span class="skolem">r2</span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> hs_α <span class="skolem">Qh</span>"</span></span> 
        <span class="quoted"><span class="quoted">"<span class="skolem">W'</span> <span class="main">=</span> <span class="skolem">Wnn</span> <span class="main">@</span> <span class="skolem">Wh</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

      <span class="comment1">― ‹Put it all together›</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> LEN Let_def ls.ins_dj_correct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> INVAH<span class="main"><span class="main"><span class="main"><span class="main">(</span></span></span></span>2<span class="main"><span class="main"><span class="main"><span class="main">)</span></span></span></span> RPD<span class="main"><span class="main">]</span></span> 
                         PAUF inv_def UC<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="skolem">Wnn</span><span class="main">@</span><span class="skolem">Wn</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> f_succ_alt δ_prod_insert RULE_FMT UC INVH 
                              δ_prod_sng2_def δ_prod_sng1_def<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">from</span></span> G <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?T1</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"pa_step <span class="free">H1</span> <span class="free">H2</span> <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">,</span><span class="free">δd</span><span class="main">)</span>"</span></span><span class="main">)</span>
       <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pa_invar_add_def inv_def<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> G <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?T2</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"pa_step <span class="free">H1</span> <span class="free">H2</span> <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">,</span><span class="free">δd</span><span class="main">)</span>"</span></span><span class="main">)</span>
       <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inv_def pa_α_def Let_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> frp_step.intros<span class="main">)</span>

<span class="keyword1"><span class="command">qed</span></span>
    
  

  <span class="comment1">― ‹The product-automaton algorithm is a precise implementation of its
      specification›</span>
<span class="keyword1"><span class="command">lemma</span></span> pa_pref_frp<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> TA<span class="main">:</span> <span class="quoted"><span class="quoted">"hashedTa <span class="free">H1</span>"</span></span> <span class="quoted"><span class="quoted">"hashedTa <span class="free">H2</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> idx<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hta_has_idx_s <span class="free">H1</span>"</span></span> <span class="quoted"><span class="quoted">"hta_has_idx_sf <span class="free">H2</span>"</span></span>

  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"wa_precise_refine <span class="main">(</span>det_wa_wa <span class="main">(</span>pa_det_algo <span class="free">H1</span> <span class="free">H2</span><span class="main">)</span><span class="main">)</span> 
                           <span class="main">(</span>frp_algo <span class="main">(</span>hta_α <span class="free">H1</span><span class="main">)</span> <span class="main">(</span>hta_α <span class="free">H2</span><span class="main">)</span><span class="main">)</span> 
                           pa_α"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> h1<span class="main">:</span> hashedTa <span class="quoted"><span class="free">H1</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword1"><span class="command">interpret</span></span> h2<span class="main">:</span> hashedTa <span class="quoted"><span class="free">H2</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> det_wa_wa_def pa_det_algo_def pa_α_def 
                          pa_cond_def frp_algo_def frp_cond_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> det_wa_wa_def pa_det_algo_def pa_cond_def
                          hta_α_def frp_algo_def frp_cond_def 
                <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> pa_step_correct<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> TA<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> det_wa_wa_def pa_det_algo_def pa_α_def 
                          hta_α_def pa_cond_def frp_algo_def frp_cond_def
                          pa_invar_def pa_step_def pa_initial_def 
                          hs.correct ls.correct Let_def hhh_cart.cart_correct 
                <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> frp_initial.intros
    <span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>3<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>


  <span class="comment1">― ‹The product automaton algorithm is a correct while-algorithm›</span>
<span class="keyword1"><span class="command">lemma</span></span> pa_while_algo<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> TA<span class="main">:</span> <span class="quoted"><span class="quoted">"hashedTa <span class="free">H1</span>"</span></span> <span class="quoted"><span class="quoted">"hashedTa <span class="free">H2</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> idx<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hta_has_idx_s <span class="free">H1</span>"</span></span> <span class="quoted"><span class="quoted">"hta_has_idx_sf <span class="free">H2</span>"</span></span>

  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"while_algo <span class="main">(</span>det_wa_wa <span class="main">(</span>pa_det_algo <span class="free">H1</span> <span class="free">H2</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> h1<span class="main">:</span> hashedTa <span class="quoted"><span class="free">H1</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword1"><span class="command">interpret</span></span> h2<span class="main">:</span> hashedTa <span class="quoted"><span class="free">H2</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>

  <span class="keyword1"><span class="command">interpret</span></span> ref<span class="main">:</span> wa_precise_refine <span class="quoted"><span class="quoted">"<span class="main">(</span>det_wa_wa <span class="main">(</span>pa_det_algo <span class="free">H1</span> <span class="free">H2</span><span class="main">)</span><span class="main">)</span>"</span></span> 
                                   <span class="quoted"><span class="quoted">"<span class="main">(</span>frp_algo <span class="main">(</span>hta_α <span class="free">H1</span><span class="main">)</span> <span class="main">(</span>hta_α <span class="free">H2</span><span class="main">)</span><span class="main">)</span>"</span></span> 
                                   <span class="quoted"><span class="quoted">"pa_α"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> pa_pref_frp<span class="main">[</span><span class="operator">OF</span> TA idx<span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ref.wa_intro<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> frp_while_algo<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> det_wa_wa_def pa_det_algo_def pa_invar_def frp_algo_def<span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> det_wa_wa_def pa_det_algo_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> pa_step_correct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> TA idx<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pa_invar_def frp_algo_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>
    
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> det_wa_wa_def pa_det_algo_def pa_initial_def 
                     pa_invar_add_def Let_def hhh_cart.cart_correct ls.correct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>
    
<span class="comment1">― ‹By definition, the product automaton algorithm is deterministic›</span>
<span class="keyword1"><span class="command">lemmas</span></span> pa_det_while_algo <span class="main">=</span> det_while_algo_intro<span class="main">[</span><span class="operator">OF</span> pa_while_algo<span class="main">]</span>

<span class="comment1">― ‹Transferred correctness lemma›</span>
<span class="keyword1"><span class="command">lemmas</span></span> pa_inv_final <span class="main">=</span> 
  wa_precise_refine.transfer_correctness<span class="main">[</span><span class="operator">OF</span> pa_pref_frp frp_inv_final<span class="main">]</span>


<span class="comment1">― ‹The next two definitions specify the product-automata algorithm. The first
    version requires the s-index of the first and the sf-index of the second
    automaton to be present, while the second version computes the required 
    indices, if necessary›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hta_prod'</span> <span class="free"><span class="bound"><span class="entity">H1</span></span></span> <span class="free"><span class="bound"><span class="entity">H2</span></span></span> <span class="main">==</span>
  <span class="keyword1">let</span> <span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">δd</span><span class="main">)</span> <span class="main">=</span> while pa_cond <span class="main">(</span>pa_step <span class="free"><span class="bound"><span class="entity">H1</span></span></span> <span class="free"><span class="bound"><span class="entity">H2</span></span></span><span class="main">)</span> <span class="main">(</span>pa_initial <span class="free"><span class="bound"><span class="entity">H1</span></span></span> <span class="free"><span class="bound"><span class="entity">H2</span></span></span><span class="main">)</span> <span class="keyword1">in</span>
    init_hta <span class="main">(</span>hhh_cart.cart <span class="main">(</span>hta_Qi <span class="free"><span class="bound"><span class="entity">H1</span></span></span><span class="main">)</span> <span class="main">(</span>hta_Qi <span class="free"><span class="bound"><span class="entity">H2</span></span></span><span class="main">)</span><span class="main">)</span> <span class="bound">δd</span>
  "</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hta_prod</span> <span class="free"><span class="bound"><span class="entity">H1</span></span></span> <span class="free"><span class="bound"><span class="entity">H2</span></span></span> <span class="main">==</span> 
  hta_prod' <span class="main">(</span>hta_ensure_idx_s <span class="free"><span class="bound"><span class="entity">H1</span></span></span><span class="main">)</span> <span class="main">(</span>hta_ensure_idx_sf <span class="free"><span class="bound"><span class="entity">H2</span></span></span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">lemma</span></span> hta_prod'_correct_aux<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> TA<span class="main">:</span> <span class="quoted"><span class="quoted">"hashedTa <span class="free">H1</span>"</span></span> <span class="quoted"><span class="quoted">"hashedTa <span class="free">H2</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> idx<span class="main">:</span> <span class="quoted"><span class="quoted">"hta_has_idx_s <span class="free">H1</span>"</span></span> <span class="quoted"><span class="quoted">"hta_has_idx_sf <span class="free">H2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"hta_α <span class="main">(</span>hta_prod' <span class="free">H1</span> <span class="free">H2</span><span class="main">)</span> 
         <span class="main">=</span> ta_fwd_reduce <span class="main">(</span>ta_prod <span class="main">(</span>hta_α <span class="free">H1</span><span class="main">)</span> <span class="main">(</span>hta_α <span class="free">H2</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T1</span></span></span><span class="main">)</span>
        <span class="quoted"><span class="quoted">"hashedTa <span class="main">(</span>hta_prod' <span class="free">H1</span> <span class="free">H2</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T2</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> h1<span class="main">:</span> hashedTa <span class="quoted"><span class="free">H1</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword1"><span class="command">interpret</span></span> h2<span class="main">:</span> hashedTa <span class="quoted"><span class="free">H2</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>

  <span class="keyword1"><span class="command">interpret</span></span> dwa<span class="main">:</span> det_while_algo <span class="quoted"><span class="quoted">"pa_det_algo <span class="free">H1</span> <span class="free">H2</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> pa_det_while_algo<span class="main">[</span><span class="operator">OF</span> TA idx<span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">have</span></span> LC<span class="main">:</span> <span class="quoted"><span class="quoted">"while pa_cond <span class="main">(</span>pa_step <span class="free">H1</span> <span class="free">H2</span><span class="main">)</span> <span class="main">(</span>pa_initial <span class="free">H1</span> <span class="free">H2</span><span class="main">)</span> <span class="main">=</span> dwa.loop"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> dwa.loop_def<span class="main">)</span>
       <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pa_det_algo_def<span class="main">)</span>

  <span class="keyword1"><span class="command">from</span></span> dwa.while_proof'<span class="main">[</span><span class="operator">OF</span> pa_inv_final<span class="main"><span class="main">[</span></span><span class="operator">OF</span> TA idx<span class="main"><span class="main">]</span></span><span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?T1</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> dwa.loop_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hta_prod'_def init_hta_def hta_α_def pa_det_algo_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>while pa_cond <span class="main">(</span>pa_step <span class="free">H1</span> <span class="free">H2</span><span class="main">)</span> <span class="main">(</span>pa_initial <span class="free">H1</span> <span class="free">H2</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pa_α_def hhh_cart.cart_correct hta_α_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?T2</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hta_prod'_def LC<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> dwa.while_proof<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">s</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pa_det_algo_def pa_invar_add_def pa_invar_def init_hta_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hhh_cart.cart_correct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> hta_prod'_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> TA<span class="main">:</span> <span class="quoted"><span class="quoted">"hashedTa <span class="free">H1</span>"</span></span> <span class="quoted"><span class="quoted">"hashedTa <span class="free">H2</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> HI<span class="main">:</span> <span class="quoted"><span class="quoted">"hta_has_idx_s <span class="free">H1</span>"</span></span> <span class="quoted"><span class="quoted">"hta_has_idx_sf <span class="free">H2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> 
    <span class="quoted"><span class="quoted">"ta_lang <span class="main">(</span>hta_α <span class="main">(</span>hta_prod' <span class="free">H1</span> <span class="free">H2</span><span class="main">)</span><span class="main">)</span> 
     <span class="main">=</span> ta_lang <span class="main">(</span>hta_α <span class="free">H1</span><span class="main">)</span> <span class="main">∩</span> ta_lang <span class="main">(</span>hta_α <span class="free">H2</span><span class="main">)</span>"</span></span>

    <span class="quoted"><span class="quoted">"hashedTa <span class="main">(</span>hta_prod' <span class="free">H1</span> <span class="free">H2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hta_prod'_correct_aux<span class="main"><span class="main">[</span></span><span class="operator">OF</span> TA HI<span class="main"><span class="main">]</span></span> ta_prod_correct_aux1<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> hta_prod_correct_aux<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> TA<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hashedTa <span class="free">H1</span>"</span></span> <span class="quoted"><span class="quoted">"hashedTa <span class="free">H2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> 
    <span class="quoted"><span class="quoted">"hta_α <span class="main">(</span>hta_prod <span class="free">H1</span> <span class="free">H2</span><span class="main">)</span> <span class="main">=</span> ta_fwd_reduce <span class="main">(</span>ta_prod <span class="main">(</span>hta_α <span class="free">H1</span><span class="main">)</span> <span class="main">(</span>hta_α <span class="free">H2</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"hashedTa <span class="main">(</span>hta_prod <span class="free">H1</span> <span class="free">H2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> hta_prod_def<span class="main">)</span>
     <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hta_prod'_correct_aux<span class="main">)</span>
  
<span class="keyword1"><span class="command">theorem</span></span> hta_prod_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> TA<span class="main">:</span> <span class="quoted"><span class="quoted">"hashedTa <span class="free">H1</span>"</span></span> <span class="quoted"><span class="quoted">"hashedTa <span class="free">H2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> 
    <span class="quoted"><span class="quoted">"ta_lang <span class="main">(</span>hta_α <span class="main">(</span>hta_prod <span class="free">H1</span> <span class="free">H2</span><span class="main">)</span><span class="main">)</span> 
     <span class="main">=</span> ta_lang <span class="main">(</span>hta_α <span class="free">H1</span><span class="main">)</span> <span class="main">∩</span> ta_lang <span class="main">(</span>hta_α <span class="free">H2</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"hashedTa <span class="main">(</span>hta_prod <span class="free">H1</span> <span class="free">H2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hta_prod_correct_aux<span class="main"><span class="main">[</span></span><span class="operator">OF</span> TA<span class="main"><span class="main">]</span></span> ta_prod_correct_aux1<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Remap States"</span></span>

<span class="comment1">― ‹Mapping the states of an automaton›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">hta_remap</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'q</span><span class="main">::</span>hashable <span class="main">⇒</span> <span class="tfree">'qn</span><span class="main">::</span>hashable<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'q</span><span class="main">,</span><span class="tfree">'l</span><span class="main">::</span>hashable<span class="main">)</span> hashedTa 
      <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'qn</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> hashedTa"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">hta_remap</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">H</span></span></span> <span class="main">==</span> 
    init_hta <span class="main">(</span>hh_set_xy.g_image <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>hta_Qi <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">)</span><span class="main">)</span> 
      <span class="main">(</span>ll_set_xy.g_image <span class="main">(</span>remap_rule <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span> <span class="main">(</span>hta_δ <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> hashedTa<span class="main">)</span> hta_remap_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"hta_α <span class="main">(</span>hta_remap <span class="free">f</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> ta_remap <span class="free">f</span> <span class="main">(</span>hta_α <span class="free">H</span><span class="main">)</span>"</span></span>
        <span class="quoted"><span class="quoted">"hashedTa <span class="main">(</span>hta_remap <span class="free">f</span> <span class="free">H</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
    <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hta_remap_def init_hta_def hta_α_def 
              hh_set_xy.image_correct ll_set_xy.image_correct ta_remap_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hh_set_xy.image_correct ll_set_xy.image_correct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">"Reindex Automaton"</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  In this section, an algorithm for re-indexing the states of the automaton to
  an initial segment of the naturals is implemented. The language of the 
  automaton is not changed by the reindexing operation.
›</span></span>

  <span class="comment1">― ‹Set of states of a rule›</span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">rule_states_l</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rule_states_l</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">→</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">qs</span></span></span><span class="main">)</span> <span class="main">=</span> ls_ins <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">(</span>ls.from_list <span class="free"><span class="bound"><span class="entity">qs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> rule_states_l_correct<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"ls_α <span class="main">(</span>rule_states_l <span class="free">r</span><span class="main">)</span> <span class="main">=</span> rule_states <span class="free">r</span>"</span></span>
  <span class="quoted"><span class="quoted">"ls_invar <span class="main">(</span>rule_states_l <span class="free">r</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">r</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ls.correct<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hta_δ_states</span> <span class="free"><span class="bound"><span class="entity">H</span></span></span> 
  <span class="main">==</span> <span class="main">(</span>llh_set_xyy.g_Union_image id <span class="main">(</span>ll_set_xy.g_image_filter 
       <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> Some <span class="main">(</span>rule_states_l <span class="bound">r</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>hta_δ <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hta_states</span> <span class="free"><span class="bound"><span class="entity">H</span></span></span> <span class="main">==</span>
  hs_union <span class="main">(</span>hta_Qi <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">)</span> <span class="main">(</span>hta_δ_states <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> hashedTa<span class="main">)</span> hta_δ_states_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"hs_α <span class="main">(</span>hta_δ_states <span class="free">H</span><span class="main">)</span> <span class="main">=</span> δ_states <span class="main">(</span>ta_rules <span class="main">(</span>hta_α <span class="free">H</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"hs_invar <span class="main">(</span>hta_δ_states <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hta_α_def hta_δ_states_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 1
  <span class="keyword1"><span class="command">have</span></span> 
    <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ls_α <span class="main">(</span>ll_set_xy.g_image_filter <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> Some <span class="main">(</span>rule_states_l <span class="bound">x</span><span class="main">)</span><span class="main">)</span> δ<span class="main">)</span> 
             <span class="main">=</span> rule_states_l <span class="main">`</span> ls_α δ"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ll_set_xy.image_filter_correct<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> δ_states_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span>
      llh_set_xyy.Union_image_correct<span class="main"><span class="main">[</span></span>
        <span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span>ll_set_xy.g_image_filter <span class="main"><span class="main">(</span></span><span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">x</span></span><span class="main"><span class="main">.</span></span> Some <span class="main"><span class="main">(</span></span>rule_states_l <span class="bound"><span class="bound">x</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">)</span></span> δ<span class="main"><span class="main">)</span></span>"</span></span></span><span class="main"><span class="main">,</span></span> 
        <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ll_set_xy.image_filter_correct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="comment1">(*next
  case goal2 thus ?case
    apply (rule llh.Union_image_correct)
    apply (auto simp add: ls.image_filter_correct)
    done*)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> hashedTa<span class="main">)</span> hta_states_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"hs_α <span class="main">(</span>hta_states <span class="free">H</span><span class="main">)</span> <span class="main">=</span> ta_rstates <span class="main">(</span>hta_α <span class="free">H</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"hs_invar <span class="main">(</span>hta_states <span class="free">H</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> 
    <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hta_states_def ta_rstates_def hs.correct hta_δ_states_correct 
         hta_α_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">reindex_map</span> <span class="free"><span class="bound"><span class="entity">H</span></span></span> <span class="main">==</span> 
  <span class="main">λ</span><span class="bound">q</span><span class="main">.</span> the <span class="main">(</span>hm_lookup <span class="bound">q</span> <span class="main">(</span>hh_map_to_nat.map_to_nat <span class="main">(</span>hta_states <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">hta_reindex</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'L</span><span class="main">::</span>hashable<span class="main">)</span> hashedTa <span class="main">⇒</span> <span class="main">(</span>nat<span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> hashedTa"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">hta_reindex</span> <span class="free"><span class="bound"><span class="entity">H</span></span></span> <span class="main">==</span> hta_remap <span class="main">(</span>reindex_map <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">H</span></span></span>"</span></span>

<span class="keyword1"><span class="command">declare</span></span> hta_reindex_def <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">del</span><span class="main">]</span>

  <span class="comment1">― ‹This version is more efficient, as the map is only computed once›</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hta_reindex <span class="free">H</span> <span class="main">=</span> <span class="main">(</span>
  <span class="keyword1">let</span> <span class="bound">mp</span> <span class="main">=</span> <span class="main">(</span>hh_map_to_nat.map_to_nat <span class="main">(</span>hta_states <span class="free">H</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">in</span>
    hta_remap <span class="main">(</span><span class="main">λ</span><span class="bound">q</span><span class="main">.</span> the <span class="main">(</span>hm_lookup <span class="bound">q</span> <span class="bound">mp</span><span class="main">)</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span>
  "</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def hta_reindex_def reindex_map_def<span class="main">)</span>


<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> hashedTa<span class="main">)</span> reindex_map_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"inj_on <span class="main">(</span>reindex_map <span class="free">H</span><span class="main">)</span> <span class="main">(</span>ta_rstates <span class="main">(</span>hta_α <span class="free">H</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"reindex_map <span class="free">H</span> <span class="main">=</span> the <span class="main">∘</span> hm_α <span class="main">(</span>hh_map_to_nat.map_to_nat <span class="main">(</span>hta_states <span class="free">H</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span>
       <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> reindex_map_def hm.correct 
         hh_map_to_nat.map_to_nat_correct<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> 
         hta_states_correct<span class="main">)</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hta_states_correct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> inj_on_map_the<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hh_map_to_nat.map_to_nat_correct hta_states_correct<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> hashedTa<span class="main">)</span> hta_reindex_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ta_lang <span class="main">(</span>hta_α <span class="main">(</span>hta_reindex <span class="free">H</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> ta_lang <span class="main">(</span>hta_α <span class="free">H</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"hashedTa <span class="main">(</span>hta_reindex <span class="free">H</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> hta_reindex_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> 
    <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hta_remap_correct tree_automaton.remap_lang<span class="main"><span class="main">[</span></span><span class="operator">OF</span> hta_α_is_ta<span class="main"><span class="main">]</span></span> 
         reindex_map_correct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Union"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">"Computes the union of two automata"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">hta_union</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'q1</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'l</span><span class="main">::</span>hashable<span class="main">)</span> hashedTa 
      <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'q2</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> hashedTa 
      <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'q1</span><span class="main">,</span><span class="tfree">'q2</span><span class="main">)</span> ustate_wrapper<span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> hashedTa"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">hta_union</span> <span class="free"><span class="bound"><span class="entity">H1</span></span></span> <span class="free"><span class="bound"><span class="entity">H2</span></span></span> <span class="main">==</span> 
    init_hta <span class="main">(</span>hs_union <span class="main">(</span>hh_set_xy.g_image USW1 <span class="main">(</span>hta_Qi <span class="free"><span class="bound"><span class="entity">H1</span></span></span><span class="main">)</span><span class="main">)</span> 
                       <span class="main">(</span>hh_set_xy.g_image USW2 <span class="main">(</span>hta_Qi <span class="free"><span class="bound"><span class="entity">H2</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
             <span class="main">(</span>ls_union_dj <span class="main">(</span>ll_set_xy.g_image <span class="main">(</span>remap_rule USW1<span class="main">)</span> <span class="main">(</span>hta_δ <span class="free"><span class="bound"><span class="entity">H1</span></span></span><span class="main">)</span><span class="main">)</span> 
                          <span class="main">(</span>ll_set_xy.g_image <span class="main">(</span>remap_rule USW2<span class="main">)</span> <span class="main">(</span>hta_δ <span class="free"><span class="bound"><span class="entity">H2</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> hta_union_correct'<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> TA<span class="main">:</span> <span class="quoted"><span class="quoted">"hashedTa <span class="free">H1</span>"</span></span> <span class="quoted"><span class="quoted">"hashedTa <span class="free">H2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"hta_α <span class="main">(</span>hta_union <span class="free">H1</span> <span class="free">H2</span><span class="main">)</span> 
         <span class="main">=</span> ta_union_wrap <span class="main">(</span>hta_α <span class="free">H1</span><span class="main">)</span> <span class="main">(</span>hta_α <span class="free">H2</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T1</span></span></span><span class="main">)</span>
        <span class="quoted"><span class="quoted">"hashedTa <span class="main">(</span>hta_union <span class="free">H1</span> <span class="free">H2</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T2</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> a1<span class="main">:</span> hashedTa <span class="quoted"><span class="free">H1</span></span> <span class="main">+</span> a2<span class="main">:</span> hashedTa <span class="quoted"><span class="free">H2</span></span> <span class="keyword1"><span class="command">using</span></span> TA <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?T1</span></span></span> <span class="var"><span class="quoted"><span class="var">?T2</span></span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
      <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hta_union_def init_hta_def hta_α_def 
                hs.correct ls.correct 
                ll_set_xy.image_correct hh_set_xy.image_correct
                ta_remap_def ta_union_def ta_union_wrap_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
      <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hs.correct ls.correct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> hta_union_correct<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> TA<span class="main">:</span> <span class="quoted"><span class="quoted">"hashedTa <span class="free">H1</span>"</span></span> <span class="quoted"><span class="quoted">"hashedTa <span class="free">H2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> 
    <span class="quoted"><span class="quoted">"ta_lang <span class="main">(</span>hta_α <span class="main">(</span>hta_union <span class="free">H1</span> <span class="free">H2</span><span class="main">)</span><span class="main">)</span> 
     <span class="main">=</span> ta_lang <span class="main">(</span>hta_α <span class="free">H1</span><span class="main">)</span> <span class="main">∪</span> ta_lang <span class="main">(</span>hta_α <span class="free">H2</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T1</span></span></span><span class="main">)</span>
    <span class="quoted"><span class="quoted">"hashedTa <span class="main">(</span>hta_union <span class="free">H1</span> <span class="free">H2</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T2</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> a1<span class="main">:</span> hashedTa <span class="quoted"><span class="free">H1</span></span> <span class="main">+</span> a2<span class="main">:</span> hashedTa <span class="quoted"><span class="free">H2</span></span> <span class="keyword1"><span class="command">using</span></span> TA <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?T1</span></span></span> <span class="var"><span class="quoted"><span class="var">?T2</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hta_union_correct'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> TA<span class="main"><span class="main">]</span></span> ta_union_wrap_correct<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Operators to Construct Tree Automata"</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This section defines operators that add initial states and rules to a tree 
  automaton, and thus incrementally construct a tree automaton from the empty
  automaton.
›</span></span>

<span class="comment1">― ‹The empty automaton›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">hta_empty</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"unit <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'q</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'l</span><span class="main">::</span>hashable<span class="main">)</span> hashedTa"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">hta_empty</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">==</span> init_hta <span class="main">(</span>hs_empty <span class="main">()</span><span class="main">)</span> <span class="main">(</span>ls_empty <span class="main">()</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> hta_empty_correct <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span></span></span></span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>hta_α <span class="main">(</span>hta_empty <span class="main">()</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> ta_empty"</span></span>
        <span class="quoted"><span class="quoted">"hashedTa <span class="main">(</span>hta_empty <span class="main">()</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span>
    <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> init_hta_def hta_empty_def hta_α_def δ_states_def ta_empty_def
              hs.correct ls.correct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hs.correct ls.correct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="comment1">― ‹Add an initial state to the automaton›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">hta_add_qi</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'q</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'q</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'l</span><span class="main">::</span>hashable<span class="main">)</span> hashedTa <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'q</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> hashedTa"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">hta_add_qi</span> <span class="free"><span class="bound"><span class="entity">qi</span></span></span> <span class="free"><span class="bound"><span class="entity">H</span></span></span> <span class="main">==</span> init_hta <span class="main">(</span>hs_ins <span class="free"><span class="bound"><span class="entity">qi</span></span></span> <span class="main">(</span>hta_Qi <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>hta_δ <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> hashedTa<span class="main">)</span> hta_add_qi_correct<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"hta_α <span class="main">(</span>hta_add_qi <span class="free">qi</span> <span class="free">H</span><span class="main">)</span> 
         <span class="main">=</span> <span class="main">⦇</span> ta_initial <span class="main">=</span> insert <span class="free">qi</span> <span class="main">(</span>ta_initial <span class="main">(</span>hta_α <span class="free">H</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> 
             ta_rules <span class="main">=</span> ta_rules <span class="main">(</span>hta_α <span class="free">H</span><span class="main">)</span> 
           <span class="main">⦈</span>"</span></span>
        <span class="quoted"><span class="quoted">"hashedTa <span class="main">(</span>hta_add_qi <span class="free">qi</span> <span class="free">H</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
    <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> init_hta_def hta_add_qi_def hta_α_def δ_states_def 
              hs.correct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hs.correct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span> <span class="main">=</span> hashedTa.hta_add_qi_correct

<span class="comment1">― ‹Add a rule to the automaton›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">hta_add_rule</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'q</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> ta_rule <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'q</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'l</span><span class="main">::</span>hashable<span class="main">)</span> hashedTa 
      <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'q</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> hashedTa"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">hta_add_rule</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">H</span></span></span> <span class="main">==</span> init_hta <span class="main">(</span>hta_Qi <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">)</span> <span class="main">(</span>ls_ins <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">(</span>hta_δ <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> hashedTa<span class="main">)</span> hta_add_rule_correct<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"hta_α <span class="main">(</span>hta_add_rule <span class="free">r</span> <span class="free">H</span><span class="main">)</span> 
         <span class="main">=</span> <span class="main">⦇</span> ta_initial <span class="main">=</span> ta_initial <span class="main">(</span>hta_α <span class="free">H</span><span class="main">)</span><span class="main">,</span> 
             ta_rules <span class="main">=</span> insert <span class="free">r</span> <span class="main">(</span>ta_rules <span class="main">(</span>hta_α <span class="free">H</span><span class="main">)</span><span class="main">)</span> 
           <span class="main">⦈</span>"</span></span>
        <span class="quoted"><span class="quoted">"hashedTa <span class="main">(</span>hta_add_rule <span class="free">r</span> <span class="free">H</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
    <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> init_hta_def hta_add_rule_def hta_α_def 
              δ_states_def ls.correct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ls.correct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span> <span class="main">=</span> hashedTa.hta_add_rule_correct


  <span class="comment1">― ‹Reduces an automaton to the given set of states›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hta_reduce</span> <span class="free"><span class="bound"><span class="entity">H</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">==</span>
  init_hta <span class="main">(</span>hs_inter <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">(</span>hta_Qi <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">)</span><span class="main">)</span> 
           <span class="main">(</span>ll_set_xy.g_image_filter 
              <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="keyword1">if</span> hs_memb <span class="main">(</span>lhs <span class="bound">r</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">∧</span> list_all <span class="main">(</span><span class="main">λ</span><span class="bound">q</span><span class="main">.</span> hs_memb <span class="bound">q</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">)</span> <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span> <span class="keyword1">then</span> Some <span class="bound">r</span> <span class="keyword1">else</span> None<span class="main">)</span> 
              <span class="main">(</span>hta_δ <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">)</span><span class="main">)</span>
"</span></span>

<span class="keyword1"><span class="command">theorem</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> hashedTa<span class="main">)</span> hta_reduce_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hs_invar <span class="free">Q</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"hta_α <span class="main">(</span>hta_reduce <span class="free">H</span> <span class="free">Q</span><span class="main">)</span> <span class="main">=</span> ta_reduce <span class="main">(</span>hta_α <span class="free">H</span><span class="main">)</span> <span class="main">(</span>hs_α <span class="free">Q</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T1</span></span></span><span class="main">)</span>
  <span class="quoted"><span class="quoted">"hashedTa <span class="main">(</span>hta_reduce <span class="free">H</span> <span class="free">Q</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T2</span></span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
    <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> 
      hta_reduce_def ta_reduce_def hta_α_def init_hta_def 
      hs.correct ls.correct
    <span class="comment1">(*hs_correct ls_correct *)</span>
      list_all_iff 
      reduce_rules_def rule_states_simp 
      ll_set_xy.image_filter_correct
    <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> 
      ta_rule.split_asm
  <span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> hta_reduce_def init_hta_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hs.correct ls.correct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>



<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Backwards Reduction and Emptiness Check"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The algorithm uses a map from states to the set of rules that contain 
  the state on their rhs.
›</span></span>

  <span class="comment1">― ‹Add an entry to the index›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">rqrm_add</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">res</span></span></span> <span class="main">==</span>
  <span class="keyword1">case</span> hm_lookup <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="free"><span class="bound"><span class="entity">res</span></span></span> <span class="keyword1">of</span>
    None <span class="main">⇒</span> hm_update <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">(</span>ls_ins <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">(</span>ls_empty <span class="main">()</span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">res</span></span></span> <span class="main">|</span>
    Some <span class="bound">s</span> <span class="main">⇒</span> hm_update <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">(</span>ls_ins <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="bound">s</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">res</span></span></span>
  "</span></span>

  <span class="comment1">― ‹Lookup the set of rules with given state on rhs›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">rqrm_lookup</span> <span class="free"><span class="bound"><span class="entity">rqrm</span></span></span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">==</span> <span class="keyword1">case</span> hm_lookup <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="free"><span class="bound"><span class="entity">rqrm</span></span></span> <span class="keyword1">of</span>
  None <span class="main">⇒</span> ls_empty <span class="main">()</span> <span class="main">|</span>
  Some <span class="bound">s</span> <span class="main">⇒</span> <span class="bound">s</span>
  "</span></span>

  <span class="comment1">― ‹Build the index from a set of rules›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">build_rqrm</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'q</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'l</span><span class="main">::</span>hashable<span class="main">)</span> ta_rule ls 
      <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'q</span><span class="main">,</span><span class="main">(</span><span class="tfree">'q</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> ta_rule ls<span class="main">)</span> hm"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">build_rqrm</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">==</span>
    ls_iteratei <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span>
      <span class="main">(</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">res</span><span class="main">.</span> 
        foldl <span class="main">(</span><span class="main">λ</span><span class="bound">res</span> <span class="bound">q</span><span class="main">.</span> rqrm_add <span class="bound">q</span> <span class="bound">r</span> <span class="bound">res</span><span class="main">)</span> <span class="bound">res</span> <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span>
      <span class="main">)</span>
      <span class="main">(</span>hm_empty <span class="main">()</span><span class="main">)</span>
  "</span></span>

<span class="comment1">― ‹Whether the index satisfies the map and set invariants›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">rqrm_invar</span> <span class="free"><span class="bound"><span class="entity">rqrm</span></span></span> <span class="main">==</span> 
  hm_invar <span class="free"><span class="bound"><span class="entity">rqrm</span></span></span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">q</span><span class="main">.</span> ls_invar <span class="main">(</span>rqrm_lookup <span class="free"><span class="bound"><span class="entity">rqrm</span></span></span> <span class="bound">q</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="comment1">― ‹Whether the index really maps a state to the set of rules with this 
    state on their rhs›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">rqrm_prop</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="free"><span class="bound"><span class="entity">rqrm</span></span></span> <span class="main">==</span> 
  <span class="main">∀</span><span class="bound">q</span><span class="main">.</span> ls_α <span class="main">(</span>rqrm_lookup <span class="free"><span class="bound"><span class="entity">rqrm</span></span></span> <span class="bound">q</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">δ</span></span></span><span class="main">.</span> <span class="bound">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> rqrm_α_lookup_update<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"rqrm_invar <span class="free">rqrm</span> <span class="main">⟹</span> 
    ls_α <span class="main">(</span>rqrm_lookup <span class="main">(</span>rqrm_add <span class="free">q</span> <span class="free">r</span> <span class="free">rqrm</span><span class="main">)</span> <span class="free">q'</span><span class="main">)</span> 
    <span class="main">=</span> <span class="main">(</span> <span class="keyword1">if</span> <span class="free">q</span><span class="main">=</span><span class="free">q'</span> <span class="keyword1">then</span> 
          insert <span class="free">r</span> <span class="main">(</span>ls_α <span class="main">(</span>rqrm_lookup <span class="free">rqrm</span> <span class="free">q'</span><span class="main">)</span><span class="main">)</span> 
        <span class="keyword1">else</span> 
          ls_α <span class="main">(</span>rqrm_lookup <span class="free">rqrm</span> <span class="free">q'</span><span class="main">)</span>
      <span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> 
    <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rqrm_lookup_def rqrm_add_def rqrm_invar_def hm.correct 
         ls.correct 
    <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm option.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> rqrm_propD<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"rqrm_prop <span class="free">δ</span> <span class="free">rqrm</span> <span class="main">⟹</span> ls_α <span class="main">(</span>rqrm_lookup <span class="free">rqrm</span> <span class="free">q</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span><span class="free">δ</span><span class="main">.</span> <span class="free">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rqrm_prop_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> build_rqrm_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">δ</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ls_invar <span class="free">δ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"rqrm_invar <span class="main">(</span>build_rqrm <span class="free">δ</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T1</span></span></span><span class="main">)</span> <span class="keyword2"><span class="keyword">and</span></span>
        <span class="quoted"><span class="quoted">"rqrm_prop <span class="main">(</span>ls_α <span class="free">δ</span><span class="main">)</span> <span class="main">(</span>build_rqrm <span class="free">δ</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T2</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"rqrm_invar <span class="main">(</span>build_rqrm <span class="free">δ</span><span class="main">)</span> <span class="main">∧</span> 
    <span class="main">(</span><span class="main">∀</span><span class="bound">q</span><span class="main">.</span> ls_α <span class="main">(</span>rqrm_lookup <span class="main">(</span>build_rqrm <span class="free">δ</span><span class="main">)</span> <span class="bound">q</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span>ls_α <span class="free">δ</span><span class="main">.</span> <span class="bound">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> build_rqrm_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> 
      I<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">it</span> <span class="bound">res</span><span class="main">.</span> <span class="main">(</span>rqrm_invar <span class="bound">res</span><span class="main">)</span> 
                  <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">q</span><span class="main">.</span> ls_α <span class="main">(</span>rqrm_lookup <span class="bound">res</span> <span class="bound">q</span><span class="main">)</span> 
                     <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span>ls_α <span class="free">δ</span> <span class="main">-</span> <span class="bound">it</span><span class="main">.</span> <span class="bound">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span> 
      <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> ls.iterate_rule_P<span class="main">)</span>
      <span class="comment1">― ‹Invar›</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="comment1">― ‹Initial›</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hm_correct ls_correct rqrm_lookup_def rqrm_invar_def<span class="main">)</span>
      <span class="comment1">― ‹Step›</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> 
      I<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">res</span> <span class="bound">itl</span> <span class="bound">itr</span><span class="main">.</span> 
        <span class="main">(</span>rqrm_invar <span class="bound">res</span><span class="main">)</span> 
        <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">q</span><span class="main">.</span> ls_α <span class="main">(</span>rqrm_lookup <span class="bound">res</span> <span class="bound">q</span><span class="main">)</span> 
           <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">r</span></span><span class="main">∈</span>ls_α <span class="free">δ</span> <span class="main">-</span> <span class="improper">it</span><span class="main">.</span> <span class="bound">q</span><span class="main">∈</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span><span class="main">}</span> 
             <span class="main">∪</span> <span class="main">{</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span><span class="main">=</span><span class="improper">x</span> <span class="main">∧</span> <span class="bound">q</span><span class="main">∈</span>set <span class="bound">itl</span><span class="main">}</span><span class="main">)</span>"</span></span> 
      <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> Misc.foldl_rule_P<span class="main">)</span>
        <span class="comment1">― ‹Initial›</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
        <span class="comment1">― ‹Step›</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> 
        <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rqrm_invar_def rqrm_add_def rqrm_lookup_def hm_correct 
             ls_correct 
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split option.split_asm<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> 
        <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rqrm_add_def rqrm_lookup_def hm_correct ls_correct 
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split option.split_asm<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
        <span class="comment1">― ‹Final›</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
      <span class="comment1">― ‹Final›</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?T1</span></span></span> <span class="var"><span class="quoted"><span class="var">?T2</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rqrm_prop_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">― ‹A state of the basic algorithm contains a set of discovered states, 
    a worklist and a map from rules to the number of distinct states on 
    its RHS that have not yet been discovered or are still on the worklist›</span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> brc_state 
  <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> hs <span class="main">×</span> <span class="tfree">'Q</span> list <span class="main">×</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule<span class="main">,</span> nat<span class="main">)</span> hm"</span></span>

<span class="comment1">― ‹Abstraction to <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">α'</span><span class="antiquote">}</span></span>-level:›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">brc_α</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'L</span><span class="main">::</span>hashable<span class="main">)</span> brc_state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> br'_state"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">brc_α</span> <span class="main">==</span> <span class="main">λ</span><span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">rcm</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span>hs_α <span class="bound">Q</span><span class="main">,</span> set <span class="bound">W</span><span class="main">,</span> hm_α <span class="bound">rcm</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">brc_invar_add</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'L</span><span class="main">::</span>hashable<span class="main">)</span> brc_state set"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">brc_invar_add</span> <span class="main">==</span> <span class="main">{</span><span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">rcm</span><span class="main">)</span><span class="main">.</span> 
    hs_invar <span class="bound">Q</span> <span class="main">∧</span> 
    distinct <span class="bound">W</span> <span class="main">∧</span> 
    hm_invar <span class="bound">rcm</span>
    <span class="comment1">⌦‹∧ set W ⊆ hs_α Q›</span><span class="main">}</span>
  "</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">brc_invar</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">==</span> brc_invar_add <span class="main">∩</span> <span class="main">{</span><span class="bound">s</span><span class="main">.</span> brc_α <span class="bound">s</span> <span class="main">∈</span> br'_invar <span class="free"><span class="bound"><span class="entity">δ</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">brc_cond</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'q</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'l</span><span class="main">::</span>hashable<span class="main">)</span> brc_state <span class="main">⇒</span> bool"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">brc_cond</span> <span class="main">==</span> <span class="main">λ</span><span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">rcm</span><span class="main">)</span><span class="main">.</span> <span class="bound">W</span><span class="main">≠</span><span class="main">[]</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">brc_inner_step</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'q</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> ta_rule <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'q</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'l</span><span class="main">::</span>hashable<span class="main">)</span> brc_state 
      <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'q</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> brc_state"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">brc_inner_step</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">==</span> <span class="main">λ</span><span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">rcm</span><span class="main">)</span><span class="main">.</span> 
    <span class="keyword1">let</span> <span class="bound">c</span><span class="main">=</span>the <span class="main">(</span>hm_lookup <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="bound">rcm</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">rcm'</span> <span class="main">=</span> hm_update <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">(</span><span class="bound">c</span><span class="main">-</span><span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span> <span class="bound">rcm</span><span class="main">;</span>
        <span class="bound">Q'</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">c</span> <span class="main">≤</span> <span class="main">1</span> <span class="keyword1">then</span> hs_ins <span class="main">(</span>lhs <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="bound">Q</span> <span class="keyword1">else</span> <span class="bound">Q</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">W'</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">c</span> <span class="main">≤</span> <span class="main">1</span> <span class="main">∧</span> <span class="main">¬</span> hs_memb <span class="main">(</span>lhs <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="bound">Q</span> <span class="keyword1">then</span> lhs <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">#</span> <span class="bound">W</span> <span class="keyword1">else</span> <span class="bound">W</span><span class="main">)</span> <span class="keyword1">in</span>
      <span class="main">(</span><span class="bound">Q'</span><span class="main">,</span><span class="bound">W'</span><span class="main">,</span><span class="bound">rcm'</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">brc_step</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'q</span><span class="main">,</span><span class="main">(</span><span class="tfree">'q</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> ta_rule ls<span class="main">)</span> hm 
      <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'q</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'l</span><span class="main">::</span>hashable<span class="main">)</span> brc_state 
      <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'q</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> brc_state"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">brc_step</span> <span class="free"><span class="bound"><span class="entity">rqrm</span></span></span> <span class="main">==</span> <span class="main">λ</span><span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">rcm</span><span class="main">)</span><span class="main">.</span>
    ls_iteratei <span class="main">(</span>rqrm_lookup <span class="free"><span class="bound"><span class="entity">rqrm</span></span></span> <span class="main">(</span>hd <span class="bound">W</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> brc_inner_step 
      <span class="main">(</span><span class="bound">Q</span><span class="main">,</span>tl <span class="bound">W</span><span class="main">,</span> <span class="bound">rcm</span><span class="main">)</span>"</span></span>

  <span class="comment1">― ‹Initial concrete state›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">brc_iq</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'q</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> ta_rule ls <span class="main">⇒</span> <span class="tfree">'q</span><span class="main">::</span>hashable hs"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">brc_iq</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">==</span> lh_set_xy.g_image_filter <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> 
    <span class="keyword1">if</span> rhsq <span class="bound">r</span> <span class="main">=</span> <span class="main">[]</span> <span class="keyword1">then</span> Some <span class="main">(</span>lhs <span class="bound">r</span><span class="main">)</span> <span class="keyword1">else</span> None<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">brc_rcm_init</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'q</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'l</span><span class="main">::</span>hashable<span class="main">)</span> ta_rule ls 
      <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'q</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> ta_rule<span class="main">,</span>nat<span class="main">)</span> hm"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">brc_rcm_init</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">==</span> 
    ls_iteratei <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> 
      <span class="main">(</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">res</span><span class="main">.</span> hm_update <span class="bound">r</span> <span class="main">(</span><span class="main">(</span>length <span class="main">(</span>remdups <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="bound">res</span><span class="main">)</span> 
      <span class="main">(</span>hm_empty <span class="main">()</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">brc_initial</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'q</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'l</span><span class="main">::</span>hashable<span class="main">)</span> ta_rule ls <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'q</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> brc_state"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">brc_initial</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">==</span> 
    <span class="keyword1">let</span> <span class="bound">iq</span><span class="main">=</span>brc_iq <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="keyword1">in</span> 
      <span class="main">(</span><span class="bound">iq</span><span class="main">,</span> hs_to_list <span class="main">(</span><span class="bound">iq</span><span class="main">)</span><span class="main">,</span> brc_rcm_init <span class="free"><span class="bound"><span class="entity">δ</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">brc_det_algo</span> <span class="free"><span class="bound"><span class="entity">rqrm</span></span></span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">==</span> <span class="main">⦇</span>
  dwa_cond <span class="main">=</span> brc_cond<span class="main">,</span>
  dwa_step <span class="main">=</span> brc_step <span class="free"><span class="bound"><span class="entity">rqrm</span></span></span><span class="main">,</span>
  dwa_initial <span class="main">=</span> brc_initial <span class="free"><span class="bound"><span class="entity">δ</span></span></span><span class="main">,</span>
  dwa_invar <span class="main">=</span> brc_invar <span class="main">(</span>ls_α <span class="free"><span class="bound"><span class="entity">δ</span></span></span><span class="main">)</span>
<span class="main">⦈</span>"</span></span>

  <span class="comment1">― ‹Additional facts needed from the abstract level›</span>
<span class="keyword1"><span class="command">lemma</span></span> brc_inv_imp_WssQ<span class="main">:</span> <span class="quoted"><span class="quoted">"brc_α <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">,</span><span class="free">rcm</span><span class="main">)</span><span class="main">∈</span>br'_invar <span class="free">δ</span> <span class="main">⟹</span> set <span class="free">W</span> <span class="main">⊆</span> hs_α <span class="free">Q</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brc_α_def br'_invar_def br'_α_def br_invar_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> brc_iq_correct<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ls_invar <span class="free">δ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"hs_invar <span class="main">(</span>brc_iq <span class="free">δ</span><span class="main">)</span>"</span></span>
        <span class="quoted"><span class="quoted">"hs_α <span class="main">(</span>brc_iq <span class="free">δ</span><span class="main">)</span> <span class="main">=</span> br_iq <span class="main">(</span>ls_α <span class="free">δ</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brc_iq_def br_iq_def lh_set_xy.image_filter_correct<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> brc_rcm_init_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ls_invar <span class="free">δ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span><span class="main">∈</span>ls_α <span class="free">δ</span> 
    <span class="main">⟹</span> hm_α <span class="main">(</span>brc_rcm_init <span class="free">δ</span><span class="main">)</span> <span class="free">r</span> <span class="main">=</span> Some <span class="main">(</span><span class="main">(</span>card <span class="main">(</span>set <span class="main">(</span>rhsq <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">⟹</span> <span class="var">?T1</span> <span class="free">r</span>"</span></span><span class="main">)</span> <span class="keyword2"><span class="keyword">and</span></span>
    <span class="quoted"><span class="quoted">"hm_invar <span class="main">(</span>brc_rcm_init <span class="free">δ</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T2</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> G<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">r</span><span class="main">∈</span>ls_α <span class="free">δ</span><span class="main">.</span> <span class="var">?T1</span> <span class="bound">r</span><span class="main">)</span> <span class="main">∧</span> <span class="var">?T2</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> brc_rcm_init_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> 
      I<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">it</span> <span class="bound">res</span><span class="main">.</span> hm_invar <span class="bound">res</span> 
           <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">r</span><span class="main">∈</span>ls_α <span class="free">δ</span> <span class="main">-</span> <span class="bound">it</span><span class="main">.</span> hm_α <span class="bound">res</span> <span class="bound">r</span> <span class="main">=</span> Some <span class="main">(</span><span class="main">(</span>card <span class="main">(</span>set <span class="main">(</span>rhsq <span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> 
      <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> ls.iterate_rule_P<span class="main">)</span>
      <span class="comment1">― ‹Invar›</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="comment1">― ‹Init›</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hm_correct<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
      <span class="comment1">― ‹Step›</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> conjI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hm.update_correct<span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> hm_correct hs_correct INV<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ballI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="improper">r</span><span class="main">=</span><span class="improper">x</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
        <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> length_remdups_card 
        <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> arg_cong<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">card</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="comment1">― ‹Final›</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">from</span></span> G <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?T2</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">r</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span><span class="main">∈</span>ls_α <span class="free">δ</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="var">?T1</span> <span class="skolem">r</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> G <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> brc_inner_step_br'_desc<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">,</span><span class="free">rcm</span><span class="main">)</span><span class="main">∈</span>brc_invar <span class="free">δ</span> <span class="main">⟧</span> <span class="main">⟹</span> brc_α <span class="main">(</span>brc_inner_step <span class="free">r</span> <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">W</span><span class="main">,</span><span class="free">rcm</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
    <span class="keyword1">if</span> the <span class="main">(</span>hm_α <span class="free">rcm</span> <span class="free">r</span><span class="main">)</span> <span class="main">≤</span> <span class="main">1</span> <span class="keyword1">then</span> 
      insert <span class="main">(</span>lhs <span class="free">r</span><span class="main">)</span> <span class="main">(</span>hs_α <span class="free">Q</span><span class="main">)</span> 
    <span class="keyword1">else</span> hs_α <span class="free">Q</span><span class="main">,</span> 
    <span class="keyword1">if</span> the <span class="main">(</span>hm_α <span class="free">rcm</span> <span class="free">r</span><span class="main">)</span> <span class="main">≤</span> <span class="main">1</span> <span class="main">∧</span> <span class="main">(</span>lhs <span class="free">r</span><span class="main">)</span> <span class="main">∉</span> hs_α <span class="free">Q</span> <span class="keyword1">then</span> 
      insert <span class="main">(</span>lhs <span class="free">r</span><span class="main">)</span> <span class="main">(</span>set <span class="free">W</span><span class="main">)</span> 
    <span class="keyword1">else</span> <span class="main">(</span>set <span class="free">W</span><span class="main">)</span><span class="main">,</span> 
    <span class="main">(</span><span class="main">(</span>hm_α <span class="free">rcm</span><span class="main">)</span><span class="main">(</span><span class="free">r</span> <span class="main">↦</span> the <span class="main">(</span>hm_α <span class="free">rcm</span> <span class="free">r</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>
  <span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> 
    <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brc_invar_def brc_invar_add_def brc_α_def brc_inner_step_def Let_def 
         hs_correct hm_correct<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> brc_step_invar<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> RQRM<span class="main">:</span> <span class="quoted"><span class="quoted">"rqrm_invar <span class="free">rqrm</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">Σ</span><span class="main">∈</span>brc_invar_add<span class="main">;</span> brc_α <span class="free">Σ</span><span class="main">∈</span>br'_invar <span class="free">δ</span><span class="main">;</span> brc_cond <span class="free">Σ</span> <span class="main">⟧</span> 
         <span class="main">⟹</span> <span class="main">(</span>brc_step <span class="free">rqrm</span> <span class="free">Σ</span><span class="main">)</span><span class="main">∈</span>brc_invar_add"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">Σ</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brc_step_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> I<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">it</span> <span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">rcm</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">rcm</span><span class="main">)</span><span class="main">∈</span>brc_invar_add <span class="main">∧</span> set <span class="bound">W</span> <span class="main">⊆</span> hs_α <span class="bound">Q</span>"</span></span> 
                  <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> ls.iterate_rule_P<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RQRM<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> rqrm_invar_def<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">b</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brc_invar_add_def distinct_tl brc_cond_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brc_invar_add_def distinct_tl brc_cond_def 
              <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> brc_inv_imp_WssQ<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">σ</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brc_invar_add_def br_invar_def brc_inner_step_def 
                        Let_def hs_correct hm_correct<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">σ</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">lemma</span></span> brc_step_abs<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> RQRM<span class="main">:</span> <span class="quoted"><span class="quoted">"rqrm_invar <span class="free">rqrm</span>"</span></span> <span class="quoted"><span class="quoted">"rqrm_prop <span class="free">δ</span> <span class="free">rqrm</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Σ</span><span class="main">∈</span>brc_invar <span class="free">δ</span>"</span></span> <span class="quoted"><span class="quoted">"brc_cond <span class="free">Σ</span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>brc_α <span class="free">Σ</span><span class="main">,</span> brc_α <span class="main">(</span>brc_step <span class="free">rqrm</span> <span class="free">Σ</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> br'_step <span class="free">δ</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">Q</span></span> <span class="skolem"><span class="skolem">W</span></span> <span class="skolem"><span class="skolem">rcm</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Σ</span><span class="main">=</span><span class="main">(</span><span class="skolem">Q</span><span class="main">,</span><span class="skolem">W</span><span class="main">,</span><span class="skolem">rcm</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">Σ</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> A <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brc_step_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> 
      br'_inner_step_proof<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ls.v1_iteratei_impl<span class="main"><span class="main">,</span></span> 
         <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> cinvar<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">it</span> <span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">rcm</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">rcm</span><span class="main">)</span><span class="main">∈</span>brc_invar_add 
                                      <span class="main">∧</span> set <span class="bound">W</span> <span class="main">⊆</span> hs_α <span class="bound">Q</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> 
               q<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"hd <span class="skolem">W</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="skolem">W</span></span><span class="main">)</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brc_cond_def brc_invar_add_def brc_invar_def 
                <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> brc_inv_imp_WssQ<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span> 6
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brc_α_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">Σ</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
      <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brc_invar_def brc_invar_add_def brc_inner_step_def 
                Let_def hm_correct hs_correct<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
      <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brc_invar_add_def brc_inner_step_def brc_α_def 
                br'_inner_step_def Let_def hm_correct hs_correct<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RQRM<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> rqrm_invar_def<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rqrm_propD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> RQRM<span class="main"><span class="main"><span class="main">(</span></span></span>2<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="skolem">W</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brc_α_def brc_cond_def brc_invar_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="skolem">W</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brc_α_def brc_cond_def brc_invar_def 
                         brc_invar_add_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>
    
<span class="keyword1"><span class="command">lemma</span></span> brc_initial_invar<span class="main">:</span> <span class="quoted"><span class="quoted">"ls_invar <span class="free">δ</span> <span class="main">⟹</span> <span class="main">(</span>brc_initial <span class="free">δ</span><span class="main">)</span><span class="main">∈</span>brc_invar_add"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> 
    <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brc_invar_add_def brc_initial_def brc_iq_correct Let_def 
         brc_rcm_init_correct hs_correct<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> brc_cond_abs<span class="main">:</span> <span class="quoted"><span class="quoted">"brc_cond <span class="free">Σ</span> <span class="main">⟷</span> <span class="main">(</span>brc_α <span class="free">Σ</span><span class="main">)</span><span class="main">∈</span>br'_cond"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">Σ</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brc_cond_def br'_cond_def brc_α_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> brc_initial_abs<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"ls_invar <span class="free">δ</span> <span class="main">⟹</span> brc_α <span class="main">(</span>brc_initial <span class="free">δ</span><span class="main">)</span> <span class="main">∈</span> br'_initial <span class="main">(</span>ls_α <span class="free">δ</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
    <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brc_initial_def Let_def brc_α_def brc_iq_correct 
              brc_rcm_init_correct hs_correct 
    <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> br'_initial.intros<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> brc_pref_br'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> RQRM<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rqrm_invar <span class="free">rqrm</span>"</span></span> <span class="quoted"><span class="quoted">"rqrm_prop <span class="main">(</span>ls_α <span class="free">δ</span><span class="main">)</span> <span class="free">rqrm</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ls_invar <span class="free">δ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"wa_precise_refine <span class="main">(</span>det_wa_wa <span class="main">(</span>brc_det_algo <span class="free">rqrm</span> <span class="free">δ</span><span class="main">)</span><span class="main">)</span> 
                           <span class="main">(</span>br'_algo <span class="main">(</span>ls_α <span class="free">δ</span><span class="main">)</span><span class="main">)</span> 
                           brc_α"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brc_det_algo_def br'_algo_def det_wa_wa_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brc_cond_abs<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brc_step_abs<span class="main"><span class="main">[</span></span><span class="operator">OF</span> RQRM<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brc_initial_abs<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brc_invar_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brc_cond_abs<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> brc_while_algo<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> RQRM<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rqrm_invar <span class="free">rqrm</span>"</span></span> <span class="quoted"><span class="quoted">"rqrm_prop <span class="main">(</span>ls_α <span class="free">δ</span><span class="main">)</span> <span class="free">rqrm</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ls_invar <span class="free">δ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"while_algo <span class="main">(</span>det_wa_wa <span class="main">(</span>brc_det_algo <span class="free">rqrm</span> <span class="free">δ</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> brc_pref_br'<span class="main">[</span><span class="operator">OF</span> RQRM INV<span class="main">]</span> <span class="keyword1"><span class="command">interpret</span></span> 
    ref<span class="main">:</span> wa_precise_refine <span class="quoted"><span class="quoted">"<span class="main">(</span>det_wa_wa <span class="main">(</span>brc_det_algo <span class="free">rqrm</span> <span class="free">δ</span><span class="main">)</span><span class="main">)</span>"</span></span> 
                           <span class="quoted"><span class="quoted">"<span class="main">(</span>br'_algo <span class="main">(</span>ls_α <span class="free">δ</span><span class="main">)</span><span class="main">)</span>"</span></span> 
                           <span class="quoted">brc_α</span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ref.wa_intro<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br'_while_algo<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> det_wa_wa_def brc_det_algo_def br'_algo_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brc_invar_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brc_step_invar<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brc_initial_invar<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> brc_det_while_algo <span class="main">=</span>
  det_while_algo_intro<span class="main">[</span><span class="operator">OF</span> brc_while_algo<span class="main">]</span>


<span class="keyword1"><span class="command">lemma</span></span> fst_brc_α<span class="main">:</span> <span class="quoted"><span class="quoted">"fst <span class="main">(</span>brc_α <span class="free">s</span><span class="main">)</span> <span class="main">=</span> hs_α <span class="main">(</span>fst <span class="free">s</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brc_α_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> brc_invar_final <span class="main">=</span>
  wa_precise_refine.transfer_correctness<span class="main">[</span><span class="operator">OF</span> 
    brc_pref_br' br'_invar_final<span class="main">,</span> <span class="operator">unfolded</span> fst_brc_α<span class="main">]</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hta_bwd_reduce</span> <span class="free"><span class="bound"><span class="entity">H</span></span></span> <span class="main">==</span> 
  <span class="keyword1">let</span> <span class="bound">rqrm</span> <span class="main">=</span> build_rqrm <span class="main">(</span>hta_δ <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">)</span> <span class="keyword1">in</span> 
    hta_reduce 
      <span class="free"><span class="bound"><span class="entity">H</span></span></span> 
      <span class="main">(</span>fst <span class="main">(</span>while brc_cond <span class="main">(</span>brc_step <span class="bound">rqrm</span><span class="main">)</span> <span class="main">(</span>brc_initial <span class="main">(</span>hta_δ <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
"</span></span>

<span class="keyword1"><span class="command">theorem</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> hashedTa<span class="main">)</span> hta_bwd_reduce_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"hta_α <span class="main">(</span>hta_bwd_reduce <span class="free">H</span><span class="main">)</span> 
         <span class="main">=</span> ta_reduce <span class="main">(</span>hta_α <span class="free">H</span><span class="main">)</span> <span class="main">(</span>b_accessible <span class="main">(</span>ls_α <span class="main">(</span>hta_δ <span class="free">H</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T1</span></span></span><span class="main">)</span>
        <span class="quoted"><span class="quoted">"hashedTa <span class="main">(</span>hta_bwd_reduce <span class="free">H</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T2</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> det_while_algo <span class="quoted"><span class="quoted">"<span class="main">(</span>brc_det_algo <span class="main">(</span>build_rqrm δ<span class="main">)</span> δ<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> brc_det_while_algo<span class="main">)</span>
       <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> build_rqrm_correct<span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> LC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>while brc_cond <span class="main">(</span>brc_step <span class="main">(</span>build_rqrm δ<span class="main">)</span><span class="main">)</span> <span class="main">(</span>brc_initial δ<span class="main">)</span><span class="main">)</span> <span class="main">=</span> loop"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> loop_def<span class="main">)</span>
       <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brc_det_algo_def<span class="main">)</span>

  <span class="keyword1"><span class="command">from</span></span> while_proof'<span class="main">[</span><span class="operator">OF</span> brc_invar_final<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> 
    G1<span class="main">:</span> <span class="quoted"><span class="quoted">"hs_α <span class="main">(</span>fst loop<span class="main">)</span> <span class="main">=</span> b_accessible <span class="main">(</span>ls_α δ<span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> build_rqrm_correct<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> G2<span class="main">:</span> <span class="quoted"><span class="quoted">"loop <span class="main">∈</span> brc_invar <span class="main">(</span>ls_α δ<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> while_proof<span class="main">)</span>
       <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brc_det_algo_def<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hs_invar <span class="main">(</span>fst loop<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted">loop</span><span class="main">)</span>
       <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brc_invar_def brc_invar_add_def<span class="main">)</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?T1</span></span></span> <span class="var"><span class="quoted"><span class="var">?T2</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hta_bwd_reduce_def LC hta_reduce_correct G1<span class="main">)</span>
    
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Emptiness Check with Witness Computation›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">brec_construct_witness</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'q</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'l</span><span class="main">::</span>hashable tree<span class="main">)</span> hm <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'q</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> ta_rule <span class="main">⇒</span> <span class="tfree">'l</span> tree"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">brec_construct_witness</span> <span class="free"><span class="bound"><span class="entity">Qm</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">==</span> 
  NODE <span class="main">(</span>rhsl <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">(</span>List.map <span class="main">(</span><span class="main">λ</span><span class="bound">q</span><span class="main">.</span> the <span class="main">(</span>hm_lookup <span class="bound">q</span> <span class="free"><span class="bound"><span class="entity">Qm</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>rhsq <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> brec_construct_witness_correct<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>hm_invar <span class="free">Qm</span><span class="main">⟧</span> <span class="main">⟹</span> 
    brec_construct_witness <span class="free">Qm</span> <span class="free">r</span> <span class="main">=</span> construct_witness <span class="main">(</span>hm_α <span class="free">Qm</span><span class="main">)</span> <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
    <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> construct_witness_def brec_construct_witness_def hm_correct<span class="main">)</span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> brec_state 
  <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span> tree<span class="main">)</span> hm 
      <span class="main">×</span> <span class="tfree">'Q</span> fifo 
      <span class="main">×</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> ta_rule<span class="main">,</span> nat<span class="main">)</span> hm 
      <span class="main">×</span> <span class="tfree">'Q</span> option<span class="main">)</span>"</span></span>


  <span class="comment1">― ‹Abstractions›</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">brec_α</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'L</span><span class="main">::</span>hashable<span class="main">)</span> brec_state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'L</span><span class="main">)</span> brw_state"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">brec_α</span> <span class="main">==</span> <span class="main">λ</span><span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">rcm</span><span class="main">,</span><span class="bound">f</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span>hm_α <span class="bound">Q</span><span class="main">,</span> set <span class="main">(</span>fifo_α <span class="bound">W</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>hm_α <span class="bound">rcm</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">brec_inner_step</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'q</span> hs <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'q</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> ta_rule 
      <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'q</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'l</span><span class="main">::</span>hashable<span class="main">)</span> brec_state 
      <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'q</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> brec_state"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">brec_inner_step</span> <span class="free"><span class="bound"><span class="entity">Qi</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">==</span> <span class="main">λ</span><span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">rcm</span><span class="main">,</span><span class="bound">qwit</span><span class="main">)</span><span class="main">.</span> 
    <span class="keyword1">let</span> <span class="bound">c</span><span class="main">=</span>the <span class="main">(</span>hm_lookup <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="bound">rcm</span><span class="main">)</span><span class="main">;</span> 
        <span class="bound">cond</span> <span class="main">=</span> <span class="bound">c</span> <span class="main">≤</span> <span class="main">1</span> <span class="main">∧</span> hm_lookup <span class="main">(</span>lhs <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="bound">Q</span> <span class="main">=</span> None<span class="main">;</span>
        <span class="bound">rcm'</span> <span class="main">=</span> hm_update <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">(</span><span class="bound">c</span><span class="main">-</span><span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span> <span class="bound">rcm</span><span class="main">;</span>
        <span class="bound">Q'</span> <span class="main">=</span> <span class="main">(</span> <span class="keyword1">if</span> <span class="bound">cond</span> <span class="keyword1">then</span> 
                 hm_update <span class="main">(</span>lhs <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">(</span>brec_construct_witness <span class="bound">Q</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="bound">Q</span> 
               <span class="keyword1">else</span> <span class="bound">Q</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">W'</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">cond</span> <span class="keyword1">then</span> fifo_enqueue <span class="main">(</span>lhs <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="bound">W</span> <span class="keyword1">else</span> <span class="bound">W</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">qwit'</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">c</span> <span class="main">≤</span> <span class="main">1</span> <span class="main">∧</span> hs_memb <span class="main">(</span>lhs <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">Qi</span></span></span> <span class="keyword1">then</span> Some <span class="main">(</span>lhs <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="keyword1">else</span> <span class="bound">qwit</span><span class="main">)</span>
    <span class="keyword1">in</span>
      <span class="main">(</span><span class="bound">Q'</span><span class="main">,</span><span class="bound">W'</span><span class="main">,</span><span class="bound">rcm'</span><span class="main">,</span><span class="bound">qwit'</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">brec_step</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'q</span><span class="main">,</span><span class="main">(</span><span class="tfree">'q</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> ta_rule ls<span class="main">)</span> hm <span class="main">⇒</span> <span class="tfree">'q</span> hs 
      <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'q</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'l</span><span class="main">::</span>hashable<span class="main">)</span> brec_state 
      <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'q</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> brec_state"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">brec_step</span> <span class="free"><span class="bound"><span class="entity">rqrm</span></span></span> <span class="free"><span class="bound"><span class="entity">Qi</span></span></span> <span class="main">==</span> <span class="main">λ</span><span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">rcm</span><span class="main">,</span><span class="bound">qwit</span><span class="main">)</span><span class="main">.</span>
    <span class="keyword1">let</span> <span class="main">(</span><span class="bound">q</span><span class="main">,</span><span class="bound">W'</span><span class="main">)</span><span class="main">=</span>fifo_dequeue <span class="bound">W</span> <span class="keyword1">in</span> 
      ls_iteratei <span class="main">(</span>rqrm_lookup <span class="free"><span class="bound"><span class="entity">rqrm</span></span></span> <span class="bound">q</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> 
        <span class="main">(</span>brec_inner_step <span class="free"><span class="bound"><span class="entity">Qi</span></span></span><span class="main">)</span> <span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W'</span><span class="main">,</span><span class="bound">rcm</span><span class="main">,</span><span class="bound">qwit</span><span class="main">)</span>
  "</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">brec_iqm</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'q</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'l</span><span class="main">::</span>hashable<span class="main">)</span> ta_rule ls <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'q</span><span class="main">,</span><span class="tfree">'l</span> tree<span class="main">)</span> hm"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">brec_iqm</span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">==</span> 
    ls_iteratei <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">m</span><span class="main">.</span> <span class="keyword1">if</span> rhsq <span class="bound">r</span> <span class="main">=</span> <span class="main">[]</span> <span class="keyword1">then</span> 
                         hm_update <span class="main">(</span>lhs <span class="bound">r</span><span class="main">)</span> <span class="main">(</span>NODE <span class="main">(</span>rhsl <span class="bound">r</span><span class="main">)</span> <span class="main">[]</span><span class="main">)</span> <span class="bound">m</span> 
                      <span class="keyword1">else</span> <span class="bound">m</span><span class="main">)</span> 
                <span class="main">(</span>hm_empty <span class="main">()</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">brec_initial</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'q</span> hs <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'q</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'l</span><span class="main">::</span>hashable<span class="main">)</span> ta_rule ls 
      <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'q</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> brec_state"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">brec_initial</span> <span class="free"><span class="bound"><span class="entity">Qi</span></span></span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">==</span> 
  <span class="keyword1">let</span> <span class="bound">iq</span><span class="main">=</span>brc_iq <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="keyword1">in</span> 
    <span class="main">(</span> brec_iqm <span class="free"><span class="bound"><span class="entity">δ</span></span></span><span class="main">,</span> 
      hs_to_fifo.g_set_to_listr <span class="bound">iq</span><span class="main">,</span> 
      brc_rcm_init <span class="free"><span class="bound"><span class="entity">δ</span></span></span><span class="main">,</span>
      hh_set_xx.g_disjoint_witness <span class="bound">iq</span> <span class="free"><span class="bound"><span class="entity">Qi</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">brec_cond</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'q</span><span class="main">,</span><span class="tfree">'l</span><span class="main">)</span> brec_state <span class="main">⇒</span> bool"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">brec_cond</span> <span class="main">==</span> <span class="main">λ</span><span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">rcm</span><span class="main">,</span><span class="bound">qwit</span><span class="main">)</span><span class="main">.</span> <span class="main">¬</span> fifo_isEmpty <span class="bound">W</span> <span class="main">∧</span> <span class="bound">qwit</span> <span class="main">=</span> None"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">brec_invar_add</span>
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q</span><span class="main">::</span>hashable<span class="main">,</span><span class="tfree">'L</span><span class="main">::</span>hashable<span class="main">)</span> brec_state set"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">brec_invar_add</span> <span class="free"><span class="bound"><span class="entity">Qi</span></span></span> <span class="main">==</span> <span class="main">{</span><span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">rcm</span><span class="main">,</span><span class="bound">qwit</span><span class="main">)</span><span class="main">.</span> 
    hm_invar <span class="bound">Q</span> <span class="main">∧</span> 
    distinct <span class="main">(</span>fifo_α <span class="bound">W</span><span class="main">)</span> <span class="main">∧</span> 
    hm_invar <span class="bound">rcm</span> <span class="main">∧</span>
    <span class="main">(</span> <span class="keyword1">case</span> <span class="bound">qwit</span> <span class="keyword1">of</span> 
        None <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">Qi</span></span></span> <span class="main">∩</span> dom <span class="main">(</span>hm_α <span class="bound">Q</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">|</span> 
        Some <span class="bound">q</span> <span class="main">⇒</span> <span class="bound">q</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">Qi</span></span></span> <span class="main">∩</span> dom <span class="main">(</span>hm_α <span class="bound">Q</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>
  "</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">brec_invar</span> <span class="free"><span class="bound"><span class="entity">Qi</span></span></span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">==</span> brec_invar_add <span class="free"><span class="bound"><span class="entity">Qi</span></span></span> <span class="main">∩</span> <span class="main">{</span><span class="bound">s</span><span class="main">.</span> brec_α <span class="bound">s</span> <span class="main">∈</span> brw_invar <span class="free"><span class="bound"><span class="entity">δ</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">brec_invar_inner</span> <span class="free"><span class="bound"><span class="entity">Qi</span></span></span> <span class="main">==</span> 
  brec_invar_add <span class="free"><span class="bound"><span class="entity">Qi</span></span></span> <span class="main">∩</span> <span class="main">{</span><span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> set <span class="main">(</span>fifo_α <span class="bound">W</span><span class="main">)</span> <span class="main">⊆</span> dom <span class="main">(</span>hm_α <span class="bound">Q</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> brec_invar_cons<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">Σ</span><span class="main">∈</span>brec_invar <span class="free">Qi</span> <span class="free">δ</span> <span class="main">⟹</span> <span class="free">Σ</span><span class="main">∈</span>brec_invar_inner <span class="free">Qi</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">Σ</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brec_invar_def brw_invar_def br'_invar_def br_invar_def
                   brec_α_def brw_α_def br'_α_def brec_invar_inner_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> brec_brw_invar_cons<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"brec_α <span class="free">Σ</span> <span class="main">∈</span> brw_invar <span class="free">Qi</span> <span class="main">⟹</span> set <span class="main">(</span>fifo_α <span class="main">(</span>fst <span class="main">(</span>snd <span class="free">Σ</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> dom <span class="main">(</span>hm_α <span class="main">(</span>fst <span class="free">Σ</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">Σ</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brec_invar_def brw_invar_def br'_invar_def br_invar_def
                   brec_α_def brw_α_def br'_α_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">brec_det_algo</span> <span class="free"><span class="bound"><span class="entity">rqrm</span></span></span> <span class="free"><span class="bound"><span class="entity">Qi</span></span></span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span> <span class="main">==</span> <span class="main">⦇</span>
  dwa_cond<span class="main">=</span>brec_cond<span class="main">,</span>
  dwa_step<span class="main">=</span>brec_step <span class="free"><span class="bound"><span class="entity">rqrm</span></span></span> <span class="free"><span class="bound"><span class="entity">Qi</span></span></span><span class="main">,</span>
  dwa_initial<span class="main">=</span>brec_initial <span class="free"><span class="bound"><span class="entity">Qi</span></span></span> <span class="free"><span class="bound"><span class="entity">δ</span></span></span><span class="main">,</span>
  dwa_invar<span class="main">=</span>brec_invar <span class="main">(</span>hs_α <span class="free"><span class="bound"><span class="entity">Qi</span></span></span><span class="main">)</span> <span class="main">(</span>ls_α <span class="free"><span class="bound"><span class="entity">δ</span></span></span><span class="main">)</span>
<span class="main">⦈</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> brec_iqm_correct'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ls_invar <span class="free">δ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> 
    <span class="quoted"><span class="quoted">"dom <span class="main">(</span>hm_α <span class="main">(</span>brec_iqm <span class="free">δ</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span>lhs <span class="bound">r</span> <span class="main">|</span> <span class="bound">r</span><span class="main">.</span> <span class="bound">r</span><span class="main">∈</span>ls_α <span class="free">δ</span> <span class="main">∧</span> rhsq <span class="bound">r</span> <span class="main">=</span> <span class="main">[]</span><span class="main">}</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T1</span></span></span><span class="main">)</span>
    <span class="quoted"><span class="quoted">"witness_prop <span class="main">(</span>ls_α <span class="free">δ</span><span class="main">)</span> <span class="main">(</span>hm_α <span class="main">(</span>brec_iqm <span class="free">δ</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T2</span></span></span><span class="main">)</span>
    <span class="quoted"><span class="quoted">"hm_invar <span class="main">(</span>brec_iqm <span class="free">δ</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T3</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?T1</span> <span class="main">∧</span> <span class="var">?T2</span> <span class="main">∧</span> <span class="var">?T3</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> brec_iqm_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> 
      I<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">it</span> <span class="bound">m</span><span class="main">.</span> hm_invar <span class="bound">m</span> 
                <span class="main">∧</span> dom <span class="main">(</span>hm_α <span class="bound">m</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span>lhs <span class="bound">r</span> <span class="main">|</span> <span class="bound">r</span><span class="main">.</span> <span class="bound">r</span><span class="main">∈</span>ls_α <span class="free">δ</span> <span class="main">-</span> <span class="bound">it</span> <span class="main">∧</span> rhsq <span class="bound">r</span> <span class="main">=</span> <span class="main">[]</span><span class="main">}</span> 
                <span class="main">∧</span> witness_prop <span class="main">(</span>ls_α <span class="free">δ</span><span class="main">)</span> <span class="main">(</span>hm_α <span class="bound">m</span><span class="main">)</span>"</span></span> 
      <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> ls.iterate_rule_P<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hm_correct witness_prop_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hm_correct witness_prop_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> accs.intros<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?T1</span></span></span> <span class="var"><span class="quoted"><span class="var">?T2</span></span></span> <span class="var"><span class="quoted"><span class="var">?T3</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> brec_iqm_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ls_invar <span class="free">δ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"hm_α <span class="main">(</span>brec_iqm <span class="free">δ</span><span class="main">)</span> <span class="main">∈</span> brw_iq <span class="main">(</span>ls_α <span class="free">δ</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">q</span> <span class="bound">t</span><span class="main">.</span> hm_α <span class="main">(</span>brec_iqm <span class="free">δ</span><span class="main">)</span> <span class="bound">q</span> <span class="main">=</span> Some <span class="bound">t</span> 
          <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">r</span><span class="main">∈</span>ls_α <span class="free">δ</span><span class="main">.</span> rhsq <span class="bound">r</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">∧</span> <span class="bound">q</span> <span class="main">=</span> lhs <span class="bound">r</span> <span class="main">∧</span> <span class="bound">t</span> <span class="main">=</span> NODE <span class="main">(</span>rhsl <span class="bound">r</span><span class="main">)</span> <span class="main">[]</span><span class="main">)</span><span class="main">)</span> 
        <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">r</span><span class="main">∈</span>ls_α <span class="free">δ</span><span class="main">.</span> rhsq <span class="bound">r</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">⟶</span> hm_α <span class="main">(</span>brec_iqm <span class="free">δ</span><span class="main">)</span> <span class="main">(</span>lhs <span class="bound">r</span><span class="main">)</span> <span class="main">≠</span> None<span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> brec_iqm_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> I<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">it</span> <span class="bound">m</span><span class="main">.</span> <span class="main">(</span>
      <span class="main">(</span>hm_invar <span class="bound">m</span><span class="main">)</span> <span class="main">∧</span> 
      <span class="main">(</span><span class="main">∀</span><span class="bound">q</span> <span class="bound">t</span><span class="main">.</span> hm_α <span class="bound">m</span> <span class="bound">q</span> <span class="main">=</span> Some <span class="bound">t</span> 
        <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">r</span><span class="main">∈</span>ls_α <span class="free">δ</span><span class="main">.</span> rhsq <span class="bound">r</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">∧</span> <span class="bound">q</span> <span class="main">=</span> lhs <span class="bound">r</span> <span class="main">∧</span> <span class="bound">t</span> <span class="main">=</span> NODE <span class="main">(</span>rhsl <span class="bound">r</span><span class="main">)</span> <span class="main">[]</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> 
      <span class="main">(</span><span class="main">∀</span><span class="bound">r</span><span class="main">∈</span>ls_α <span class="free">δ</span><span class="main">-</span><span class="bound">it</span><span class="main">.</span> rhsq <span class="bound">r</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">⟶</span> hm_α <span class="bound">m</span> <span class="main">(</span>lhs <span class="bound">r</span><span class="main">)</span> <span class="main">≠</span> None<span class="main">)</span>
      <span class="main">)</span>"</span></span> 
      <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> ls.iterate_rule_P<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hm_correct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hm_correct<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hm_correct<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> brw_iq.intros<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> brec_inner_step_brw_desc<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">Σ</span><span class="main">∈</span>brec_invar_inner <span class="main">(</span>hs_α <span class="free">Qi</span><span class="main">)</span> <span class="main">⟧</span> 
    <span class="main">⟹</span> <span class="main">(</span>brec_α <span class="free">Σ</span><span class="main">,</span> brec_α <span class="main">(</span>brec_inner_step <span class="free">Qi</span> <span class="free">r</span> <span class="free">Σ</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> brw_inner_step <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">Σ</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> brw_inner_step.intros<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> <span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> brec_α_def split_conv<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> brec_inner_step_def brec_α_def Let_def split_conv<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
    <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brec_invar_inner_def brec_invar_add_def brec_α_def 
              brec_inner_step_def 
              Let_def hs_correct hm_correct fifo_correct
              brec_construct_witness_correct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">lemma</span></span> brec_step_invar<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> RQRM<span class="main">:</span> <span class="quoted"><span class="quoted">"rqrm_invar <span class="free">rqrm</span>"</span></span> <span class="quoted"><span class="quoted">"rqrm_prop <span class="free">δ</span> <span class="free">rqrm</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hs_invar <span class="free">Qi</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">Σ</span><span class="main">∈</span>brec_invar_add <span class="main">(</span>hs_α <span class="free">Qi</span><span class="main">)</span><span class="main">;</span> brec_α <span class="free">Σ</span> <span class="main">∈</span> brw_invar <span class="free">δ</span><span class="main">;</span>  brec_cond <span class="free">Σ</span> <span class="main">⟧</span> 
          <span class="main">⟹</span> <span class="main">(</span>brec_step <span class="free">rqrm</span> <span class="free">Qi</span> <span class="free">Σ</span><span class="main">)</span><span class="main">∈</span>brec_invar_add <span class="main">(</span>hs_α <span class="free">Qi</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> brec_brw_invar_cons<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">Σ</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brec_step_def fifo_correct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"fifo_α <span class="improper">b</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> 
    <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brec_invar_def distinct_tl brec_cond_def fifo_correct
         <span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> s<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">b</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> fifo.removelE<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> 
    I<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">it</span> <span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">rcm</span><span class="main">,</span><span class="bound">qwit</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">W</span><span class="main">,</span><span class="bound">rcm</span><span class="main">,</span><span class="bound">qwit</span><span class="main">)</span><span class="main">∈</span>brec_invar_add <span class="main">(</span>hs_α <span class="free">Qi</span><span class="main">)</span> 
                           <span class="main">∧</span> set <span class="main">(</span>fifo_α <span class="bound">W</span><span class="main">)</span> <span class="main">⊆</span> dom <span class="main">(</span>hm_α <span class="bound">Q</span><span class="main">)</span>"</span></span> 
    <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> ls.iterate_rule_P<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> 
    <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brec_invar_def distinct_tl brec_cond_def fifo_correct
         <span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> 
    <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brec_invar_def brec_invar_add_def distinct_tl brec_cond_def 
         fifo_correct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">σ</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
    <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brec_invar_add_def brec_inner_step_def Let_def hs_correct 
              hm_correct fifo_correct <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">σ</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> brec_step_abs<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> RQRM<span class="main">:</span> <span class="quoted"><span class="quoted">"rqrm_invar <span class="free">rqrm</span>"</span></span> <span class="quoted"><span class="quoted">"rqrm_prop <span class="free">δ</span> <span class="free">rqrm</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hs_invar <span class="free">Qi</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> A'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Σ</span><span class="main">∈</span>brec_invar <span class="main">(</span>hs_α <span class="free">Qi</span><span class="main">)</span> <span class="free">δ</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> COND<span class="main">:</span> <span class="quoted"><span class="quoted">"brec_cond <span class="free">Σ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>brec_α <span class="free">Σ</span><span class="main">,</span> brec_α <span class="main">(</span>brec_step <span class="free">rqrm</span> <span class="free">Qi</span> <span class="free">Σ</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> brw_step <span class="free">δ</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> A' <span class="keyword1"><span class="command">have</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>brec_α <span class="free">Σ</span><span class="main">)</span><span class="main">∈</span>brw_invar <span class="free">δ</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Σ</span><span class="main">∈</span>brec_invar_add <span class="main">(</span>hs_α <span class="free">Qi</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brec_invar_def<span class="main">)</span>

  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">Q</span></span> <span class="skolem"><span class="skolem">W</span></span> <span class="skolem"><span class="skolem">rcm</span></span> <span class="skolem"><span class="skolem">qwit</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Σ</span><span class="main">=</span><span class="main">(</span><span class="skolem">Q</span><span class="main">,</span><span class="skolem">W</span><span class="main">,</span><span class="skolem">rcm</span><span class="main">,</span><span class="skolem">qwit</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">Σ</span></span><span class="main">)</span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">from</span></span> A COND <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brec_step_def fifo_correct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"fifo_α <span class="skolem">W</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> 
      <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brec_invar_def distinct_tl brec_cond_def fifo_correct
    <span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> s<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">W</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> fifo.removelE<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> brw_inner_step_proof<span class="main"><span class="main">[</span></span>
      <span class="operator">OF</span> ls.v1_iteratei_impl<span class="main"><span class="main">,</span></span> 
      <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> cinvar<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">it</span> <span class="bound">Σ</span><span class="main">.</span> <span class="bound">Σ</span><span class="main">∈</span>brec_invar_inner <span class="main">(</span>hs_α <span class="free">Qi</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> 
            q<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"hd <span class="main">(</span>fifo_α <span class="skolem">W</span><span class="main">)</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> brec_brw_invar_cons<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> 
      <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brec_cond_def brec_invar_add_def fifo_correct
            brec_invar_inner_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span> 6
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brec_α_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">Σ</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
      <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brec_invar_add_def brec_inner_step_def Let_def hm_correct 
                hs_correct fifo_correct brec_invar_inner_def 
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> brec_inner_step_brw_desc<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RQRM<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> rqrm_invar_def<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> 
      <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rqrm_propD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> RQRM<span class="main"><span class="main"><span class="main">(</span></span></span>2<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main"><span class="main">]</span></span> fifo_correct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> 
      <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brec_α_def brec_cond_def brec_invar_def fifo_correct<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> 
      <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brec_α_def brec_cond_def brec_invar_add_def fifo_correct<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>
    
<span class="keyword1"><span class="command">lemma</span></span> brec_invar_initial<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>ls_invar <span class="free">δ</span><span class="main">;</span> hs_invar <span class="free">Qi</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span>brec_initial <span class="free">Qi</span> <span class="free">δ</span><span class="main">)</span> <span class="main">∈</span> brec_invar_add <span class="main">(</span>hs_α <span class="free">Qi</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
    <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brec_invar_add_def brec_initial_def brc_iq_correct 
              brec_iqm_correct' hs_correct hs.isEmpty_correct Let_def 
              brc_rcm_init_correct br_iq_def 
              hh_set_xx.disjoint_witness_correct 
              hs_to_fifo.g_set_to_listr_correct 
    <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brc_iq_correct 
    hh_set_xx.disjoint_witness_None br_iq_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> hh_set_xx.disjoint_witness_correct<span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> hh_set_xx.disjoint_witness_correct<span class="main"><span class="main">[</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brc_iq_correct br_iq_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> brec_cond_abs<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">Σ</span><span class="main">∈</span>brec_invar <span class="free">Qi</span> <span class="free">δ</span><span class="main">⟧</span> <span class="main">⟹</span> brec_cond <span class="free">Σ</span> <span class="main">⟷</span> <span class="main">(</span>brec_α <span class="free">Σ</span><span class="main">)</span><span class="main">∈</span>brw_cond <span class="free">Qi</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">Σ</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
    <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brec_cond_def brw_cond_def brec_α_def brec_invar_def 
              brec_invar_add_def fifo_correct
    <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> brec_initial_abs<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> ls_invar <span class="free">δ</span><span class="main">;</span> hs_invar <span class="free">Qi</span> <span class="main">⟧</span> 
     <span class="main">⟹</span> brec_α <span class="main">(</span>brec_initial <span class="free">Qi</span> <span class="free">δ</span><span class="main">)</span> <span class="main">∈</span> brw_initial <span class="main">(</span>ls_α <span class="free">δ</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brec_initial_def Let_def brec_α_def 
                     brc_iq_correct brc_rcm_init_correct brec_iqm_correct 
                     br_iq_def fifo_correct hs_to_fifo.g_set_to_listr_correct 
              <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> brw_initial.intros<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> br_iq_def<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> brec_pref_brw<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> RQRM<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rqrm_invar <span class="free">rqrm</span>"</span></span> <span class="quoted"><span class="quoted">"rqrm_prop <span class="main">(</span>ls_α <span class="free">δ</span><span class="main">)</span> <span class="free">rqrm</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ls_invar <span class="free">δ</span>"</span></span> <span class="quoted"><span class="quoted">"hs_invar <span class="free">Qi</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"wa_precise_refine <span class="main">(</span>det_wa_wa <span class="main">(</span>brec_det_algo <span class="free">rqrm</span> <span class="free">Qi</span> <span class="free">δ</span><span class="main">)</span><span class="main">)</span> 
                           <span class="main">(</span>brw_algo <span class="main">(</span>hs_α <span class="free">Qi</span><span class="main">)</span> <span class="main">(</span>ls_α <span class="free">δ</span><span class="main">)</span><span class="main">)</span>  
                           brec_α"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> det_wa_wa_def brec_det_algo_def brw_algo_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brec_cond_abs brec_step_abs brec_initial_abs<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brec_invar_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> brec_while_algo<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> RQRM<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rqrm_invar <span class="free">rqrm</span>"</span></span> <span class="quoted"><span class="quoted">"rqrm_prop <span class="main">(</span>ls_α <span class="free">δ</span><span class="main">)</span> <span class="free">rqrm</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ls_invar <span class="free">δ</span>"</span></span> <span class="quoted"><span class="quoted">"hs_invar <span class="free">Qi</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"while_algo <span class="main">(</span>det_wa_wa <span class="main">(</span>brec_det_algo <span class="free">rqrm</span> <span class="free">Qi</span> <span class="free">δ</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> ref<span class="main">:</span> 
    wa_precise_refine <span class="quoted"><span class="quoted">"<span class="main">(</span>det_wa_wa <span class="main">(</span>brec_det_algo <span class="free">rqrm</span> <span class="free">Qi</span> <span class="free">δ</span><span class="main">)</span><span class="main">)</span>"</span></span> 
                      <span class="quoted"><span class="quoted">"<span class="main">(</span>brw_algo <span class="main">(</span>hs_α <span class="free">Qi</span><span class="main">)</span> <span class="main">(</span>ls_α <span class="free">δ</span><span class="main">)</span><span class="main">)</span>"</span></span> 
                      <span class="quoted"><span class="quoted">"brec_α"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> brec_pref_brw<span class="main">[</span><span class="operator">OF</span> RQRM INV<span class="main">]</span> <span class="keyword1"><span class="command">.</span></span> 

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ref.wa_intro<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brw_while_algo<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> det_wa_wa_def brec_det_algo_def brw_algo_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brec_invar_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brec_step_invar<span class="main"><span class="main">[</span></span><span class="operator">OF</span> RQRM INV<span class="main"><span class="main"><span class="main">(</span></span></span>2<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brec_invar_initial<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> fst_brec_α<span class="main">:</span> <span class="quoted"><span class="quoted">"fst <span class="main">(</span>brec_α <span class="free">Σ</span><span class="main">)</span> <span class="main">=</span> hm_α <span class="main">(</span>fst <span class="free">Σ</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">Σ</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brec_α_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> brec_invar_final <span class="main">=</span> 
  wa_precise_refine.transfer_correctness<span class="main">[</span>
    <span class="operator">OF</span> brec_pref_brw brw_invar_final<span class="main">,</span> 
    <span class="operator">unfolded</span> fst_brec_α<span class="main">]</span>

<span class="keyword1"><span class="command">lemmas</span></span> brec_det_algo <span class="main">=</span> det_while_algo_intro<span class="main">[</span><span class="operator">OF</span> brec_while_algo<span class="main">]</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hta_is_empty_witness</span> <span class="free"><span class="bound"><span class="entity">H</span></span></span> <span class="main">==</span> 
  <span class="keyword1">let</span> <span class="bound">rqrm</span> <span class="main">=</span> build_rqrm <span class="main">(</span>hta_δ <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">)</span><span class="main">;</span>
      <span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">qwit</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>while brec_cond <span class="main">(</span>brec_step <span class="bound">rqrm</span> <span class="main">(</span>hta_Qi <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">)</span><span class="main">)</span> 
                            <span class="main">(</span>brec_initial <span class="main">(</span>hta_Qi <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">)</span> <span class="main">(</span>hta_δ <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
  <span class="keyword1">in</span>
    <span class="keyword1">case</span> <span class="bound">qwit</span> <span class="keyword1">of</span> 
      None <span class="main">⇒</span> None <span class="main">|</span>
      Some <span class="bound">q</span> <span class="main">⇒</span> <span class="main">(</span>hm_lookup <span class="bound">q</span> <span class="bound">Q</span><span class="main">)</span>
"</span></span>

<span class="keyword1"><span class="command">theorem</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> hashedTa<span class="main">)</span> hta_is_empty_witness_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="main">[</span><span class="operator">rule_format</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hta_is_empty_witness <span class="free">H</span> <span class="main">=</span> Some <span class="free">t</span> 
                        <span class="main">⟶</span> <span class="free">t</span><span class="main">∈</span>ta_lang <span class="main">(</span>hta_α <span class="free">H</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T1</span></span></span><span class="main">)</span>
        <span class="quoted"><span class="quoted">"hta_is_empty_witness <span class="free">H</span> <span class="main">=</span> None <span class="main">⟶</span> ta_lang <span class="main">(</span>hta_α <span class="free">H</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?T2</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>

  <span class="keyword1"><span class="command">interpret</span></span> det_while_algo <span class="quoted"><span class="quoted">"<span class="main">(</span>brec_det_algo <span class="main">(</span>build_rqrm δ<span class="main">)</span> Qi δ<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> brec_det_algo<span class="main">)</span>
       <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> build_rqrm_correct<span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> LC<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span>while brec_cond <span class="main">(</span>brec_step <span class="main">(</span>build_rqrm δ<span class="main">)</span> Qi<span class="main">)</span> <span class="main">(</span>brec_initial Qi δ<span class="main">)</span><span class="main">)</span> <span class="main">=</span> loop"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> loop_def<span class="main">)</span>
       <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brec_det_algo_def<span class="main">)</span>

  <span class="keyword1"><span class="command">from</span></span> while_proof'<span class="main">[</span><span class="operator">OF</span> brec_invar_final<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> X<span class="main">:</span>
    <span class="quoted"><span class="quoted">"hs_α Qi <span class="main">∩</span> dom <span class="main">(</span>hm_α <span class="main">(</span>fst loop<span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span> 
     <span class="main">⟷</span> <span class="main">(</span>hs_α Qi <span class="main">∩</span> b_accessible <span class="main">(</span>ls_α δ<span class="main">)</span> <span class="main">=</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"witness_prop <span class="main">(</span>ls_α δ<span class="main">)</span> <span class="main">(</span>hm_α <span class="main">(</span>fst loop<span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> build_rqrm_correct<span class="main">)</span>

  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">Q</span></span> <span class="skolem"><span class="skolem">W</span></span> <span class="skolem"><span class="skolem">rcm</span></span> <span class="skolem"><span class="skolem">qwit</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"loop <span class="main">=</span> <span class="main">(</span><span class="skolem">Q</span><span class="main">,</span><span class="skolem">W</span><span class="main">,</span><span class="skolem">rcm</span><span class="main">,</span><span class="skolem">qwit</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"loop"</span></span><span class="main">)</span> <span class="operator">blast</span>

  <span class="keyword1"><span class="command">from</span></span> loop_invar <span class="keyword1"><span class="command">have</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"loop <span class="main">∈</span> brec_invar <span class="main">(</span>hs_α Qi<span class="main">)</span> <span class="main">(</span>ls_α δ<span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brec_det_algo_def<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> INVARS<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hm_invar <span class="skolem">Q</span>"</span></span> <span class="quoted"><span class="quoted">"hm_invar <span class="skolem">rcm</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brec_invar_def brec_invar_add_def<span class="main">)</span> 
  
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">assume</span></span> C<span class="main">:</span> <span class="quoted"><span class="quoted">"hta_is_empty_witness <span class="free">H</span> <span class="main">=</span> Some <span class="free">t</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">q</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
      <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">qwit</span><span class="main">=</span>Some <span class="skolem">q</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 
        LUQ<span class="main">:</span> <span class="quoted"><span class="quoted">"hm_lookup <span class="skolem">q</span> <span class="skolem">Q</span> <span class="main">=</span> Some <span class="free">t</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> hta_is_empty_witness_def<span class="main">)</span>
         <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> LC <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> LUQ <span class="keyword1"><span class="command">have</span></span> QqF<span class="main">:</span> <span class="quoted"><span class="quoted">"hm_α <span class="skolem">Q</span> <span class="skolem">q</span> <span class="main">=</span> Some <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hm_correct<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> I <span class="keyword1"><span class="command">have</span></span> QMEM<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span><span class="main">∈</span>hs_α Qi"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brec_invar_def brec_invar_add_def<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> witness_propD<span class="main">[</span><span class="operator">OF</span> X<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> QqF <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"accs <span class="main">(</span>ls_α δ<span class="main">)</span> <span class="free">t</span> <span class="skolem">q</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span><span class="main">∈</span>ta_lang <span class="main">(</span>hta_α <span class="free">H</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ta_lang_def hta_α_def<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">assume</span></span> C<span class="main">:</span> <span class="quoted"><span class="quoted">"hta_is_empty_witness <span class="free">H</span> <span class="main">=</span> None"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> DJ<span class="main">:</span> <span class="quoted"><span class="quoted">"hs_α Qi <span class="main">∩</span> dom <span class="main">(</span>hm_α <span class="skolem">Q</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> I
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hta_is_empty_witness_def LC brec_invar_def 
                         brec_invar_add_def hm_correct 
               <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> X <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hs_α Qi <span class="main">∩</span> b_accessible <span class="main">(</span>ls_α δ<span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> brec_α_def<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> empty_if_no_b_accessible<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"hta_α <span class="free">H</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ta_lang <span class="main">(</span>hta_α <span class="free">H</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hta_α_def<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?T1</span></span></span> <span class="var"><span class="quoted"><span class="var">?T2</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Interface for Natural Number States and Symbols›</span></span>
  <span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:htai_intf}›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The library-interface is statically instantiated to use natural numbers 
  as both, states and symbols.

  This interface is easier to use from ML and OCaml, because there is no 
  overhead with typeclass emulation.
›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> htai <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat<span class="main">,</span>nat<span class="main">)</span> hashedTa"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">htai_mem</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">⇒</span> htai <span class="main">⇒</span> bool"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">htai_mem</span> <span class="main">==</span> hta_mem"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">htai_prod</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"htai <span class="main">⇒</span> htai <span class="main">⇒</span> htai"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">htai_prod</span> <span class="free"><span class="bound"><span class="entity">H1</span></span></span> <span class="free"><span class="bound"><span class="entity">H2</span></span></span> <span class="main">==</span> hta_reindex <span class="main">(</span>hta_prod <span class="free"><span class="bound"><span class="entity">H1</span></span></span> <span class="free"><span class="bound"><span class="entity">H2</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">htai_prodWR</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"htai <span class="main">⇒</span> htai <span class="main">⇒</span> htai"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">htai_prodWR</span> <span class="free"><span class="bound"><span class="entity">H1</span></span></span> <span class="free"><span class="bound"><span class="entity">H2</span></span></span> <span class="main">==</span> hta_reindex <span class="main">(</span>hta_prodWR <span class="free"><span class="bound"><span class="entity">H1</span></span></span> <span class="free"><span class="bound"><span class="entity">H2</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">htai_union</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"htai <span class="main">⇒</span> htai <span class="main">⇒</span> htai"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">htai_union</span> <span class="free"><span class="bound"><span class="entity">H1</span></span></span> <span class="free"><span class="bound"><span class="entity">H2</span></span></span> <span class="main">==</span> hta_reindex <span class="main">(</span>hta_union <span class="free"><span class="bound"><span class="entity">H1</span></span></span> <span class="free"><span class="bound"><span class="entity">H2</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">htai_empty</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"unit <span class="main">⇒</span> htai"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">htai_empty</span> <span class="main">==</span> hta_empty"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">htai_add_qi</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">⇒</span> htai <span class="main">⇒</span> htai"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">htai_add_qi</span> <span class="main">==</span> hta_add_qi"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">htai_add_rule</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">⇒</span> htai <span class="main">⇒</span> htai"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">htai_add_rule</span> <span class="main">==</span> hta_add_rule"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">htai_bwd_reduce</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"htai <span class="main">⇒</span> htai"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">htai_bwd_reduce</span> <span class="main">==</span> hta_bwd_reduce"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">htai_is_empty_witness</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"htai <span class="main">⇒</span> <span class="main">_</span>"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">htai_is_empty_witness</span> <span class="main">==</span> hta_is_empty_witness"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">htai_ensure_idx_f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"htai <span class="main">⇒</span> htai"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">htai_ensure_idx_f</span> <span class="main">==</span> hta_ensure_idx_f"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">htai_ensure_idx_s</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"htai <span class="main">⇒</span> htai"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">htai_ensure_idx_s</span> <span class="main">==</span> hta_ensure_idx_s"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">htai_ensure_idx_sf</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"htai <span class="main">⇒</span> htai"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">htai_ensure_idx_sf</span> <span class="main">==</span> hta_ensure_idx_sf"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">htaip_prod</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"htai <span class="main">⇒</span> htai <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">*</span> nat<span class="main">,</span>nat<span class="main">)</span> hashedTa"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">htaip_prod</span> <span class="main">==</span> hta_prod"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">htaip_prodWR</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"htai <span class="main">⇒</span> htai <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">*</span> nat<span class="main">,</span>nat<span class="main">)</span> hashedTa"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">htaip_prodWR</span> <span class="main">==</span> hta_prodWR"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">htaip_reindex</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat <span class="main">*</span> nat<span class="main">,</span>nat<span class="main">)</span> hashedTa <span class="main">⇒</span> htai"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">htaip_reindex</span> <span class="main">==</span> hta_reindex"</span></span>

<span class="keyword1"><span class="command">locale</span></span> htai <span class="main">=</span> hashedTa <span class="main">+</span>
  <span class="keyword2"><span class="keyword">constrains</span></span> H <span class="main">::</span> <span class="quoted">htai</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">lemmas</span></span> htai_mem_correct <span class="main">=</span> hta_mem_correct<span class="main">[</span><span class="operator">folded</span> htai_mem_def<span class="main">]</span>

  <span class="keyword1"><span class="command">lemma</span></span> htai_empty_correct<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"hta_α <span class="main">(</span>htai_empty <span class="main">()</span><span class="main">)</span> <span class="main">=</span> ta_empty"</span></span>
    <span class="quoted"><span class="quoted">"hashedTa <span class="main">(</span>htai_empty <span class="main">()</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> htai_empty_def hta_empty_correct<span class="main">)</span>

  <span class="keyword1"><span class="command">lemmas</span></span> htai_add_qi_correct <span class="main">=</span> hta_add_qi_correct<span class="main">[</span><span class="operator">folded</span> htai_add_qi_def<span class="main">]</span>
  <span class="keyword1"><span class="command">lemmas</span></span> htai_add_rule_correct <span class="main">=</span> hta_add_rule_correct<span class="main">[</span><span class="operator">folded</span> htai_add_rule_def<span class="main">]</span>

  <span class="keyword1"><span class="command">lemmas</span></span> htai_bwd_reduce_correct <span class="main">=</span> 
    hta_bwd_reduce_correct<span class="main">[</span><span class="operator">folded</span> htai_bwd_reduce_def<span class="main">]</span>
  <span class="keyword1"><span class="command">lemmas</span></span> htai_is_empty_witness_correct <span class="main">=</span> 
    hta_is_empty_witness_correct<span class="main">[</span><span class="operator">folded</span> htai_is_empty_witness_def<span class="main">]</span>

  <span class="keyword1"><span class="command">lemmas</span></span> htai_ensure_idx_f_correct <span class="main">=</span> 
    hta_ensure_idx_f_correct<span class="main">[</span><span class="operator">folded</span> htai_ensure_idx_f_def<span class="main">]</span>
  <span class="keyword1"><span class="command">lemmas</span></span> htai_ensure_idx_s_correct <span class="main">=</span> 
    hta_ensure_idx_s_correct<span class="main">[</span><span class="operator">folded</span> htai_ensure_idx_s_def<span class="main">]</span>
  <span class="keyword1"><span class="command">lemmas</span></span> htai_ensure_idx_sf_correct <span class="main">=</span> 
    hta_ensure_idx_sf_correct<span class="main">[</span><span class="operator">folded</span> htai_ensure_idx_sf_def<span class="main">]</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> htai_prod_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hashedTa <span class="free">H1</span>"</span></span> <span class="quoted"><span class="quoted">"hashedTa <span class="free">H2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> 
  <span class="quoted"><span class="quoted">"ta_lang <span class="main">(</span>hta_α <span class="main">(</span>htai_prod <span class="free">H1</span> <span class="free">H2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> ta_lang <span class="main">(</span>hta_α <span class="free">H1</span><span class="main">)</span> <span class="main">∩</span> ta_lang <span class="main">(</span>hta_α <span class="free">H2</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"hashedTa <span class="main">(</span>htai_prod <span class="free">H1</span> <span class="free">H2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> htai_prod_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hta_prod_correct hashedTa.hta_reindex_correct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> htai_prodWR_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hashedTa <span class="free">H1</span>"</span></span> <span class="quoted"><span class="quoted">"hashedTa <span class="free">H2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> 
  <span class="quoted"><span class="quoted">"ta_lang <span class="main">(</span>hta_α <span class="main">(</span>htai_prodWR <span class="free">H1</span> <span class="free">H2</span><span class="main">)</span><span class="main">)</span> 
   <span class="main">=</span> ta_lang <span class="main">(</span>hta_α <span class="free">H1</span><span class="main">)</span> <span class="main">∩</span> ta_lang <span class="main">(</span>hta_α <span class="free">H2</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"hashedTa <span class="main">(</span>htai_prodWR <span class="free">H1</span> <span class="free">H2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> htai_prodWR_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hta_prodWR_correct hashedTa.hta_reindex_correct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> htai_union_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"hashedTa <span class="free">H1</span>"</span></span> <span class="quoted"><span class="quoted">"hashedTa <span class="free">H2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> 
  <span class="quoted"><span class="quoted">"ta_lang <span class="main">(</span>hta_α <span class="main">(</span>htai_union <span class="free">H1</span> <span class="free">H2</span><span class="main">)</span><span class="main">)</span> 
   <span class="main">=</span> ta_lang <span class="main">(</span>hta_α <span class="free">H1</span><span class="main">)</span> <span class="main">∪</span> ta_lang <span class="main">(</span>hta_α <span class="free">H2</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"hashedTa <span class="main">(</span>htai_union <span class="free">H1</span> <span class="free">H2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> htai_union_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hta_union_correct hashedTa.hta_reindex_correct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Interface Documentation›</span></span> <span class="keyword1"><span class="command">text_raw</span></span><span class="quoted"><span class="plain_text">‹\label{sec:intf_doc}›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This section contains a documentation of the executable tree-automata
  interface. The documentation contains a description of each function along
  with the relevant correctness lemmas.
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  ML/OCaml users should note, that there is an interface that has the fixed type
  Int for both states and function symbols. This interface is simpler to use
  from ML/OCaml than the generic one, as it requires no overhead to emulate
  Isabelle/HOL type-classes.

  The functions of this interface start with the prefix {\em htai} instead of
  {\em hta}, but have the same semantics otherwise 
  (cf Section~\ref{sec:htai_intf}).
›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Building a Tree Automaton›</span></span>
<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹
  \newcommand{\fundesc}[2]{{\bf Function: #1}\\#2}

›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  \fundesc{<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> [show_types] hta_empty<span class="antiquote"><span class="antiquote">}</span></span></span></span>}{
    Returns a tree automaton with no states and no rules. 
  }
  
  \paragraph{Relevant Lemmas}
  \begin{description}
    \item[<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] hta_empty_correct<span class="antiquote"><span class="antiquote">}</span></span></span></span>:] <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> hta_empty_correct<span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">no_vars</span></span><span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
    \item[<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] ta_empty_lang<span class="antiquote"><span class="antiquote">}</span></span></span></span>:] <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> ta_empty_lang<span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">no_vars</span></span><span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  \end{description}
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  \fundesc{<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> [show_types] hta_add_qi<span class="antiquote"><span class="antiquote">}</span></span></span></span>}{
    Adds an initial state to the given automaton.
  }
  \paragraph{Relevant Lemmas}
  \begin{description}
    \item[<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] hashedTa.hta_add_qi_correct<span class="antiquote"><span class="antiquote">}</span></span></span></span>]
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> hashedTa.hta_add_qi_correct<span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">no_vars</span></span><span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  \end{description}
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  \fundesc{<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> [show_types] hta_add_rule<span class="antiquote"><span class="antiquote">}</span></span></span></span>}{
    Adds a rule to the given automaton.
  }
  \paragraph{Relevant Lemmas}
  \begin{description}
    \item[<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] hashedTa.hta_add_rule_correct<span class="antiquote"><span class="antiquote">}</span></span></span></span>:]
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> hashedTa.hta_add_rule_correct<span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">no_vars</span></span><span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  \end{description}
›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Basic Operations›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The tree automata of this library may have some optional indices, that 
  accelerate computation. The tree-automata operations will compute the 
  indices if necessary, but due to the pure nature of the Isabelle-language,
  the computed index cannot be stored for the next usage. Hence, before using a
  bulk of tree-automaton operations on the same tree-automata, the relevant 
  indexes should be pre-computed.
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  \fundesc{
    <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> [show_types] hta_ensure_idx_f<span class="antiquote"><span class="antiquote">}</span></span></span></span>\\
    <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> [show_types] hta_ensure_idx_s<span class="antiquote"><span class="antiquote">}</span></span></span></span>\\
    <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> [show_types] hta_ensure_idx_sf<span class="antiquote"><span class="antiquote">}</span></span></span></span>
  }{
    Computes an index for a tree automaton, if it is not yet present.
  }
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  \fundesc{<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> [show_types] hta_mem<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> [show_types] hta_mem'<span class="antiquote"><span class="antiquote">}</span></span></span></span>}{
    Check whether a tree is accepted by the tree automaton.
  }
  \paragraph{Relevant Lemmas}
  \begin{description}
    \item[<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] hashedTa.hta_mem_correct<span class="antiquote"><span class="antiquote">}</span></span></span></span>:]
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> hashedTa.hta_mem_correct<span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">no_vars</span></span><span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
    \item[<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] hashedTa.hta_mem'_correct<span class="antiquote"><span class="antiquote">}</span></span></span></span>:]
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> hashedTa.hta_mem'_correct<span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">no_vars</span></span><span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  \end{description}
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  \fundesc{<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> [show_types] hta_prod<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> [show_types] hta_prod'<span class="antiquote"><span class="antiquote">}</span></span></span></span>}{
    Compute the product automaton. The computed automaton is in 
    forward-reduced form. 
    The language of the product automaton is the intersection of 
    the languages of the two argument automata.
  }
  \paragraph{Relevant Lemmas}
  \begin{description}
    \item[<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] hta_prod_correct_aux<span class="antiquote"><span class="antiquote">}</span></span></span></span>:] 
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> hta_prod_correct_aux<span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">no_vars</span></span><span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
    \item[<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] hta_prod_correct<span class="antiquote"><span class="antiquote">}</span></span></span></span>:] 
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> hta_prod_correct<span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">no_vars</span></span><span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
    \item[<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] hta_prod'_correct_aux<span class="antiquote"><span class="antiquote">}</span></span></span></span>:] 
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> hta_prod'_correct_aux<span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">no_vars</span></span><span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
    \item[<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] hta_prod'_correct<span class="antiquote"><span class="antiquote">}</span></span></span></span>:] 
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> hta_prod'_correct<span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">no_vars</span></span><span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  \end{description}
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  \fundesc{<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> [show_types] hta_prodWR<span class="antiquote"><span class="antiquote">}</span></span></span></span>}{
    Compute the product automaton by brute-force algorithm. 
    The resulting automaton is not reduced.
    The language of the product automaton is the intersection of 
    the languages of the two argument automata.
  }
  \paragraph{Relevant Lemmas}
  \begin{description}
  \item[<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] hta_prodWR_correct_aux<span class="antiquote"><span class="antiquote">}</span></span></span></span>:]
    <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> hta_prodWR_correct_aux<span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">no_vars</span></span><span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  \item[<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] hta_prodWR_correct<span class="antiquote"><span class="antiquote">}</span></span></span></span>:] 
    <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> hta_prodWR_correct<span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">no_vars</span></span><span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  \end{description}
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  \fundesc{<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> [show_types] hta_union<span class="antiquote"><span class="antiquote">}</span></span></span></span>}{
    Compute the union of two tree automata.
  }
  \paragraph{Relevant Lemmas}
  \begin{description}
  \item[<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] hta_union_correct'<span class="antiquote"><span class="antiquote">}</span></span></span></span>:] <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> hta_union_correct'<span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">no_vars</span></span><span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  \item[<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] hta_union_correct<span class="antiquote"><span class="antiquote">}</span></span></span></span>:] <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> hta_union_correct<span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">no_vars</span></span><span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  \end{description}
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  \fundesc{<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> [show_types] hta_reduce<span class="antiquote"><span class="antiquote">}</span></span></span></span>}{
    Reduce the automaton to the given set of states. All initial states outside
    this set will be removed. Moreover, all rules that contain states outside 
    this set are removed, too.
  }
  \paragraph{Relevant Lemmas}
  \begin{description}
    \item[<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] hashedTa.hta_reduce_correct<span class="antiquote"><span class="antiquote">}</span></span></span></span>:]
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> hashedTa.hta_reduce_correct<span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">no_vars</span></span><span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  \end{description}
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  \fundesc{<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> [show_types] hta_bwd_reduce<span class="antiquote"><span class="antiquote">}</span></span></span></span>}{
    Compute the backwards-reduced version of a tree automata.
    States from that no tree can be produced are removed. 
    Backwards reduction does not change the language of the automaton.
  }
  \paragraph{Relevant Lemmas}
  \begin{description}
    \item[<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] hashedTa.hta_bwd_reduce_correct<span class="antiquote"><span class="antiquote">}</span></span></span></span>:]
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> hashedTa.hta_bwd_reduce_correct<span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">no_vars</span></span><span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
    \item[<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] ta_reduce_b_acc<span class="antiquote"><span class="antiquote">}</span></span></span></span>:] <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> ta_reduce_b_acc<span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">no_vars</span></span><span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  \end{description}
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  \fundesc{<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> [show_types] hta_is_empty_witness<span class="antiquote"><span class="antiquote">}</span></span></span></span>}{
    Check whether the language of the automaton is empty.
    If the language is not empty, a tree of the language is returned.

    The following property is not (yet) formally proven, but should hold: 
    If a tree is returned, the language contains no tree with a smaller depth
    than the returned one.
  }
  \paragraph{Relevant Lemmas}
  \begin{description}
    \item[<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] hashedTa.hta_is_empty_witness_correct<span class="antiquote"><span class="antiquote">}</span></span></span></span>:]
       <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> hashedTa.hta_is_empty_witness_correct<span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">no_vars</span></span><span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  \end{description}
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Code Generation›</span></span>

<span class="comment1">(* TODO/FIXME: There seems to be no way to reference the project-directory,
  in order to control the placement of the generated code files.
  The code-generation in this file only dumps the generated code to standard output.
  Hence it is safe to include this file from other projects.

  Actual code generation is done in Ta_impl_codegen.thy
  *)</span>

<span class="keyword1"><span class="command">export_code</span></span> 
  <span class="quoted"><span class="quoted">hta_mem</span></span> <span class="quoted"><span class="quoted">hta_mem'</span></span> <span class="quoted"><span class="quoted">hta_prod</span></span> <span class="quoted"><span class="quoted">hta_prod'</span></span> <span class="quoted"><span class="quoted">hta_prodWR</span></span> <span class="quoted"><span class="quoted">hta_union</span></span> 
  <span class="quoted"><span class="quoted">hta_empty</span></span> <span class="quoted"><span class="quoted">hta_add_qi</span></span> <span class="quoted"><span class="quoted">hta_add_rule</span></span>
  <span class="quoted"><span class="quoted">hta_reduce</span></span> <span class="quoted"><span class="quoted">hta_bwd_reduce</span></span> <span class="quoted"><span class="quoted">hta_is_empty_witness</span></span>
  <span class="quoted"><span class="quoted">hta_ensure_idx_f</span></span> <span class="quoted"><span class="quoted">hta_ensure_idx_s</span></span> <span class="quoted"><span class="quoted">hta_ensure_idx_sf</span></span>

  <span class="quoted"><span class="quoted">htai_mem</span></span> <span class="quoted"><span class="quoted">htai_prod</span></span> <span class="quoted"><span class="quoted">htai_prodWR</span></span> <span class="quoted"><span class="quoted">htai_union</span></span> 
  <span class="quoted"><span class="quoted">htai_empty</span></span> <span class="quoted"><span class="quoted">htai_add_qi</span></span> <span class="quoted"><span class="quoted">htai_add_rule</span></span>
  <span class="quoted"><span class="quoted">htai_bwd_reduce</span></span> <span class="quoted"><span class="quoted">htai_is_empty_witness</span></span>
  <span class="quoted"><span class="quoted">htai_ensure_idx_f</span></span> <span class="quoted"><span class="quoted">htai_ensure_idx_s</span></span> <span class="quoted"><span class="quoted">htai_ensure_idx_sf</span></span>

  <span class="comment1">(*ls_size hs_size rs_size*)</span>
  <span class="keyword2"><span class="keyword">in</span></span> SML 
  <span class="keyword2"><span class="keyword">module_name</span></span> Ta


<span class="keyword1"><span class="command">export_code</span></span> 
  <span class="quoted"><span class="quoted">hta_mem</span></span> <span class="quoted"><span class="quoted">hta_mem'</span></span> <span class="quoted"><span class="quoted">hta_prod</span></span> <span class="quoted"><span class="quoted">hta_prod'</span></span> <span class="quoted"><span class="quoted">hta_prodWR</span></span> <span class="quoted"><span class="quoted">hta_union</span></span> 
  <span class="quoted"><span class="quoted">hta_empty</span></span> <span class="quoted"><span class="quoted">hta_add_qi</span></span> <span class="quoted"><span class="quoted">hta_add_rule</span></span>
  <span class="quoted"><span class="quoted">hta_reduce</span></span> <span class="quoted"><span class="quoted">hta_bwd_reduce</span></span> <span class="quoted"><span class="quoted">hta_is_empty_witness</span></span>
  <span class="quoted"><span class="quoted">hta_ensure_idx_f</span></span> <span class="quoted"><span class="quoted">hta_ensure_idx_s</span></span> <span class="quoted"><span class="quoted">hta_ensure_idx_sf</span></span>

  <span class="quoted"><span class="quoted">htai_mem</span></span> <span class="quoted"><span class="quoted">htai_prod</span></span> <span class="quoted"><span class="quoted">htai_prodWR</span></span> <span class="quoted"><span class="quoted">htai_union</span></span> 
  <span class="quoted"><span class="quoted">htai_empty</span></span> <span class="quoted"><span class="quoted">htai_add_qi</span></span> <span class="quoted"><span class="quoted">htai_add_rule</span></span>
  <span class="quoted"><span class="quoted">htai_bwd_reduce</span></span> <span class="quoted"><span class="quoted">htai_is_empty_witness</span></span>
  <span class="quoted"><span class="quoted">htai_ensure_idx_f</span></span> <span class="quoted"><span class="quoted">htai_ensure_idx_s</span></span> <span class="quoted"><span class="quoted">htai_ensure_idx_sf</span></span>

  <span class="comment1">(*ls_size hs_size rs_size*)</span>
  <span class="keyword2"><span class="keyword">in</span></span> Haskell 
  <span class="keyword2"><span class="keyword">module_name</span></span> Ta
  <span class="main">(</span>string_classes<span class="main">)</span>

<span class="keyword1"><span class="command">export_code</span></span> 
  <span class="quoted"><span class="quoted">hta_mem</span></span> <span class="quoted"><span class="quoted">hta_mem'</span></span> <span class="quoted"><span class="quoted">hta_prod</span></span> <span class="quoted"><span class="quoted">hta_prod'</span></span> <span class="quoted"><span class="quoted">hta_prodWR</span></span> <span class="quoted"><span class="quoted">hta_union</span></span> 
  <span class="quoted"><span class="quoted">hta_empty</span></span> <span class="quoted"><span class="quoted">hta_add_qi</span></span> <span class="quoted"><span class="quoted">hta_add_rule</span></span>
  <span class="quoted"><span class="quoted">hta_reduce</span></span> <span class="quoted"><span class="quoted">hta_bwd_reduce</span></span> <span class="quoted"><span class="quoted">hta_is_empty_witness</span></span>
  <span class="quoted"><span class="quoted">hta_ensure_idx_f</span></span> <span class="quoted"><span class="quoted">hta_ensure_idx_s</span></span> <span class="quoted"><span class="quoted">hta_ensure_idx_sf</span></span>

  <span class="quoted"><span class="quoted">htai_mem</span></span> <span class="quoted"><span class="quoted">htai_prod</span></span> <span class="quoted"><span class="quoted">htai_prodWR</span></span> <span class="quoted"><span class="quoted">htai_union</span></span> 
  <span class="quoted"><span class="quoted">htai_empty</span></span> <span class="quoted"><span class="quoted">htai_add_qi</span></span> <span class="quoted"><span class="quoted">htai_add_rule</span></span>
  <span class="quoted"><span class="quoted">htai_bwd_reduce</span></span> <span class="quoted"><span class="quoted">htai_is_empty_witness</span></span>
  <span class="quoted"><span class="quoted">htai_ensure_idx_f</span></span> <span class="quoted"><span class="quoted">htai_ensure_idx_s</span></span> <span class="quoted"><span class="quoted">htai_ensure_idx_sf</span></span>

  <span class="comment1">(*ls_size hs_size rs_size*)</span>
  <span class="keyword2"><span class="keyword">in</span></span> OCaml 
  <span class="keyword2"><span class="keyword">module_name</span></span> Ta

<span class="comment1">(* If this statement fails with an error from ML, this indicates a problem 
  with the code-generator. The most frequent problem in this context is, that
  the code generator generates code that violates the ML value-restriction.
*)</span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">hta_mem</span><span class="antiquote">}</span></span></span><span class="main">;</span>
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">hta_mem'</span><span class="antiquote">}</span></span></span><span class="main">;</span>
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">hta_prod</span><span class="antiquote">}</span></span></span><span class="main">;</span>
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">hta_prod'</span><span class="antiquote">}</span></span></span><span class="main">;</span>
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">hta_prodWR</span><span class="antiquote">}</span></span></span><span class="main">;</span>
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">hta_union</span><span class="antiquote">}</span></span></span><span class="main">;</span>
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">hta_empty</span><span class="antiquote">}</span></span></span><span class="main">;</span>
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">hta_add_qi</span><span class="antiquote">}</span></span></span><span class="main">;</span>
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">hta_add_rule</span><span class="antiquote">}</span></span></span><span class="main">;</span>
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">hta_reduce</span><span class="antiquote">}</span></span></span><span class="main">;</span>
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">hta_bwd_reduce</span><span class="antiquote">}</span></span></span><span class="main">;</span>
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">hta_is_empty_witness</span><span class="antiquote">}</span></span></span><span class="main">;</span>
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">hta_ensure_idx_f</span><span class="antiquote">}</span></span></span><span class="main">;</span>
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">hta_ensure_idx_s</span><span class="antiquote">}</span></span></span><span class="main">;</span>
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">hta_ensure_idx_sf</span><span class="antiquote">}</span></span></span><span class="main">;</span>
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">htai_mem</span><span class="antiquote">}</span></span></span><span class="main">;</span>
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">htai_prod</span><span class="antiquote">}</span></span></span><span class="main">;</span>
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">htai_prodWR</span><span class="antiquote">}</span></span></span><span class="main">;</span>
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">htai_union</span><span class="antiquote">}</span></span></span><span class="main">;</span>
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">htai_empty</span><span class="antiquote">}</span></span></span><span class="main">;</span>
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">htai_add_qi</span><span class="antiquote">}</span></span></span><span class="main">;</span>
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">htai_add_rule</span><span class="antiquote">}</span></span></span><span class="main">;</span>
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">htai_bwd_reduce</span><span class="antiquote">}</span></span></span><span class="main">;</span>
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">htai_is_empty_witness</span><span class="antiquote">}</span></span></span><span class="main">;</span>
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">htai_ensure_idx_f</span><span class="antiquote">}</span></span></span><span class="main">;</span>
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">htai_ensure_idx_s</span><span class="antiquote">}</span></span></span><span class="main">;</span>
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">htai_ensure_idx_sf</span><span class="antiquote">}</span></span></span><span class="main">;</span>
  <span class="comment1">(*@{code ls_size};
  @{code hs_size};
  @{code rs_size}*)</span>
›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Ta_impl_codegen">
<div class="head">
<h1>Theory Ta_impl_codegen</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> Ta_impl_codegen
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Ta_impl.html">Ta_impl</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*
  Code generation with actual directories as targets.
  As there is no way to reference the project directory for code generation targets,
  the code generation has been put into this file so that it is not
  invoked when Ta_impl is included from other projects (In which case the code generation targets would be 
  errounously interpreted relative to the including project's path).
*)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ls_size</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ls_size</span> <span class="main">≡</span> ls.size"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">hs_size</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">hs_size</span> <span class="main">≡</span> hs.size"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">rs_size</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">rs_size</span> <span class="main">≡</span> rs.size"</span></span>

<span class="comment1">(* CAUTION: If this statement fails because the directory cannot be found, 
  you are probably including this library from another project, and the 
  relative path refers to that project's directory. As there seems to be 
  no way to reference a project's directory in the path, the only known 
  workaround is to disable writing the code to a file, by simply replacing
  the filename by "-" *)</span>
<span class="keyword1"><span class="command">export_code</span></span> 
  <span class="quoted"><span class="quoted">hta_mem</span></span> <span class="quoted"><span class="quoted">hta_mem'</span></span> <span class="quoted"><span class="quoted">hta_prod</span></span> <span class="quoted"><span class="quoted">hta_prod'</span></span> <span class="quoted"><span class="quoted">hta_prodWR</span></span> <span class="quoted"><span class="quoted">hta_union</span></span> 
  <span class="quoted"><span class="quoted">hta_empty</span></span> <span class="quoted"><span class="quoted">hta_add_qi</span></span> <span class="quoted"><span class="quoted">hta_add_rule</span></span>
  <span class="quoted"><span class="quoted">hta_reduce</span></span> <span class="quoted"><span class="quoted">hta_bwd_reduce</span></span> <span class="quoted"><span class="quoted">hta_is_empty_witness</span></span>
  <span class="quoted"><span class="quoted">hta_ensure_idx_f</span></span> <span class="quoted"><span class="quoted">hta_ensure_idx_s</span></span> <span class="quoted"><span class="quoted">hta_ensure_idx_sf</span></span>

  <span class="quoted"><span class="quoted">htai_mem</span></span> <span class="quoted"><span class="quoted">htai_prod</span></span> <span class="quoted"><span class="quoted">htai_prodWR</span></span> <span class="quoted"><span class="quoted">htai_union</span></span> 
  <span class="quoted"><span class="quoted">htai_empty</span></span> <span class="quoted"><span class="quoted">htai_add_qi</span></span> <span class="quoted"><span class="quoted">htai_add_rule</span></span>
  <span class="quoted"><span class="quoted">htai_bwd_reduce</span></span> <span class="quoted"><span class="quoted">htai_is_empty_witness</span></span>
  <span class="quoted"><span class="quoted">htai_ensure_idx_f</span></span> <span class="quoted"><span class="quoted">htai_ensure_idx_s</span></span> <span class="quoted"><span class="quoted">htai_ensure_idx_sf</span></span>

  <span class="quoted"><span class="quoted">integer_of_nat</span></span> <span class="quoted"><span class="quoted">nat_of_integer</span></span>

  <span class="quoted"><span class="quoted">ls_size</span></span> <span class="quoted"><span class="quoted">hs_size</span></span> <span class="quoted"><span class="quoted">rs_size</span></span>
  <span class="keyword2"><span class="keyword">in</span></span> SML 
  <span class="keyword2"><span class="keyword">module_name</span></span> Ta
  <span class="keyword2"><span class="keyword">file</span></span> <span class="quoted">‹code/ml/generated/Ta.ML›</span>


<span class="comment1">(* CAUTION: If this statement fails because the directory cannot be found, 
  you are probably including this library from another project, and the 
  relative path refers to that project's directory. As there seems to be 
  no way to reference a project's directory in the path, the only known 
  workaround is to disable writing the code to a file, by simply replacing
  the filename by "-" *)</span>
<span class="keyword1"><span class="command">export_code</span></span> 
  <span class="quoted"><span class="quoted">hta_mem</span></span> <span class="quoted"><span class="quoted">hta_mem'</span></span> <span class="quoted"><span class="quoted">hta_prod</span></span> <span class="quoted"><span class="quoted">hta_prod'</span></span> <span class="quoted"><span class="quoted">hta_prodWR</span></span> <span class="quoted"><span class="quoted">hta_union</span></span> 
  <span class="quoted"><span class="quoted">hta_empty</span></span> <span class="quoted"><span class="quoted">hta_add_qi</span></span> <span class="quoted"><span class="quoted">hta_add_rule</span></span>
  <span class="quoted"><span class="quoted">hta_reduce</span></span> <span class="quoted"><span class="quoted">hta_bwd_reduce</span></span> <span class="quoted"><span class="quoted">hta_is_empty_witness</span></span>
  <span class="quoted"><span class="quoted">hta_ensure_idx_f</span></span> <span class="quoted"><span class="quoted">hta_ensure_idx_s</span></span> <span class="quoted"><span class="quoted">hta_ensure_idx_sf</span></span>

  <span class="quoted"><span class="quoted">htai_mem</span></span> <span class="quoted"><span class="quoted">htai_prod</span></span> <span class="quoted"><span class="quoted">htai_prodWR</span></span> <span class="quoted"><span class="quoted">htai_union</span></span> 
  <span class="quoted"><span class="quoted">htai_empty</span></span> <span class="quoted"><span class="quoted">htai_add_qi</span></span> <span class="quoted"><span class="quoted">htai_add_rule</span></span>
  <span class="quoted"><span class="quoted">htai_bwd_reduce</span></span> <span class="quoted"><span class="quoted">htai_is_empty_witness</span></span>
  <span class="quoted"><span class="quoted">htai_ensure_idx_f</span></span> <span class="quoted"><span class="quoted">htai_ensure_idx_s</span></span> <span class="quoted"><span class="quoted">htai_ensure_idx_sf</span></span>

  <span class="quoted"><span class="quoted">integer_of_nat</span></span> <span class="quoted"><span class="quoted">nat_of_integer</span></span>

  <span class="quoted"><span class="quoted">ls_size</span></span> <span class="quoted"><span class="quoted">hs_size</span></span> <span class="quoted"><span class="quoted">rs_size</span></span>
  <span class="keyword2"><span class="keyword">in</span></span> Haskell 
  <span class="keyword2"><span class="keyword">module_name</span></span> Ta
  <span class="keyword2"><span class="keyword">file</span></span> <span class="quoted">‹code/haskell/generated›</span>
  <span class="main">(</span>string_classes<span class="main">)</span>

<span class="comment1">(* CAUTION: If this statement fails because the directory cannot be found, 
  you are probably including this library from another project, and the 
  relative path refers to that project's directory. As there seems to be 
  no way to reference a project's directory in the path, the only known 
  workaround is to disable writing the code to a file, by simply replacing
  the filename by "-" *)</span>
<span class="keyword1"><span class="command">export_code</span></span> 
  <span class="quoted"><span class="quoted">hta_mem</span></span> <span class="quoted"><span class="quoted">hta_mem'</span></span> <span class="quoted"><span class="quoted">hta_prod</span></span> <span class="quoted"><span class="quoted">hta_prod'</span></span> <span class="quoted"><span class="quoted">hta_prodWR</span></span> <span class="quoted"><span class="quoted">hta_union</span></span> 
  <span class="quoted"><span class="quoted">hta_empty</span></span> <span class="quoted"><span class="quoted">hta_add_qi</span></span> <span class="quoted"><span class="quoted">hta_add_rule</span></span>
  <span class="quoted"><span class="quoted">hta_reduce</span></span> <span class="quoted"><span class="quoted">hta_bwd_reduce</span></span> <span class="quoted"><span class="quoted">hta_is_empty_witness</span></span>
  <span class="quoted"><span class="quoted">hta_ensure_idx_f</span></span> <span class="quoted"><span class="quoted">hta_ensure_idx_s</span></span> <span class="quoted"><span class="quoted">hta_ensure_idx_sf</span></span>

  <span class="quoted"><span class="quoted">htai_mem</span></span> <span class="quoted"><span class="quoted">htai_prod</span></span> <span class="quoted"><span class="quoted">htai_prodWR</span></span> <span class="quoted"><span class="quoted">htai_union</span></span> 
  <span class="quoted"><span class="quoted">htai_empty</span></span> <span class="quoted"><span class="quoted">htai_add_qi</span></span> <span class="quoted"><span class="quoted">htai_add_rule</span></span>
  <span class="quoted"><span class="quoted">htai_bwd_reduce</span></span> <span class="quoted"><span class="quoted">htai_is_empty_witness</span></span>
  <span class="quoted"><span class="quoted">htai_ensure_idx_f</span></span> <span class="quoted"><span class="quoted">htai_ensure_idx_s</span></span> <span class="quoted"><span class="quoted">htai_ensure_idx_sf</span></span>

  <span class="quoted"><span class="quoted">integer_of_nat</span></span> <span class="quoted"><span class="quoted">nat_of_integer</span></span>

  <span class="quoted"><span class="quoted">ls_size</span></span> <span class="quoted"><span class="quoted">hs_size</span></span> <span class="quoted"><span class="quoted">rs_size</span></span>
  <span class="keyword2"><span class="keyword">in</span></span> OCaml 
  <span class="keyword2"><span class="keyword">module_name</span></span> Ta
  <span class="keyword2"><span class="keyword">file</span></span> <span class="quoted">‹code/ocaml/generated/Ta.ml›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>