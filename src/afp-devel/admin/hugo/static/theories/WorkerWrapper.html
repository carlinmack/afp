<div id="Nats">
<div class="head">
<h1>Theory Nats</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="comment1">(*
 * Domains of natural numbers.
 * (C)opyright 2009-2011, Peter Gammie, peteg42 at gmail.com.
 * License: BSD
 *)</span>

<span class="keyword1"><span class="command">theory</span></span> Nats
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOLCF/HOLCF.html">HOLCF</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Boxed Types, HOL's natural numbers hoisted.›</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Unboxed naturals.›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹We can represent the unboxed naturals as a discrete domain (every
number is equal to itself and unequal to everything else, and there is no
bottom). Think of these functions as the machine operations.

We could actually lift all HOL types and classes in this way; indeed
the HOLCF theory "Lift" does something similar, but is not as
fine-grained as this development.

Note: we default to just CPOs (not pointed CPOs) in this theory. We
adopt bothg the Isabelle syntax for overloaded arithmetic and the
notation for unboxed operators of \citet{SPJ-JL:1991}.›</span></span>

<span class="keyword1"><span class="command">default_sort</span></span> <span class="quoted">predomain</span>

<span class="keyword1"><span class="command">type_synonym</span></span> UNat <span class="main">=</span> <span class="quoted"><span class="quoted">"nat discr"</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> discr <span class="main">::</span> <span class="main">(</span><span class="quoted">zero</span><span class="main">)</span> <span class="quoted">zero</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> zero_discr_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≡</span> Discr <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> zero_discr<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"undiscr <span class="main">0</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> zero_discr_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">instantiation</span></span> discr <span class="main">::</span> <span class="main">(</span><span class="quoted">one</span><span class="main">)</span> <span class="quoted">one</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> one_discr_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">≡</span> Discr <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> one_discr<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"undiscr <span class="main">1</span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> one_discr_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">instantiation</span></span> discr <span class="main">::</span> <span class="main">(</span><span class="quoted">ord</span><span class="main">)</span> <span class="quoted">ord</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> less_def<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">≡</span> <span class="main">(</span>undiscr <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">&lt;</span> <span class="main">(</span>undiscr <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> le_def<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>   <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">≡</span> <span class="main">(</span>undiscr <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">≤</span> <span class="main">(</span>undiscr <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">uPlus</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"UNat <span class="main">→</span> UNat <span class="main">→</span> UNat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">uPlus</span> <span class="main">≡</span> <span class="keyword1">Λ</span> x y<span class="main">.</span> Discr <span class="main">(</span>undiscr <span class="bound">x</span> <span class="main">+</span> undiscr <span class="bound">y</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">uPlus_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"UNat <span class="main">⇒</span> UNat <span class="main">⇒</span> UNat"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">+<span class="hidden">⇩</span><sub>#</sub></span>"</span> 65<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main"><span class="free">+<span class="hidden">⇩</span><sub>#</sub></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≡</span> uPlus<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">y</span></span></span>"</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> discr <span class="main">::</span> <span class="main">(</span><span class="quoted">plus</span><span class="main">)</span> <span class="quoted">plus</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> plus_discr_def<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">+</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≡</span> Discr <span class="main">(</span>undiscr <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">+</span> undiscr <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">uMinus</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"UNat <span class="main">→</span> UNat <span class="main">→</span> UNat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">uMinus</span> <span class="main">≡</span> <span class="keyword1">Λ</span> x y<span class="main">.</span> Discr <span class="main">(</span>undiscr <span class="bound">x</span> <span class="main">-</span> undiscr <span class="bound">y</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">uMinus_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"UNat <span class="main">⇒</span> UNat <span class="main">⇒</span> UNat"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">-<span class="hidden">⇩</span><sub>#</sub></span>"</span> 65<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main"><span class="free">-<span class="hidden">⇩</span><sub>#</sub></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≡</span> uMinus<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">y</span></span></span>"</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> discr <span class="main">::</span> <span class="main">(</span><span class="quoted">minus</span><span class="main">)</span> <span class="quoted">minus</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> minus_discr_def<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≡</span> Discr <span class="main">(</span>undiscr <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">-</span> undiscr <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">uMult</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"UNat <span class="main">→</span> UNat <span class="main">→</span> UNat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">uMult</span> <span class="main">≡</span> <span class="keyword1">Λ</span> x y<span class="main">.</span> Discr <span class="main">(</span>undiscr <span class="bound">x</span> <span class="main">*</span> undiscr <span class="bound">y</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">uMult_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"UNat <span class="main">⇒</span> UNat <span class="main">⇒</span> UNat"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">*<span class="hidden">⇩</span><sub>#</sub></span>"</span> 65<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main"><span class="free">*<span class="hidden">⇩</span><sub>#</sub></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≡</span> uMult<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">y</span></span></span>"</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> discr <span class="main">::</span> <span class="main">(</span><span class="quoted">times</span><span class="main">)</span> <span class="quoted">times</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> times_discr_def<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">*</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≡</span> Discr <span class="main">(</span>undiscr <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">*</span> undiscr <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> uMult_unit_left<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">*<span class="hidden">⇩</span><sub>#</sub></span> <span class="main">(</span><span class="free">x</span><span class="main">::</span>UNat<span class="main">)</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> uMult_def one_discr_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> uMult_unit_right<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">::</span>UNat<span class="main">)</span> <span class="main">*<span class="hidden">⇩</span><sub>#</sub></span> <span class="main">1</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> uMult_def one_discr_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> uMult_assoc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">*<span class="hidden">⇩</span><sub>#</sub></span> <span class="free">y</span><span class="main">)</span> <span class="main">*<span class="hidden">⇩</span><sub>#</sub></span> <span class="free">z</span> <span class="main">=</span> <span class="free">x</span> <span class="main">*<span class="hidden">⇩</span><sub>#</sub></span> <span class="main">(</span><span class="free">y</span> <span class="main">*<span class="hidden">⇩</span><sub>#</sub></span> <span class="free">z</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> uMult_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> uMult_commute<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">*<span class="hidden">⇩</span><sub>#</sub></span> <span class="free">y</span> <span class="main">=</span> <span class="free">y</span> <span class="main">*<span class="hidden">⇩</span><sub>#</sub></span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> uMult_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> uMult_left_commute<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">*<span class="hidden">⇩</span><sub>#</sub></span> <span class="main">(</span><span class="free">b</span> <span class="main">*<span class="hidden">⇩</span><sub>#</sub></span> <span class="free">c</span><span class="main">)</span> <span class="main">=</span> <span class="free">b</span> <span class="main">*<span class="hidden">⇩</span><sub>#</sub></span> <span class="main">(</span><span class="free">a</span> <span class="main">*<span class="hidden">⇩</span><sub>#</sub></span> <span class="free">c</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> uMult_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemmas</span></span> uMult_arithmetic <span class="main">=</span>
  uMult_unit_left uMult_unit_right uMult_assoc uMult_commute uMult_left_commute

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The "<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="main"><span class="quoted"><span class="main">⊥</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>" monad.›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

As Brian Huffman helpfully observed, the "<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">⊥</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>" type
constructor supports the monadic operations; it's isomorphic to
Haskell's <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">Maybe</span></span> <span class="free"><span class="free">a</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, or ML's <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> option"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

Note that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">return</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"up"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">bbind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>cpo<span class="main">)</span><span class="main"><span class="hidden">⇩</span><sub>⊥</sub></span> <span class="main">→</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">::</span>pcpo<span class="main">)</span><span class="main">)</span> <span class="main">→</span> <span class="tfree">'b</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">bbind</span> <span class="main">≡</span> <span class="keyword1">Λ</span> b g<span class="main">.</span> fup<span class="main">⋅</span><span class="bound">g</span><span class="main">⋅</span><span class="bound">b</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">bbind_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>cpo<span class="main">)</span><span class="main"><span class="hidden">⇩</span><sub>⊥</sub></span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">::</span>pcpo<span class="main">)</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">&gt;&gt;=</span>"</span> 65<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main"><span class="free">&gt;&gt;=</span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">≡</span> bbind<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">g</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> bbind_strict1<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bbind<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bbind_def<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> bbind_strict2<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">&gt;&gt;=</span> <span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bbind_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> bbind_leftID<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"up<span class="main">⋅</span><span class="free">a</span> <span class="main">&gt;&gt;=</span> <span class="free">f</span> <span class="main">=</span> <span class="free">f</span><span class="main">⋅</span><span class="free">a</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bbind_def<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> bbind_rightID<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">&gt;&gt;=</span> up <span class="main">=</span> <span class="free">m</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">m</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> bbind_assoc<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">&gt;&gt;=</span> <span class="free">g</span> <span class="main">&gt;&gt;=</span> <span class="free">h</span> <span class="main">=</span> <span class="free">f</span> <span class="main">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="free">g</span><span class="main">⋅</span><span class="bound">x</span> <span class="main">&gt;&gt;=</span> <span class="free">h</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">f</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> bbind_case_distr_strict<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span> <span class="main">⟹</span> <span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">g</span> <span class="main">&gt;&gt;=</span> <span class="free">h</span><span class="main">)</span> <span class="main">=</span> <span class="free">g</span> <span class="main">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">h</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> bbind_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">g</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Kleisli composition is sometimes helpful. It forms a monad too,
and has many useful algebraic properties. Unfortunately it is more
work than is useful to write the lemmas in a way that makes the
higher-order unifier in the simplifier happy. Seems easier just to
unfold the definition and go from there.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">bKleisli</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>cpo <span class="main">→</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">::</span>cpo<span class="main">)</span><span class="main"><span class="hidden">⇩</span><sub>⊥</sub></span><span class="main">)</span> <span class="main">→</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">→</span> <span class="main">(</span><span class="tfree">'c</span><span class="main">::</span>cpo<span class="main">)</span><span class="main"><span class="hidden">⇩</span><sub>⊥</sub></span><span class="main">)</span> <span class="main">→</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'c</span><span class="main"><span class="hidden">⇩</span><sub>⊥</sub></span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">bKleisli</span> <span class="main">≡</span> <span class="keyword1">Λ</span> f g x<span class="main">.</span> <span class="bound">f</span><span class="main">⋅</span><span class="bound">x</span> <span class="main">&gt;&gt;=</span> <span class="bound">g</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">bKleisli_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>cpo <span class="main">→</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">::</span>cpo<span class="main">)</span><span class="main"><span class="hidden">⇩</span><sub>⊥</sub></span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">→</span> <span class="main">(</span><span class="tfree">'c</span><span class="main">::</span>cpo<span class="main">)</span><span class="main"><span class="hidden">⇩</span><sub>⊥</sub></span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'c</span><span class="main"><span class="hidden">⇩</span><sub>⊥</sub></span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">&gt;=&gt;</span>"</span> 65<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main"><span class="free">&gt;=&gt;</span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">≡</span> bKleisli<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">g</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> bKleisli_strict1<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bKleisli<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bKleisli_def<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> bKleisli_strict2<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">&gt;=&gt;</span> <span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bKleisli_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> bKleisli_bbind<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">&gt;&gt;=</span> <span class="free">g</span><span class="main">)</span> <span class="main">&gt;=&gt;</span> <span class="free">h</span> <span class="main">=</span> <span class="free">f</span> <span class="main">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="free">g</span><span class="main">⋅</span><span class="bound">x</span> <span class="main">&gt;=&gt;</span> <span class="free">h</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">f</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹

The "Box" type denotes computations that, when demanded, yield
either <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">⊥</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> or an unboxed value. Note that the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">Box</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
constructor is strict, and so merely tags the lifted computation <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span>
<span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main"><span class="hidden">⇩</span><sub>⊥</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> can be pointed or unpointed. This approach enables
us to distinguish the boxed values from the lifted-function-space that
models recursive functions with unboxed codomains.

›</span></span>

<span class="keyword1"><span class="command">domain</span></span> <span class="tfree">'a</span> Box <span class="main">=</span> Box <span class="main">(</span>unbox <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main"><span class="hidden">⇩</span><sub>⊥</sub></span>"</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">box</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>predomain<span class="main">)</span> <span class="main">→</span> <span class="tfree">'a</span> Box"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">box</span> <span class="main">≡</span> Box <span class="keyword1">oo</span> up"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> boxI<span class="main">:</span> <span class="quoted"><span class="quoted">"Box<span class="main">⋅</span><span class="main">(</span>up<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> box<span class="main">⋅</span><span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> box_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> unbox_box<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"unbox<span class="main">⋅</span><span class="main">(</span>box<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> up<span class="main">⋅</span><span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> box_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> unbox_Box<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟹</span> unbox<span class="main">⋅</span><span class="main">(</span>Box<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

If we suceed in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"box"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>ing something, then clearly that
something was not <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">⊥</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> box_casedist<span class="main">[</span><span class="operator">case_names</span> bottom Box<span class="main">,</span> <span class="operator">cases</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">type</span></span></span><span class="main"><span class="main"><span class="main"><span class="main">:</span></span></span></span> Box<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> xbot<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="main">⊥</span> <span class="main">⟹</span> <span class="free">P</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> xbox<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">u</span><span class="main">.</span> <span class="free">x</span> <span class="main">=</span> box<span class="main">⋅</span><span class="bound">u</span> <span class="main">⟹</span> <span class="free">P</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> bottom <span class="keyword1"><span class="command">with</span></span> xbot <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Box <span class="skolem">u</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> xbox <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">u</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> box_def up_def cont_Iup bottomI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> minimal_up<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> bbind_leftID'<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"unbox<span class="main">⋅</span><span class="free">a</span> <span class="main">&gt;&gt;=</span> box <span class="main">=</span> <span class="free">a</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">a</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bbind_def<span class="main">)</span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹

The optimisations of \citet{SPJ-JL:1991}.

p11: Repeated unboxing of the same value can be done once (roughly:
store the value in a register). Their story is more general.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> box_repeated<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1">Λ</span> x'<span class="main">.</span> <span class="free">f</span> <span class="main">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1">Λ</span> y'<span class="main">.</span> <span class="free">x</span> <span class="main">&gt;&gt;=</span> <span class="free">body</span><span class="main">⋅</span><span class="bound">x'</span><span class="main">⋅</span><span class="bound">y'</span><span class="main">)</span><span class="main">)</span>
  <span class="main">=</span> <span class="free">x</span> <span class="main">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1">Λ</span> x'<span class="main">.</span> <span class="free">f</span> <span class="main">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1">Λ</span> y'<span class="main">.</span> <span class="free">body</span><span class="main">⋅</span><span class="bound">x'</span><span class="main">⋅</span><span class="bound">y'</span><span class="main">⋅</span><span class="bound">x'</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Lift binary predicates over <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> discr"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> into <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> discr Box"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">bliftM</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">bliftM2</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> encapsulate the boxing
and unboxing.›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">bliftM</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>predomain <span class="main">→</span> <span class="tfree">'b</span><span class="main">::</span>predomain<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> Box <span class="main">→</span> <span class="tfree">'b</span> Box"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">bliftM</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="keyword1">Λ</span> x<span class="main">.</span> unbox<span class="main">⋅</span><span class="bound">x</span> <span class="main">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1">Λ</span> x'<span class="main">.</span> box<span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="bound">x'</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> bliftM_strict1<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bliftM <span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bliftM_def<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> bliftM_op<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bliftM <span class="free">f</span><span class="main">⋅</span><span class="main">(</span>box<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> box<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bliftM_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">bliftM2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>predomain <span class="main">→</span> <span class="tfree">'b</span><span class="main">::</span>predomain <span class="main">→</span> <span class="tfree">'c</span><span class="main">::</span>predomain<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> Box <span class="main">→</span> <span class="tfree">'b</span> Box <span class="main">→</span> <span class="tfree">'c</span> Box"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">bliftM2</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="keyword1">Λ</span> x y<span class="main">.</span> unbox<span class="main">⋅</span><span class="bound">x</span> <span class="main">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1">Λ</span> x'<span class="main">.</span> unbox<span class="main">⋅</span><span class="bound">y</span> <span class="main">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1">Λ</span> y'<span class="main">.</span> box<span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="bound">x'</span><span class="main">⋅</span><span class="bound">y'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> bliftM2_strict1<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bliftM2 <span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bliftM2_def<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> bliftM2_strict2<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bliftM2 <span class="free">f</span><span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bliftM2_def<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> bliftM2_op<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bliftM2 <span class="free">f</span><span class="main">⋅</span><span class="main">(</span>box<span class="main">⋅</span><span class="free">x</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>box<span class="main">⋅</span><span class="free">y</span><span class="main">)</span> <span class="main">=</span> box<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="free">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bliftM2_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Define the arithmetic operations. We need extra continuity lemmas as
we're using the full function space, so we can re-use the conventional
operators. The goal is to work at this level.

›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> Box <span class="main">::</span> <span class="main">(</span><span class="quoted"><span class="quoted">"<span class="main">{</span>predomain<span class="main">,</span>plus<span class="main">}</span>"</span></span><span class="main">)</span> <span class="quoted">plus</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> plus_Box_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">+</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≡</span> bliftM2 <span class="main">(</span><span class="keyword1">Λ</span> a b<span class="main">.</span> <span class="bound">a</span> <span class="main">+</span> <span class="bound">b</span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">y</span></span></span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> plus_Box_cont<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">cont2cont</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>cont <span class="free">g</span><span class="main">;</span> cont <span class="free">h</span><span class="main">⟧</span> <span class="main">⟹</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="free">g</span> <span class="bound">x</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">::</span> <span class="main">{</span>predomain<span class="main">,</span> plus<span class="main">}</span> Box<span class="main">)</span> <span class="main">+</span> <span class="free">h</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> plus_Box_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> plus_Box_strict1<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⊥</span> <span class="main">+</span> <span class="main">(</span><span class="free">y</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">::</span><span class="main">{</span>predomain<span class="main">,</span> plus<span class="main">}</span> Box<span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> plus_Box_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> plus_Box_strict2<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">::</span><span class="main">{</span>predomain<span class="main">,</span> plus<span class="main">}</span> Box<span class="main">)</span> <span class="main">+</span> <span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> plus_Box_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">instantiation</span></span> Box <span class="main">::</span> <span class="main">(</span><span class="quoted"><span class="quoted">"<span class="main">{</span>predomain<span class="main">,</span>minus<span class="main">}</span>"</span></span><span class="main">)</span> <span class="quoted">minus</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> minus_Box_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≡</span> bliftM2 <span class="main">(</span><span class="keyword1">Λ</span> a b<span class="main">.</span> <span class="bound">a</span> <span class="main">-</span> <span class="bound">b</span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">y</span></span></span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> minus_Box_cont<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">cont2cont</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>cont <span class="free">g</span><span class="main">;</span> cont <span class="free">h</span><span class="main">⟧</span> <span class="main">⟹</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="free">g</span> <span class="bound">x</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">::</span> <span class="main">{</span>predomain<span class="main">,</span> minus<span class="main">}</span> Box<span class="main">)</span> <span class="main">-</span> <span class="free">h</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> minus_Box_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> minus_Box_strict1<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⊥</span> <span class="main">-</span> <span class="main">(</span><span class="free">y</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">::</span><span class="main">{</span>predomain<span class="main">,</span> minus<span class="main">}</span> Box<span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> minus_Box_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> minus_Box_strict2<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">::</span><span class="main">{</span>predomain<span class="main">,</span> minus<span class="main">}</span> Box<span class="main">)</span> <span class="main">-</span> <span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> minus_Box_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">instantiation</span></span> Box <span class="main">::</span> <span class="main">(</span><span class="quoted"><span class="quoted">"<span class="main">{</span>predomain<span class="main">,</span>times<span class="main">}</span>"</span></span><span class="main">)</span> <span class="quoted">times</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> times_Box_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">*</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≡</span> bliftM2 <span class="main">(</span><span class="keyword1">Λ</span> a b<span class="main">.</span> <span class="bound">a</span> <span class="main">*</span> <span class="bound">b</span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">y</span></span></span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> times_Box_cont<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">cont2cont</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>cont <span class="free">g</span><span class="main">;</span> cont <span class="free">h</span><span class="main">⟧</span> <span class="main">⟹</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="free">g</span> <span class="bound">x</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">::</span> <span class="main">{</span>predomain<span class="main">,</span> times<span class="main">}</span> Box<span class="main">)</span> <span class="main">*</span> <span class="free">h</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> times_Box_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> times_Box_strict1<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⊥</span> <span class="main">*</span> <span class="main">(</span><span class="free">y</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">::</span><span class="main">{</span>predomain<span class="main">,</span> times<span class="main">}</span> Box<span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> times_Box_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> times_Box_strict2<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">::</span><span class="main">{</span>predomain<span class="main">,</span> times<span class="main">}</span> Box<span class="main">)</span> <span class="main">*</span> <span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> times_Box_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">bpred</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>countable discr <span class="main">⇒</span> <span class="tfree">'a</span> discr <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> discr Box <span class="main">→</span> <span class="tfree">'a</span> discr Box <span class="main">→</span> tr"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">bpred</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> <span class="keyword1">Λ</span> x y<span class="main">.</span> unbox<span class="main">⋅</span><span class="bound">x</span> <span class="main">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1">Λ</span> x'<span class="main">.</span> unbox<span class="main">⋅</span><span class="bound">y</span> <span class="main">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1">Λ</span> y'<span class="main">.</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="bound">x'</span> <span class="bound">y'</span> <span class="keyword1">then</span> TT <span class="keyword1">else</span> FF<span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> bpred_strict1<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bpred <span class="free">p</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> bpred_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> bpred_strict2<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bpred <span class="free">p</span><span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> bpred_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> bpred_eval<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bpred <span class="free">p</span><span class="main">⋅</span><span class="main">(</span>box<span class="main">⋅</span><span class="free">x</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>box<span class="main">⋅</span><span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">p</span> <span class="free">x</span> <span class="free">y</span> <span class="keyword1">then</span> TT <span class="keyword1">else</span> FF<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> bpred_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">beq_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>countable discr Box <span class="main">⇒</span> <span class="tfree">'a</span> discr Box <span class="main">⇒</span> tr"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">=<span class="hidden">⇩</span><sub>B</sub></span>"</span> 50<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1"><span class="free">=<span class="hidden">⇩</span><sub>B</sub></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≡</span> bpred <span class="main">(=)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">y</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">ble_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span><span class="main">{</span>countable<span class="main">,</span>ord<span class="main">}</span> discr Box <span class="main">⇒</span> <span class="tfree">'a</span> discr Box <span class="main">⇒</span> tr"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">≤<span class="hidden">⇩</span><sub>B</sub></span>"</span> 50<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1"><span class="free">≤<span class="hidden">⇩</span><sub>B</sub></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≡</span> bpred <span class="main">(≤)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">y</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">blt_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span><span class="main">{</span>countable<span class="main">,</span>ord<span class="main">}</span> discr Box <span class="main">⇒</span> <span class="tfree">'a</span> discr Box <span class="main">⇒</span> tr"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">&lt;<span class="hidden">⇩</span><sub>B</sub></span>"</span> 50<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1"><span class="free">&lt;<span class="hidden">⇩</span><sub>B</sub></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≡</span> bpred <span class="main">(&lt;)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">y</span></span></span>"</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹The flat domain of natural numbers›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Lift arithmetic to the boxed naturals. Define some things that make
playing with boxed naturals more convenient.›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> Nat <span class="main">=</span> <span class="quoted"><span class="quoted">"UNat Box"</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> Box <span class="main">::</span> <span class="main">(</span><span class="quoted"><span class="quoted">"<span class="main">{</span>predomain<span class="main">,</span> zero<span class="main">}</span>"</span></span><span class="main">)</span> <span class="quoted">zero</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> zero_Nat_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≡</span> box<span class="main">⋅</span><span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> Box <span class="main">::</span> <span class="main">(</span><span class="quoted"><span class="quoted">"<span class="main">{</span>predomain<span class="main">,</span> one<span class="main">}</span>"</span></span><span class="main">)</span> <span class="quoted">one</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> one_Nat_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">≡</span> box<span class="main">⋅</span><span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We need to know the underlying operations are continuous for these to work.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> plus_Nat_eval<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>box<span class="main">⋅</span><span class="free">x</span> <span class="main">::</span> Nat<span class="main">)</span> <span class="main">+</span> box<span class="main">⋅</span><span class="free">y</span> <span class="main">=</span> box<span class="main">⋅</span><span class="main">(</span><span class="free">x</span> <span class="main">+</span> <span class="free">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> plus_Box_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> minus_Nat_eval<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>box<span class="main">⋅</span><span class="free">x</span> <span class="main">::</span> Nat<span class="main">)</span> <span class="main">-</span> box<span class="main">⋅</span><span class="free">y</span> <span class="main">=</span> box<span class="main">⋅</span><span class="main">(</span><span class="free">x</span> <span class="main">-</span> <span class="free">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> minus_Box_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> times_Nat_eval<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>box<span class="main">⋅</span><span class="free">x</span> <span class="main">::</span> Nat<span class="main">)</span> <span class="main">*</span> box<span class="main">⋅</span><span class="free">y</span> <span class="main">=</span> box<span class="main">⋅</span><span class="main">(</span><span class="free">x</span> <span class="main">*</span> <span class="free">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> times_Box_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">Nat_case</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>domain <span class="main">→</span> <span class="main">(</span>Nat <span class="main">→</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">→</span> Nat <span class="main">→</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Nat_case</span> <span class="main">≡</span> <span class="keyword1">Λ</span> z s n<span class="main">.</span> unbox<span class="main">⋅</span><span class="bound">n</span> <span class="main">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1">Λ</span> n'<span class="main">.</span> case_nat <span class="bound">z</span> <span class="main">(</span><span class="main">λ</span><span class="bound">n''</span><span class="main">.</span> <span class="bound">s</span><span class="main">⋅</span><span class="main">(</span>box<span class="main">⋅</span><span class="main">(</span>Discr <span class="bound">n''</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>undiscr <span class="bound">n'</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cont_case_nat<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">n</span><span class="main">.</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">g</span> <span class="bound">x</span> <span class="bound">n</span><span class="main">)</span> <span class="main">⟧</span> <span class="main">⟹</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> case_nat <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span> <span class="bound">x</span><span class="main">)</span> <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Nat_case_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Nat_case<span class="main">⋅</span><span class="free">z</span><span class="main">⋅</span><span class="free">s</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Nat_case_def<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> Nat_case_zero<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Nat_case<span class="main">⋅</span><span class="free">z</span><span class="main">⋅</span><span class="free">s</span><span class="main">⋅</span><span class="main">0</span> <span class="main">=</span> <span class="free">z</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Nat_case_def zero_Nat_def zero_discr_def<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> Nat_case_suc<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>  <span class="quoted"><span class="quoted">"Nat_case<span class="main">⋅</span><span class="free">z</span><span class="main">⋅</span><span class="free">s</span><span class="main">⋅</span><span class="main">(</span>box<span class="main">⋅</span><span class="main">(</span>Discr <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">s</span><span class="main">⋅</span><span class="main">(</span>box<span class="main">⋅</span><span class="main">(</span>Discr <span class="free">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Nat_case_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Nat_case_add_1<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ndef<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Nat_case<span class="main">⋅</span><span class="free">z</span><span class="main">⋅</span><span class="free">s</span><span class="main">⋅</span><span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">=</span> <span class="free">s</span><span class="main">⋅</span><span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> ndef <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">nu</span></span> <span class="keyword2"><span class="keyword">where</span></span> nu<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">=</span> box<span class="main">⋅</span><span class="skolem">nu</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> box_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">n</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> Box.exhaust<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="improper">u</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">nu</span> <span class="main">=</span> Discr <span class="skolem">u</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> box_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">nu</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">with</span></span> nu <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> one_Nat_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Nat_case_case_nat<span class="main">:</span> <span class="quoted"><span class="quoted">"Nat_case<span class="main">⋅</span><span class="free">z</span><span class="main">⋅</span><span class="free">s</span><span class="main">⋅</span><span class="main">(</span>box<span class="main">⋅</span><span class="main">(</span>Discr <span class="free">n</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> case_nat <span class="free">z</span> <span class="main">(</span><span class="main">λ</span><span class="bound">n'</span><span class="main">.</span> <span class="free">s</span><span class="main">⋅</span><span class="main">(</span>box<span class="main">⋅</span><span class="main">(</span>Discr <span class="bound">n'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Nat_case_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Nat_casedist<span class="main">[</span><span class="operator">case_names</span> bottom zero Suc<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted">Nat</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> xbot<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="main">⊥</span> <span class="main">⟹</span> <span class="free">P</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> xzero<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟹</span> <span class="free">P</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> xsuc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">n</span><span class="main">.</span> <span class="free">x</span> <span class="main">=</span> <span class="bound">n</span> <span class="main">+</span> <span class="main">1</span> <span class="main">⟹</span> <span class="free">P</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> Box.exhaust<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> bottom <span class="keyword1"><span class="command">with</span></span> xbot <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Box <span class="skolem">u</span><span class="main">)</span> <span class="keyword1"><span class="command">hence</span></span> xu<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> Box<span class="main">⋅</span><span class="skolem">u</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> ubottom<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">from</span></span> ubottom <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="keyword2"><span class="keyword">where</span></span> ndn<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">=</span> up<span class="main">⋅</span><span class="main">(</span>Discr <span class="skolem">n</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">u</span></span><span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">n</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword1"><span class="command">with</span></span> ndn xu xzero <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> zero_Nat_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> boxI zero_discr_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">m</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> ndn xu xsuc<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> n<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"box<span class="main">⋅</span><span class="main">(</span>Discr <span class="skolem">m</span><span class="main">)</span>"</span></span><span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> plus_Box_def <span class="keyword1"><span class="command">unfolding</span></span> one_Nat_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> boxI one_discr_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cont_Nat_case<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">n</span><span class="main">.</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">g</span> <span class="bound">x</span><span class="main">⋅</span><span class="bound">n</span><span class="main">)</span> <span class="main">⟧</span> <span class="main">⟹</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> Nat_case<span class="main">⋅</span><span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">g</span> <span class="bound">x</span><span class="main">)</span><span class="main">⋅</span><span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> Nat_casedist<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">na</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> Box.exhaust<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> Nat_induct<span class="main">[</span><span class="operator">case_names</span> bottom zero Suc<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">P</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Nat <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> xbot<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">⊥</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> xzero<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">0</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> xsuc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">n</span><span class="main">.</span> <span class="main">⟦</span><span class="bound">n</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free">P</span> <span class="bound">n</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span><span class="bound">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> box_casedist<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> bottom <span class="keyword1"><span class="command">with</span></span> xbot <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Box <span class="skolem">u</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="keyword2"><span class="keyword">where</span></span> un<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">=</span> Discr <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">u</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">=</span> box<span class="main">⋅</span><span class="main">(</span>Discr <span class="skolem">n</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">x</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">n</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword1"><span class="command">with</span></span> xzero <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> zero_Nat_def zero_discr_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span>box<span class="main">⋅</span><span class="main">(</span>Discr <span class="skolem">n</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> xsuc<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> n<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"box<span class="main">⋅</span><span class="main">(</span>Discr <span class="skolem">n</span><span class="main">)</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span>box<span class="main">⋅</span><span class="main">(</span>Discr <span class="skolem">n</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> box_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> Suc <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> one_Nat_def one_discr_def plus_Box_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">with</span></span> un Box <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> plus_commute<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">::</span> Nat<span class="main">)</span> <span class="main">+</span> <span class="free">y</span> <span class="main">=</span> <span class="free">y</span> <span class="main">+</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> dc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">u</span> <span class="bound">v</span><span class="main">.</span> <span class="main">(</span>undiscr <span class="main">(</span><span class="bound">u</span><span class="main">::</span>nat discr<span class="main">)</span> <span class="main">+</span> undiscr <span class="bound">v</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>undiscr <span class="bound">v</span> <span class="main">+</span> undiscr <span class="bound">u</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">y</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dc plus_Box_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> mult_unit<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">::</span>Nat<span class="main">)</span> <span class="main">*</span> <span class="main">1</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> times_Box_def one_Nat_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> mult_commute<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">::</span> Nat<span class="main">)</span> <span class="main">*</span> <span class="free">y</span> <span class="main">=</span> <span class="free">y</span> <span class="main">*</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> dc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">u</span> <span class="bound">v</span><span class="main">.</span> <span class="main">(</span>undiscr <span class="main">(</span><span class="bound">u</span><span class="main">::</span>nat discr<span class="main">)</span> <span class="main">*</span> undiscr <span class="bound">v</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>undiscr <span class="bound">v</span> <span class="main">*</span> undiscr <span class="bound">u</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">y</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dc<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> mult_assoc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">x</span> <span class="main">::</span> Nat<span class="main">)</span> <span class="main">*</span> <span class="free">y</span><span class="main">)</span> <span class="main">*</span> <span class="free">z</span> <span class="main">=</span> <span class="free">x</span> <span class="main">*</span> <span class="main">(</span><span class="free">y</span> <span class="main">*</span> <span class="free">z</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> ac<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">w</span><span class="main">.</span> undiscr <span class="main">(</span><span class="bound">u</span><span class="main">::</span>nat discr<span class="main">)</span> <span class="main">*</span> <span class="main">(</span>undiscr <span class="bound">v</span> <span class="main">*</span> undiscr <span class="bound">w</span><span class="main">)</span>
                   <span class="main">=</span>  <span class="main">(</span>undiscr <span class="bound">u</span> <span class="main">*</span> undiscr <span class="bound">v</span><span class="main">)</span> <span class="main">*</span> undiscr <span class="bound">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">y</span></span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">z</span></span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ac<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Restore the HOLCF default sort.›</span></span>

<span class="keyword1"><span class="command">default_sort</span></span> <span class="quoted"><span class="quoted">"domain"</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="LList">
<div class="head">
<h1>Theory LList</h1>
</div>
<pre class="source"><span class="comment1">(*
 * Lazy lists.
 * (C)opyright 2009-2011, Peter Gammie, peteg42 at gmail.com.
 * License: BSD
 *)</span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">theory</span></span> LList
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../../HOL/HOLCF/HOLCF.html">HOLCF</a>
  <a href="Nats.html">Nats</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹The fully-lazy list type.›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The list can contain anything that is a predomain.›</span></span>

<span class="keyword1"><span class="command">default_sort</span></span> <span class="quoted">predomain</span>

<span class="keyword1"><span class="command">domain</span></span> <span class="tfree">'a</span> llist <span class="main">=</span>
    lnil <span class="main">(</span><span class="quoted">"<span class="keyword1">lnil</span>"</span><span class="main">)</span>
  <span class="main">|</span> lcons <span class="main">(</span><span class="keyword2"><span class="keyword">lazy</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="keyword2"><span class="keyword">lazy</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist"</span></span><span class="main">)</span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixr</span></span> <span class="quoted">"<span class="keyword1">:@</span>"</span> 65<span class="main">)</span>

<span class="comment1">(*&lt;*)</span>
<span class="comment1">(* Why aren't these in the library? *)</span>

<span class="keyword1"><span class="command">lemma</span></span> llist_map_eval_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"llist_map<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"llist_map<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="keyword1">lnil</span> <span class="main">=</span> <span class="keyword1">lnil</span>"</span></span>
  <span class="quoted"><span class="quoted">"llist_map<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">x</span> <span class="main">:@</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span><span class="main">⋅</span><span class="free">x</span> <span class="main">:@</span> llist_map<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">xs</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> llist_map_unfold<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> llist_map_unfold<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lnil_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> llist_map_unfold<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lcons_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> llist_case_distr_strict<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span> <span class="main">⟹</span> <span class="free">f</span><span class="main">⋅</span><span class="main">(</span>llist_case<span class="main">⋅</span><span class="free">g</span><span class="main">⋅</span><span class="free">h</span><span class="main">⋅</span><span class="free">xxs</span><span class="main">)</span> <span class="main">=</span> llist_case<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="free">g</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x xs<span class="main">.</span> <span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">h</span><span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="bound">xs</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="free">xxs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xxs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">lsingleton</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>predomain<span class="main">)</span> <span class="main">→</span> <span class="tfree">'a</span> llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lsingleton</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:@</span> <span class="keyword1">lnil</span>"</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">lappend</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span> llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lappend</span><span class="main">⋅</span><span class="keyword1">lnil</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">lappend</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:@</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:@</span> <span class="main">(</span><span class="free">lappend</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">lappend_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'a</span> llist"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixr</span></span> <span class="quoted">"<span class="keyword1">:++</span>"</span> 65<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main"><span class="free">:++</span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">≡</span> lappend<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lappend_strict'<span class="main">:</span> <span class="quoted"><span class="quoted">"lappend<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> a<span class="main">.</span> <span class="main">⊥</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹This gives us that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> lappend_strict'<span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This is where we use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> inst_cfun_pcpo<span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> lappend_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lappend<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_strict'<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lappend_assoc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">xs</span> <span class="main">:++</span> <span class="free">ys</span><span class="main">)</span> <span class="main">:++</span> <span class="free">zs</span> <span class="main">=</span> <span class="free">xs</span> <span class="main">:++</span> <span class="main">(</span><span class="free">ys</span> <span class="main">:++</span> <span class="free">zs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lappend_lnil_id_left<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lappend<span class="main">⋅</span><span class="keyword1">lnil</span> <span class="main">=</span> ID"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> lappend_lnil_id_right<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">:++</span> <span class="keyword1">lnil</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">lconcat</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist llist <span class="main">→</span> <span class="tfree">'a</span> llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lconcat</span><span class="main">⋅</span><span class="keyword1">lnil</span> <span class="main">=</span> <span class="keyword1">lnil</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">lconcat</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:@</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:++</span> <span class="free">lconcat</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lconcat_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lconcat<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">lall</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> tr<span class="main">)</span> <span class="main">→</span> <span class="tfree">'a</span> llist <span class="main">→</span> tr"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lall</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">⋅</span><span class="keyword1">lnil</span> <span class="main">=</span> TT"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">lall</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:@</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">andalso</span> <span class="free">lall</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lall_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lall<span class="main">⋅</span><span class="free">p</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">lfilter</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> tr<span class="main">)</span> <span class="main">→</span> <span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span> llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lfilter</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">⋅</span><span class="keyword1">lnil</span> <span class="main">=</span> <span class="keyword1">lnil</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">lfilter</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:@</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">If</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:@</span> <span class="free">lfilter</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">else</span> <span class="free">lfilter</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lfilter_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lfilter<span class="main">⋅</span><span class="free">p</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1"><span class="command">lemma</span></span> lfilter_const_true<span class="main">:</span> <span class="quoted"><span class="quoted">"lfilter<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> TT<span class="main">)</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lfilter_lnil<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>lfilter<span class="main">⋅</span><span class="free">p</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="keyword1">lnil</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>lall<span class="main">⋅</span><span class="main">(</span>neg <span class="keyword1">oo</span> <span class="free">p</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> TT<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">l</span> <span class="keyword3"><span class="command">assume</span></span> indhyp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>lfilter<span class="main">⋅</span><span class="free">p</span><span class="main">⋅</span><span class="skolem">l</span> <span class="main">=</span> <span class="keyword1">lnil</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>lall<span class="main">⋅</span><span class="main">(</span>Tr.neg <span class="keyword1">oo</span> <span class="free">p</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">l</span> <span class="main">=</span> TT<span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>lfilter<span class="main">⋅</span><span class="free">p</span><span class="main">⋅</span><span class="main">(</span><span class="skolem">a</span> <span class="main">:@</span> <span class="skolem">l</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">lnil</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>lall<span class="main">⋅</span><span class="main">(</span>Tr.neg <span class="keyword1">oo</span> <span class="free">p</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="skolem">a</span> <span class="main">:@</span> <span class="skolem">l</span><span class="main">)</span> <span class="main">=</span> TT<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">⋅</span><span class="skolem">a</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> trE<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> filter_filter<span class="main">:</span> <span class="quoted"><span class="quoted">"lfilter<span class="main">⋅</span><span class="free">p</span><span class="main">⋅</span><span class="main">(</span>lfilter<span class="main">⋅</span><span class="free">q</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lfilter<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="free">q</span><span class="main">⋅</span><span class="bound">x</span> <span class="keyword1">andalso</span> <span class="free">p</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">l</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"lfilter<span class="main">⋅</span><span class="free">p</span><span class="main">⋅</span><span class="main">(</span>lfilter<span class="main">⋅</span><span class="free">q</span><span class="main">⋅</span><span class="skolem">l</span><span class="main">)</span> <span class="main">=</span> lfilter<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span><span class="main">(</span>x<span class="main">::</span><span class="tfree">'a</span><span class="main">)</span><span class="main">.</span> <span class="free">q</span><span class="main">⋅</span><span class="bound">x</span> <span class="keyword1">andalso</span> <span class="free">p</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">l</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"lfilter<span class="main">⋅</span><span class="free">p</span><span class="main">⋅</span><span class="main">(</span>lfilter<span class="main">⋅</span><span class="free">q</span><span class="main">⋅</span><span class="main">(</span><span class="skolem">a</span> <span class="main">:@</span> <span class="skolem">l</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> lfilter<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span><span class="main">(</span>x<span class="main">::</span><span class="tfree">'a</span><span class="main">)</span><span class="main">.</span> <span class="free">q</span><span class="main">⋅</span><span class="bound">x</span> <span class="keyword1">andalso</span> <span class="free">p</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="skolem">a</span> <span class="main">:@</span> <span class="skolem">l</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">q</span><span class="main">⋅</span><span class="skolem">a</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> trE<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">ldropWhile</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> tr<span class="main">)</span> <span class="main">→</span> <span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span> llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ldropWhile</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">⋅</span><span class="keyword1">lnil</span> <span class="main">=</span> <span class="keyword1">lnil</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ldropWhile</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:@</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">If</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">then</span> <span class="free">ldropWhile</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:@</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ldropWhile_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ldropWhile<span class="main">⋅</span><span class="free">p</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1"><span class="command">lemma</span></span> ldropWhile_lnil<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>ldropWhile<span class="main">⋅</span><span class="free">p</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="keyword1">lnil</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>lall<span class="main">⋅</span><span class="free">p</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> TT<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">l</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>ldropWhile<span class="main">⋅</span><span class="free">p</span><span class="main">⋅</span><span class="skolem">l</span> <span class="main">=</span> <span class="keyword1">lnil</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>lall<span class="main">⋅</span><span class="free">p</span><span class="main">⋅</span><span class="skolem">l</span> <span class="main">=</span> TT<span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>ldropWhile<span class="main">⋅</span><span class="free">p</span><span class="main">⋅</span><span class="main">(</span><span class="skolem">a</span> <span class="main">:@</span> <span class="skolem">l</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">lnil</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>lall<span class="main">⋅</span><span class="free">p</span><span class="main">⋅</span><span class="main">(</span><span class="skolem">a</span> <span class="main">:@</span> <span class="skolem">l</span><span class="main">)</span> <span class="main">=</span> TT<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">⋅</span><span class="skolem">a</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> trE<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">literate</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">→</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'a</span> llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">literate</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:@</span> <span class="free">literate</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">declare</span></span> literate.simps<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹This order of tests is convenient for the nub proof. I can
imagine the other would be convenient for other proofs...›</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">lmember</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'a</span> <span class="main">→</span> tr<span class="main">)</span> <span class="main">→</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'a</span> llist <span class="main">→</span> tr"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lmember</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">eq</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="keyword1">lnil</span> <span class="main">=</span> FF"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">lmember</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">eq</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="main">(</span>lcons<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">lmember</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">eq</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="keyword1">orelse</span> <span class="free"><span class="bound"><span class="entity">eq</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lmember_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lmember<span class="main">⋅</span><span class="free">eq</span><span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">llength</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">→</span> Nat"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">llength</span><span class="main">⋅</span><span class="keyword1">lnil</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">llength</span><span class="main">⋅</span><span class="main">(</span>lcons<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span> <span class="main">+</span> <span class="free">llength</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> llength_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"llength<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">lmap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">→</span> <span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'b</span> llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lmap</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="keyword1">lnil</span> <span class="main">=</span> <span class="keyword1">lnil</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">lmap</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:@</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:@</span> <span class="free">lmap</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lmap_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1"><span class="command">lemma</span></span> lmap_lmap<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>lmap<span class="main">⋅</span><span class="free">g</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lmap<span class="main">⋅</span><span class="main">(</span><span class="free">f</span> <span class="keyword1">oo</span> <span class="free">g</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The traditional list monad uses lconcatMap as its bind.›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lconcatMap</span> <span class="main">≡</span> <span class="main">(</span><span class="keyword1">Λ</span> f<span class="main">.</span> lconcat <span class="keyword1">oo</span> lmap<span class="main">⋅</span><span class="bound">f</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lconcatMap_comp_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lconcatMap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"lconcatMap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="keyword1">lnil</span> <span class="main">=</span> <span class="keyword1">lnil</span>"</span></span>
  <span class="quoted"><span class="quoted">"lconcatMap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">x</span> <span class="main">:@</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span><span class="main">⋅</span><span class="free">x</span> <span class="main">:++</span> lconcatMap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lconcatMap_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lconcatMap_lsingleton<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lconcatMap<span class="main">⋅</span>lsingleton<span class="main">⋅</span><span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lconcatMap_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹This <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">zipWith</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> function is only fully defined if the
lists have the same length.›</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">lzipWith0</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span> <span class="main">→</span> <span class="tfree">'c</span><span class="main">)</span> <span class="main">→</span> <span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'b</span> llist <span class="main">→</span> <span class="tfree">'c</span> llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lzipWith0</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">:@</span> <span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">:@</span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">:@</span> <span class="free">lzipWith0</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">bs</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">lzipWith0</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="keyword1">lnil</span><span class="main">⋅</span><span class="keyword1">lnil</span> <span class="main">=</span> <span class="keyword1">lnil</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lzipWith0_stricts <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lzipWith0<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span><span class="main">⋅</span><span class="free">ys</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"lzipWith0<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="keyword1">lnil</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"lzipWith0<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">x</span> <span class="main">:@</span> <span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lzipWith0_undefs <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lzipWith0<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="keyword1">lnil</span><span class="main">⋅</span><span class="main">(</span><span class="free">y</span> <span class="main">:@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"lzipWith0<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">x</span> <span class="main">:@</span> <span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="keyword1">lnil</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹This <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">zipWith</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> function follows Haskell's in being more
permissive: zipping uneven lists results in a list as long as the
shortest one. This is what the backtracking monad expects.›</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">lzipWith</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span> <span class="main">→</span> <span class="tfree">'c</span><span class="main">)</span> <span class="main">→</span> <span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'b</span> llist <span class="main">→</span> <span class="tfree">'c</span> llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lzipWith</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">:@</span> <span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">:@</span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">:@</span> <span class="free">lzipWith</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">bs</span></span></span>"</span></span>
<span class="main">|</span> <span class="main">(</span><span class="keyword2"><span class="keyword">unchecked</span></span><span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">lzipWith</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">=</span> <span class="keyword1">lnil</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lzipWith_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lzipWith<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">x</span> <span class="main">:@</span> <span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">y</span> <span class="main">:@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span><span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="free">y</span> <span class="main">:@</span> lzipWith<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">ys</span>"</span></span>
  <span class="quoted"><span class="quoted">"lzipWith<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">x</span> <span class="main">:@</span> <span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="keyword1">lnil</span> <span class="main">=</span> <span class="keyword1">lnil</span>"</span></span>
  <span class="quoted"><span class="quoted">"lzipWith<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="keyword1">lnil</span><span class="main">⋅</span><span class="main">(</span><span class="free">y</span> <span class="main">:@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">lnil</span>"</span></span>
  <span class="quoted"><span class="quoted">"lzipWith<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="keyword1">lnil</span><span class="main">⋅</span><span class="keyword1">lnil</span> <span class="main">=</span> <span class="keyword1">lnil</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lzipWith_stricts <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lzipWith<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span><span class="main">⋅</span><span class="free">ys</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"lzipWith<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">x</span> <span class="main">:@</span> <span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Homomorphism properties, see Bird's life's work.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lmap_lappend_dist<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">xs</span> <span class="main">:++</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> lmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">:++</span> lmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> lconcat_lappend_dist<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lconcat<span class="main">⋅</span><span class="main">(</span><span class="free">xs</span> <span class="main">:++</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> lconcat<span class="main">⋅</span><span class="free">xs</span> <span class="main">:++</span> lconcat<span class="main">⋅</span><span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lappend_assoc<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lconcatMap_assoc<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lconcatMap<span class="main">⋅</span><span class="free">h</span><span class="main">⋅</span><span class="main">(</span>lconcatMap<span class="main">⋅</span><span class="free">g</span><span class="main">⋅</span><span class="free">f</span><span class="main">)</span> <span class="main">=</span> lconcatMap<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> v<span class="main">.</span> lconcatMap<span class="main">⋅</span><span class="free">h</span><span class="main">⋅</span><span class="main">(</span><span class="free">g</span><span class="main">⋅</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">f</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lmap_lappend_dist lconcat_lappend_dist lconcatMap_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lconcatMap_lappend_dist<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lconcatMap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">xs</span> <span class="main">:++</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> lconcatMap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">:++</span> lconcatMap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> lconcatMap_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lconcat_lappend_dist lmap_lappend_dist<span class="main">)</span>

<span class="comment1">(* The following avoid some case_tackery. *)</span>

<span class="keyword1"><span class="command">lemma</span></span> lmap_not_bottoms<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟹</span> lmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">x</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> lsingleton_not_bottom<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lsingleton<span class="main">⋅</span><span class="free">x</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> lappend_not_bottom<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free">xs</span> <span class="main">=</span> <span class="keyword1">lnil</span> <span class="main">⟹</span> <span class="free">ys</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">xs</span> <span class="main">:++</span> <span class="free">ys</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">default_sort</span></span> <span class="quoted"><span class="quoted">"domain"</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="Maybe">
<div class="head">
<h1>Theory Maybe</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="comment1">(*
 * The Maybe monad.
 * (C)opyright 2009-2011, Peter Gammie, peteg42 at gmail.com.
 * License: BSD
 *)</span>

<span class="keyword1"><span class="command">theory</span></span> Maybe
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOLCF/HOLCF.html">HOLCF</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹The <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a Maybe›</span></span></span></span> Monad›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹This section defines the monadic machinery for the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a
Maybe›</span></span></span></span> type. <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">return</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">Just</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">domain</span></span> <span class="tfree">'a</span> Maybe <span class="main">=</span> Nothing <span class="main">|</span> Just <span class="main">(</span><span class="keyword2"><span class="keyword">lazy</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span>"</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">mfail</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> Maybe"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mfail</span> <span class="main">≡</span> Nothing"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">mcatch</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> Maybe <span class="main">→</span> <span class="tfree">'a</span> Maybe <span class="main">→</span> <span class="tfree">'a</span> Maybe"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mcatch</span> <span class="main">≡</span> <span class="keyword1">Λ</span> body handler<span class="main">.</span> <span class="keyword1">case</span> <span class="bound">body</span> <span class="keyword1">of</span> Nothing <span class="main">⇒</span> <span class="bound">handler</span> <span class="main">|</span> Just<span class="main">⋅</span><span class="bound">x</span> <span class="main">⇒</span> Just<span class="main">⋅</span><span class="bound">x</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> mcatch_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"mcatch<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mcatch_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">mbind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> Maybe <span class="main">→</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span> Maybe<span class="main">)</span> <span class="main">→</span> <span class="tfree">'b</span> Maybe"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mbind</span> <span class="main">≡</span> <span class="keyword1">Λ</span> f g<span class="main">.</span> <span class="main">(</span><span class="keyword1">case</span> <span class="bound">f</span> <span class="keyword1">of</span> Nothing <span class="main">⇒</span> Nothing <span class="main">|</span> Just<span class="main">⋅</span><span class="bound">f'</span> <span class="main">⇒</span> <span class="bound">g</span><span class="main">⋅</span><span class="bound">f'</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">mbind_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> Maybe <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span> Maybe<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'b</span> Maybe"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">&gt;&gt;=<span class="hidden">⇩</span><sub>M</sub></span>"</span> 55<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="keyword1"><span class="free">&gt;&gt;=<span class="hidden">⇩</span><sub>M</sub></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">≡</span> mbind<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">g</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> mbind_strict1<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⊥</span> <span class="keyword1">&gt;&gt;=<span class="hidden">⇩</span><sub>M</sub></span> <span class="free">g</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mbind_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The standard monad laws.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> leftID<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Just<span class="main">⋅</span><span class="free">a</span> <span class="keyword1">&gt;&gt;=<span class="hidden">⇩</span><sub>M</sub></span> <span class="free">f</span> <span class="main">=</span> <span class="free">f</span><span class="main">⋅</span><span class="free">a</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mbind_def<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> rightID<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="keyword1">&gt;&gt;=<span class="hidden">⇩</span><sub>M</sub></span> Just <span class="main">=</span> <span class="free">m</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">m</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mbind_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> assoc<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">m</span> <span class="keyword1">&gt;&gt;=<span class="hidden">⇩</span><sub>M</sub></span> <span class="free">f</span><span class="main">)</span> <span class="keyword1">&gt;&gt;=<span class="hidden">⇩</span><sub>M</sub></span> <span class="free">g</span> <span class="main">=</span> <span class="free">m</span> <span class="keyword1">&gt;&gt;=<span class="hidden">⇩</span><sub>M</sub></span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="free">f</span><span class="main">⋅</span><span class="bound">x</span> <span class="keyword1">&gt;&gt;=<span class="hidden">⇩</span><sub>M</sub></span> <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">m</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mbind_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Reduction for the Maybe monad.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> nothing_bind<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Nothing <span class="keyword1">&gt;&gt;=<span class="hidden">⇩</span><sub>M</sub></span> <span class="free">f</span> <span class="main">=</span> Nothing"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mbind_def<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> just_bind<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Just<span class="main">⋅</span><span class="free">x</span> <span class="keyword1">&gt;&gt;=<span class="hidden">⇩</span><sub>M</sub></span> <span class="free">f</span> <span class="main">=</span> <span class="free">f</span><span class="main">⋅</span><span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mbind_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">mliftM2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span> <span class="main">→</span> <span class="tfree">'c</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> Maybe <span class="main">→</span> <span class="tfree">'b</span> Maybe <span class="main">→</span> <span class="tfree">'c</span> Maybe"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mliftM2</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="keyword1">Λ</span> x y<span class="main">.</span> <span class="bound">x</span> <span class="keyword1">&gt;&gt;=<span class="hidden">⇩</span><sub>M</sub></span> <span class="main">(</span><span class="keyword1">Λ</span> x'<span class="main">.</span> <span class="bound">y</span> <span class="keyword1">&gt;&gt;=<span class="hidden">⇩</span><sub>M</sub></span> <span class="main">(</span><span class="keyword1">Λ</span> y'<span class="main">.</span> Just<span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="bound">x'</span><span class="main">⋅</span><span class="bound">y'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> mliftM2_Nothing1<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"mliftM2 <span class="free">f</span><span class="main">⋅</span>Nothing<span class="main">⋅</span><span class="free">y</span> <span class="main">=</span> Nothing"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mliftM2_def<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> mliftM2_Nothing2<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"mliftM2 <span class="free">f</span><span class="main">⋅</span><span class="main">(</span>Just<span class="main">⋅</span><span class="free">x</span><span class="main">)</span><span class="main">⋅</span>Nothing <span class="main">=</span> Nothing"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mliftM2_def<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> mliftM2_op<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"mliftM2 <span class="free">f</span><span class="main">⋅</span><span class="main">(</span>Just<span class="main">⋅</span><span class="free">x</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>Just<span class="main">⋅</span><span class="free">y</span><span class="main">)</span> <span class="main">=</span> Just<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="free">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mliftM2_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> mliftM2_strict1<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"mliftM2 <span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mliftM2_def<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> mliftM2_strict2<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"mliftM2 <span class="free">f</span><span class="main">⋅</span><span class="main">(</span>Just<span class="main">⋅</span><span class="free">x</span><span class="main">)</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mliftM2_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="FixedPointTheorems">
<div class="head">
<h1>Theory FixedPointTheorems</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="comment1">(*
 * The worker/wrapper transformation, following Gill and Hutton.
 * (C)opyright 2009-2011, Peter Gammie, peteg42 at gmail.com.
 * License: BSD
 *)</span>

<span class="keyword1"><span class="command">theory</span></span> FixedPointTheorems
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../../HOL/HOLCF/HOLCF.html">HOLCF</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹
  <span class="entity">Thy_Output.antiquotation_raw</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">binding</span><span class="hidden">&gt;</span></span>‹haskell›</span></span> <span class="main">(</span>Scan.lift Args.name<span class="main">)</span>
    <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">s</span> <span class="main">=&gt;</span> Latex.string <span class="main">(</span><span class="inner_quoted">"\\"</span> ^ <span class="inner_quoted">"&lt;"</span> ^ <span class="entity">s</span> ^ <span class="inner_quoted">"\\&gt;"</span><span class="main">)</span><span class="main">)</span>
›</span>

<span class="comment1">(* LaTeXsugar fights with HOLCF syntax: at least cdot *)</span>

<span class="comment1">(* THEOREMS *)</span>
<span class="keyword1"><span class="command">notation</span></span> <span class="main">(</span>Rule <span class="keyword2"><span class="keyword">output</span></span><span class="main">)</span>
  Pure.imp  <span class="main">(</span><span class="quoted">"<span class="keyword1"><span class="hidden">\&lt;^</span><span class="control">latex</span><span class="hidden">&gt;</span>‹\\mbox{}\\inferrule{\\mbox{›</span>_<span class="keyword1"><span class="hidden">\&lt;^</span><span class="control">latex</span><span class="hidden">&gt;</span>‹}}›<span class="hidden">\&lt;^</span><span class="control">latex</span><span class="hidden">&gt;</span>‹{\\mbox{›</span>_<span class="keyword1"><span class="hidden">\&lt;^</span><span class="control">latex</span><span class="hidden">&gt;</span>‹}}›</span>"</span><span class="main">)</span>

<span class="keyword1"><span class="command">syntax</span></span> <span class="main">(</span>Rule <span class="keyword2"><span class="keyword">output</span></span><span class="main">)</span>
  <span class="quoted">"_bigimpl"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"asms <span class="main">⇒</span> prop <span class="main">⇒</span> prop"</span></span>
  <span class="main">(</span><span class="quoted">"<span class="keyword1"><span class="hidden">\&lt;^</span><span class="control">latex</span><span class="hidden">&gt;</span>‹\\mbox{}\\inferrule{›</span>_<span class="keyword1"><span class="hidden">\&lt;^</span><span class="control">latex</span><span class="hidden">&gt;</span>‹}›<span class="hidden">\&lt;^</span><span class="control">latex</span><span class="hidden">&gt;</span>‹{\\mbox{›</span>_<span class="keyword1"><span class="hidden">\&lt;^</span><span class="control">latex</span><span class="hidden">&gt;</span>‹}}›</span>"</span><span class="main">)</span>

  <span class="quoted">"_asms"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prop <span class="main">⇒</span> asms <span class="main">⇒</span> asms"</span></span>
  <span class="main">(</span><span class="quoted">"<span class="keyword1"><span class="hidden">\&lt;^</span><span class="control">latex</span><span class="hidden">&gt;</span>‹\\mbox{›</span>_<span class="keyword1"><span class="hidden">\&lt;^</span><span class="control">latex</span><span class="hidden">&gt;</span>‹}\\\\›</span><span class="keyword3">/ </span>_"</span><span class="main">)</span>

  <span class="quoted">"_asm"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prop <span class="main">⇒</span> asms"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1"><span class="hidden">\&lt;^</span><span class="control">latex</span><span class="hidden">&gt;</span>‹\\mbox{›</span>_<span class="keyword1"><span class="hidden">\&lt;^</span><span class="control">latex</span><span class="hidden">&gt;</span>‹}›</span>"</span><span class="main">)</span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Fixed-point theorems for program transformation›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We begin by recounting some standard theorems from the early days of
denotational semantics. The origins of these results are lost to
history; the interested reader can find some of it in
\citet{Bekic:1969, Manna:1974, Greibach:1975, Stoy:1977,
DBLP:books/daglib/0002432, Harel:1980, Plotkin:1983, Winskel:1993,
DBLP:journals/toplas/Sangiorgi09}.

›</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹The rolling rule›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The \emph{rolling rule} captures what intuitively happens when we
re-order a recursive computation consisting of two parts. This theorem
dates from the 1970s at the latest -- see \citet[p210]{Stoy:1977} and
\citet{Plotkin:1983}. The following proofs were provided by
\citet{GillHutton:2009}.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> rolling_rule_ltr<span class="main">:</span> <span class="quoted"><span class="quoted">"fix<span class="main">⋅</span><span class="main">(</span><span class="free">g</span> <span class="keyword1">oo</span> <span class="free">f</span><span class="main">)</span> <span class="main">⊑</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="main">(</span><span class="free">f</span> <span class="keyword1">oo</span> <span class="free">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="main">(</span><span class="free">f</span> <span class="keyword1">oo</span> <span class="free">g</span><span class="main">)</span><span class="main">)</span> <span class="main">⊑</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="main">(</span><span class="free">f</span> <span class="keyword1">oo</span> <span class="free">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> below_refl<span class="main">)</span> <span class="comment1">― ‹reflexivity›</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="main">(</span><span class="main">(</span><span class="free">f</span> <span class="keyword1">oo</span> <span class="free">g</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="main">(</span><span class="free">f</span> <span class="keyword1">oo</span> <span class="free">g</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">⊑</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="main">(</span><span class="free">f</span> <span class="keyword1">oo</span> <span class="free">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> fix_eq<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> F<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="keyword1">oo</span> <span class="free">g</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="comment1">― ‹computation›</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">g</span> <span class="keyword1">oo</span> <span class="free">f</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">g</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="main">(</span><span class="free">f</span> <span class="keyword1">oo</span> <span class="free">g</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">⊑</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="main">(</span><span class="free">f</span> <span class="keyword1">oo</span> <span class="free">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="comment1">― ‹re-associate <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="keyword1">(oo)</span>"</span><span class="antiquote">}</span></span>›</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"fix<span class="main">⋅</span><span class="main">(</span><span class="free">g</span> <span class="keyword1">oo</span> <span class="free">f</span><span class="main">)</span> <span class="main">⊑</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="main">(</span><span class="free">f</span> <span class="keyword1">oo</span> <span class="free">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> fix_least_below <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> <span class="comment1">― ‹induction›</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> rolling_rule_rtl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="main">(</span><span class="free">f</span> <span class="keyword1">oo</span> <span class="free">g</span><span class="main">)</span><span class="main">)</span> <span class="main">⊑</span> fix<span class="main">⋅</span><span class="main">(</span><span class="free">g</span> <span class="keyword1">oo</span> <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"fix<span class="main">⋅</span><span class="main">(</span><span class="free">f</span> <span class="keyword1">oo</span> <span class="free">g</span><span class="main">)</span> <span class="main">⊑</span> <span class="free">f</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="main">(</span><span class="free">g</span> <span class="keyword1">oo</span> <span class="free">f</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> rolling_rule_ltr<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="main">(</span><span class="free">f</span> <span class="keyword1">oo</span> <span class="free">g</span><span class="main">)</span><span class="main">)</span> <span class="main">⊑</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="main">(</span><span class="free">g</span> <span class="keyword1">oo</span> <span class="free">f</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> monofun_cfun_arg<span class="main">)</span> <span class="comment1">― ‹g is monotonic›</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="main">(</span><span class="free">f</span> <span class="keyword1">oo</span> <span class="free">g</span><span class="main">)</span><span class="main">)</span> <span class="main">⊑</span> fix<span class="main">⋅</span><span class="main">(</span><span class="free">g</span> <span class="keyword1">oo</span> <span class="free">f</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> fix_eq<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> F<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="keyword1">oo</span> <span class="free">f</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="comment1">― ‹computation›</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> rolling_rule<span class="main">:</span> <span class="quoted"><span class="quoted">"fix<span class="main">⋅</span><span class="main">(</span><span class="free">g</span> <span class="keyword1">oo</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="main">(</span><span class="free">f</span> <span class="keyword1">oo</span> <span class="free">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> below_antisym<span class="main"><span class="main">[</span></span><span class="operator">OF</span> rolling_rule_ltr rolling_rule_rtl<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="comment1">(*

This property of a fixed-point operator is termed \emph{dinaturality}
by \citet{DBLP:conf/lics/SimpsonP00}.

*)</span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Least-fixed-point fusion›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\label{sec:lfp-fusion}

\emph{Least-fixed-point fusion} provides a kind of induction that has
proven to be very useful in calculational settings. Intuitively it
lifts the step-by-step correspondence between <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">f</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span>
<span class="quoted"><span class="quoted">"<span class="free"><span class="free">h</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> witnessed by the strict function <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">g</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to the fixed points
of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">f</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">g</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>:
\[
  \begin{diagram}
    \node{\bullet} \arrow{e,t}{h} \node{\bullet}\\
    \node{\bullet} \arrow{n,l}{g} \arrow{e,b}{f} \node{\bullet} \arrow{n,r}{g}
  \end{diagram}
  \qquad \Longrightarrow \qquad
  \begin{diagram}
    \node{\mathsf{fix}\ h}\\
    \node{\mathsf{fix}\ f} \arrow{n,r}{g}
  \end{diagram}
\]
\citet*{FokkingaMeijer:1991}, and also their later
\citet*{barbed-wire:1991}, made extensive use of this rule, as did
\citet{Tullsen:PhDThesis} in his program transformation tool PATH.
This diagram is strongly reminiscent of the simulations used to
establish refinement relations between imperative programs and their
specifications \citep*{EdR:cup98}.

The following proof is close to the third variant of
\citet[p215]{Stoy:1977}. We relate the two fixpoints using the rule
\texttt{parallel\_fix\_ind}:
\begin{center}
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span>[mode=Rule] parallel_fix_ind<span class="antiquote"><span class="antiquote">}</span></span></span></span>
\end{center}
in a very straightforward way:

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lfp_fusion<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="keyword1">oo</span> <span class="free">f</span> <span class="main">=</span> <span class="free">h</span> <span class="keyword1">oo</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="free">f</span><span class="main">)</span> <span class="main">=</span> fix<span class="main">⋅</span><span class="free">h</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> parallel_fix_ind<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 2 <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>3 <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="free">g</span><span class="main">⋅</span><span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">g</span> <span class="keyword1">oo</span> <span class="free">f</span> <span class="main">=</span> <span class="free">h</span> <span class="keyword1">oo</span> <span class="free">g</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">h</span><span class="main">⋅</span><span class="skolem">y</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfun_eq_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

This lemma also goes by the name of \emph{Plotkin's axiom}
\citep{PittsAM:relpod} or \emph{uniformity}
\citep{DBLP:conf/lics/SimpsonP00}.

›</span></span>
<span class="comment1">(*&lt;*)</span>

<span class="comment1">(* The rest of this theory is only of historical interest. *)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Some may find the pointed version easier to read.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lfp_fusion_pointed<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Cfg<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">f</span><span class="main">.</span> <span class="free">C</span><span class="main">⋅</span><span class="main">(</span><span class="free">F</span><span class="main">⋅</span><span class="bound">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">G</span><span class="main">⋅</span><span class="main">(</span><span class="free">C</span><span class="main">⋅</span><span class="bound">f</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> strictC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">C</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">C</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="free">F</span><span class="main">)</span> <span class="main">=</span> fix<span class="main">⋅</span><span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> lfp_fusion<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">F</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> g<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">C</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> h<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">G</span></span><span class="main">]</span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfcomp1<span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹More about <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>lfp-fusion›</span></span>›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Alternative proofs. This is the ``intuitive'' one
\citet[p125]{Gunter:1992} and \citet[p46]{Tullsen:PhDThesis}, where we
can shuffle <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="free">g</span>"</span><span class="antiquote">}</span></span> to the end of the the iteration of <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="free">f</span>"</span><span class="antiquote">}</span></span>
using <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="free">fgh</span>"</span><span class="antiquote">}</span></span>.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lfp_fusion2_aux<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> fgh<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="keyword1">oo</span> <span class="free">f</span> <span class="main">=</span> <span class="free">h</span> <span class="keyword1">oo</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="main">(</span>iterate <span class="free">i</span><span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span><span class="main">)</span> <span class="main">=</span> iterate <span class="free">i</span><span class="main">⋅</span><span class="free">h</span><span class="main">⋅</span><span class="main">(</span><span class="free">g</span><span class="main">⋅</span><span class="main">⊥</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">i</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="main">(</span>iterate <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span><span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">g</span> <span class="keyword1">oo</span> <span class="free">f</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>iterate <span class="skolem">i</span><span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="free">h</span><span class="main">⋅</span><span class="main">(</span><span class="free">g</span><span class="main">⋅</span><span class="main">(</span>iterate <span class="skolem">i</span><span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fgh <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfcomp1<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="free">h</span><span class="main">⋅</span><span class="main">(</span>iterate <span class="skolem">i</span><span class="main">⋅</span><span class="free">h</span><span class="main">⋅</span><span class="main">(</span><span class="free">g</span><span class="main">⋅</span><span class="main">⊥</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Suc <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> iterate <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span><span class="main">⋅</span><span class="free">h</span><span class="main">⋅</span><span class="main">(</span><span class="free">g</span><span class="main">⋅</span><span class="main">⊥</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> lfp_fusion2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> fgh<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="keyword1">oo</span> <span class="free">f</span> <span class="main">=</span> <span class="free">h</span> <span class="keyword1">oo</span> <span class="free">g</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> strictg<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="free">f</span><span class="main">)</span> <span class="main">=</span> fix<span class="main">⋅</span><span class="free">h</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span><span class="main">⨆</span><span class="bound">i</span><span class="main">.</span> iterate <span class="bound">i</span><span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> fix_def2<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span><span class="main">⨆</span><span class="bound">i</span><span class="main">.</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span>iterate <span class="bound">i</span><span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> contlub_cfun_arg<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span><span class="main">⨆</span><span class="bound">i</span><span class="main">.</span> <span class="main">(</span>iterate <span class="bound">i</span><span class="main">⋅</span><span class="free">h</span><span class="main">⋅</span><span class="main">(</span><span class="free">g</span><span class="main">⋅</span><span class="main">⊥</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> lfp_fusion2_aux<span class="main"><span class="main">[</span></span><span class="operator">OF</span> fgh<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> fix<span class="main">⋅</span><span class="free">h</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> strictg <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> fix_def2<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹This is the first one by \citet[p213]{Stoy:1977}, almost
identical to the above.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lfp_fusion3_aux<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> fgh<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="keyword1">oo</span> <span class="free">f</span> <span class="main">=</span> <span class="free">h</span> <span class="keyword1">oo</span> <span class="free">g</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> strictg<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="main">(</span>iterate <span class="free">i</span><span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span><span class="main">)</span> <span class="main">=</span> iterate <span class="free">i</span><span class="main">⋅</span><span class="free">h</span><span class="main">⋅</span><span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">i</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword1"><span class="command">from</span></span> strictg <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="main">(</span>iterate <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span><span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">g</span> <span class="keyword1">oo</span> <span class="free">f</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>iterate <span class="skolem">i</span><span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="free">h</span><span class="main">⋅</span><span class="main">(</span><span class="free">g</span><span class="main">⋅</span><span class="main">(</span>iterate <span class="skolem">i</span><span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fgh <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfcomp1<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="free">h</span><span class="main">⋅</span><span class="main">(</span>iterate <span class="skolem">i</span><span class="main">⋅</span><span class="free">h</span><span class="main">⋅</span><span class="main">⊥</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Suc <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> iterate <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span><span class="main">⋅</span><span class="free">h</span><span class="main">⋅</span><span class="main">⊥</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lfp_fusion3<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> fgh<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="keyword1">oo</span> <span class="free">f</span> <span class="main">=</span> <span class="free">h</span> <span class="keyword1">oo</span> <span class="free">g</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> strictg<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="free">f</span><span class="main">)</span> <span class="main">=</span> fix<span class="main">⋅</span><span class="free">h</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span><span class="main">⨆</span><span class="bound">i</span><span class="main">.</span> iterate <span class="bound">i</span><span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> fix_def2<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span><span class="main">⨆</span><span class="bound">i</span><span class="main">.</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span>iterate <span class="bound">i</span><span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> contlub_cfun_arg<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span><span class="main">⨆</span><span class="bound">i</span><span class="main">.</span> <span class="main">(</span>iterate <span class="bound">i</span><span class="main">⋅</span><span class="free">h</span><span class="main">⋅</span><span class="main">⊥</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> lfp_fusion3_aux<span class="main"><span class="main">[</span></span><span class="operator">OF</span> fgh strictg<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> fix<span class="main">⋅</span><span class="free">h</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> fix_def2<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Stoy's second proof \citep[p214]{Stoy:1977} is similar to the
original proof using fixed-point induction.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lfp_fusion4<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> fgh<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="keyword1">oo</span> <span class="free">f</span> <span class="main">=</span> <span class="free">h</span> <span class="keyword1">oo</span> <span class="free">g</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> strictg<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="free">f</span><span class="main">)</span> <span class="main">=</span> fix<span class="main">⋅</span><span class="free">h</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> below_antisym<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"fix<span class="main">⋅</span><span class="free">h</span> <span class="main">⊑</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span><span class="main">⋅</span><span class="main">(</span><span class="free">g</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="free">f</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">g</span> <span class="keyword1">oo</span> <span class="free">f</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="free">f</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fgh <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="free">f</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> fix_eq<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> fix_least<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?P</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">g</span><span class="main">⋅</span><span class="bound">x</span> <span class="main">⊑</span> fix<span class="main">⋅</span><span class="free">h</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="main">(</span>fix<span class="main">⋅</span><span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> fix_ind<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> P<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="var"><span class="var">?P</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> 2 <span class="keyword1"><span class="command">with</span></span> strictg <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>3 <span class="skolem">x</span><span class="main">)</span> <span class="keyword1"><span class="command">hence</span></span> indhyp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="skolem">x</span> <span class="main">⊑</span> fix<span class="main">⋅</span><span class="free">h</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">h</span> <span class="keyword1">oo</span> <span class="free">g</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fgh<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> indhyp <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span> <span class="main">⊑</span> fix<span class="main">⋅</span><span class="free">h</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> fix_eq<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monofun_cfun<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹A wrinkly variant from \citet[p11]{barbed-wire:1991}.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lfp_fusion_barbed_variant<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ff'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="free">f'</span><span class="main">⋅</span><span class="main">⊥</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> fgh<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="keyword1">oo</span> <span class="free">g</span> <span class="main">=</span> <span class="free">h</span> <span class="keyword1">oo</span> <span class="free">f</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> f'g'h<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f'</span> <span class="keyword1">oo</span> <span class="free">g'</span> <span class="main">=</span> <span class="free">h</span> <span class="keyword1">oo</span> <span class="free">f'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="free">g</span><span class="main">)</span> <span class="main">=</span> <span class="free">f'</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="free">g'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> parallel_fix_ind<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 2 <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="free">f'</span><span class="main">⋅</span><span class="main">⊥</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> ff'<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>3 <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="free">f</span><span class="main">⋅</span><span class="skolem">x</span> <span class="main">=</span> <span class="free">f'</span><span class="main">⋅</span><span class="skolem">y</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span><span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">h</span><span class="main">⋅</span><span class="main">(</span><span class="free">f'</span><span class="main">⋅</span><span class="skolem">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">with</span></span> fgh f'g'h <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">g</span><span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">f'</span><span class="main">⋅</span><span class="main">(</span><span class="free">g'</span><span class="main">⋅</span><span class="skolem">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> cfcomp2<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">f</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> g<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">g</span>"</span></span><span class="main">,</span> <span class="operator">symmetric</span><span class="main">]</span>
          cfcomp2<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">f'</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> g<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">g'</span>"</span></span><span class="main">,</span> <span class="operator">symmetric</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
<span class="comment1">(*&gt;*)</span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="WorkerWrapper">
<div class="head">
<h1>Theory WorkerWrapper</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="comment1">(*
 * The worker/wrapper transformation, following Gill and Hutton.
 * (C)opyright 2009-2011, Peter Gammie, peteg42 at gmail.com, commenced December 2007.
 * License: BSD
 *)</span>

<span class="keyword1"><span class="command">theory</span></span> WorkerWrapper
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../../HOL/HOLCF/HOLCF.html">HOLCF</a>
  <a href="FixedPointTheorems.html">FixedPointTheorems</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹The transformation according to Gill and Hutton›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\begin{figure}[tb]
 \begin{center}
  \fbox{\parbox{0.96\textwidth}{For a recursive definition <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">haskell</span></span> "comp =
      \\mathsf{fix}\\ body"<span class="antiquote"><span class="antiquote">}</span></span></span></span> for some <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">haskell</span></span> "body :: A \\to A"<span class="antiquote"><span class="antiquote">}</span></span></span></span> and a pair of
      functions <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">haskell</span></span> "wrap :: B \\to A"<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">haskell</span></span> "unwrap :: A \\to B"<span class="antiquote"><span class="antiquote">}</span></span></span></span> where
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">haskell</span></span> "wrap \\circ unwrap = id_A"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, we have:

      \parbox{0.35\textwidth}{\begin{haskell}
        comp = wrap\ work\\
        \quad work :: B\\
        \quad work = \mathsf{fix}\ (unwrap \circ body \circ wrap)
      \end{haskell}}\hfill \textsf{(the worker/wrapper transformation)}

      Also:

      \parbox{0.35\textwidth}{\begin{haskell}
        (unwrap \circ wrap)\ work = work
      \end{haskell}}\hfill \textsf{(worker/wrapper fusion)}}}%
 \end{center}%
 \caption{The worker/wrapper transformation and fusion rule of \citet{GillHutton:2009}.}\label{fig:ww}
\end{figure}

The worker/wrapper transformation and associated fusion rule as
formalised by \citet*{GillHutton:2009} are reproduced in
Figure~\ref{fig:ww}, and the reader is referred to the original paper
for further motivation and background.

Armed with the rolling rule we can show that Gill and Hutton's
justification of the worker/wrapper transformation is sound. There is
a battery of these transformations with varying strengths of
hypothesis.

The first requires <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">wrap</span></span> <span class="keyword1"><span class="keyword1">oo</span></span> <span class="free"><span class="free">unwrap</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to be the identity for all
values.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> worker_wrapper_id<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">wrap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span><span class="main">::</span>pcpo <span class="main">→</span> <span class="tfree">'a</span><span class="main">::</span>pcpo"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">unwrap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> wrap_unwrap<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">wrap</span> <span class="keyword1">oo</span> <span class="free">unwrap</span> <span class="main">=</span> ID"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> comp_body<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">computation</span> <span class="main">=</span> fix<span class="main">⋅</span><span class="free">body</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">computation</span> <span class="main">=</span> <span class="free">wrap</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="main">(</span><span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">body</span> <span class="keyword1">oo</span> <span class="free">wrap</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> comp_body <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">computation</span> <span class="main">=</span> fix<span class="main">⋅</span><span class="main">(</span>ID <span class="keyword1">oo</span> <span class="free">body</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> wrap_unwrap <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> fix<span class="main">⋅</span><span class="main">(</span><span class="free">wrap</span> <span class="keyword1">oo</span> <span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">body</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assoc_oo<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="free">wrap</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="main">(</span><span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">body</span> <span class="keyword1">oo</span> <span class="free">wrap</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> rolling_rule<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">body</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> g<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">wrap</span>"</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assoc_oo<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The second weakens this assumption by requiring that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">wrap</span></span> <span class="keyword1"><span class="keyword1">oo</span></span>
<span class="free"><span class="free">wrap</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> only act as the identity on values in the image of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span>
<span class="quoted"><span class="quoted">"<span class="free"><span class="free">body</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> worker_wrapper_body<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">wrap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span><span class="main">::</span>pcpo <span class="main">→</span> <span class="tfree">'a</span><span class="main">::</span>pcpo"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">unwrap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> wrap_unwrap<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">wrap</span> <span class="keyword1">oo</span> <span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">body</span> <span class="main">=</span> <span class="free">body</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> comp_body<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">computation</span> <span class="main">=</span> fix<span class="main">⋅</span><span class="free">body</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">computation</span> <span class="main">=</span> <span class="free">wrap</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="main">(</span><span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">body</span> <span class="keyword1">oo</span> <span class="free">wrap</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> comp_body <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">computation</span> <span class="main">=</span> fix<span class="main">⋅</span><span class="main">(</span><span class="free">wrap</span> <span class="keyword1">oo</span> <span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">body</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> wrap_unwrap <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assoc_oo wrap_unwrap<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="free">wrap</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="main">(</span><span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">body</span> <span class="keyword1">oo</span> <span class="free">wrap</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> rolling_rule<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">body</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> g<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">wrap</span>"</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assoc_oo<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

This is particularly useful when the computation being transformed is
strict in its argument.

Finally we can allow the identity to take the full recursive context
into account. This rule was described by Gill and Hutton but not used.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> worker_wrapper_fix<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">wrap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span><span class="main">::</span>pcpo <span class="main">→</span> <span class="tfree">'a</span><span class="main">::</span>pcpo"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">unwrap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> wrap_unwrap<span class="main">:</span> <span class="quoted"><span class="quoted">"fix<span class="main">⋅</span><span class="main">(</span><span class="free">wrap</span> <span class="keyword1">oo</span> <span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">body</span><span class="main">)</span> <span class="main">=</span> fix<span class="main">⋅</span><span class="free">body</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> comp_body<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">computation</span> <span class="main">=</span> fix<span class="main">⋅</span><span class="free">body</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">computation</span> <span class="main">=</span> <span class="free">wrap</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="main">(</span><span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">body</span> <span class="keyword1">oo</span> <span class="free">wrap</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> comp_body <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">computation</span> <span class="main">=</span> fix<span class="main">⋅</span><span class="main">(</span><span class="free">wrap</span> <span class="keyword1">oo</span> <span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">body</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> wrap_unwrap <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assoc_oo wrap_unwrap<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="free">wrap</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="main">(</span><span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">body</span> <span class="keyword1">oo</span> <span class="free">wrap</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> rolling_rule<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">body</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> g<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">wrap</span>"</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assoc_oo<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Gill and Hutton's <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>worker_wrapper_fusion›</span></span></span></span> rule is intended to
allow the transformation of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="free"><span class="free">unwrap</span></span> <span class="keyword1"><span class="keyword1">oo</span></span> <span class="free"><span class="free">wrap</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">R</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span>
<span class="quoted"><span class="quoted">"<span class="free"><span class="free">R</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in recursive contexts, where <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">R</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is meant to be a
self-call. Note that it assumes that the first worker/wrapper
hypothesis can be established.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> worker_wrapper_fusion<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">wrap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span><span class="main">::</span>pcpo <span class="main">→</span> <span class="tfree">'a</span><span class="main">::</span>pcpo"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">unwrap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> wrap_unwrap<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">wrap</span> <span class="keyword1">oo</span> <span class="free">unwrap</span> <span class="main">=</span> ID"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> work<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">work</span> <span class="main">=</span> fix<span class="main">⋅</span><span class="main">(</span><span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">body</span> <span class="keyword1">oo</span> <span class="free">wrap</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">wrap</span><span class="main">)</span><span class="main">⋅</span><span class="free">work</span> <span class="main">=</span> <span class="free">work</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">wrap</span><span class="main">)</span><span class="main">⋅</span><span class="free">work</span> <span class="main">=</span> <span class="main">(</span><span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">wrap</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="main">(</span><span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">body</span> <span class="keyword1">oo</span> <span class="free">wrap</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> work <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">wrap</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="main">(</span><span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">body</span> <span class="keyword1">oo</span> <span class="free">wrap</span> <span class="keyword1">oo</span> <span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">wrap</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> wrap_unwrap <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assoc_oo<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> fix<span class="main">⋅</span><span class="main">(</span><span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">wrap</span> <span class="keyword1">oo</span> <span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">body</span> <span class="keyword1">oo</span> <span class="free">wrap</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> rolling_rule<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">body</span> <span class="keyword1">oo</span> <span class="free">wrap</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> g<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">wrap</span>"</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assoc_oo<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> fix<span class="main">⋅</span><span class="main">(</span><span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">body</span> <span class="keyword1">oo</span> <span class="free">wrap</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> wrap_unwrap <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assoc_oo<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> work <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The following sections show that this rule only preserves partial
correctness. This is because Gill and Hutton apply it in the context
of the fold/unfold program transformation framework of
\citet*{BurstallDarlington:1977}, which need not preserve termination.
We show that the fusion rule does in fact require extra conditions to
be totally correct and propose one such sufficient condition.


›</span></span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="CounterExample">
<div class="head">
<h1>Theory CounterExample</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">theory</span></span> CounterExample
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../../HOL/HOLCF/HOLCF.html">HOLCF</a>
  <a href="WorkerWrapper.html">WorkerWrapper</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Worker/wrapper fusion is partially correct›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We now examine how Gill and Hutton apply their worker/wrapper fusion
rule in the context of the fold/unfold framework.

The key step of those left implicit in the original paper is the use
of the \textsf{fold} rule to justify replacing the worker with the
fused version. Schematically, the fold/unfold framework maintains a
history of all definitions that have appeared during transformation,
and the \textsf{fold} rule treats this as a set of rewrite rules
oriented right-to-left. (The \textsf{unfold} rule treats the current
working set of definitions as rewrite rules oriented left-to-right.)
Hence as each definition <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">haskell</span></span> "f = body"<span class="antiquote"><span class="antiquote">}</span></span></span></span> yields a rule of the form
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">haskell</span></span> "body\\ \\Longrightarrow\\ f"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, one can always derive <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">haskell</span></span> "f =\\
f"<span class="antiquote"><span class="antiquote">}</span></span></span></span>. Clearly this has dire implications for the preservation of
termination behaviour.

\citet{Tullsen:PhDThesis} in his \S3.1.2 observes that the semantic
essence of the \textsf{fold} rule is Park induction:
\begin{center}
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span>[mode=Rule] "fix_least"<span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">where</span></span> F<span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">f</span></span></span></span><span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> {\texttt{fix\_least}}
\end{center}
viz that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">haskell</span></span> "f\\ x = x"<span class="antiquote"><span class="antiquote">}</span></span></span></span> implies only the partially correct <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">haskell</span></span> "fix\\ f
\\sqsubseteq x"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, and not the totally correct <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">haskell</span></span> "fix\\ f = x"<span class="antiquote"><span class="antiquote">}</span></span></span></span>. We use
this characterisation to show that if <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">haskell</span></span> "unwrap"<span class="antiquote"><span class="antiquote">}</span></span></span></span> is non-strict
(i.e. <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">haskell</span></span> "unwrap \\bot \\neq \\bot"<span class="antiquote"><span class="antiquote">}</span></span></span></span>) then there are programs where
worker/wrapper fusion as used by Gill and Hutton need only be
partially correct.

Consider the scenario described in Figure~\ref{fig:ww}. After applying
the worker/wrapper transformation, we attempt to apply fusion by
finding a residual expression <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">body'</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> such that the body of
the worker, i.e. the expression <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">unwrap</span></span> <span class="keyword1"><span class="keyword1">oo</span></span> <span class="free"><span class="free">body</span></span> <span class="keyword1"><span class="keyword1">oo</span></span> <span class="free"><span class="free">wrap</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, can
be rewritten as <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">body'</span></span> <span class="keyword1"><span class="keyword1">oo</span></span> <span class="free"><span class="free">unwrap</span></span> <span class="keyword1"><span class="keyword1">oo</span></span> <span class="free"><span class="free">wrap</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. Intuitively this is
the semantic form of workers where all self-calls are fusible. Our
goal is to justify redefining <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">work</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"fix<span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">body'</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
i.e. to establish:
\begin{center}
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"fix<span class="main"><span class="main">⋅</span></span><span class="main"><span class="main">(</span></span><span class="free"><span class="free">unwrap</span></span> <span class="keyword1"><span class="keyword1">oo</span></span> <span class="free"><span class="free">body</span></span> <span class="keyword1"><span class="keyword1">oo</span></span> <span class="free"><span class="free">wrap</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">=</span></span> fix<span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">body'</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
\end{center}
We show that worker/wrapper fusion as proposed by Gill and Hutton is
partially correct using Park induction:

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> fusion_partially_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> wrap_unwrap<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">wrap</span> <span class="keyword1">oo</span> <span class="free">unwrap</span> <span class="main">=</span> ID"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> work<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">work</span> <span class="main">=</span> fix<span class="main">⋅</span><span class="main">(</span><span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">body</span> <span class="keyword1">oo</span> <span class="free">wrap</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> body'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">body</span> <span class="keyword1">oo</span> <span class="free">wrap</span> <span class="main">=</span> <span class="free">body'</span> <span class="keyword1">oo</span> <span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">wrap</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fix<span class="main">⋅</span><span class="free">body'</span> <span class="main">⊑</span> <span class="free">work</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> fix_least<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">work</span> <span class="main">=</span> <span class="main">(</span><span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">body</span> <span class="keyword1">oo</span> <span class="free">wrap</span><span class="main">)</span><span class="main">⋅</span><span class="free">work</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> work <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fix_eq<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span><span class="free">body'</span> <span class="keyword1">oo</span> <span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">wrap</span><span class="main">)</span><span class="main">⋅</span><span class="free">work</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> body' <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span><span class="free">body'</span> <span class="keyword1">oo</span> <span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">wrap</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="main">(</span><span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">body</span> <span class="keyword1">oo</span> <span class="free">wrap</span><span class="main">)</span><span class="main">⋅</span><span class="free">work</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> work <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fix_eq<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span><span class="free">body'</span> <span class="keyword1">oo</span> <span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">wrap</span> <span class="keyword1">oo</span> <span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">body</span> <span class="keyword1">oo</span> <span class="free">wrap</span><span class="main">)</span><span class="main">⋅</span><span class="free">work</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span><span class="free">body'</span> <span class="keyword1">oo</span> <span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">body</span> <span class="keyword1">oo</span> <span class="free">wrap</span><span class="main">)</span><span class="main">⋅</span><span class="free">work</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> wrap_unwrap <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assoc_oo<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="free">body'</span><span class="main">⋅</span><span class="free">work</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> work <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fix_eq<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">body'</span><span class="main">⋅</span><span class="free">work</span> <span class="main">=</span> <span class="free">work</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The next section shows the converse does not obtain.

›</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹A non-strict <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">unwrap</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> may go awry›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\label{sec:ww-counterexample}

If <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">unwrap</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is non-strict, then it is possible that the fusion
rule proposed by Gill and Hutton does not preserve termination. To
show this we take a small artificial example. The type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">A</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is
not important, but we need access to a non-bottom inhabitant. The
target type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">B</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is the non-strict lift of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">A</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">domain</span></span> A <span class="main">=</span> A
<span class="keyword1"><span class="command">domain</span></span> B <span class="main">=</span> B <span class="main">(</span><span class="keyword2"><span class="keyword">lazy</span></span> <span class="quoted"><span class="quoted">"A"</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The functions <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">wrap</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">unwrap</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> that map between
these types are routine. Note that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">wrap</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is (necessarily)
strict due to the property <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> "retraction_strict"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">wrap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"B <span class="main">→</span> A"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">wrap</span><span class="main">⋅</span><span class="main">(</span>B<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span>"</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">lemma</span></span> wrap_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"wrap<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">unwrap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"A <span class="main">→</span> B"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">unwrap</span> <span class="main">=</span> B"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Discharging the worker/wrapper hypothesis is similarly routine.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> wrap_unwrap<span class="main">:</span> <span class="quoted"><span class="quoted">"wrap <span class="keyword1">oo</span> unwrap <span class="main">=</span> ID"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfun_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The candidate computation we transform can be any that uses the
recursion parameter <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">r</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> non-strictly. The following is
especially trivial.

›</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">body</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"A <span class="main">→</span> A"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">body</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">=</span> A"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The wrinkle is that the transformed worker can be strict in the
recursion parameter <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">r</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, as <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"unwrap"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> always lifts it.

›</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">body'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"B <span class="main">→</span> B"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">body'</span><span class="main">⋅</span><span class="main">(</span>B<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="main">=</span> B<span class="main">⋅</span>A"</span></span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> body'_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"body'<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

As explained above, we set up the fusion opportunity:

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> body_body'<span class="main">:</span> <span class="quoted"><span class="quoted">"unwrap <span class="keyword1">oo</span> body <span class="keyword1">oo</span> wrap <span class="main">=</span> body' <span class="keyword1">oo</span> unwrap <span class="keyword1">oo</span> wrap"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfun_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

This result depends crucially on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"unwrap"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> being non-strict.

Our earlier result shows that the proposed transformation is partially
correct:

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"fix<span class="main">⋅</span>body' <span class="main">⊑</span> fix<span class="main">⋅</span><span class="main">(</span>unwrap <span class="keyword1">oo</span> body <span class="keyword1">oo</span> wrap<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> fusion_partially_correct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> wrap_unwrap refl body_body'<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

However it is easy to see that it is not totally correct:

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> fix<span class="main">⋅</span><span class="main">(</span>unwrap <span class="keyword1">oo</span> body <span class="keyword1">oo</span> wrap<span class="main">)</span> <span class="main">⊑</span> fix<span class="main">⋅</span>body'"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> l<span class="main">:</span> <span class="quoted"><span class="quoted">"fix<span class="main">⋅</span><span class="main">(</span>unwrap <span class="keyword1">oo</span> body <span class="keyword1">oo</span> wrap<span class="main">)</span> <span class="main">=</span> B<span class="main">⋅</span>A"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> fix_eq<span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">have</span></span> r<span class="main">:</span> <span class="quoted"><span class="quoted">"fix<span class="main">⋅</span>body' <span class="main">=</span> <span class="main">⊥</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fix_strict<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> l r <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

This trick works whenever <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"unwrap"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is not strict. In the
following section we show that requiring <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"unwrap"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to be strict
leads to a straightforward proof of total correctness.

Note that if we have already established that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"wrap <span class="keyword1"><span class="keyword1">oo</span></span> unwrap <span class="main"><span class="main">=</span></span>
ID"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, then making <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"unwrap"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> strict preserves this equation:

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"wrap <span class="keyword1">oo</span> unwrap <span class="main">=</span> ID"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"wrap <span class="keyword1">oo</span> strictify<span class="main">⋅</span>unwrap <span class="main">=</span> ID"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
  <span class="keyword1"><span class="command">from</span></span> assms
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>wrap <span class="keyword1">oo</span> strictify<span class="main">⋅</span>unwrap<span class="main">)</span><span class="main">⋅</span><span class="skolem">x</span> <span class="main">=</span> ID<span class="main">⋅</span><span class="skolem">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfun_eq_iff retraction_strict<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

From this we conclude that the worker/wrapper transformation itself
cannot exploit any laziness in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"unwrap"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> under the
context-insensitive assumptions of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source]
"worker_wrapper_id"<span class="antiquote"><span class="antiquote">}</span></span></span></span>. This is not to say that other program
transformations may not be able to.

›</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">lemma</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">¬</span> strictify<span class="main">⋅</span>unwrap <span class="keyword1">oo</span> body <span class="keyword1">oo</span> wrap <span class="main">=</span> body' <span class="keyword1">oo</span> strictify<span class="main">⋅</span>unwrap <span class="keyword1">oo</span> wrap"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfun_eq_iff exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">⊥</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="comment1">(*&gt;*)</span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="WorkerWrapperNew">
<div class="head">
<h1>Theory WorkerWrapperNew</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="comment1">(*
 * The worker/wrapper transformation, following Gill and Hutton.
 * (C)opyright 2009-2011, Peter Gammie, peteg42 at gmail.com.
 * License: BSD
 *)</span>

<span class="keyword1"><span class="command">theory</span></span> WorkerWrapperNew
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../../HOL/HOLCF/HOLCF.html">HOLCF</a>
  <a href="FixedPointTheorems.html">FixedPointTheorems</a>
  <a href="WorkerWrapper.html">WorkerWrapper</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹A totally-correct fusion rule›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
\label{sec:ww-fixed}

We now show that a termination-preserving worker/wrapper fusion rule
can be obtained by requiring <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">unwrap</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to be strict. (As we
observed earlier, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">wrap</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> must always be strict due to the
assumption that <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>wrap oo unwrap = ID›</span></span></span></span>.)

Our first result shows that a combined worker/wrapper transformation
and fusion rule is sound, using the assumptions of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>worker_wrapper_id›</span></span></span></span> and the ubiquitous <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>lfp_fusion›</span></span></span></span> rule.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> worker_wrapper_fusion_new<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">wrap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span><span class="main">::</span>pcpo <span class="main">→</span> <span class="tfree">'a</span><span class="main">::</span>pcpo"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">unwrap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span>"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">body'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">→</span> <span class="tfree">'b</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> wrap_unwrap<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">wrap</span> <span class="keyword1">oo</span> <span class="free">unwrap</span> <span class="main">=</span> <span class="main">(</span>ID <span class="main">::</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'a</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> unwrap_strict<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">unwrap</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> body_body'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">body</span> <span class="keyword1">oo</span> <span class="free">wrap</span> <span class="main">=</span> <span class="free">body'</span> <span class="keyword1">oo</span> <span class="main">(</span><span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">wrap</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fix<span class="main">⋅</span><span class="free">body</span> <span class="main">=</span> <span class="free">wrap</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="free">body'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> body_body'
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">body</span> <span class="keyword1">oo</span> <span class="main">(</span><span class="free">wrap</span> <span class="keyword1">oo</span> <span class="free">unwrap</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">body'</span> <span class="keyword1">oo</span> <span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="main">(</span><span class="free">wrap</span> <span class="keyword1">oo</span> <span class="free">unwrap</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assoc_oo<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> wrap_unwrap <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">body</span> <span class="main">=</span> <span class="free">body'</span> <span class="keyword1">oo</span> <span class="free">unwrap</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">with</span></span> unwrap_strict <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">unwrap</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="free">body</span><span class="main">)</span> <span class="main">=</span> fix<span class="main">⋅</span><span class="free">body'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> lfp_fusion<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">wrap</span> <span class="keyword1">oo</span> <span class="free">unwrap</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="free">body</span><span class="main">)</span> <span class="main">=</span> <span class="free">wrap</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="free">body'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">with</span></span> wrap_unwrap <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We can also show a more general result which allows fusion to be
optionally performed on a per-recursive-call basis using
\texttt{parallel\_fix\_ind}:

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> worker_wrapper_fusion_new_general<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">wrap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span><span class="main">::</span>pcpo <span class="main">→</span> <span class="tfree">'a</span><span class="main">::</span>pcpo"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">unwrap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> wrap_unwrap<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">wrap</span> <span class="keyword1">oo</span> <span class="free">unwrap</span> <span class="main">=</span> <span class="main">(</span>ID <span class="main">::</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'a</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> unwrap_strict<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">unwrap</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> body_body'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">r</span><span class="main">.</span> <span class="main">(</span><span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">wrap</span><span class="main">)</span><span class="main">⋅</span><span class="bound">r</span> <span class="main">=</span> <span class="bound">r</span>
                        <span class="main">⟹</span> <span class="main">(</span><span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">body</span> <span class="keyword1">oo</span> <span class="free">wrap</span><span class="main">)</span><span class="main">⋅</span><span class="bound">r</span> <span class="main">=</span> <span class="free">body'</span><span class="main">⋅</span><span class="bound">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fix<span class="main">⋅</span><span class="free">body</span> <span class="main">=</span> <span class="free">wrap</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="free">body'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?P</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">y</span> <span class="main">∧</span> <span class="free">unwrap</span><span class="main">⋅</span><span class="main">(</span><span class="free">wrap</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="bound">x</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="main">(</span>fix<span class="main">⋅</span><span class="main">(</span><span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">body</span> <span class="keyword1">oo</span> <span class="free">wrap</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>fix<span class="main">⋅</span><span class="free">body'</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> parallel_fix_ind<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> 2 <span class="keyword1"><span class="command">with</span></span> retraction_strict unwrap_strict wrap_unwrap <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="main">(</span><span class="main">⊥</span><span class="main">,</span> <span class="main">⊥</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">bestsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfun_eq_iff<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>3 <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> xy<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> unwrap_wrap<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">unwrap</span><span class="main">⋅</span><span class="main">(</span><span class="free">wrap</span><span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> body_body' xy unwrap_wrap
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">body</span> <span class="keyword1">oo</span> <span class="free">wrap</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">x</span> <span class="main">=</span> <span class="free">body'</span><span class="main">⋅</span><span class="skolem">y</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">from</span></span> wrap_unwrap
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">unwrap</span><span class="main">⋅</span><span class="main">(</span><span class="free">wrap</span><span class="main">⋅</span><span class="main">(</span><span class="main">(</span><span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">body</span> <span class="keyword1">oo</span> <span class="free">wrap</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">unwrap</span> <span class="keyword1">oo</span> <span class="free">body</span> <span class="keyword1">oo</span> <span class="free">wrap</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">x</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfun_eq_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> worker_wrapper_id<span class="main">[</span><span class="operator">OF</span> wrap_unwrap refl<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

This justifies the syntactically-oriented rules shown in
Figure~\ref{fig:wwc2}; note the scoping of the fusion rule.

Those familiar with the ``bananas'' work of \citet*{barbed-wire:1991}
will not be surprised that adding a strictness assumption justifies an
equational fusion rule.

\begin{figure}[tb]
 \begin{center}
  \fbox{\parbox{0.96\textwidth}{For a recursive definition <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">haskell</span></span> "comp =
      body"<span class="antiquote"><span class="antiquote">}</span></span></span></span> of type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">haskell</span></span> "A"<span class="antiquote"><span class="antiquote">}</span></span></span></span> and a pair of functions <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">haskell</span></span> "wrap :: B \\to A"<span class="antiquote"><span class="antiquote">}</span></span></span></span>
      and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">haskell</span></span> "unwrap :: A \\to B"<span class="antiquote"><span class="antiquote">}</span></span></span></span> where <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">haskell</span></span> "wrap \\circ unwrap = id_A"<span class="antiquote"><span class="antiquote">}</span></span></span></span> and
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">haskell</span></span> "unwrap\\ \\bot = \\bot"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, define:

      \parbox{0.35\textwidth}{\begin{haskell}
        comp &amp; = wrap\ work\\
        work &amp; = unwrap\ (body[wrap\ work / comp])
      \end{haskell}}\hfill \textsf{(the worker/wrapper transformation)}

    In the scope of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">haskell</span></span> "work"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, the following rewrite is admissable:

    \parbox{0.35\textwidth}{\begin{haskell}
        unwrap\ (wrap\ work) \Longrightarrow work
      \end{haskell}}\hfill \textsf{(worker/wrapper fusion)}}}%
 \end{center}%
\caption{The syntactic worker/wrapper transformation and fusion rule.}\label{fig:wwc2}
\end{figure}

›</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="Accumulator">
<div class="head">
<h1>Theory Accumulator</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="comment1">(*
 * The worker/wrapper transformation, following Gill and Hutton.
 * (C)opyright 2009-2011, Peter Gammie, peteg42 at gmail.com.
 * License: BSD
 *)</span>

<span class="keyword1"><span class="command">theory</span></span> Accumulator
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../../HOL/HOLCF/HOLCF.html">HOLCF</a>
  <a href="LList.html">LList</a>
  <a href="WorkerWrapperNew.html">WorkerWrapperNew</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Naive reverse becomes accumulator-reverse.›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹\label{sec:accum}›</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Hughes lists, naive reverse, worker-wrapper optimisation.›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The ``Hughes'' list type.›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'a</span> H <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span> llist"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">list2H</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span> H"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">list2H</span> <span class="main">≡</span> lappend"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> acc_c2a_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"list2H<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list2H_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">H2list</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> H <span class="main">→</span> <span class="tfree">'a</span> llist"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">H2list</span> <span class="main">≡</span> <span class="keyword1">Λ</span> f <span class="main">.</span> <span class="bound">f</span><span class="main">⋅</span><span class="keyword1">lnil</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The paper only claims the homomorphism holds for finite lists,
but in fact it holds for all lazy lists in HOLCF. They are trying to
dodge an explicit appeal to the equation <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> "inst_cfun_pcpo"<span class="antiquote"><span class="antiquote">}</span></span></span></span>,
which does not hold in Haskell.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> H_llist_hom_append<span class="main">:</span> <span class="quoted"><span class="quoted">"list2H<span class="main">⋅</span><span class="main">(</span><span class="free">xs</span> <span class="main">:++</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> list2H<span class="main">⋅</span><span class="free">xs</span> <span class="keyword1">oo</span> list2H<span class="main">⋅</span><span class="free">ys</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">zs</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span><span class="main">⋅</span><span class="skolem">zs</span> <span class="main">=</span> <span class="main">(</span><span class="free">xs</span> <span class="main">:++</span> <span class="free">ys</span><span class="main">)</span> <span class="main">:++</span> <span class="skolem">zs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list2H_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">xs</span> <span class="main">:++</span> <span class="main">(</span><span class="free">ys</span> <span class="main">:++</span> <span class="skolem">zs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> lappend_assoc<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> list2H<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="main">(</span><span class="free">ys</span> <span class="main">:++</span> <span class="skolem">zs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list2H_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> list2H<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="main">(</span>list2H<span class="main">⋅</span><span class="free">ys</span><span class="main">⋅</span><span class="skolem">zs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list2H_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span>list2H<span class="main">⋅</span><span class="free">xs</span> <span class="keyword1">oo</span> list2H<span class="main">⋅</span><span class="free">ys</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">zs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span><span class="main">⋅</span><span class="skolem">zs</span> <span class="main">=</span> <span class="main">(</span>list2H<span class="main">⋅</span><span class="free">xs</span> <span class="keyword1">oo</span> list2H<span class="main">⋅</span><span class="free">ys</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">zs</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> H_llist_hom_id<span class="main">:</span> <span class="quoted"><span class="quoted">"list2H<span class="main">⋅</span><span class="keyword1">lnil</span> <span class="main">=</span> ID"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list2H_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> H2list_list2H_inv<span class="main">:</span> <span class="quoted"><span class="quoted">"H2list <span class="keyword1">oo</span> list2H <span class="main">=</span> ID"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> H2list_def list2H_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹\citet[\S4.2]{GillHutton:2009} define the naive reverse
function as follows.›</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">lrev</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span> llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lrev</span><span class="main">⋅</span><span class="keyword1">lnil</span> <span class="main">=</span> <span class="keyword1">lnil</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">lrev</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:@</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">lrev</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">:++</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:@</span> <span class="keyword1">lnil</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Note ``body'' is the generator of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">lrev_def</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lrev_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lrev<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">lrev_body</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span> llist<span class="main">)</span> <span class="main">→</span> <span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span> llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lrev_body</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="keyword1">lnil</span> <span class="main">=</span> <span class="keyword1">lnil</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">lrev_body</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:@</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">:++</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:@</span> <span class="keyword1">lnil</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lrev_body_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lrev_body<span class="main">⋅</span><span class="free">r</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹This is trivial but syntactically a bit touchy. Would be nicer
to define <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"lrev_body"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> as the generator of the fixpoint
definition of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"lrev"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> directly.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lrev_lrev_body_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"lrev <span class="main">=</span> fix<span class="main">⋅</span>lrev_body"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> lrev_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> lrev_body.unfold<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Wrap / unwrap functions.›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">unwrapH</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span> llist<span class="main">)</span> <span class="main">→</span> <span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span> H"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">unwrapH</span> <span class="main">≡</span> <span class="keyword1">Λ</span> f xs <span class="main">.</span> list2H<span class="main">⋅</span><span class="main">(</span><span class="bound">f</span><span class="main">⋅</span><span class="bound">xs</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> unwrapH_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"unwrapH<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> unwrapH_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">wrapH</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span> H<span class="main">)</span> <span class="main">→</span> <span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span> llist"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">wrapH</span> <span class="main">≡</span> <span class="keyword1">Λ</span> f xs <span class="main">.</span> H2list<span class="main">⋅</span><span class="main">(</span><span class="bound">f</span><span class="main">⋅</span><span class="bound">xs</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> wrapH_unwrapH_id<span class="main">:</span> <span class="quoted"><span class="quoted">"wrapH <span class="keyword1">oo</span> unwrapH <span class="main">=</span> ID"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="skolem">xs</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span><span class="main">⋅</span><span class="skolem">f</span><span class="main">⋅</span><span class="skolem">xs</span> <span class="main">=</span> H2list<span class="main">⋅</span><span class="main">(</span>list2H<span class="main">⋅</span><span class="main">(</span><span class="skolem">f</span><span class="main">⋅</span><span class="skolem">xs</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> wrapH_def unwrapH_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span>H2list <span class="keyword1">oo</span> list2H<span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="skolem">f</span><span class="main">⋅</span><span class="skolem">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> ID<span class="main">⋅</span><span class="main">(</span><span class="skolem">f</span><span class="main">⋅</span><span class="skolem">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> H2list_list2H_inv<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="var">?rhs</span><span class="main">⋅</span><span class="skolem">f</span><span class="main">⋅</span><span class="skolem">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span><span class="main">⋅</span><span class="skolem">f</span><span class="main">⋅</span><span class="skolem">xs</span> <span class="main">=</span> <span class="var">?rhs</span><span class="main">⋅</span><span class="skolem">f</span><span class="main">⋅</span><span class="skolem">xs</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Gill/Hutton-style worker/wrapper.›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">lrev_work</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span> H"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lrev_work</span> <span class="main">≡</span> fix<span class="main">⋅</span><span class="main">(</span>unwrapH <span class="keyword1">oo</span> lrev_body <span class="keyword1">oo</span> wrapH<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">lrev_wrap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span> llist"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lrev_wrap</span> <span class="main">≡</span> wrapH<span class="main">⋅</span>lrev_work"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lrev_lrev_ww_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"lrev <span class="main">=</span> lrev_wrap"</span></span>
  <span class="keyword1"><span class="command">using</span></span> worker_wrapper_id<span class="main">[</span><span class="operator">OF</span> wrapH_unwrapH_id lrev_lrev_body_eq<span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lrev_wrap_def lrev_work_def<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Optimise worker/wrapper.›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Intermediate worker.›</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">lrev_body1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span> H<span class="main">)</span> <span class="main">→</span> <span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span> H"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lrev_body1</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="keyword1">lnil</span> <span class="main">=</span> list2H<span class="main">⋅</span><span class="keyword1">lnil</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">lrev_body1</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:@</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> list2H<span class="main">⋅</span><span class="main">(</span>wrapH<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">:++</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:@</span> <span class="keyword1">lnil</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">lrev_work1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span> H"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lrev_work1</span> <span class="main">≡</span> fix<span class="main">⋅</span>lrev_body1"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lrev_body_lrev_body1_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"lrev_body1 <span class="main">=</span> unwrapH <span class="keyword1">oo</span> lrev_body <span class="keyword1">oo</span> wrapH"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> lrev_body.unfold<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> lrev_body1.unfold<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">xa</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list2H_def wrapH_def unwrapH_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> lrev_work1_lrev_work_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"lrev_work1 <span class="main">=</span> lrev_work"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> lrev_work_def lrev_work1_def<span class="main"><span class="keyword3">,</span></span>
      <span class="operator">rule</span> cfun_arg_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lrev_body_lrev_body1_eq<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Now use the homomorphism.›</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">lrev_body2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span> H<span class="main">)</span> <span class="main">→</span> <span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span> H"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lrev_body2</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="keyword1">lnil</span> <span class="main">=</span> ID"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">lrev_body2</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:@</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> list2H<span class="main">⋅</span><span class="main">(</span>wrapH<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="keyword1">oo</span> list2H<span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:@</span> <span class="keyword1">lnil</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lrev_body2_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lrev_body2<span class="main">⋅</span><span class="free">r</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">lrev_work2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span> H"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lrev_work2</span> <span class="main">≡</span> fix<span class="main">⋅</span>lrev_body2"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lrev_work2_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lrev_work2<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> lrev_work2_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> fix_eq<span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> lrev_body2_lrev_body1_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"lrev_body2 <span class="main">=</span> lrev_body1"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
     <span class="main"><span class="keyword3">,</span></span> <span class="main">(</span><span class="operator">subst</span> lrev_body1.unfold<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> lrev_body2.unfold<span class="main">)</span>
     <span class="main"><span class="keyword3">,</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> H_llist_hom_append<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> H_llist_hom_id<span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lrev_work2_lrev_work1_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"lrev_work2 <span class="main">=</span> lrev_work1"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> lrev_work2_def lrev_work1_def
     <span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> cfun_arg_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lrev_body2_lrev_body1_eq<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Simplify.›</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">lrev_body3</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span> H<span class="main">)</span> <span class="main">→</span> <span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span> H"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lrev_body3</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="keyword1">lnil</span> <span class="main">=</span> ID"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">lrev_body3</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:@</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">oo</span> list2H<span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:@</span> <span class="keyword1">lnil</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lrev_body3_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lrev_body3<span class="main">⋅</span><span class="free">r</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">lrev_work3</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span> H"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lrev_work3</span> <span class="main">≡</span> fix<span class="main">⋅</span>lrev_body3"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lrev_wwfusion<span class="main">:</span> <span class="quoted"><span class="quoted">"list2H<span class="main">⋅</span><span class="main">(</span><span class="main">(</span>wrapH<span class="main">⋅</span>lrev_work2<span class="main">)</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lrev_work2<span class="main">⋅</span><span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"list2H <span class="keyword1">oo</span> wrapH<span class="main">⋅</span>lrev_work2 <span class="main">=</span> unwrapH<span class="main">⋅</span><span class="main">(</span>wrapH<span class="main">⋅</span>lrev_work2<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> unwrapH_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span>unwrapH <span class="keyword1">oo</span> wrapH<span class="main">)</span><span class="main">⋅</span>lrev_work2"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> lrev_work2"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> worker_wrapper_fusion<span class="main"><span class="main">[</span></span><span class="operator">OF</span> wrapH_unwrapH_id<span class="main"><span class="main">,</span></span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> body<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"lrev_body"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">iff</span><span class="main"><span class="main">:</span></span> lrev_body2_lrev_body1_eq lrev_body_lrev_body1_eq lrev_work2_def lrev_work1_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"list2H <span class="keyword1">oo</span> wrapH<span class="main">⋅</span>lrev_work2 <span class="main">=</span> lrev_work2"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> cfun_eq_iff<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"list2H <span class="keyword1">oo</span> wrapH<span class="main">⋅</span>lrev_work2"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> g<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"lrev_work2"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹If we use this result directly, we only get a partially-correct
program transformation, see \citet{Tullsen:PhDThesis} for details.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"lrev_work3 <span class="main">⊑</span> lrev_work2"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> lrev_work3_def
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> fix_least<span class="main">)</span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lrev_body3<span class="main">⋅</span>lrev_work2<span class="main">⋅</span><span class="skolem">xs</span> <span class="main">=</span> lrev_work2<span class="main">⋅</span><span class="skolem">xs</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> bottom <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> lnil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> lrev_work2_def
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> fix_eq<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> F<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"lrev_body2"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>lcons <span class="skolem">y</span> <span class="skolem">ys</span><span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lrev_body3<span class="main">⋅</span>lrev_work2<span class="main">⋅</span><span class="skolem">xs</span> <span class="main">=</span> lrev_work2<span class="main">⋅</span><span class="skolem">ys</span> <span class="keyword1">oo</span> list2H<span class="main">⋅</span><span class="main">(</span><span class="skolem">y</span> <span class="main">:@</span> <span class="keyword1">lnil</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> list2H<span class="main">⋅</span><span class="main">(</span><span class="main">(</span>wrapH<span class="main">⋅</span>lrev_work2<span class="main">)</span><span class="main">⋅</span><span class="skolem">ys</span><span class="main">)</span> <span class="keyword1">oo</span> list2H<span class="main">⋅</span><span class="main">(</span><span class="skolem">y</span> <span class="main">:@</span> <span class="keyword1">lnil</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> lrev_wwfusion<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> xs<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">ys</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> lcons <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> lrev_body2<span class="main">⋅</span>lrev_work2<span class="main">⋅</span><span class="skolem">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> lrev_work2<span class="main">⋅</span><span class="skolem">xs</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> lrev_work2_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> fix_eq<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"lrev_body3<span class="main">⋅</span>lrev_work2 <span class="main">=</span> lrev_work2"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹We can't show the reverse inclusion in the same way as the
fusion law doesn't hold for the optimised definition. (Intuitively we
haven't established that it is equal to the original <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"lrev"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
definition.) We could show termination of the optimised definition
though, as it operates on finite lists. Alternatively we can use
induction (over the list argument) to show total equivalence.

The following lemma shows that the fusion Gill/Hutton want to do is
completely sound in this context, by appealing to the lazy list
induction principle.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lrev_work3_lrev_work2_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"lrev_work3 <span class="main">=</span> lrev_work2"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span><span class="main">⋅</span><span class="skolem">x</span> <span class="main">=</span> <span class="var">?rhs</span><span class="main">⋅</span><span class="skolem">x</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lrev_work3<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> lrev_work2<span class="main">⋅</span><span class="main">⊥</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> lrev_work3_def lrev_work2_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> fix_eq<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> F<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"lrev_body2"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> fix_eq<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> F<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"lrev_body3"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lrev_body3.unfold lrev_body2.unfold<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lrev_work3<span class="main">⋅</span><span class="keyword1">lnil</span> <span class="main">=</span> lrev_work2<span class="main">⋅</span><span class="keyword1">lnil</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> lrev_work3_def lrev_work2_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> fix_eq<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> F<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"lrev_body2"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> fix_eq<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> F<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"lrev_body3"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lrev_body3.unfold lrev_body2.unfold<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">l</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"lrev_work3<span class="main">⋅</span><span class="skolem">l</span> <span class="main">=</span> lrev_work2<span class="main">⋅</span><span class="skolem">l</span>"</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"lrev_work3<span class="main">⋅</span><span class="main">(</span><span class="skolem">a</span> <span class="main">:@</span> <span class="skolem">l</span><span class="main">)</span> <span class="main">=</span> lrev_work2<span class="main">⋅</span><span class="main">(</span><span class="skolem">a</span> <span class="main">:@</span> <span class="skolem">l</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> lrev_work3_def lrev_work2_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> fix_eq<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> F<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"lrev_body2"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> fix_eq<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> F<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"lrev_body3"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fold</span> lrev_work3_def lrev_work2_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lrev_body3.unfold lrev_body2.unfold lrev_wwfusion<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Use the combined worker/wrapper-fusion rule. Note we get a weaker lemma.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lrev3_2_syntactic<span class="main">:</span> <span class="quoted"><span class="quoted">"lrev_body3 <span class="keyword1">oo</span> <span class="main">(</span>unwrapH <span class="keyword1">oo</span> wrapH<span class="main">)</span> <span class="main">=</span> lrev_body2"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> lrev_body2.unfold<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> lrev_body3.unfold<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">xa</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> unwrapH_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> lrev_work3_lrev_work2_eq'<span class="main">:</span> <span class="quoted"><span class="quoted">"lrev <span class="main">=</span> wrapH<span class="main">⋅</span>lrev_work3"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> lrev_lrev_body_eq
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lrev <span class="main">=</span> fix<span class="main">⋅</span>lrev_body"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> wrapH_unwrapH_id unwrapH_strict
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> wrapH<span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span>lrev_body3<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> worker_wrapper_fusion_new
       <span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lrev3_2_syntactic lrev_body2_lrev_body1_eq lrev_body_lrev_body1_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> lrev_work3_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Final syntactic tidy-up.›</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">lrev_body_final</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span> H<span class="main">)</span> <span class="main">→</span> <span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span> H"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lrev_body_final</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="keyword1">lnil</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">lrev_body_final</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:@</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:@</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">lrev_work_final</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span> H"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lrev_work_final</span> <span class="main">≡</span> fix<span class="main">⋅</span>lrev_body_final"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">lrev_final</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span> llist"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lrev_final</span> <span class="main">≡</span> <span class="keyword1">Λ</span> xs<span class="main">.</span> lrev_work_final<span class="main">⋅</span><span class="bound">xs</span><span class="main">⋅</span><span class="keyword1">lnil</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lrev_body_final_lrev_body3_eq'<span class="main">:</span> <span class="quoted"><span class="quoted">"lrev_body_final<span class="main">⋅</span><span class="free">r</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> lrev_body3<span class="main">⋅</span><span class="free">r</span><span class="main">⋅</span><span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> lrev_body_final.unfold<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> lrev_body3.unfold<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list2H_def ID_def cfun_eqI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> lrev_body_final_lrev_body3_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"lrev_body_final <span class="main">=</span> lrev_body3"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> lrev_body_final_lrev_body3_eq' cfun_eqI<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lrev_final_lrev_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"lrev <span class="main">=</span> lrev_final"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> lrev_wrap"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> lrev_lrev_ww_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> wrapH<span class="main">⋅</span>lrev_work"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> lrev_wrap_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> wrapH<span class="main">⋅</span>lrev_work1"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> lrev_work1_lrev_work_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> wrapH<span class="main">⋅</span>lrev_work2"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> lrev_work2_lrev_work1_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> wrapH<span class="main">⋅</span>lrev_work3"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> lrev_work3_lrev_work2_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> wrapH<span class="main">⋅</span>lrev_work_final"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> lrev_work3_def lrev_work_final_def lrev_body_final_lrev_body3_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> lrev_final"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lrev_final_def cfun_eqI H2list_def wrapH_def<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="UnboxedNats">
<div class="head">
<h1>Theory UnboxedNats</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="comment1">(*
 * The worker/wrapper transformation, following Gill and Hutton.
 * (C)opyright 2009-2011, Peter Gammie, peteg42 at gmail.com.
 * License: BSD
 *)</span>

<span class="keyword1"><span class="command">theory</span></span> UnboxedNats
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../../HOL/HOLCF/HOLCF.html">HOLCF</a>
  <a href="Nats.html">Nats</a>
  <a href="WorkerWrapperNew.html">WorkerWrapperNew</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Unboxing types.›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The original application of the worker/wrapper transformation
was the unboxing of flat types by \citet{SPJ-JL:1991}. We can model
the boxed and unboxed types as (respectively) pointed and unpointed
domains in HOLCF. Concretely <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"UNat"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> denotes the discrete domain
of naturals, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"UNat<span class="main"><span class="main"><span class="hidden">⇩</span><sub>⊥</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> the lifted (flat and pointed) variant, and
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"Nat"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> the standard boxed domain, isomorphic to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span>
<span class="quoted"><span class="quoted">"UNat<span class="main"><span class="main"><span class="hidden">⇩</span><sub>⊥</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. This latter distinction helps us keep the boxed naturals and
lifted function codomains separated; applications of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"unbox"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
should be thought of in the same way as Haskell's <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">newtype</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
constructors, i.e. operationally equivalent to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"ID"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

The divergence monad is used to handle the unboxing, see below.›</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Factorial example.›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Standard definition of factorial.›</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">fac</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Nat <span class="main">→</span> Nat"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fac</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="keyword1">If</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">=<span class="hidden">⇩</span><sub>B</sub></span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">*</span> <span class="free">fac</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">declare</span></span> fac.simps<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> fac_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"fac<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">fac_body</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Nat <span class="main">→</span> Nat<span class="main">)</span> <span class="main">→</span> Nat <span class="main">→</span> Nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fac_body</span> <span class="main">≡</span> <span class="keyword1">Λ</span> r n<span class="main">.</span> <span class="keyword1">If</span> <span class="bound">n</span> <span class="keyword1">=<span class="hidden">⇩</span><sub>B</sub></span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="bound">n</span> <span class="main">*</span> <span class="bound">r</span><span class="main">⋅</span><span class="main">(</span><span class="bound">n</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> fac_body_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"fac_body<span class="main">⋅</span><span class="free">r</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fac_body_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> fac_fac_body_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"fac <span class="main">=</span> fix<span class="main">⋅</span>fac_body"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fac_body_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> fac_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Wrap / unwrap functions. Note the explicit lifting of the
co-domain. For some reason the published version of
\citet{GillHutton:2009} does not discuss this point: if we're going to
handle recursive functions, we need a bottom.

<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"unbox"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> simply removes the tag, yielding a possibly-divergent
unboxed value, the result of the function.›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">unwrapB</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Nat <span class="main">→</span> Nat<span class="main">)</span> <span class="main">→</span> UNat <span class="main">→</span> UNat<span class="main"><span class="hidden">⇩</span><sub>⊥</sub></span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">unwrapB</span> <span class="main">≡</span> <span class="keyword1">Λ</span> f<span class="main">.</span> unbox <span class="keyword1">oo</span> <span class="bound">f</span> <span class="keyword1">oo</span> box"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Note that the monadic bind operator <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(&gt;&gt;=)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> here stands
in for the \textsf{case} construct in the paper.›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">wrapB</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>UNat <span class="main">→</span> UNat<span class="main"><span class="hidden">⇩</span><sub>⊥</sub></span><span class="main">)</span> <span class="main">→</span> Nat <span class="main">→</span> Nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">wrapB</span> <span class="main">≡</span> <span class="keyword1">Λ</span> f x <span class="main">.</span> unbox<span class="main">⋅</span><span class="bound">x</span> <span class="main">&gt;&gt;=</span> <span class="bound">f</span> <span class="main">&gt;&gt;=</span> box"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> wrapB_unwrapB_body<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> strictF<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>wrapB <span class="keyword1">oo</span> unwrapB<span class="main">)</span><span class="main">⋅</span><span class="free">f</span> <span class="main">=</span> <span class="free">f</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted">Nat</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span><span class="main">⋅</span><span class="skolem">x</span> <span class="main">=</span> unbox<span class="main">⋅</span><span class="skolem">x</span> <span class="main">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1">Λ</span> x'<span class="main">.</span> unwrapB<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="bound">x'</span> <span class="main">&gt;&gt;=</span> box<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> wrapB_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> unbox<span class="main">⋅</span><span class="skolem">x</span> <span class="main">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1">Λ</span> x'<span class="main">.</span> unbox<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>box<span class="main">⋅</span><span class="bound">x'</span><span class="main">)</span><span class="main">)</span> <span class="main">&gt;&gt;=</span> box<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> unwrapB_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> strictF <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">f</span><span class="main">⋅</span><span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span><span class="main">⋅</span><span class="skolem">x</span> <span class="main">=</span> <span class="var">?rhs</span><span class="main">⋅</span><span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Apply worker/wrapper.›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">fac_work</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"UNat <span class="main">→</span> UNat<span class="main"><span class="hidden">⇩</span><sub>⊥</sub></span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fac_work</span> <span class="main">≡</span> fix<span class="main">⋅</span><span class="main">(</span>unwrapB <span class="keyword1">oo</span> fac_body <span class="keyword1">oo</span> wrapB<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">fac_wrap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Nat <span class="main">→</span> Nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fac_wrap</span> <span class="main">≡</span> wrapB<span class="main">⋅</span>fac_work"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> fac_fac_ww_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"fac <span class="main">=</span> fac_wrap"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"wrapB <span class="keyword1">oo</span> unwrapB <span class="keyword1">oo</span> fac_body <span class="main">=</span> fac_body"</span></span>
    <span class="keyword1"><span class="command">using</span></span> wrapB_unwrapB_body<span class="main">[</span><span class="operator">OF</span> fac_body_strict<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> worker_wrapper_body<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> computation<span class="main"><span class="main">=</span></span><span class="quoted">fac</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> body<span class="main"><span class="main">=</span></span><span class="quoted">fac_body</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> wrap<span class="main"><span class="main">=</span></span><span class="quoted">wrapB</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> unwrap<span class="main"><span class="main">=</span></span><span class="quoted">unwrapB</span><span class="main">]</span>
    <span class="keyword1"><span class="command">unfolding</span></span> fac_work_def fac_wrap_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fac_fac_body_eq<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹This is not entirely faithful to the paper, as they don't
explicitly handle the lifting of the codomain.›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">fac_body'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>UNat <span class="main">→</span> UNat<span class="main"><span class="hidden">⇩</span><sub>⊥</sub></span><span class="main">)</span> <span class="main">→</span> UNat <span class="main">→</span> UNat<span class="main"><span class="hidden">⇩</span><sub>⊥</sub></span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fac_body'</span> <span class="main">≡</span> <span class="keyword1">Λ</span> r n<span class="main">.</span>
     unbox<span class="main">⋅</span><span class="main">(</span><span class="keyword1">If</span> box<span class="main">⋅</span><span class="bound">n</span> <span class="keyword1">=<span class="hidden">⇩</span><sub>B</sub></span> <span class="main">0</span>
              <span class="keyword1">then</span> <span class="main">1</span>
              <span class="keyword1">else</span> unbox<span class="main">⋅</span><span class="main">(</span>box<span class="main">⋅</span><span class="bound">n</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">&gt;&gt;=</span> <span class="bound">r</span> <span class="main">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1">Λ</span> b<span class="main">.</span> box<span class="main">⋅</span><span class="bound">n</span> <span class="main">*</span> box<span class="main">⋅</span><span class="bound">b</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> fac_body'_fac_body<span class="main">:</span> <span class="quoted"><span class="quoted">"fac_body' <span class="main">=</span> unwrapB <span class="keyword1">oo</span> fac_body <span class="keyword1">oo</span> wrapB"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">r</span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span><span class="main">⋅</span><span class="skolem">r</span><span class="main">⋅</span><span class="skolem">x</span> <span class="main">=</span> <span class="var">?rhs</span><span class="main">⋅</span><span class="skolem">r</span><span class="main">⋅</span><span class="skolem">x</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> bbind_case_distr_strict<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="keyword1">Λ</span> y<span class="main">.</span> box<span class="main">⋅</span><span class="skolem">x</span> <span class="main">*</span> <span class="bound">y</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> g<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"unbox<span class="main">⋅</span><span class="main">(</span>box<span class="main">⋅</span><span class="skolem">x</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span><span class="main">]</span>
          bbind_case_distr_strict<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="keyword1">Λ</span> y<span class="main">.</span> box<span class="main">⋅</span><span class="skolem">x</span> <span class="main">*</span> <span class="bound">y</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> h<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"box"</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">unfolding</span></span> fac_body'_def fac_body_def unwrapB_def wrapB_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"up"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> constructors here again mediate the
isomorphism, operationally doing nothing. Note the switch to the
machine-oriented \emph{if} construct: the test <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">n</span></span> <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">0</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> cannot
diverge.›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">fac_body_final</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>UNat <span class="main">→</span> UNat<span class="main"><span class="hidden">⇩</span><sub>⊥</sub></span><span class="main">)</span> <span class="main">→</span> UNat <span class="main">→</span> UNat<span class="main"><span class="hidden">⇩</span><sub>⊥</sub></span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fac_body_final</span> <span class="main">≡</span> <span class="keyword1">Λ</span> r n<span class="main">.</span>
     <span class="keyword1">if</span> <span class="bound">n</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> up<span class="main">⋅</span><span class="main">1</span> <span class="keyword1">else</span> <span class="bound">r</span><span class="main">⋅</span><span class="main">(</span><span class="bound">n</span> <span class="main">-<span class="hidden">⇩</span><sub>#</sub></span> <span class="main">1</span><span class="main">)</span> <span class="main">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1">Λ</span> b<span class="main">.</span> up<span class="main">⋅</span><span class="main">(</span><span class="bound">n</span> <span class="main">*<span class="hidden">⇩</span><sub>#</sub></span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> fac_body_final_fac_body'<span class="main">:</span> <span class="quoted"><span class="quoted">"fac_body_final <span class="main">=</span> fac_body'"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">r</span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span><span class="main">⋅</span><span class="skolem">r</span><span class="main">⋅</span><span class="skolem">x</span> <span class="main">=</span> <span class="var">?rhs</span><span class="main">⋅</span><span class="skolem">r</span><span class="main">⋅</span><span class="skolem">x</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> bbind_case_distr_strict<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"unbox"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> g<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="skolem">r</span><span class="main">⋅</span><span class="main">(</span><span class="skolem">x</span> <span class="main">-<span class="hidden">⇩</span><sub>#</sub></span> <span class="main">1</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> h<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">Λ</span> b<span class="main">.</span> box<span class="main">⋅</span><span class="main">(</span><span class="skolem">x</span> <span class="main">*<span class="hidden">⇩</span><sub>#</sub></span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">unfolding</span></span> fac_body_final_def fac_body'_def uMinus_def uMult_def zero_Nat_def one_Nat_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">fac_work_final</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"UNat <span class="main">→</span> UNat<span class="main"><span class="hidden">⇩</span><sub>⊥</sub></span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fac_work_final</span> <span class="main">≡</span> fix<span class="main">⋅</span>fac_body_final"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">fac_final</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Nat <span class="main">→</span> Nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fac_final</span> <span class="main">≡</span> <span class="keyword1">Λ</span> n<span class="main">.</span> unbox<span class="main">⋅</span><span class="bound">n</span> <span class="main">&gt;&gt;=</span> fac_work_final <span class="main">&gt;&gt;=</span> box"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> fac_fac_final<span class="main">:</span> <span class="quoted"><span class="quoted">"fac <span class="main">=</span> fac_final"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span><span class="main">=</span><span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> fac_wrap"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> fac_fac_ww_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> wrapB<span class="main">⋅</span>fac_work"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> fac_wrap_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> wrapB<span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="main">(</span>unwrapB <span class="keyword1">oo</span> fac_body <span class="keyword1">oo</span> wrapB<span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> fac_work_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> wrapB<span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span>fac_body'<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> fac_body'_fac_body<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> wrapB<span class="main">⋅</span>fac_work_final"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> fac_body_final_fac_body' fac_work_final_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> fac_final"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fac_final_def wrapB_def<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(* **************************************** *)</span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Introducing an accumulator.›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The final version of factorial uses unboxed naturals but is not
tail-recursive. We can apply worker/wrapper once more to introduce an
accumulator, similar to \S\ref{sec:accum}.

The monadic machinery complicates things slightly here. We use
\emph{Kleisli composition}, denoted <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(&gt;=&gt;)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, in the
homomorphism.

Firstly we introduce an ``accumulator'' monoid and show the
homomorphism.

›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> UNatAcc <span class="main">=</span> <span class="quoted"><span class="quoted">"UNat <span class="main">→</span> UNat<span class="main"><span class="hidden">⇩</span><sub>⊥</sub></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">n2a</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"UNat <span class="main">→</span> UNatAcc"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">n2a</span> <span class="main">≡</span> <span class="keyword1">Λ</span> m n<span class="main">.</span> up<span class="main">⋅</span><span class="main">(</span><span class="bound">m</span> <span class="main">*<span class="hidden">⇩</span><sub>#</sub></span> <span class="bound">n</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">a2n</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"UNatAcc <span class="main">→</span> UNat<span class="main"><span class="hidden">⇩</span><sub>⊥</sub></span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">a2n</span> <span class="main">≡</span> <span class="keyword1">Λ</span> a<span class="main">.</span> <span class="bound">a</span><span class="main">⋅</span><span class="main">1</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> a2n_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"a2n<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> a2n_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> a2n_n2a<span class="main">:</span> <span class="quoted"><span class="quoted">"a2n<span class="main">⋅</span><span class="main">(</span>n2a<span class="main">⋅</span><span class="free">u</span><span class="main">)</span> <span class="main">=</span> up<span class="main">⋅</span><span class="free">u</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> a2n_def n2a_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> uMult_arithmetic<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> A_hom_mult<span class="main">:</span> <span class="quoted"><span class="quoted">"n2a<span class="main">⋅</span><span class="main">(</span><span class="free">x</span> <span class="main">*<span class="hidden">⇩</span><sub>#</sub></span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>n2a<span class="main">⋅</span><span class="free">x</span> <span class="main">&gt;=&gt;</span> n2a<span class="main">⋅</span><span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> n2a_def bKleisli_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> uMult_arithmetic<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">unwrapA</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>UNat <span class="main">→</span> UNat<span class="main"><span class="hidden">⇩</span><sub>⊥</sub></span><span class="main">)</span> <span class="main">→</span> UNat <span class="main">→</span> UNatAcc"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">unwrapA</span> <span class="main">≡</span> <span class="keyword1">Λ</span> f n<span class="main">.</span> <span class="bound">f</span><span class="main">⋅</span><span class="bound">n</span> <span class="main">&gt;&gt;=</span> n2a"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> unwrapA_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"unwrapA<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> unwrapA_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">wrapA</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>UNat <span class="main">→</span> UNatAcc<span class="main">)</span> <span class="main">→</span> UNat <span class="main">→</span> UNat<span class="main"><span class="hidden">⇩</span><sub>⊥</sub></span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">wrapA</span> <span class="main">≡</span> <span class="keyword1">Λ</span> f<span class="main">.</span> a2n <span class="keyword1">oo</span> <span class="bound">f</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> wrapA_unwrapA_id<span class="main">:</span> <span class="quoted"><span class="quoted">"wrapA <span class="keyword1">oo</span> unwrapA <span class="main">=</span> ID"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> wrapA_def unwrapA_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="improper">x</span><span class="main">⋅</span><span class="improper">xa</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> a2n_n2a<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Some steps along the way.›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">fac_acc_body1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>UNat <span class="main">→</span> UNatAcc<span class="main">)</span> <span class="main">→</span> UNat <span class="main">→</span> UNatAcc"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fac_acc_body1</span> <span class="main">≡</span> <span class="keyword1">Λ</span> r n<span class="main">.</span>
     <span class="keyword1">if</span> <span class="bound">n</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> n2a<span class="main">⋅</span><span class="main">1</span> <span class="keyword1">else</span> wrapA<span class="main">⋅</span><span class="bound">r</span><span class="main">⋅</span><span class="main">(</span><span class="bound">n</span> <span class="main">-<span class="hidden">⇩</span><sub>#</sub></span> <span class="main">1</span><span class="main">)</span> <span class="main">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1">Λ</span> res<span class="main">.</span> n2a<span class="main">⋅</span><span class="main">(</span><span class="bound">n</span> <span class="main">*<span class="hidden">⇩</span><sub>#</sub></span> <span class="bound">res</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> fac_acc_body1_fac_body_final_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"fac_acc_body1 <span class="main">=</span> unwrapA <span class="keyword1">oo</span> fac_body_final <span class="keyword1">oo</span> wrapA"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fac_acc_body1_def fac_body_final_def wrapA_def unwrapA_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Use the homomorphism.›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">fac_acc_body2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>UNat <span class="main">→</span> UNatAcc<span class="main">)</span> <span class="main">→</span> UNat <span class="main">→</span> UNatAcc"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fac_acc_body2</span> <span class="main">≡</span> <span class="keyword1">Λ</span> r n<span class="main">.</span>
     <span class="keyword1">if</span> <span class="bound">n</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> n2a<span class="main">⋅</span><span class="main">1</span> <span class="keyword1">else</span> wrapA<span class="main">⋅</span><span class="bound">r</span><span class="main">⋅</span><span class="main">(</span><span class="bound">n</span> <span class="main">-<span class="hidden">⇩</span><sub>#</sub></span> <span class="main">1</span><span class="main">)</span> <span class="main">&gt;&gt;=</span> <span class="main">(</span><span class="keyword1">Λ</span> res<span class="main">.</span> n2a<span class="main">⋅</span><span class="bound">n</span> <span class="main">&gt;=&gt;</span> n2a<span class="main">⋅</span><span class="bound">res</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> fac_acc_body2_body1_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"fac_acc_body2 <span class="main">=</span> fac_acc_body1"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fac_acc_body1_def fac_acc_body2_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> A_hom_mult<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Apply worker/wrapper.›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">fac_acc_body3</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>UNat <span class="main">→</span> UNatAcc<span class="main">)</span> <span class="main">→</span> UNat <span class="main">→</span> UNatAcc"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fac_acc_body3</span> <span class="main">≡</span> <span class="keyword1">Λ</span> r n<span class="main">.</span>
     <span class="keyword1">if</span> <span class="bound">n</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> n2a<span class="main">⋅</span><span class="main">1</span> <span class="keyword1">else</span> n2a<span class="main">⋅</span><span class="bound">n</span> <span class="main">&gt;=&gt;</span> <span class="bound">r</span><span class="main">⋅</span><span class="main">(</span><span class="bound">n</span> <span class="main">-<span class="hidden">⇩</span><sub>#</sub></span> <span class="main">1</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> fac_acc_body3_body2<span class="main">:</span> <span class="quoted"><span class="quoted">"fac_acc_body3 <span class="keyword1">oo</span> <span class="main">(</span>unwrapA <span class="keyword1">oo</span> wrapA<span class="main">)</span> <span class="main">=</span> fac_acc_body2"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span><span class="main">=</span><span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">r</span> <span class="skolem">n</span> <span class="skolem">acc</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>fac_acc_body3 <span class="keyword1">oo</span> <span class="main">(</span>unwrapA <span class="keyword1">oo</span> wrapA<span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">r</span><span class="main">⋅</span><span class="skolem">n</span><span class="main">⋅</span><span class="skolem">acc</span><span class="main">)</span> <span class="main">=</span> fac_acc_body2<span class="main">⋅</span><span class="skolem">r</span><span class="main">⋅</span><span class="skolem">n</span><span class="main">⋅</span><span class="skolem">acc</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> fac_acc_body2_def fac_acc_body3_def unwrapA_def
    <span class="keyword1"><span class="command">using</span></span> bbind_case_distr_strict<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="keyword1">Λ</span> y<span class="main">.</span> n2a<span class="main">⋅</span><span class="skolem">n</span> <span class="main">&gt;=&gt;</span> <span class="bound">y</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> h<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"n2a"</span></span><span class="main">,</span> <span class="operator">symmetric</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> fac_work_final_body3_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"fac_work_final <span class="main">=</span> wrapA<span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span>fac_acc_body3<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fac_work_final_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> worker_wrapper_fusion_new<span class="main"><span class="main">[</span></span><span class="operator">OF</span> wrapA_unwrapA_id unwrapA_strict<span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fac_acc_body3_body2 fac_acc_body2_body1_eq fac_acc_body1_fac_body_final_eq<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">fac_acc_body_final</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>UNat <span class="main">→</span> UNatAcc<span class="main">)</span> <span class="main">→</span> UNat <span class="main">→</span> UNatAcc"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fac_acc_body_final</span> <span class="main">≡</span> <span class="keyword1">Λ</span> r n acc<span class="main">.</span>
     <span class="keyword1">if</span> <span class="bound">n</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> up<span class="main">⋅</span><span class="bound">acc</span> <span class="keyword1">else</span> <span class="bound">r</span><span class="main">⋅</span><span class="main">(</span><span class="bound">n</span> <span class="main">-<span class="hidden">⇩</span><sub>#</sub></span> <span class="main">1</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="bound">n</span> <span class="main">*<span class="hidden">⇩</span><sub>#</sub></span> <span class="bound">acc</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">fac_acc_work_final</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"UNat <span class="main">→</span> UNat<span class="main"><span class="hidden">⇩</span><sub>⊥</sub></span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fac_acc_work_final</span> <span class="main">≡</span> <span class="keyword1">Λ</span> x<span class="main">.</span> fix<span class="main">⋅</span>fac_acc_body_final<span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="main">1</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> fac_acc_work_final_fac_acc_work3_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"fac_acc_body_final <span class="main">=</span> fac_acc_body3"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span><span class="main">=</span><span class="var">?rhs</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> fac_acc_body3_def fac_acc_body_final_def n2a_def bKleisli_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
     <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> uMult_arithmetic<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> fac_acc_work_final_fac_work<span class="main">:</span> <span class="quoted"><span class="quoted">"fac_acc_work_final <span class="main">=</span> fac_work_final"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span><span class="main">=</span><span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span> <span class="main">=</span> wrapA<span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span>fac_acc_body3<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> fac_work_final_body3_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> wrapA<span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span>fac_acc_body_final<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> fac_acc_work_final_fac_acc_work3_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="var">?lhs</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> fac_acc_work_final_def wrapA_def a2n_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfcomp1<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="Streams">
<div class="head">
<h1>Theory Streams</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="comment1">(*
 * The worker/wrapper transformation, following Gill and Hutton.
 * (C)opyright 2009-2011, Peter Gammie, peteg42 at gmail.com.
 * License: BSD
 *)</span>

<span class="keyword1"><span class="command">theory</span></span> Streams
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../../HOL/HOLCF/HOLCF.html">HOLCF</a>
  <a href="Nats.html">Nats</a>
  <a href="WorkerWrapper.html">WorkerWrapper</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Memoisation using streams.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
\label{sec:memoisation-example}›</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Streams.›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The type of infinite streams.›</span></span>

<span class="keyword1"><span class="command">domain</span></span> <span class="tfree">'a</span> Stream <span class="main">=</span> stcons <span class="main">(</span><span class="keyword2"><span class="keyword">lazy</span></span> sthead <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="keyword2"><span class="keyword">lazy</span></span> sttail <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> Stream"</span></span><span class="main">)</span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixr</span></span> <span class="quoted">"<span class="keyword1">&amp;&amp;</span>"</span> 65<span class="main">)</span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">lemma</span></span> Stream_bisimI<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">xs</span> <span class="bound">ys</span><span class="main">.</span> <span class="free">R</span> <span class="bound">xs</span> <span class="bound">ys</span>
     <span class="main">⟹</span> <span class="main">(</span><span class="bound">xs</span> <span class="main">=</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="bound">ys</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span>
       <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">h</span> <span class="bound">t</span> <span class="bound">t'</span><span class="main">.</span> <span class="free">R</span> <span class="bound">t</span> <span class="bound">t'</span> <span class="main">∧</span> <span class="bound">xs</span> <span class="main">=</span> <span class="bound">h</span> <span class="main">&amp;&amp;</span> <span class="bound">t</span> <span class="main">∧</span> <span class="bound">ys</span> <span class="main">=</span> <span class="bound">h</span> <span class="main">&amp;&amp;</span> <span class="bound">t'</span><span class="main">)</span><span class="main">)</span>
  <span class="main">⟹</span> Stream_bisim <span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Stream.bisim_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">smap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">→</span> <span class="tfree">'a</span> Stream <span class="main">→</span> <span class="tfree">'b</span> Stream"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">smap</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">&amp;&amp;</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">&amp;&amp;</span> <span class="free">smap</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">lemma</span></span> smap_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"smap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> smap_smap<span class="main">:</span> <span class="quoted"><span class="quoted">"smap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>smap<span class="main">⋅</span><span class="free">g</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> smap<span class="main">⋅</span><span class="main">(</span><span class="free">f</span> <span class="keyword1">oo</span> <span class="free">g</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span>"</span></span>
<span class="comment1">(*&lt;*)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span> <span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">i_th</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> Stream <span class="main">→</span> Nat <span class="main">→</span> <span class="tfree">'a</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">i_th</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">&amp;&amp;</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> Nat_case<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free">i_th</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">i_th_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> Stream <span class="main">⇒</span> Nat <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">!!</span>"</span> 100<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main"><span class="free">!!</span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">≡</span> i_th<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">i</span></span></span>"</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">lemma</span></span> i_th_strict1<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⊥</span> <span class="main">!!</span> <span class="free">i</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1"><span class="command">lemma</span></span> i_th_strict2<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">!!</span> <span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> i_th.unfold<span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> i_th_0<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s</span> <span class="main">!!</span> <span class="main">0</span><span class="main">)</span> <span class="main">=</span> sthead<span class="main">⋅</span><span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> i_th.unfold<span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> i_th_suc<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span> <span class="main">&amp;&amp;</span> <span class="free">xs</span><span class="main">)</span> <span class="main">!!</span> <span class="main">(</span><span class="free">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">=</span> <span class="free">xs</span> <span class="main">!!</span> <span class="free">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> i_th.unfold<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The infinite stream of natural numbers.›</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">nats</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Nat Stream"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">nats</span> <span class="main">=</span> <span class="main">0</span> <span class="main">&amp;&amp;</span> smap<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="main">1</span> <span class="main">+</span> <span class="bound">x</span><span class="main">)</span><span class="main">⋅</span><span class="free">nats</span>"</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">declare</span></span> nats.simps<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹The wrapper/unwrapper functions.›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">unwrapS'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Nat <span class="main">→</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">→</span> <span class="tfree">'a</span> Stream"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">unwrapS'</span> <span class="main">≡</span> <span class="keyword1">Λ</span> f <span class="main">.</span> smap<span class="main">⋅</span><span class="bound">f</span><span class="main">⋅</span>nats"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> unwrapS'_unfold<span class="main">:</span> <span class="quoted"><span class="quoted">"unwrapS'<span class="main">⋅</span><span class="free">f</span> <span class="main">=</span> <span class="free">f</span><span class="main">⋅</span><span class="main">0</span> <span class="main">&amp;&amp;</span> smap<span class="main">⋅</span><span class="main">(</span><span class="free">f</span> <span class="keyword1">oo</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="main">1</span> <span class="main">+</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span>nats"</span></span>
<span class="comment1">(*&lt;*)</span><span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> unwrapS'_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> nats.unfold<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> smap_smap<span class="main">)</span><span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">unwrapS</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Nat <span class="main">→</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">→</span> <span class="tfree">'a</span> Stream"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">unwrapS</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="main">0</span> <span class="main">&amp;&amp;</span> <span class="free">unwrapS</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="keyword1">oo</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="main">1</span> <span class="main">+</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">declare</span></span> unwrapS.simps<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The two versions of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"unwrapS"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> are equivalent. We could
try to fold some definitions here but it's easier if the stream
constructor is manifest.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> unwrapS_unwrapS'_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"unwrapS <span class="main">=</span> unwrapS'"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span><span class="main">⋅</span><span class="skolem">f</span> <span class="main">=</span> <span class="var">?rhs</span><span class="main">⋅</span><span class="skolem">f</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> Stream.coinduct<span class="main">)</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?R</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">s</span> <span class="bound">s'</span><span class="main">.</span> <span class="main">(</span><span class="main">∃</span><span class="bound">f</span><span class="main">.</span> <span class="bound">s</span> <span class="main">=</span> <span class="bound">f</span><span class="main">⋅</span><span class="main">0</span> <span class="main">&amp;&amp;</span> unwrapS<span class="main">⋅</span><span class="main">(</span><span class="bound">f</span> <span class="keyword1">oo</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="main">1</span> <span class="main">+</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>
                        <span class="main">∧</span> <span class="bound">s'</span> <span class="main">=</span> <span class="bound">f</span><span class="main">⋅</span><span class="main">0</span> <span class="main">&amp;&amp;</span> smap<span class="main">⋅</span><span class="main">(</span><span class="bound">f</span> <span class="keyword1">oo</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="main">1</span> <span class="main">+</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span>nats<span class="main">)</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Stream_bisim <span class="var">?R</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">s</span> <span class="skolem">s'</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="var">?R</span> <span class="skolem">s</span> <span class="skolem">s'</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">f</span></span> <span class="keyword2"><span class="keyword">where</span></span> fs<span class="main">:</span>  <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">=</span> <span class="skolem">f</span><span class="main">⋅</span><span class="main">0</span> <span class="main">&amp;&amp;</span> unwrapS<span class="main">⋅</span><span class="main">(</span><span class="skolem">f</span> <span class="keyword1">oo</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="main">1</span> <span class="main">+</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
                      <span class="keyword2"><span class="keyword">and</span></span> fs'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">s'</span> <span class="main">=</span> <span class="skolem">f</span><span class="main">⋅</span><span class="main">0</span> <span class="main">&amp;&amp;</span> smap<span class="main">⋅</span><span class="main">(</span><span class="skolem">f</span> <span class="keyword1">oo</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="main">1</span> <span class="main">+</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span>nats"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?R</span> <span class="main">(</span>unwrapS<span class="main">⋅</span><span class="main">(</span><span class="skolem">f</span> <span class="keyword1">oo</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="main">1</span> <span class="main">+</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>smap<span class="main">⋅</span><span class="main">(</span><span class="skolem">f</span> <span class="keyword1">oo</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="main">1</span> <span class="main">+</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span>nats<span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span> <span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="skolem"><span class="skolem"><span class="skolem">f</span></span></span> <span class="keyword1"><span class="keyword1"><span class="keyword1">oo</span></span></span> <span class="main"><span class="main"><span class="main">(</span></span></span><span class="keyword1"><span class="keyword1"><span class="keyword1">Λ</span></span></span> x<span class="main"><span class="main"><span class="main">.</span></span></span> <span class="main"><span class="main"><span class="main">1</span></span></span> <span class="main"><span class="main"><span class="main">+</span></span></span> <span class="bound"><span class="bound"><span class="bound">x</span></span></span><span class="main"><span class="main"><span class="main">)</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span>
           <span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> unwrapS.unfold<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> nats.unfold<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> smap_smap<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> fs fs'
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">s</span> <span class="main">=</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="skolem">s'</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span>
          <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">h</span> <span class="bound">t</span> <span class="bound">t'</span><span class="main">.</span>
              <span class="main">(</span><span class="main">∃</span><span class="bound">f</span><span class="main">.</span> <span class="bound">t</span> <span class="main">=</span> <span class="bound">f</span><span class="main">⋅</span><span class="main">0</span> <span class="main">&amp;&amp;</span> unwrapS<span class="main">⋅</span><span class="main">(</span><span class="bound">f</span> <span class="keyword1">oo</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="main">1</span> <span class="main">+</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>
                 <span class="main">∧</span> <span class="bound">t'</span> <span class="main">=</span> <span class="bound">f</span><span class="main">⋅</span><span class="main">0</span> <span class="main">&amp;&amp;</span> smap<span class="main">⋅</span><span class="main">(</span><span class="bound">f</span> <span class="keyword1">oo</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="main">1</span> <span class="main">+</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span>nats<span class="main">)</span>
                 <span class="main">∧</span> <span class="skolem">s</span> <span class="main">=</span> <span class="bound">h</span> <span class="main">&amp;&amp;</span> <span class="bound">t</span> <span class="main">∧</span> <span class="skolem">s'</span> <span class="main">=</span> <span class="bound">h</span> <span class="main">&amp;&amp;</span> <span class="bound">t'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">best</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?R</span> <span class="main">(</span><span class="var">?lhs</span><span class="main">⋅</span><span class="skolem">f</span><span class="main">)</span> <span class="main">(</span><span class="var">?rhs</span><span class="main">⋅</span><span class="skolem">f</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">have</span></span> lhs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span><span class="main">⋅</span><span class="skolem">f</span> <span class="main">=</span> <span class="skolem">f</span><span class="main">⋅</span><span class="main">0</span> <span class="main">&amp;&amp;</span> unwrapS<span class="main">⋅</span><span class="main">(</span><span class="skolem">f</span> <span class="keyword1">oo</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="main">1</span> <span class="main">+</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> unwrapS.unfold<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> rhs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span><span class="main">⋅</span><span class="skolem">f</span> <span class="main">=</span> <span class="skolem">f</span><span class="main">⋅</span><span class="main">0</span> <span class="main">&amp;&amp;</span> smap<span class="main">⋅</span><span class="main">(</span><span class="skolem">f</span> <span class="keyword1">oo</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="main">1</span> <span class="main">+</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span>nats"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> unwrapS'_unfold<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> lhs rhs <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">best</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">wrapS</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> Stream <span class="main">→</span> Nat <span class="main">→</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">wrapS</span> <span class="main">≡</span> <span class="keyword1">Λ</span> s i <span class="main">.</span> <span class="bound">s</span> <span class="main">!!</span> <span class="bound">i</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Note the identity requires that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">f</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> be
strict. \citet[\S6.1]{GillHutton:2009} do not make this requirement,
an oversight on their part.

In practice all functions worth memoising are strict in the memoised
argument.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> wrapS_unwrapS_id'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> strictF<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span><span class="main">::</span>Nat <span class="main">→</span> <span class="tfree">'a</span><span class="main">)</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"unwrapS<span class="main">⋅</span><span class="free">f</span> <span class="main">!!</span> <span class="free">n</span> <span class="main">=</span> <span class="free">f</span><span class="main">⋅</span><span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> strictF
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> Nat_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> bottom <span class="keyword1"><span class="command">with</span></span> strictF <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> zero <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> unwrapS.unfold<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">i</span> <span class="skolem">f</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"unwrapS<span class="main">⋅</span><span class="skolem">f</span> <span class="main">!!</span> <span class="main">(</span><span class="skolem">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">f</span><span class="main">⋅</span><span class="main">0</span> <span class="main">&amp;&amp;</span> unwrapS<span class="main">⋅</span><span class="main">(</span><span class="skolem">f</span> <span class="keyword1">oo</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="main">1</span> <span class="main">+</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">!!</span> <span class="main">(</span><span class="skolem">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> unwrapS.unfold<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> Suc <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> unwrapS<span class="main">⋅</span><span class="main">(</span><span class="skolem">f</span> <span class="keyword1">oo</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="main">1</span> <span class="main">+</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">!!</span> <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> Suc <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">f</span> <span class="keyword1">oo</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="main">1</span> <span class="main">+</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="skolem">f</span><span class="main">⋅</span><span class="main">(</span><span class="skolem">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> plus_commute<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> wrapS_unwrapS_id<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span> <span class="main">⟹</span> <span class="main">(</span>wrapS <span class="keyword1">oo</span> unwrapS<span class="main">)</span><span class="main">⋅</span><span class="free">f</span> <span class="main">=</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> wrapS_unwrapS_id' wrapS_def<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Fibonacci example.›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">fib_body</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Nat <span class="main">→</span> Nat<span class="main">)</span> <span class="main">→</span> Nat <span class="main">→</span> Nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fib_body</span> <span class="main">≡</span> <span class="keyword1">Λ</span> r<span class="main">.</span> Nat_case<span class="main">⋅</span><span class="main">1</span><span class="main">⋅</span><span class="main">(</span>Nat_case<span class="main">⋅</span><span class="main">1</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> n<span class="main">.</span> <span class="bound">r</span><span class="main">⋅</span><span class="bound">n</span> <span class="main">+</span> <span class="bound">r</span><span class="main">⋅</span><span class="main">(</span><span class="bound">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">lemma</span></span> fib_body_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"fib_body<span class="main">⋅</span><span class="free">r</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fib_body_def<span class="main">)</span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">fib</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Nat <span class="main">→</span> Nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fib</span> <span class="main">≡</span> fix<span class="main">⋅</span>fib_body"</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">lemma</span></span> fib_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"fib<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> fib_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> fix_eq<span class="main"><span class="keyword3">,</span></span> <span class="operator">fold</span> fib_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fib_body_def<span class="main">)</span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Apply worker/wrapper.›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">fib_work</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Nat Stream"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fib_work</span> <span class="main">≡</span> fix<span class="main">⋅</span><span class="main">(</span>unwrapS <span class="keyword1">oo</span> fib_body <span class="keyword1">oo</span> wrapS<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">fib_wrap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Nat <span class="main">→</span> Nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fib_wrap</span> <span class="main">≡</span> wrapS<span class="main">⋅</span>fib_work"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> wrapS_unwrapS_fib_body<span class="main">:</span> <span class="quoted"><span class="quoted">"wrapS <span class="keyword1">oo</span> unwrapS <span class="keyword1">oo</span> fib_body <span class="main">=</span> fib_body"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">r</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>wrapS <span class="keyword1">oo</span> unwrapS <span class="keyword1">oo</span> fib_body<span class="main">)</span><span class="main">⋅</span><span class="skolem">r</span> <span class="main">=</span> fib_body<span class="main">⋅</span><span class="skolem">r</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> wrapS_unwrapS_id<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"fib_body<span class="main">⋅</span><span class="skolem">r</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> fib_ww_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"fib <span class="main">=</span> fib_wrap"</span></span>
  <span class="keyword1"><span class="command">using</span></span> worker_wrapper_body<span class="main">[</span><span class="operator">OF</span> wrapS_unwrapS_fib_body<span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fib_def fib_wrap_def fib_work_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Optimise.›</span></span>

<span class="keyword1"><span class="command">fixrec</span></span>
  <span class="entity">fib_work_final</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Nat Stream"</span></span>
<span class="keyword2"><span class="keyword">and</span></span>
  <span class="entity">fib_f_final</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Nat <span class="main">→</span> Nat"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fib_work_final</span> <span class="main">=</span> smap<span class="main">⋅</span><span class="free">fib_f_final</span><span class="main">⋅</span>nats"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">fib_f_final</span> <span class="main">=</span> Nat_case<span class="main">⋅</span><span class="main">1</span><span class="main">⋅</span><span class="main">(</span>Nat_case<span class="main">⋅</span><span class="main">1</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> n'<span class="main">.</span> <span class="free">fib_work_final</span> <span class="main">!!</span> <span class="bound">n'</span> <span class="main">+</span> <span class="free">fib_work_final</span> <span class="main">!!</span> <span class="main">(</span><span class="bound">n'</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">declare</span></span> fib_f_final.simps<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span> fib_work_final.simps<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">fib_final</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Nat <span class="main">→</span> Nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">fib_final</span> <span class="main">≡</span> <span class="keyword1">Λ</span> n<span class="main">.</span> fib_work_final <span class="main">!!</span> <span class="bound">n</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

This proof is only fiddly due to the way mutual recursion is encoded:
we need to use Beki\'{c}'s Theorem \citep{Bekic:1969}\footnote{The
interested reader can find some historical commentary in
\citet{Harel:1980, DBLP:journals/toplas/Sangiorgi09}.} to massage the
definitions into their final form.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> fib_work_final_fib_work_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"fib_work_final <span class="main">=</span> fib_work"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?wb</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="keyword1">Λ</span> r<span class="main">.</span> Nat_case<span class="main">⋅</span><span class="main">1</span><span class="main">⋅</span><span class="main">(</span>Nat_case<span class="main">⋅</span><span class="main">1</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> n'<span class="main">.</span> <span class="bound">r</span> <span class="main">!!</span> <span class="bound">n'</span> <span class="main">+</span> <span class="bound">r</span> <span class="main">!!</span> <span class="main">(</span><span class="bound">n'</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?mr</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="keyword1">Λ</span> <span class="main">(</span>fwf <span class="main">::</span> Nat Stream<span class="main">,</span> fff<span class="main">)</span><span class="main">.</span> <span class="main">(</span>smap<span class="main">⋅</span><span class="bound">fff</span><span class="main">⋅</span>nats<span class="main">,</span> <span class="var">?wb</span><span class="main">⋅</span><span class="bound">fwf</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> fst <span class="main">(</span>fix<span class="main">⋅</span><span class="var">?mr</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fib_work_final_def split_def csplit_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">μ</span> <span class="bound">fwf</span><span class="main">.</span> fst <span class="main">(</span><span class="var">?mr</span><span class="main">⋅</span><span class="main">(</span><span class="bound">fwf</span><span class="main">,</span> <span class="keyword1">μ</span> <span class="bound">fff</span><span class="main">.</span> snd <span class="main">(</span><span class="var">?mr</span><span class="main">⋅</span><span class="main">(</span><span class="bound">fwf</span><span class="main">,</span> <span class="bound">fff</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> fix_cprod<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> F<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="var">?mr</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">μ</span> <span class="bound">fwf</span><span class="main">.</span> smap<span class="main">⋅</span><span class="main">(</span><span class="keyword1">μ</span> <span class="bound">fff</span><span class="main">.</span> <span class="var">?wb</span><span class="main">⋅</span><span class="bound">fwf</span><span class="main">)</span><span class="main">⋅</span>nats<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">μ</span> <span class="bound">fwf</span><span class="main">.</span> smap<span class="main">⋅</span><span class="main">(</span><span class="var">?wb</span><span class="main">⋅</span><span class="bound">fwf</span><span class="main">)</span><span class="main">⋅</span>nats<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fix_const<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> fib_body_def fib_work_def unwrapS_unwrapS'_eq unwrapS'_def wrapS_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfcomp1<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> fib_final_fib_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"fib_final <span class="main">=</span> fib"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> n<span class="main">.</span> fib_work_final <span class="main">!!</span> <span class="bound">n</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fib_final_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> n<span class="main">.</span> fib_work <span class="main">!!</span> <span class="bound">n</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> fib_work_final_fib_work_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> fib_wrap"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fib_wrap_def wrapS_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> fib_ww_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="Continuations">
<div class="head">
<h1>Theory Continuations</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="comment1">(*
 * The worker/wrapper transformation, following Gill and Hutton.
 * (C)opyright 2009-2011, Peter Gammie, peteg42 at gmail.com.
 * License: BSD
 *)</span>

<span class="keyword1"><span class="command">theory</span></span> Continuations
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../../HOL/HOLCF/HOLCF.html">HOLCF</a>
  <a href="Maybe.html">Maybe</a>
  <a href="Nats.html">Nats</a>
  <a href="WorkerWrapperNew.html">WorkerWrapperNew</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Tagless interpreter via double-barreled continuations›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹\label{sec:continuations}›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'a</span> Cont <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">→</span> <span class="tfree">'a</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">val2cont</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'a</span> Cont"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">val2cont</span> <span class="main">≡</span> <span class="main">(</span><span class="keyword1">Λ</span> a c<span class="main">.</span> <span class="bound">c</span><span class="main">⋅</span><span class="bound">a</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">cont2val</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> Cont <span class="main">→</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">cont2val</span> <span class="main">≡</span> <span class="main">(</span><span class="keyword1">Λ</span> f<span class="main">.</span> <span class="bound">f</span><span class="main">⋅</span>ID<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cont2val_val2cont_id<span class="main">:</span> <span class="quoted"><span class="quoted">"cont2val <span class="keyword1">oo</span> val2cont <span class="main">=</span> ID"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> val2cont_def cont2val_def<span class="main">)</span>

<span class="keyword1"><span class="command">domain</span></span> Expr <span class="main">=</span>
    Val <span class="main">(</span><span class="keyword2"><span class="keyword">lazy</span></span> val<span class="main">::</span><span class="quoted"><span class="quoted">"Nat"</span></span><span class="main">)</span>
  <span class="main">|</span> Add <span class="main">(</span><span class="keyword2"><span class="keyword">lazy</span></span> addl<span class="main">::</span><span class="quoted"><span class="quoted">"Expr"</span></span><span class="main">)</span> <span class="main">(</span><span class="keyword2"><span class="keyword">lazy</span></span> addr<span class="main">::</span><span class="quoted"><span class="quoted">"Expr"</span></span><span class="main">)</span>
  <span class="main">|</span> Throw
  <span class="main">|</span> Catch <span class="main">(</span><span class="keyword2"><span class="keyword">lazy</span></span> cbody<span class="main">::</span><span class="quoted"><span class="quoted">"Expr"</span></span><span class="main">)</span> <span class="main">(</span><span class="keyword2"><span class="keyword">lazy</span></span> chandler<span class="main">::</span><span class="quoted"><span class="quoted">"Expr"</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">eval</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Expr <span class="main">→</span> Nat Maybe"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">eval</span><span class="main">⋅</span><span class="main">(</span>Val<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> Just<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">n</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">eval</span><span class="main">⋅</span><span class="main">(</span>Add<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">=</span> mliftM2 <span class="main">(</span><span class="keyword1">Λ</span> a b<span class="main">.</span> <span class="bound">a</span> <span class="main">+</span> <span class="bound">b</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">eval</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">eval</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">eval</span><span class="main">⋅</span>Throw <span class="main">=</span> mfail"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">eval</span><span class="main">⋅</span><span class="main">(</span>Catch<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">=</span> mcatch<span class="main">⋅</span><span class="main">(</span><span class="free">eval</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">eval</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">eval_body</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Expr <span class="main">→</span> Nat Maybe<span class="main">)</span> <span class="main">→</span> Expr <span class="main">→</span> Nat Maybe"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">eval_body</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="main">(</span>Val<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> Just<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">n</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">eval_body</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="main">(</span>Add<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">=</span> mliftM2 <span class="main">(</span><span class="keyword1">Λ</span> a b<span class="main">.</span> <span class="bound">a</span> <span class="main">+</span> <span class="bound">b</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">eval_body</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span>Throw <span class="main">=</span> mfail"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">eval_body</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="main">(</span>Catch<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">=</span> mcatch<span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> eval_body_strictExpr<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"eval_body<span class="main">⋅</span><span class="free">r</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> eval_body.unfold<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> eval_eval_body_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"eval <span class="main">=</span> fix<span class="main">⋅</span>eval_body"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> eval_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> eval_body.unfold<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Worker/wrapper›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">unwrapC</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Expr <span class="main">→</span> Nat Maybe<span class="main">)</span> <span class="main">→</span> <span class="main">(</span>Expr <span class="main">→</span> <span class="main">(</span>Nat <span class="main">→</span> Nat Maybe<span class="main">)</span> <span class="main">→</span> Nat Maybe <span class="main">→</span> Nat Maybe<span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">unwrapC</span> <span class="main">≡</span> <span class="keyword1">Λ</span> g e s f<span class="main">.</span> <span class="keyword1">case</span> <span class="bound">g</span><span class="main">⋅</span><span class="bound">e</span> <span class="keyword1">of</span> Nothing <span class="main">⇒</span> <span class="bound">f</span> <span class="main">|</span> Just<span class="main">⋅</span><span class="bound">n</span> <span class="main">⇒</span> <span class="bound">s</span><span class="main">⋅</span><span class="bound">n</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> unwrapC_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"unwrapC<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> unwrapC_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">wrapC</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Expr <span class="main">→</span> <span class="main">(</span>Nat <span class="main">→</span> Nat Maybe<span class="main">)</span> <span class="main">→</span> Nat Maybe <span class="main">→</span> Nat Maybe<span class="main">)</span> <span class="main">→</span> <span class="main">(</span>Expr <span class="main">→</span> Nat Maybe<span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">wrapC</span> <span class="main">≡</span> <span class="keyword1">Λ</span> g e<span class="main">.</span> <span class="bound">g</span><span class="main">⋅</span><span class="bound">e</span><span class="main">⋅</span>Just<span class="main">⋅</span>Nothing"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> wrapC_unwrapC_id<span class="main">:</span> <span class="quoted"><span class="quoted">"wrapC <span class="keyword1">oo</span> unwrapC <span class="main">=</span> ID"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> cfun_eqI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">g</span> <span class="skolem">e</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>wrapC <span class="keyword1">oo</span> unwrapC<span class="main">)</span><span class="main">⋅</span><span class="skolem">g</span><span class="main">⋅</span><span class="skolem">e</span> <span class="main">=</span> ID<span class="main">⋅</span><span class="skolem">g</span><span class="main">⋅</span><span class="skolem">e</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">g</span><span class="main">⋅</span><span class="skolem">e</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> wrapC_def unwrapC_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">eval_work</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Expr <span class="main">→</span> <span class="main">(</span>Nat <span class="main">→</span> Nat Maybe<span class="main">)</span> <span class="main">→</span> Nat Maybe <span class="main">→</span> Nat Maybe"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">eval_work</span> <span class="main">≡</span> fix<span class="main">⋅</span><span class="main">(</span>unwrapC <span class="keyword1">oo</span> eval_body <span class="keyword1">oo</span> wrapC<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">eval_wrap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Expr <span class="main">→</span> Nat Maybe"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">eval_wrap</span> <span class="main">≡</span> wrapC<span class="main">⋅</span>eval_work"</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">eval_body'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Expr <span class="main">→</span> <span class="main">(</span>Nat <span class="main">→</span> Nat Maybe<span class="main">)</span> <span class="main">→</span> Nat Maybe <span class="main">→</span> Nat Maybe<span class="main">)</span>
                    <span class="main">→</span> Expr <span class="main">→</span> <span class="main">(</span>Nat <span class="main">→</span> Nat Maybe<span class="main">)</span> <span class="main">→</span> Nat Maybe <span class="main">→</span> Nat Maybe"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">eval_body'</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="main">(</span>Val<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">n</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">eval_body'</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="main">(</span>Add<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> wrapC<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">of</span>
                                     Nothing <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span>
                                   <span class="main">|</span> Just<span class="main">⋅</span><span class="bound">n</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> wrapC<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">of</span>
                                                    Nothing <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span>
                                                  <span class="main">|</span> Just<span class="main">⋅</span><span class="bound">m</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="bound">n</span> <span class="main">+</span> <span class="bound">m</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">eval_body'</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span>Throw<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">eval_body'</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="main">(</span>Catch<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> wrapC<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">of</span>
                                       Nothing <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> wrapC<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">of</span>
                                                      Nothing <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span>
                                                    <span class="main">|</span> Just<span class="main">⋅</span><span class="bound">n</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⋅</span><span class="bound">n</span><span class="main">)</span>
                                     <span class="main">|</span> Just<span class="main">⋅</span><span class="bound">n</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⋅</span><span class="bound">n</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> eval_body'_strictExpr<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"eval_body'<span class="main">⋅</span><span class="free">r</span><span class="main">⋅</span><span class="main">⊥</span><span class="main">⋅</span><span class="free">s</span><span class="main">⋅</span><span class="free">f</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> eval_body'.unfold<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">eval_work'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Expr <span class="main">→</span> <span class="main">(</span>Nat <span class="main">→</span> Nat Maybe<span class="main">)</span> <span class="main">→</span> Nat Maybe <span class="main">→</span> Nat Maybe"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">eval_work'</span> <span class="main">≡</span> fix<span class="main">⋅</span>eval_body'"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹This proof is unfortunately quite messy, due to the
simplifier's inability to cope with HOLCF's case distinctions.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> eval_body'_eval_body_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"eval_body' <span class="main">=</span> unwrapC <span class="keyword1">oo</span> eval_body <span class="keyword1">oo</span> wrapC"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> cfun_eqI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> unwrapC_def wrapC_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">xa</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> wrapC_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="improper">x</span><span class="main">⋅</span><span class="improper">Expr1</span><span class="main">⋅</span>Just<span class="main">⋅</span>Nothing"</span></span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="improper">x</span><span class="main">⋅</span><span class="improper">Expr2</span><span class="main">⋅</span>Just<span class="main">⋅</span>Nothing"</span></span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mfail_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mcatch_def wrapC_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="improper">x</span><span class="main">⋅</span><span class="improper">Expr1</span><span class="main">⋅</span>Just<span class="main">⋅</span>Nothing"</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">eval_body_final</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Expr <span class="main">→</span> <span class="main">(</span>Nat <span class="main">→</span> Nat Maybe<span class="main">)</span> <span class="main">→</span> Nat Maybe <span class="main">→</span> Nat Maybe<span class="main">)</span>
                         <span class="main">→</span> Expr <span class="main">→</span> <span class="main">(</span>Nat <span class="main">→</span> Nat Maybe<span class="main">)</span> <span class="main">→</span> Nat Maybe <span class="main">→</span> Nat Maybe"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">eval_body_final</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="main">(</span>Val<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">n</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">eval_body_final</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="main">(</span>Add<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> n<span class="main">.</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> m<span class="main">.</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="bound">n</span> <span class="main">+</span> <span class="bound">m</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">eval_body_final</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span>Throw<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">eval_body_final</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="main">(</span>Catch<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> eval_body_final_strictExpr<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"eval_body_final<span class="main">⋅</span><span class="free">r</span><span class="main">⋅</span><span class="main">⊥</span><span class="main">⋅</span><span class="free">s</span><span class="main">⋅</span><span class="free">f</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> eval_body_final.unfold<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> eval_body'_eval_body_final_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"eval_body_final <span class="keyword1">oo</span> unwrapC <span class="keyword1">oo</span> wrapC <span class="main">=</span> eval_body'"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">xa</span></span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> unwrapC_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">eval_work_final</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Expr <span class="main">→</span> <span class="main">(</span>Nat <span class="main">→</span> Nat Maybe<span class="main">)</span> <span class="main">→</span> Nat Maybe <span class="main">→</span> Nat Maybe"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">eval_work_final</span> <span class="main">≡</span> fix<span class="main">⋅</span>eval_body_final"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">eval_final</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Expr <span class="main">→</span> Nat Maybe"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">eval_final</span> <span class="main">≡</span> <span class="main">(</span><span class="keyword1">Λ</span> e<span class="main">.</span> eval_work_final<span class="main">⋅</span><span class="bound">e</span><span class="main">⋅</span>Just<span class="main">⋅</span>Nothing<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"eval <span class="main">=</span> eval_final"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"eval <span class="main">=</span> fix<span class="main">⋅</span>eval_body"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> eval_eval_body_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> wrapC_unwrapC_id unwrapC_strict <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> wrapC<span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span>eval_body_final<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> worker_wrapper_fusion_new<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> eval_body'_eval_body_final_eq eval_body'_eval_body_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> eval_final"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> eval_final_def eval_work_final_def wrapC_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="Backtracking">
<div class="head">
<h1>Theory Backtracking</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="comment1">(*
 * The worker/wrapper transformation, following Gill and Hutton.
 * (C)opyright 2009-2011, Peter Gammie, peteg42 at gmail.com.
 * License: BSD
 *)</span>

<span class="keyword1"><span class="command">theory</span></span> Backtracking
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../../HOL/HOLCF/HOLCF.html">HOLCF</a>
  <a href="Nats.html">Nats</a>
  <a href="WorkerWrapperNew.html">WorkerWrapperNew</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Backtracking using lazy lists and continuations›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
\label{sec:ww-backtracking}

To illustrate the utility of worker/wrapper fusion to programming
language semantics, we consider here the first-order part of a
higher-order backtracking language by \citet{DBLP:conf/icfp/WandV04};
see also \citet{DBLP:journals/ngc/DanvyGR01}. We refer the reader to
these papers for a broader motivation for these languages.

As syntax is typically considered to be inductively generated, with
each syntactic object taken to be finite and completely defined, we
define the syntax for our language using a HOL datatype:

›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> expr <span class="main">=</span> const <span class="quoted">nat</span> <span class="main">|</span> add <span class="quoted">expr</span> <span class="quoted">expr</span> <span class="main">|</span> disj <span class="quoted">expr</span> <span class="quoted">expr</span> <span class="main">|</span> fail
<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> case_expr_cont<span class="main">[</span><span class="operator">cont2cont</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> f1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span><span class="main">.</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f1</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> f2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span> <span class="bound">z</span><span class="main">.</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f2</span> <span class="bound">x</span> <span class="bound">y</span> <span class="bound">z</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> f3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span> <span class="bound">z</span><span class="main">.</span> cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f3</span> <span class="bound">x</span> <span class="bound">y</span> <span class="bound">z</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> f4<span class="main">:</span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f4</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> case_expr <span class="main">(</span><span class="free">f1</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">f2</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">f3</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">f4</span> <span class="bound">x</span><span class="main">)</span> <span class="free">expr</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">expr</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="comment1">(* Presumably obsolete in the HG version, not so in Isabelle2011. *)</span>

<span class="keyword1"><span class="command">fun</span></span>
  <span class="entity">expr_encode</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"expr <span class="main">⇒</span> nat"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">expr_encode</span> <span class="main">(</span>const <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> prod_encode <span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">expr_encode</span> <span class="main">(</span>add <span class="free"><span class="bound"><span class="entity">e1</span></span></span> <span class="free"><span class="bound"><span class="entity">e2</span></span></span><span class="main">)</span> <span class="main">=</span> prod_encode <span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="main">(</span>prod_encode <span class="main">(</span><span class="free">expr_encode</span> <span class="free"><span class="bound"><span class="entity">e1</span></span></span><span class="main">,</span> <span class="free">expr_encode</span> <span class="free"><span class="bound"><span class="entity">e2</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">expr_encode</span> <span class="main">(</span>disj <span class="free"><span class="bound"><span class="entity">e1</span></span></span> <span class="free"><span class="bound"><span class="entity">e2</span></span></span><span class="main">)</span> <span class="main">=</span> prod_encode <span class="main">(</span><span class="numeral">2</span><span class="main">,</span> <span class="main">(</span>prod_encode <span class="main">(</span><span class="free">expr_encode</span> <span class="free"><span class="bound"><span class="entity">e1</span></span></span><span class="main">,</span> <span class="free">expr_encode</span> <span class="free"><span class="bound"><span class="entity">e2</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">expr_encode</span> fail <span class="main">=</span> prod_encode <span class="main">(</span><span class="numeral">3</span><span class="main">,</span> <span class="main">0</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> expr_encode_inj<span class="main">:</span>
  <span class="quoted"><span class="quoted">"expr_encode <span class="free">x</span> <span class="main">=</span> expr_encode <span class="free">y</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">x</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">y</span></span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper">y</span></span></span></span></span></span></span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> inj_onD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> inj_prod_encode<span class="main"><span class="main">,</span></span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> A<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">UNIV</span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">instance</span></span> expr <span class="main">::</span> <span class="quoted">countable</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> countable_classI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> expr_encode_inj<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The language consists of constants, an addition function, a
disjunctive choice between expressions, and failure. We give it a
direct semantics using the monad of lazy lists of natural numbers,
with the goal of deriving an an extensionally-equivalent evaluator
that uses double-barrelled continuations.

Our theory of lazy lists is entirely standard.

›</span></span>

<span class="keyword1"><span class="command">default_sort</span></span> <span class="quoted">predomain</span>

<span class="keyword1"><span class="command">domain</span></span> <span class="tfree">'a</span> llist <span class="main">=</span>
    lnil
  <span class="main">|</span> lcons <span class="main">(</span><span class="keyword2"><span class="keyword">lazy</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="keyword2"><span class="keyword">lazy</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist"</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

By relaxing the default sort of type variables to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>predomain›</span></span></span></span>,
our polymorphic definitions can be used at concrete types that do not
contain <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">⊥</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. These include those constructed from HOL types
using the discrete ordering type constructor <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> discr"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, and in
particular our interpretation <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"nat discr"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> of the natural
numbers.

The following standard list functions underpin the monadic
infrastructure:

›</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">lappend</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span> llist"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lappend</span><span class="main">⋅</span>lnil<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">lappend</span><span class="main">⋅</span><span class="main">(</span>lcons<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">=</span> lcons<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free">lappend</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">lconcat</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist llist <span class="main">→</span> <span class="tfree">'a</span> llist"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lconcat</span><span class="main">⋅</span>lnil <span class="main">=</span> lnil"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">lconcat</span><span class="main">⋅</span><span class="main">(</span>lcons<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> lappend<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free">lconcat</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">lmap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">→</span> <span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'b</span> llist"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lmap</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span>lnil <span class="main">=</span> lnil"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">lmap</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="main">(</span>lcons<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> lcons<span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">lmap</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> lappend_strict'<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lappend<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> a<span class="main">.</span> <span class="main">⊥</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1"><span class="command">lemma</span></span> lconcat_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lconcat<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1"><span class="command">lemma</span></span> lmap_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We define the lazy list monad <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>S›</span></span></span></span> in the traditional fashion:

›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> S <span class="main">=</span> <span class="quoted"><span class="quoted">"nat discr llist"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">returnS</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat discr <span class="main">→</span> S"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">returnS</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> lcons<span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span>lnil<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">bindS</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"S <span class="main">→</span> <span class="main">(</span>nat discr <span class="main">→</span> S<span class="main">)</span> <span class="main">→</span> S"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">bindS</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> x g<span class="main">.</span> lconcat<span class="main">⋅</span><span class="main">(</span>lmap<span class="main">⋅</span><span class="bound">g</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Unfortunately the lack of higher-order polymorphism in HOL prevents us
from providing the general typing one would expect a monad to have in
Haskell.

The evaluator uses the following extra constants:

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">addS</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"S <span class="main">→</span> S <span class="main">→</span> S"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">addS</span> <span class="main">≡</span> <span class="main">(</span><span class="keyword1">Λ</span> x y<span class="main">.</span> bindS<span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> xv<span class="main">.</span> bindS<span class="main">⋅</span><span class="bound">y</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> yv<span class="main">.</span> returnS<span class="main">⋅</span><span class="main">(</span><span class="bound">xv</span> <span class="main">+</span> <span class="bound">yv</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">disjS</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"S <span class="main">→</span> S <span class="main">→</span> S"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">disjS</span> <span class="main">≡</span> lappend"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">failS</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"S"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">failS</span> <span class="main">≡</span> lnil"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We interpret our language using these combinators in the obvious
way. The only complication is that, even though our evaluator is
primitive recursive, we must explicitly use the fixed point operator
as the worker/wrapper technique requires us to talk about the body of
the recursive definition.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">evalS_body</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>expr discr <span class="main">→</span> nat discr llist<span class="main">)</span>
              <span class="main">→</span> <span class="main">(</span>expr discr <span class="main">→</span> nat discr llist<span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">evalS_body</span> <span class="main">≡</span> <span class="keyword1">Λ</span> r e<span class="main">.</span> <span class="keyword1">case</span> undiscr <span class="bound">e</span> <span class="keyword1">of</span>
     const <span class="bound">n</span> <span class="main">⇒</span> returnS<span class="main">⋅</span><span class="main">(</span>Discr <span class="bound">n</span><span class="main">)</span>
   <span class="main">|</span> add <span class="bound">e1</span> <span class="bound">e2</span> <span class="main">⇒</span> addS<span class="main">⋅</span><span class="main">(</span><span class="bound">r</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="bound">e1</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="bound">r</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="bound">e2</span><span class="main">)</span><span class="main">)</span>
   <span class="main">|</span> disj <span class="bound">e1</span> <span class="bound">e2</span> <span class="main">⇒</span> disjS<span class="main">⋅</span><span class="main">(</span><span class="bound">r</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="bound">e1</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="bound">r</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="bound">e2</span><span class="main">)</span><span class="main">)</span>
   <span class="main">|</span> fail <span class="main">⇒</span> failS"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">evalS</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"expr discr <span class="main">→</span> nat discr llist"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">evalS</span> <span class="main">≡</span> fix<span class="main">⋅</span>evalS_body"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We aim to transform this evaluator into one using double-barrelled
continuations; one will serve as a "success" context, taking a natural
number into "the rest of the computation", and the other outright
failure.

In general we could work with an arbitrary observation type ala
\citet{DBLP:conf/icalp/Reynolds74}, but for convenience we use the
clearly adequate concrete type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"nat discr llist"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> Obs <span class="main">=</span> <span class="quoted"><span class="quoted">"nat discr llist"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> Failure <span class="main">=</span> <span class="quoted"><span class="quoted">"Obs"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> Success <span class="main">=</span> <span class="quoted"><span class="quoted">"nat discr <span class="main">→</span> Failure <span class="main">→</span> Obs"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> K <span class="main">=</span> <span class="quoted"><span class="quoted">"Success <span class="main">→</span> Failure <span class="main">→</span> Obs"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

To ease our development we adopt what
\citet[\S5]{DBLP:conf/icfp/WandV04} call a "failure computation"
instead of a failure continuation, which would have the type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span>
<span class="quoted"><span class="quoted">"unit <span class="main"><span class="main">→</span></span> Obs"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

The monad over the continuation type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"K"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is as follows:

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">returnK</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat discr <span class="main">→</span> K"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">returnK</span> <span class="main">≡</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="keyword1">Λ</span> s f<span class="main">.</span> <span class="bound">s</span><span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="bound">f</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">bindK</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"K <span class="main">→</span> <span class="main">(</span>nat discr <span class="main">→</span> K<span class="main">)</span> <span class="main">→</span> K"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">bindK</span> <span class="main">≡</span> <span class="keyword1">Λ</span> x g<span class="main">.</span> <span class="keyword1">Λ</span> s f<span class="main">.</span> <span class="bound">x</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> xv f'<span class="main">.</span> <span class="bound">g</span><span class="main">⋅</span><span class="bound">xv</span><span class="main">⋅</span><span class="bound">s</span><span class="main">⋅</span><span class="bound">f'</span><span class="main">)</span><span class="main">⋅</span><span class="bound">f</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Our extra constants are defined as follows:

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">addK</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"K <span class="main">→</span> K <span class="main">→</span> K"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">addK</span> <span class="main">≡</span> <span class="main">(</span><span class="keyword1">Λ</span> x y<span class="main">.</span> bindK<span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> xv<span class="main">.</span> bindK<span class="main">⋅</span><span class="bound">y</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> yv<span class="main">.</span> returnK<span class="main">⋅</span><span class="main">(</span><span class="bound">xv</span> <span class="main">+</span> <span class="bound">yv</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">disjK</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"K <span class="main">→</span> K <span class="main">→</span> K"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">disjK</span> <span class="main">≡</span> <span class="main">(</span><span class="keyword1">Λ</span> g h<span class="main">.</span> <span class="keyword1">Λ</span> s f<span class="main">.</span> <span class="bound">g</span><span class="main">⋅</span><span class="bound">s</span><span class="main">⋅</span><span class="main">(</span><span class="bound">h</span><span class="main">⋅</span><span class="bound">s</span><span class="main">⋅</span><span class="bound">f</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">failK</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"K"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">failK</span> <span class="main">≡</span> <span class="keyword1">Λ</span> s f<span class="main">.</span> <span class="bound">f</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The continuation semantics is again straightforward:

›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">evalK_body</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>expr discr <span class="main">→</span> K<span class="main">)</span> <span class="main">→</span> <span class="main">(</span>expr discr <span class="main">→</span> K<span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">evalK_body</span> <span class="main">≡</span> <span class="keyword1">Λ</span> r e<span class="main">.</span> <span class="keyword1">case</span> undiscr <span class="bound">e</span> <span class="keyword1">of</span>
     const <span class="bound">n</span> <span class="main">⇒</span> returnK<span class="main">⋅</span><span class="main">(</span>Discr <span class="bound">n</span><span class="main">)</span>
   <span class="main">|</span> add <span class="bound">e1</span> <span class="bound">e2</span> <span class="main">⇒</span> addK<span class="main">⋅</span><span class="main">(</span><span class="bound">r</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="bound">e1</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="bound">r</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="bound">e2</span><span class="main">)</span><span class="main">)</span>
   <span class="main">|</span> disj <span class="bound">e1</span> <span class="bound">e2</span> <span class="main">⇒</span> disjK<span class="main">⋅</span><span class="main">(</span><span class="bound">r</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="bound">e1</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="bound">r</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="bound">e2</span><span class="main">)</span><span class="main">)</span>
   <span class="main">|</span> fail <span class="main">⇒</span> failK"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">evalK</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"expr discr <span class="main">→</span> K"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">evalK</span> <span class="main">≡</span> fix<span class="main">⋅</span>evalK_body"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We now set up a worker/wrapper relation between these two semantics.

The kernel of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">unwrap</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is the following function that converts
a lazy list into an equivalent continuation representation.

›</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">SK</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"S <span class="main">→</span> K"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">SK</span><span class="main">⋅</span>lnil <span class="main">=</span> failK"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">SK</span><span class="main">⋅</span><span class="main">(</span>lcons<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> s f<span class="main">.</span> <span class="bound">s</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free">SK</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">⋅</span><span class="bound">s</span><span class="main">⋅</span><span class="bound">f</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">unwrap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>expr discr <span class="main">→</span> nat discr llist<span class="main">)</span> <span class="main">→</span> <span class="main">(</span>expr discr <span class="main">→</span> K<span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">unwrap</span> <span class="main">≡</span> <span class="keyword1">Λ</span> r e<span class="main">.</span> SK<span class="main">⋅</span><span class="main">(</span><span class="bound">r</span><span class="main">⋅</span><span class="bound">e</span><span class="main">)</span>"</span></span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> SK_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"SK<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1"><span class="command">lemma</span></span> unwrap_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"unwrap<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> unwrap_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Symmetrically <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">wrap</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> converts an evaluator using continuations
into one generating lazy lists by passing it the right continuations.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">KS</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"K <span class="main">→</span> S"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">KS</span> <span class="main">≡</span> <span class="main">(</span><span class="keyword1">Λ</span> k<span class="main">.</span> <span class="bound">k</span><span class="main">⋅</span>lcons<span class="main">⋅</span>lnil<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">wrap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>expr discr <span class="main">→</span> K<span class="main">)</span> <span class="main">→</span> <span class="main">(</span>expr discr <span class="main">→</span> nat discr llist<span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">wrap</span> <span class="main">≡</span> <span class="keyword1">Λ</span> r e<span class="main">.</span> KS<span class="main">⋅</span><span class="main">(</span><span class="bound">r</span><span class="main">⋅</span><span class="bound">e</span><span class="main">)</span>"</span></span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">lemma</span></span> KS_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"KS<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> KS_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> wrap_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"wrap<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> wrap_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The worker/wrapper condition follows directly from these definitions.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> KS_SK_id<span class="main">:</span>
  <span class="quoted"><span class="quoted">"KS<span class="main">⋅</span><span class="main">(</span>SK<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> KS_def failK_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> wrap_unwrap_id<span class="main">:</span>
  <span class="quoted"><span class="quoted">"wrap <span class="keyword1">oo</span> unwrap <span class="main">=</span> ID"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> wrap_def unwrap_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> KS_SK_id cfun_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The worker/wrapper transformation is only non-trivial if <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span>
<span class="quoted"><span class="quoted">"wrap"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"unwrap"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> do not witness an isomorphism. In this
case we can show that we do not even have a Galois connection.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cfun_not_below<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">⋅</span><span class="free">x</span> <span class="main">\&lt;notsqsubseteq&gt;</span> <span class="free">g</span><span class="main">⋅</span><span class="free">x</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">\&lt;notsqsubseteq&gt;</span> <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfun_below_iff<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> unwrap_wrap_not_under_id<span class="main">:</span>
  <span class="quoted"><span class="quoted">"unwrap <span class="keyword1">oo</span> wrap <span class="main">\&lt;notsqsubseteq&gt;</span> ID"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?witness</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="keyword1">Λ</span> e<span class="main">.</span> <span class="main">(</span><span class="keyword1">Λ</span> s f<span class="main">.</span> lnil <span class="main">::</span> K<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>unwrap <span class="keyword1">oo</span> wrap<span class="main">)</span><span class="main">⋅</span><span class="var">?witness</span><span class="main">⋅</span><span class="main">(</span>Discr fail<span class="main">)</span><span class="main">⋅</span><span class="main">⊥</span><span class="main">⋅</span><span class="main">(</span>lcons<span class="main">⋅</span><span class="main">0</span><span class="main">⋅</span>lnil<span class="main">)</span>
       <span class="main">\&lt;notsqsubseteq&gt;</span> <span class="var">?witness</span><span class="main">⋅</span><span class="main">(</span>Discr fail<span class="main">)</span><span class="main">⋅</span><span class="main">⊥</span><span class="main">⋅</span><span class="main">(</span>lcons<span class="main">⋅</span><span class="main">0</span><span class="main">⋅</span>lnil<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> failK_def wrap_def unwrap_def KS_def<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>unwrap <span class="keyword1">oo</span> wrap<span class="main">)</span><span class="main">⋅</span><span class="var">?witness</span> <span class="main">\&lt;notsqsubseteq&gt;</span> <span class="var">?witness</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> cfun_not_below<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfun_not_below<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We now apply \texttt{worker\_wrapper\_id}:

›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">eval_work</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"expr discr <span class="main">→</span> K"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">eval_work</span> <span class="main">≡</span> fix<span class="main">⋅</span><span class="main">(</span>unwrap <span class="keyword1">oo</span> evalS_body <span class="keyword1">oo</span> wrap<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">eval_ww</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"expr discr <span class="main">→</span> nat discr llist"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">eval_ww</span> <span class="main">≡</span> wrap<span class="main">⋅</span>eval_work"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"evalS <span class="main">=</span> eval_ww"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> eval_ww_def eval_work_def
  <span class="keyword1"><span class="command">using</span></span> worker_wrapper_id<span class="main">[</span><span class="operator">OF</span> wrap_unwrap_id<span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We now show how the monadic operations correspond by showing that
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"SK"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> witnesses a \emph{monad morphism}
\citep[\S6]{wadler92:_comprehending_monads}. As required by
\citet[Definition~2.1]{DBLP:journals/ngc/DanvyGR01}, the mapping needs
to hold for our specific operations in addition to the common monadic
scaffolding.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> SK_returnS_returnK<span class="main">:</span>
  <span class="quoted"><span class="quoted">"SK<span class="main">⋅</span><span class="main">(</span>returnS<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> returnK<span class="main">⋅</span><span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> returnS_def returnK_def failK_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> SK_lappend_distrib<span class="main">:</span>
 <span class="quoted"><span class="quoted">"SK<span class="main">⋅</span><span class="main">(</span>lappend<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">ys</span><span class="main">)</span><span class="main">⋅</span><span class="free">s</span><span class="main">⋅</span><span class="free">f</span> <span class="main">=</span> SK<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">s</span><span class="main">⋅</span><span class="main">(</span>SK<span class="main">⋅</span><span class="free">ys</span><span class="main">⋅</span><span class="free">s</span><span class="main">⋅</span><span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> failK_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> SK_bindS_bindK<span class="main">:</span>
  <span class="quoted"><span class="quoted">"SK<span class="main">⋅</span><span class="main">(</span>bindS<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="free">g</span><span class="main">)</span> <span class="main">=</span> bindK<span class="main">⋅</span><span class="main">(</span>SK<span class="main">⋅</span><span class="free">x</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>SK <span class="keyword1">oo</span> <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfun_eq_iff
                    bindS_def bindK_def failK_def
                    SK_lappend_distrib<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> SK_addS_distrib<span class="main">:</span>
  <span class="quoted"><span class="quoted">"SK<span class="main">⋅</span><span class="main">(</span>addS<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="free">y</span><span class="main">)</span> <span class="main">=</span> addK<span class="main">⋅</span><span class="main">(</span>SK<span class="main">⋅</span><span class="free">x</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>SK<span class="main">⋅</span><span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfcomp1
                     addS_def addK_def failK_def
                     SK_bindS_bindK SK_returnS_returnK<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> SK_disjS_disjK<span class="main">:</span>
 <span class="quoted"><span class="quoted">"SK<span class="main">⋅</span><span class="main">(</span>disjS<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">ys</span><span class="main">)</span> <span class="main">=</span> disjK<span class="main">⋅</span><span class="main">(</span>SK<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>SK<span class="main">⋅</span><span class="free">ys</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfun_eq_iff disjS_def disjK_def SK_lappend_distrib<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> SK_failS_failK<span class="main">:</span>
  <span class="quoted"><span class="quoted">"SK<span class="main">⋅</span>failS <span class="main">=</span> failK"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> failS_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

These lemmas directly establish the precondition for our all-in-one
worker/wrapper and fusion rule:

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> evalS_body_evalK_body<span class="main">:</span>
  <span class="quoted"><span class="quoted">"unwrap <span class="keyword1">oo</span> evalS_body <span class="keyword1">oo</span> wrap <span class="main">=</span> evalK_body <span class="keyword1">oo</span> unwrap <span class="keyword1">oo</span> wrap"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> cfun_eqI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">r</span> <span class="skolem">e'</span> <span class="skolem">s</span> <span class="skolem">f</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">e</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"expr"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> ee'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">e'</span> <span class="main">=</span> Discr <span class="skolem">e</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">e'</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>unwrap <span class="keyword1">oo</span> evalS_body <span class="keyword1">oo</span> wrap<span class="main">)</span><span class="main">⋅</span><span class="skolem">r</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="skolem">e</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">s</span><span class="main">⋅</span><span class="skolem">f</span>
      <span class="main">=</span> <span class="main">(</span>evalK_body <span class="keyword1">oo</span> unwrap <span class="keyword1">oo</span> wrap<span class="main">)</span><span class="main">⋅</span><span class="skolem">r</span><span class="main">⋅</span><span class="main">(</span>Discr <span class="skolem">e</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">s</span><span class="main">⋅</span><span class="skolem">f</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">e</span></span><span class="main">)</span>
       <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> evalS_body_def evalK_body_def unwrap_def
                      SK_returnS_returnK SK_addS_distrib
                      SK_disjS_disjK SK_failS_failK<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> ee' <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>unwrap <span class="keyword1">oo</span> evalS_body <span class="keyword1">oo</span> wrap<span class="main">)</span><span class="main">⋅</span><span class="skolem">r</span><span class="main">⋅</span><span class="skolem">e'</span><span class="main">⋅</span><span class="skolem">s</span><span class="main">⋅</span><span class="skolem">f</span>
                <span class="main">=</span> <span class="main">(</span>evalK_body <span class="keyword1">oo</span> unwrap <span class="keyword1">oo</span> wrap<span class="main">)</span><span class="main">⋅</span><span class="skolem">r</span><span class="main">⋅</span><span class="skolem">e'</span><span class="main">⋅</span><span class="skolem">s</span><span class="main">⋅</span><span class="skolem">f</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> evalS_evalK<span class="main">:</span>
  <span class="quoted"><span class="quoted">"evalS <span class="main">=</span> wrap<span class="main">⋅</span>evalK"</span></span>
  <span class="keyword1"><span class="command">using</span></span> worker_wrapper_fusion_new<span class="main">[</span><span class="operator">OF</span> wrap_unwrap_id unwrap_strict<span class="main">]</span>
        evalS_body_evalK_body
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

This proof can be considered an instance of the approach of
\citet{DBLP:journals/jfp/HuttonJG10}, which uses the worker/wrapper
machinery to relate two algebras.

This result could be obtained by a structural induction over the
syntax of the language. However our goal here is to show how such a
transformation can be achieved by purely equational means; this has
the advantange that our proof can be locally extended, e.g. to the
full language of \citet{DBLP:journals/ngc/DanvyGR01} simply by proving
extra equations. In contrast the higher-order language of
\citet{DBLP:conf/icfp/WandV04} is beyond the reach of this approach.

›</span></span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="Nub">
<div class="head">
<h1>Theory Nub</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="comment1">(*
 * The worker/wrapper transformation, following Gill and Hutton.
 * (C)opyright 2009-2011, Peter Gammie, peteg42 at gmail.com.
 * License: BSD
 *)</span>

<span class="keyword1"><span class="command">theory</span></span> Nub
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../../HOL/HOLCF/HOLCF.html">HOLCF</a>
  <a href="LList.html">LList</a>
  <a href="Maybe.html">Maybe</a>
  <a href="Nats.html">Nats</a>
  <a href="WorkerWrapperNew.html">WorkerWrapperNew</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Transforming $O(n^2)$ \emph{nub} into an $O(n\lg n)$ one›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Andy Gill's solution, mechanised.›</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹The <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">nub</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> function.›</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">nub</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Nat llist <span class="main">→</span> Nat llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">nub</span><span class="main">⋅</span><span class="keyword1">lnil</span> <span class="main">=</span> <span class="keyword1">lnil</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">nub</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:@</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:@</span> <span class="free">nub</span><span class="main">⋅</span><span class="main">(</span>lfilter<span class="main">⋅</span><span class="main">(</span>neg <span class="keyword1">oo</span> <span class="main">(</span><span class="keyword1">Λ</span> y<span class="main">.</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">=<span class="hidden">⇩</span><sub>B</sub></span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> nub_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"nub<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">nub_body</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Nat llist <span class="main">→</span> Nat llist<span class="main">)</span> <span class="main">→</span> Nat llist <span class="main">→</span> Nat llist"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">nub_body</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="keyword1">lnil</span> <span class="main">=</span> <span class="keyword1">lnil</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">nub_body</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:@</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:@</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="main">(</span>lfilter<span class="main">⋅</span><span class="main">(</span>neg <span class="keyword1">oo</span> <span class="main">(</span><span class="keyword1">Λ</span> y<span class="main">.</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">=<span class="hidden">⇩</span><sub>B</sub></span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> nub_nub_body_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"nub <span class="main">=</span> fix<span class="main">⋅</span>nub_body"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> nub_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> nub_body.unfold<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="comment1">(* **************************************** *)</span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Optimised data type.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Implement sets using lazy lists for now. Lifting up HOL's <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span>
set"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> type causes continuity grief.›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> NatSet <span class="main">=</span> <span class="quoted"><span class="quoted">"Nat llist"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">SetEmpty</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"NatSet"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">SetEmpty</span> <span class="main">≡</span> <span class="keyword1">lnil</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">SetInsert</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Nat <span class="main">→</span> NatSet <span class="main">→</span> NatSet"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">SetInsert</span> <span class="main">≡</span> lcons"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">SetMem</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Nat <span class="main">→</span> NatSet <span class="main">→</span> tr"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">SetMem</span> <span class="main">≡</span> lmember<span class="main">⋅</span><span class="main">(</span>bpred <span class="main">(=)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> SetMem_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"SetMem<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> SetMem_def<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> SetMem_SetEmpty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"SetMem<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span>SetEmpty <span class="main">=</span> FF"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> SetMem_def SetEmpty_def<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> SetMem_SetInsert<span class="main">:</span> <span class="quoted"><span class="quoted">"SetMem<span class="main">⋅</span><span class="free">v</span><span class="main">⋅</span><span class="main">(</span>SetInsert<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>SetMem<span class="main">⋅</span><span class="free">v</span><span class="main">⋅</span><span class="free">s</span> <span class="keyword1">orelse</span> <span class="free">x</span> <span class="keyword1">=<span class="hidden">⇩</span><sub>B</sub></span> <span class="free">v</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> SetMem_def SetInsert_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹AndyG's new type.›</span></span>

<span class="keyword1"><span class="command">domain</span></span> R <span class="main">=</span> R <span class="main">(</span><span class="keyword2"><span class="keyword">lazy</span></span> resultR <span class="main">::</span> <span class="quoted"><span class="quoted">"Nat llist"</span></span><span class="main">)</span> <span class="main">(</span><span class="keyword2"><span class="keyword">lazy</span></span> exceptR <span class="main">::</span> <span class="quoted"><span class="quoted">"NatSet"</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">nextR</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"R <span class="main">→</span> <span class="main">(</span>Nat <span class="main">*</span> R<span class="main">)</span> Maybe"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">nextR</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> r<span class="main">.</span> <span class="keyword1">case</span> ldropWhile<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> SetMem<span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="main">(</span>exceptR<span class="main">⋅</span><span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>resultR<span class="main">⋅</span><span class="bound">r</span><span class="main">)</span> <span class="keyword1">of</span>
                     <span class="keyword1">lnil</span> <span class="main">⇒</span> Nothing
                   <span class="main">|</span> <span class="bound">x</span> <span class="main">:@</span> <span class="bound">xs</span> <span class="main">⇒</span> Just<span class="main">⋅</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> R<span class="main">⋅</span><span class="bound">xs</span><span class="main">⋅</span><span class="main">(</span>exceptR<span class="main">⋅</span><span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> nextR_strict1<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"nextR<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nextR_def<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> nextR_strict2<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"nextR<span class="main">⋅</span><span class="main">(</span>R<span class="main">⋅</span><span class="main">⊥</span><span class="main">⋅</span><span class="free">S</span><span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nextR_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> nextR_lnil<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"nextR<span class="main">⋅</span><span class="main">(</span>R<span class="main">⋅</span><span class="keyword1">lnil</span><span class="main">⋅</span><span class="free">S</span><span class="main">)</span> <span class="main">=</span> Nothing"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nextR_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">filterR</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Nat <span class="main">→</span> R <span class="main">→</span> R"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">filterR</span> <span class="main">≡</span> <span class="main">(</span><span class="keyword1">Λ</span> v r<span class="main">.</span> R<span class="main">⋅</span><span class="main">(</span>resultR<span class="main">⋅</span><span class="bound">r</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>SetInsert<span class="main">⋅</span><span class="bound">v</span><span class="main">⋅</span><span class="main">(</span>exceptR<span class="main">⋅</span><span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">c2a</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Nat llist <span class="main">→</span> R"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">c2a</span> <span class="main">≡</span> <span class="keyword1">Λ</span> xs<span class="main">.</span> R<span class="main">⋅</span><span class="bound">xs</span><span class="main">⋅</span>SetEmpty"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">a2c</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"R <span class="main">→</span> Nat llist"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">a2c</span> <span class="main">≡</span> <span class="keyword1">Λ</span> r<span class="main">.</span> lfilter<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> v<span class="main">.</span> neg<span class="main">⋅</span><span class="main">(</span>SetMem<span class="main">⋅</span><span class="bound">v</span><span class="main">⋅</span><span class="main">(</span>exceptR<span class="main">⋅</span><span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>resultR<span class="main">⋅</span><span class="bound">r</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> a2c_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"a2c<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> a2c_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> a2c_c2a_id<span class="main">:</span> <span class="quoted"><span class="quoted">"a2c <span class="keyword1">oo</span> c2a <span class="main">=</span> ID"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> a2c_def c2a_def lfilter_const_true<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">wrap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>R <span class="main">→</span> Nat llist<span class="main">)</span> <span class="main">→</span> Nat llist <span class="main">→</span> Nat llist"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">wrap</span> <span class="main">≡</span> <span class="keyword1">Λ</span> f xs<span class="main">.</span> <span class="bound">f</span><span class="main">⋅</span><span class="main">(</span>c2a<span class="main">⋅</span><span class="bound">xs</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">unwrap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Nat llist <span class="main">→</span> Nat llist<span class="main">)</span> <span class="main">→</span> R <span class="main">→</span> Nat llist"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">unwrap</span> <span class="main">≡</span> <span class="keyword1">Λ</span> f r<span class="main">.</span> <span class="bound">f</span><span class="main">⋅</span><span class="main">(</span>a2c<span class="main">⋅</span><span class="bound">r</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> unwrap_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"unwrap<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> unwrap_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> wrap_unwrap_id<span class="main">:</span> <span class="quoted"><span class="quoted">"wrap <span class="keyword1">oo</span> unwrap <span class="main">=</span> ID"</span></span>
  <span class="keyword1"><span class="command">using</span></span> cfun_fun_cong<span class="main">[</span><span class="operator">OF</span> a2c_c2a_id<span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> wrap_def unwrap_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Equivalences needed for later.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> TR_deMorgan<span class="main">:</span> <span class="quoted"><span class="quoted">"neg<span class="main">⋅</span><span class="main">(</span><span class="free">x</span> <span class="keyword1">orelse</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>neg<span class="main">⋅</span><span class="free">x</span> <span class="keyword1">andalso</span> neg<span class="main">⋅</span><span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> trE<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> p<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">x</span></span></span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> case_maybe_case<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">case</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">L</span> <span class="keyword1">of</span> <span class="keyword1">lnil</span> <span class="main">⇒</span> Nothing <span class="main">|</span> <span class="bound">x</span> <span class="main">:@</span> <span class="bound">xs</span> <span class="main">⇒</span> Just<span class="main">⋅</span><span class="main">(</span><span class="free">h</span><span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="bound">xs</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">of</span>
     Nothing <span class="main">⇒</span> <span class="free">f</span> <span class="main">|</span> Just<span class="main">⋅</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span> <span class="free">g</span><span class="main">⋅</span><span class="bound">a</span><span class="main">⋅</span><span class="bound">b</span><span class="main">)</span>
   <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">case</span> <span class="free">L</span> <span class="keyword1">of</span> <span class="keyword1">lnil</span> <span class="main">⇒</span> <span class="free">f</span> <span class="main">|</span> <span class="bound">x</span> <span class="main">:@</span> <span class="bound">xs</span> <span class="main">⇒</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span>fst <span class="main">(</span><span class="free">h</span><span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="bound">xs</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>snd <span class="main">(</span><span class="free">h</span><span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="bound">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">L</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="free">h</span><span class="main">⋅</span><span class="improper">a</span><span class="main">⋅</span><span class="improper">llist</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> case_a2c_case_caseR<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">case</span> a2c<span class="main">⋅</span><span class="free">w</span> <span class="keyword1">of</span> <span class="keyword1">lnil</span> <span class="main">⇒</span> <span class="free">f</span> <span class="main">|</span> <span class="bound">x</span> <span class="main">:@</span> <span class="bound">xs</span> <span class="main">⇒</span> <span class="free">g</span><span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="bound">xs</span><span class="main">)</span>
   <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> nextR<span class="main">⋅</span><span class="free">w</span> <span class="keyword1">of</span> Nothing <span class="main">⇒</span> <span class="free">f</span> <span class="main">|</span> Just<span class="main">⋅</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">r</span><span class="main">)</span> <span class="main">⇒</span> <span class="free">g</span><span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="main">(</span>a2c<span class="main">⋅</span><span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="main">(</span><span class="keyword1">case</span> ldropWhile<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> SetMem<span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="main">(</span>exceptR<span class="main">⋅</span><span class="free">w</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>resultR<span class="main">⋅</span><span class="free">w</span><span class="main">)</span> <span class="keyword1">of</span>
                     <span class="keyword1">lnil</span> <span class="main">⇒</span> Nothing
                   <span class="main">|</span> <span class="bound">x</span> <span class="main">:@</span> <span class="bound">xs</span> <span class="main">⇒</span> Just<span class="main">⋅</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> R<span class="main">⋅</span><span class="bound">xs</span><span class="main">⋅</span><span class="main">(</span>exceptR<span class="main">⋅</span><span class="free">w</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">of</span> Nothing <span class="main">⇒</span> <span class="free">f</span> <span class="main">|</span> Just<span class="main">⋅</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">r</span><span class="main">)</span> <span class="main">⇒</span> <span class="free">g</span><span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="main">(</span>a2c<span class="main">⋅</span><span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nextR_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> ldropWhile<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> SetMem<span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="main">(</span>exceptR<span class="main">⋅</span><span class="free">w</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>resultR<span class="main">⋅</span><span class="free">w</span><span class="main">)</span> <span class="keyword1">of</span>
                     <span class="keyword1">lnil</span> <span class="main">⇒</span> <span class="free">f</span> <span class="main">|</span> <span class="bound">x</span> <span class="main">:@</span> <span class="bound">xs</span> <span class="main">⇒</span> <span class="free">g</span><span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="main">(</span>a2c<span class="main">⋅</span><span class="main">(</span>R<span class="main">⋅</span><span class="bound">xs</span><span class="main">⋅</span><span class="main">(</span>exceptR<span class="main">⋅</span><span class="free">w</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> case_maybe_case<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> L<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"ldropWhile<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> SetMem<span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="main">(</span>exceptR<span class="main">⋅</span><span class="free">w</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>resultR<span class="main">⋅</span><span class="free">w</span><span class="main">)</span>"</span></span>
                            <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">f</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> g<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="keyword1">Λ</span> x r<span class="main">.</span> <span class="free">g</span><span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="main">(</span>a2c<span class="main">⋅</span><span class="bound">r</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> h<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="keyword1">Λ</span> x xs<span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> R<span class="main">⋅</span><span class="bound">xs</span><span class="main">⋅</span><span class="main">(</span>exceptR<span class="main">⋅</span><span class="free">w</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="var">?lhs</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> a2c_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"resultR<span class="main">⋅</span><span class="free">w</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> p<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"SetMem<span class="main">⋅</span><span class="improper">a</span><span class="main">⋅</span><span class="main">(</span>exceptR<span class="main">⋅</span><span class="free">w</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> trE<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper">llist</span></span></span></span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> p<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"SetMem<span class="main">⋅</span><span class="improper">aa</span><span class="main">⋅</span><span class="main">(</span>exceptR<span class="main">⋅</span><span class="free">w</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> trE<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> filter_filterR<span class="main">:</span> <span class="quoted"><span class="quoted">"lfilter<span class="main">⋅</span><span class="main">(</span>neg <span class="keyword1">oo</span> <span class="main">(</span><span class="keyword1">Λ</span> y<span class="main">.</span> <span class="free">x</span> <span class="keyword1">=<span class="hidden">⇩</span><sub>B</sub></span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>a2c<span class="main">⋅</span><span class="free">r</span><span class="main">)</span> <span class="main">=</span> a2c<span class="main">⋅</span><span class="main">(</span>filterR<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="free">r</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> filter_filter<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> p<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"Tr.neg <span class="keyword1">oo</span> <span class="main">(</span><span class="keyword1">Λ</span> y<span class="main">.</span> <span class="free">x</span> <span class="keyword1">=<span class="hidden">⇩</span><sub>B</sub></span> <span class="bound">y</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> q<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="keyword1">Λ</span> v<span class="main">.</span> Tr.neg<span class="main">⋅</span><span class="main">(</span>SetMem<span class="main">⋅</span><span class="bound">v</span><span class="main">⋅</span><span class="main">(</span>exceptR<span class="main">⋅</span><span class="free">r</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">unfolding</span></span> a2c_def filterR_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">r</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> SetMem_SetInsert TR_deMorgan<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Apply worker/wrapper. Unlike Gill/Hutton, we manipulate the body of
the worker into the right form then apply the lemma.›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">nub_body'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>R <span class="main">→</span> Nat llist<span class="main">)</span> <span class="main">→</span> R <span class="main">→</span> Nat llist"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">nub_body'</span> <span class="main">≡</span> <span class="keyword1">Λ</span> f r<span class="main">.</span> <span class="keyword1">case</span> a2c<span class="main">⋅</span><span class="bound">r</span> <span class="keyword1">of</span> <span class="keyword1">lnil</span> <span class="main">⇒</span> <span class="keyword1">lnil</span>
                                   <span class="main">|</span> <span class="bound">x</span> <span class="main">:@</span> <span class="bound">xs</span> <span class="main">⇒</span> <span class="bound">x</span> <span class="main">:@</span> <span class="bound">f</span><span class="main">⋅</span><span class="main">(</span>c2a<span class="main">⋅</span><span class="main">(</span>lfilter<span class="main">⋅</span><span class="main">(</span>neg <span class="keyword1">oo</span> <span class="main">(</span><span class="keyword1">Λ</span> y<span class="main">.</span> <span class="bound">x</span> <span class="keyword1">=<span class="hidden">⇩</span><sub>B</sub></span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="bound">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> nub_body_nub_body'_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"unwrap <span class="keyword1">oo</span> nub_body <span class="keyword1">oo</span> wrap <span class="main">=</span> nub_body'"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> nub_body_def nub_body'_def unwrap_def wrap_def a2c_def c2a_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
     <span class="main"><span class="keyword3">,</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"lfilter<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> v<span class="main">.</span> Tr.neg<span class="main">⋅</span><span class="main">(</span>SetMem<span class="main">⋅</span><span class="bound">v</span><span class="main">⋅</span><span class="main">(</span>exceptR<span class="main">⋅</span><span class="improper">xa</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>resultR<span class="main">⋅</span><span class="improper">xa</span><span class="main">)</span>"</span></span>
     <span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fix_const<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">nub_body''</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>R <span class="main">→</span> Nat llist<span class="main">)</span> <span class="main">→</span> R <span class="main">→</span> Nat llist"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">nub_body''</span> <span class="main">≡</span> <span class="keyword1">Λ</span> f r<span class="main">.</span> <span class="keyword1">case</span> nextR<span class="main">⋅</span><span class="bound">r</span> <span class="keyword1">of</span> Nothing <span class="main">⇒</span> <span class="keyword1">lnil</span>
                                      <span class="main">|</span> Just<span class="main">⋅</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">xs</span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">x</span> <span class="main">:@</span> <span class="bound">f</span><span class="main">⋅</span><span class="main">(</span>c2a<span class="main">⋅</span><span class="main">(</span>lfilter<span class="main">⋅</span><span class="main">(</span>neg <span class="keyword1">oo</span> <span class="main">(</span><span class="keyword1">Λ</span> y<span class="main">.</span> <span class="bound">x</span> <span class="keyword1">=<span class="hidden">⇩</span><sub>B</sub></span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>a2c<span class="main">⋅</span><span class="bound">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> nub_body'_nub_body''_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"nub_body' <span class="main">=</span> nub_body''"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="skolem">r</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"nub_body'<span class="main">⋅</span><span class="skolem">f</span><span class="main">⋅</span><span class="skolem">r</span> <span class="main">=</span> nub_body''<span class="main">⋅</span><span class="skolem">f</span><span class="main">⋅</span><span class="skolem">r</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> nub_body'_def nub_body''_def
    <span class="keyword1"><span class="command">using</span></span> case_a2c_case_caseR<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="keyword1">lnil</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> g<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="keyword1">Λ</span> x xs<span class="main">.</span> <span class="bound">x</span> <span class="main">:@</span> <span class="skolem">f</span><span class="main">⋅</span><span class="main">(</span>c2a<span class="main">⋅</span><span class="main">(</span>lfilter<span class="main">⋅</span><span class="main">(</span>Tr.neg <span class="keyword1">oo</span> <span class="main">(</span><span class="keyword1">Λ</span> y<span class="main">.</span> <span class="bound">x</span> <span class="keyword1">=<span class="hidden">⇩</span><sub>B</sub></span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="bound">xs</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> w<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="skolem">r</span>"</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">nub_body'''</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>R <span class="main">→</span> Nat llist<span class="main">)</span> <span class="main">→</span> R <span class="main">→</span> Nat llist"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">nub_body'''</span> <span class="main">≡</span> <span class="main">(</span><span class="keyword1">Λ</span> f r<span class="main">.</span> <span class="keyword1">case</span> nextR<span class="main">⋅</span><span class="bound">r</span> <span class="keyword1">of</span> Nothing <span class="main">⇒</span> <span class="keyword1">lnil</span>
                                      <span class="main">|</span> Just<span class="main">⋅</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">xs</span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">x</span> <span class="main">:@</span> <span class="bound">f</span><span class="main">⋅</span><span class="main">(</span>filterR<span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="bound">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> nub_body''_nub_body'''_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"nub_body'' <span class="main">=</span> nub_body''' <span class="keyword1">oo</span> <span class="main">(</span>unwrap <span class="keyword1">oo</span> wrap<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> nub_body''_def nub_body'''_def wrap_def unwrap_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> filter_filterR<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Finally glue it all together.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> nub_wrap_nub_body'''<span class="main">:</span> <span class="quoted"><span class="quoted">"nub <span class="main">=</span> wrap<span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span>nub_body'''<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> worker_wrapper_fusion_new<span class="main">[</span><span class="operator">OF</span> wrap_unwrap_id unwrap_strict<span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> body<span class="main"><span class="main">=</span></span><span class="quoted">nub_body</span><span class="main">]</span>
        nub_nub_body_eq
        nub_body_nub_body'_eq
        nub_body'_nub_body''_eq
        nub_body''_nub_body'''_eq
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Last">
<div class="head">
<h1>Theory Last</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="comment1">(*
 * The worker/wrapper transformation, following Gill and Hutton.
 * (C)opyright 2011, Peter Gammie, peteg42 at gmail.com.
 * License: BSD
 *)</span>

<span class="keyword1"><span class="command">theory</span></span> Last
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../../HOL/HOLCF/HOLCF.html">HOLCF</a>
  <a href="LList.html">LList</a>
  <a href="WorkerWrapper.html">WorkerWrapper</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Optimise ``last''.›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Andy Gill's solution, mechanised. No fusion, works fine using their rule.›</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹The <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"last"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> function.›</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">llast</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">llast</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:@</span> <span class="free"><span class="bound"><span class="entity">yys</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">yys</span></span></span> <span class="keyword1">of</span> <span class="keyword1">lnil</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">|</span> <span class="bound">y</span> <span class="main">:@</span> <span class="bound">ys</span> <span class="main">⇒</span> <span class="free">llast</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">yys</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> llast_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"llast<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">llast_body</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">→</span> <span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">llast_body</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:@</span> <span class="free"><span class="bound"><span class="entity">yys</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">yys</span></span></span> <span class="keyword1">of</span> <span class="keyword1">lnil</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">|</span> <span class="bound">y</span> <span class="main">:@</span> <span class="bound">ys</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">yys</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> llast_llast_body<span class="main">:</span> <span class="quoted"><span class="quoted">"llast <span class="main">=</span> fix<span class="main">⋅</span>llast_body"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> llast_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> llast_body.unfold<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">wrap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">→</span> <span class="main">(</span><span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">wrap</span> <span class="main">≡</span> <span class="keyword1">Λ</span> f <span class="main">(</span>x <span class="main">:@</span> xs<span class="main">)</span><span class="main">.</span> <span class="bound">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="bound">xs</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">unwrap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">→</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">unwrap</span> <span class="main">≡</span> <span class="keyword1">Λ</span> f x xs<span class="main">.</span> <span class="bound">f</span><span class="main">⋅</span><span class="main">(</span><span class="bound">x</span> <span class="main">:@</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> unwrap_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"unwrap<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> unwrap_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> wrap_unwrap_ID<span class="main">:</span> <span class="quoted"><span class="quoted">"wrap <span class="keyword1">oo</span> unwrap <span class="keyword1">oo</span> llast_body <span class="main">=</span> llast_body"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> llast_body_def wrap_def unwrap_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">xa</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fix_const<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">llast_worker</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">→</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">llast_worker</span> <span class="main">≡</span> <span class="keyword1">Λ</span> r x yys<span class="main">.</span> <span class="keyword1">case</span> <span class="bound">yys</span> <span class="keyword1">of</span> <span class="keyword1">lnil</span> <span class="main">⇒</span> <span class="bound">x</span> <span class="main">|</span> <span class="bound">y</span> <span class="main">:@</span> <span class="bound">ys</span> <span class="main">⇒</span> <span class="bound">r</span><span class="main">⋅</span><span class="bound">y</span><span class="main">⋅</span><span class="bound">ys</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">llast'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">→</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">llast'</span> <span class="main">≡</span> wrap<span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span>llast_worker<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> llast_worker_llast_body<span class="main">:</span> <span class="quoted"><span class="quoted">"llast_worker <span class="main">=</span> unwrap <span class="keyword1">oo</span> llast_body <span class="keyword1">oo</span> wrap"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> llast_worker_def llast_body_def wrap_def unwrap_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">xb</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fix_const<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> llast'_llast<span class="main">:</span> <span class="quoted"><span class="quoted">"llast' <span class="main">=</span> llast"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span> <span class="main">=</span> fix<span class="main">⋅</span>llast_body"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> llast_llast_body<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> wrap<span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="main">(</span>unwrap <span class="keyword1">oo</span> llast_body <span class="keyword1">oo</span> wrap<span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> worker_wrapper_body<span class="main"><span class="main">[</span></span><span class="operator">OF</span> wrap_unwrap_ID<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> wrap<span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="main">(</span>llast_worker<span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> llast_worker_llast_body<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="var">?lhs</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> llast'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>